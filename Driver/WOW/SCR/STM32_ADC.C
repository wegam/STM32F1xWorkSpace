/******************************** User_library *********************************
* 文件名 	: STM32_SDCard.H
* 作者   	: wegam@sina.com
* 版本   	: V
* 日期   	: 2016/01/01
* 说明   	: 
********************************************************************************
* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
*******************************************************************************/

#include "STM32_ADC.H"

#include	"stdio.h"			//用于printf
#include	"string.h"		//用于printf
#include	"stdarg.h"		//用于获取不确定个数的参数
#include	"stdlib.h"		//malloc动态申请内存空间

/*##############################################################################
################################################################################
# 模块名		:	STM32_ADC	
# 功能描述	:	ADC配置使用
-------------------------------------------------------------------------------	
********ADC介绍:********
12位ADC是一种逐次逼近型模拟数字转换器。它有多达18个通道，可测量16个外部和2个内部信号源。
各通道的A/D转换可以单次、连续、扫描或间断模式执行。ADC的结果可以左对齐或右对齐方式存储在
16位数据寄存器中。 模拟看门狗特性允许应用程序检测输入电压是否超出用户定义的高/低阀值。 
ADC的输入时钟不得超过14MHz，它是由PCLK2经分频产生。
-------------------------------------------------------------------------------
********ADC主要特征:********
● 12位分辨率
● 转换结束、注入转换结束和发生模拟看门狗事件时产生中断 
● 单次和连续转换模式 
● 从通道0到通道n的自动扫描模式
● 自校准 
● 带内嵌数据一致性的数据对齐 
● 采样间隔可以按通道分别编程 
● 规则转换和注入转换均有外部触发选项 
● 间断模式 
● 双重模式(带2个或以上ADC的器件) 
● ADC转换时间： 
	─ STM32F103xx增强型产品：时钟为56MHz时为1μs(时钟为72MHz为1.17μs) 
	─ STM32F101xx基本型产品：时钟为28MHz时为1μs(时钟为36MHz为1.55μs) 
	─ STM32F102xxUSB型产品：时钟为48MHz时为1.2μs 
	─ STM32F105xx和STM32F107xx产品：时钟为56MHz时为1μs(时钟为72MHz为1.17μs) 
● ADC供电要求：2.4V到3.6V 
● ADC输入范围：VREF- ≤ VIN ≤ VREF+ 
● 规则通道转换期间有DMA请求产生。

************************ADC管脚:依据STM32F107VC引脚分布***********************
*	CH0	CH1	CH2	CH3	CH4	CH5	CH6	CH7	CH8	CH9	CH10	CH11	CH12	CH13	CH14	CH15
*	PA0	PA1	PA2	PA3	PA4	PA5	PA6	PA7	PB0	PB1	PC0		PC1		PC2		PC3		PC4		PC5				
*****************************************************************************
CH16 内部温度传感器
CH17 内部参考电压
*****************************************************************************
注入组介绍：注入通道组中可以安排最多4个通道
规则组介绍：规则通道组中可以安排最多16个通道
################################################################################
###############################################################################*/


ADCList  *ADCDisc  = NULL;
unsigned short ADCBuffer[18]   = {0};   //18通道，包括内部温度和内部基准
unsigned char ChannelCount  = 0;

/*******************************************************************************
* 函数名		:	ADC1_InjectedConfiguration	
* 功能描述	:	ADC1注入通道组配置 
* 输入		:	
* 输出		:
* 返回 		:
*******************************************************************************/
void ADC1_InjectedConfiguration(void)			//ADC1注入通道组配置
{	
}
/*******************************************************************************
* 函数名		:	
* 功能描述	:	ADC1规则通道组配置--普通方式
* 输入		:	ADC_Channel_x->通道号:ADC_Channel_0~ADC_Channel_15
						ADC_mode->
						ADC_NbrOfChannel->顺序进行规则转换的ADC通道的数目
* 输出		:
* 返回 		: 返回0设置失败，否则返回通道总数
*******************************************************************************/
unsigned char ADC1_DiscConfigurationDMANR(
                              unsigned char Rank,               //转换顺序
															unsigned char	ADC_Channel_x,			//通道号
															unsigned char	ADC_SampleTime			//采样时间周期
															)												//ADC1规则通道组配置
{	
	ADC_InitTypeDef 	ADC_InitStructure; 						//ADC结构体
	GPIO_InitTypeDef 	GPIO_InitStructure;						//GPIO结构体
	GPIO_TypeDef* GPIOx=0;
	u16 GPIO_Pin_x=0;  
  unsigned char i = 0;
  ADCList  *ADCDiscTemp = NULL;
  ADCList  *ADCDiscNew  = (ADCList*)malloc(sizeof(ADCList));
  if(NULL ==  ADCDiscNew)
  {
    ADCDiscNew  = (ADCList*)malloc(sizeof(ADCList));
    if(NULL ==  ADCDiscNew)
    {
      return 0;
    }
  }
  ADCDiscNew->Rank = Rank;
  ADCDiscNew->ADC_Channel_x  = ADC_Channel_x;
  ADCDiscNew->ADC_SampleTime = ADC_SampleTime;
  ADCDiscNew->Next  = NULL;

  if(NULL ==  ADCDisc)
  {
    ADCDisc = ADCDiscNew;
    ChannelCount=1;
  }
  else
  {    
    ADCDiscTemp = ADCDisc;
    for(i=1;i<=ADC_Channel_17;i++)
    {
      if(NULL ==  ADCDiscTemp->Next)
      {
        ADCDiscTemp->Next = ADCDiscNew;
        ChannelCount  = i+1;
        break;
      }
      else
      {
        ADCDiscTemp = ADCDiscTemp->Next;
      }
    }    
  }
	//由时钟控制器提供的ADCCLK时钟和PCLK2(APB2时钟)同步。
	//RCC控制器为ADC时钟提供一个专用的可编程预分频器。
	//1)==============================================打开ADC时钟，并设置分频因子	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);	//使能ADC时钟
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);										//6分频12MHz
	//2)==============================================根据所选的通道，打开相应GPIO时钟，配置相应GPIO为模拟输入（依据STM32F107VC引脚分布)
	//2.1)--------------------------------------------打开相应时钟
	if(ADC_Channel_x<=ADC_Channel_7)
	{
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);		//使能GPIOA时钟
	}
	else if(ADC_Channel_x>ADC_Channel_7&&ADC_Channel_x<=ADC_Channel_9)
	{
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);		//使能GPIOB时钟
	}
	else if(ADC_Channel_x>ADC_Channel_9&&ADC_Channel_x<=ADC_Channel_15)
	{
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);		//使能GPIOC时钟
	}
	else
	{
	}
	//2.2)--------------------------------------------选择相应GPIO
	switch (ADC_Channel_x)
	{
		case	ADC_Channel_0:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_0;	break;
		case	ADC_Channel_1:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_1;	break;
		case	ADC_Channel_2:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_2;	break;
		case	ADC_Channel_3:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_3;	break;
		case	ADC_Channel_4:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_4;	break;
		case	ADC_Channel_5:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_5;	break;
		case	ADC_Channel_6:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_6;	break;
		case	ADC_Channel_7:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_7;	break;
		case	ADC_Channel_8:	GPIOx=GPIOB;	GPIO_Pin_x=GPIO_Pin_0;	break;
		case	ADC_Channel_9:	GPIOx=GPIOB;	GPIO_Pin_x=GPIO_Pin_1;	break;
		case	ADC_Channel_10:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_0;	break;
		case	ADC_Channel_11:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_1;	break;
		case	ADC_Channel_12:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_2;	break;
		case	ADC_Channel_13:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_3;	break;
		case	ADC_Channel_14:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_4;	break;
		case	ADC_Channel_15:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_5;	break;
		
		default :break;					
	}
	//2.3)--------------------------------------------配置GPIO
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_x;							//GPIO_Pin_x
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;					//模拟输入
	GPIO_Init(GPIOx,&GPIO_InitStructure);									//GPIO初始化
	
	//3)==============================================设置ADC的工作模式
  ADC1_Cmd(DISABLE);
  ADC_DeInit(ADC1);
	ADC_InitStructure.ADC_Mode 								= ADC_Mode_Independent; 			//ADC工作模式:ADC1和ADC2工作在独立模式
	ADC_InitStructure.ADC_ScanConvMode 				=	ENABLE; 										//模数转换工作在扫描模式
	ADC_InitStructure.ADC_ContinuousConvMode 	= ENABLE; 										//模数转换工作在连续转换模式
	ADC_InitStructure.ADC_ExternalTrigConv 		= ADC_ExternalTrigConv_None; 	//转换由软件而不是外部触发启动--外部触发转换关闭
	ADC_InitStructure.ADC_DataAlign 					= ADC_DataAlign_Right; 				//ADC数据右对齐(左边补充0）
	ADC_InitStructure.ADC_NbrOfChannel 				= ChannelCount; 			        //顺序进行规则转换的ADC通道的数目
	ADC_Init(ADC1, &ADC_InitStructure); 																		//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
	
	//4)==============================================设置ADC的规则系列相关信息---通道选择
  ADC1_Cmd(DISABLE);
  ADCDiscTemp = ADCDisc;
  for(i=0;i<ChannelCount;i++)
  {
    ADC_RegularChannelConfig(ADC1, ADCDiscTemp->ADC_Channel_x, ADCDiscTemp->Rank,ADCDiscTemp->ADC_SampleTime);
    if(NULL ==  ADCDiscTemp->Next)
    {
      break;
    }
    else
    {
      ADCDiscTemp = ADCDiscTemp->Next;
    }
  }
  //5)==============================================设置ADC的规则系列相关信息---通道选择
	ADC1_DMAConfiguration((u32*)ADCBuffer,ChannelCount);  //ADC1 DMA配置	

  //6)==========开启ADC转换并校准
	ADC1_Cmd(ENABLE);																		//开启ADC1转换
  return ChannelCount;     //返回通道总数
}
/*******************************************************************************
* 函数名		:	
* 功能描述	:	ADC1规则通道组配置--普通方式
* 输入		:	ADC_Channel_x->通道号:ADC_Channel_0~ADC_Channel_15
						ADC_mode->
						ADC_NbrOfChannel->顺序进行规则转换的ADC通道的数目
* 输出		:
* 返回 		:
*******************************************************************************/
unsigned char ADC1_DiscGetData(unsigned short* DataBuffer)
{
  if(NULL !=  ADCBuffer)
  {
    memcpy(DataBuffer,ADCBuffer,ChannelCount*2);
    return ChannelCount;
  }
  else
  {
    return 0;
  }
}

/*******************************************************************************
*函数名		:	ADC_TempSensorConfiguration
*功能描述	:	STM32内部温度传感器配置
*输入			: 
*输出			:	无
*返回值		:	无
*例程			:
*******************************************************************************/
void ADC_TempSensorConfiguration(u32 *ADC_DATA)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);			//使能ADC时钟
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   										//分频因子6时钟为72M/6=12MHz
	ADC1_InitStructure(1);																	//ADC初始化
	ADC_RegularChannelConfig(ADC1, ADC_Channel_16, 1,ADC_SampleTime_239Cycles5);	//选择ADC，通道，顺序及转换周期
	ADC1_DMAConfiguration(ADC_DATA,1); 											//ADC1_DMA配置
	ADC_DMACmd(ADC1, ENABLE);   														//ADC命令，使能DMA的ADC转换
	ADC_TempSensorVrefintCmd(ENABLE);												//使能温度传感器和内部参考电压通道	
	ADC1_Cmd(ENABLE);																				//开启ADC1转换
	
	ADC_ResetCalibration(ADC1);   													//重新校准
	while(ADC_GetResetCalibrationStatus(ADC1)); 	 					//等待重新校准完成
	ADC_StartCalibration(ADC1); 														//开始校准
	while(ADC_GetCalibrationStatus(ADC1));    							//等待校准完成
	ADC_SoftwareStartConvCmd(ADC1, ENABLE); 								//连续转换开始，ADC通过DMA方式不断的更新RAM区。
	
//	ADC_InitTypeDef ADC_InitStructure; 
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1    , ENABLE );   //使能GPIOA,ADC1通道时钟
//	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   //分频因子6时钟为72M/6=12MHz
//	ADC_DeInit(ADC1);  //将外设 ADC1 的全部寄存器重设为缺省值
//	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  //ADC工作模式:ADC1和ADC2工作在独立模式
//	ADC_InitStructure.ADC_ScanConvMode = DISABLE;   //模数转换工作在单通道模式
//	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式
//	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动
//	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;  //ADC数据右对齐
//	ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目
//	ADC_Init(ADC1, &ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
//	ADC_TempSensorVrefintCmd(ENABLE); //开启内部温度传感器
//	ADC_Cmd(ADC1, ENABLE);  //使能指定的ADC1
//	ADC_ResetCalibration(ADC1); //重置指定的ADC1的复位寄存器
//	while(ADC_GetResetCalibrationStatus(ADC1)); //获取ADC1重置校准寄存器的状态,设置状态则等待
//	ADC_StartCalibration(ADC1);
//	while(ADC_GetCalibrationStatus(ADC1));      //获取指定ADC1的校准程序,设置状态则等待
}
/*******************************************************************************
*函数名		:	Get_ADC_Temperature
*功能描述	:	获取内部温度传感器温度
*输入			: 
*输出			:	无
*返回值		:	无
*例程			:
*******************************************************************************/
float Get_ADC_Temperature(u32 ADC_DATA)
{
	float Result=0.0;
	Result=(1.43-(ADC_DATA*3.3)/4096)*1000/4.35 + 25;
	return (float)Result;

}

/*******************************************************************************
* 函数名		:	
* 功能描述	:	 
* 输入		:	ADC_NbrOfChannel>顺序进行规则转换的ADC通道的数目
* 输出		:
* 返回 		:
*******************************************************************************/
void ADC1_InitStructure(u8 ADC_NbrOfChannel)				//ADC初始化
{
	ADC_InitTypeDef ADC_InitStructure; 						//ADC结构体
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; 													//ADC工作模式:ADC1和ADC2工作在独立模式
	ADC_InitStructure.ADC_ScanConvMode =ENABLE; 																//模数转换工作在扫描模式
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; 													//模数转换工作在连续转换模式
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; 				//转换由软件而不是外部触发启动--外部触发转换关闭
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; 											//ADC数据右对齐(左边补充0）
	ADC_InitStructure.ADC_NbrOfChannel = ADC_NbrOfChannel; 											//顺序进行规则转换的ADC通道的数目
	ADC_Init(ADC1, &ADC_InitStructure); 																				//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
}

/*******************************************************************************
* 函数名		:	
* 功能描述	:	 
* 输入		:	
* 输出		:
* 返回 		:
*******************************************************************************/
void ADC1_DMAConfiguration(u32 *ADCDataBuffer,u32 DMA_BufferSize) 		//ADC1 DMA配置
{  
	DMA_InitTypeDef DMA_InitStructure; 																					//DMA结构体
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); 		//使能DMA传输
  
	DMA_DeInit(DMA1_Channel1); 																									  //将DMA的通道1寄存器重设为缺省值
	DMA_InitStructure.DMA_PeripheralBaseAddr  = (u32)&ADC1->DR; 									//DMA外设基地址---ADC
	DMA_InitStructure.DMA_MemoryBaseAddr      = (u32)ADCDataBuffer; 						  //DMA内存基地址---ADC存储变量地址
	DMA_InitStructure.DMA_DIR                 = DMA_DIR_PeripheralSRC; 					  //设置源端---外设作为数据传输的来源
	DMA_InitStructure.DMA_BufferSize          = DMA_BufferSize; 								  //DMA通道的DMA缓存的大小
	DMA_InitStructure.DMA_PeripheralInc       = DMA_PeripheralInc_Disable; 			  //外设地址寄存器不变
	DMA_InitStructure.DMA_MemoryInc           = DMA_MemoryInc_Enable; 					  //内存地址寄存器递增：多通道转换时数据存储地址需要增加
	DMA_InitStructure.DMA_PeripheralDataSize  = DMA_PeripheralDataSize_HalfWord;  //外设数据宽度为16位
	DMA_InitStructure.DMA_MemoryDataSize      = DMA_MemoryDataSize_HalfWord;		  //内存数据宽度为16位
	DMA_InitStructure.DMA_Mode                = DMA_Mode_Circular; 							  //工作在循环缓存模式---不停地采集数据
	DMA_InitStructure.DMA_Priority            = DMA_Priority_High; 							  //DMA通道x拥有高优先级
	DMA_InitStructure.DMA_M2M                 = DMA_M2M_Disable; 								  //DMA通道x没有设置为内存到内存传输
	DMA_Init(DMA1_Channel1, &DMA_InitStructure); 																  //根据DMA_InitStruct中指定的参数初始化DMA的通道
	DMA_Cmd(DMA1_Channel1,ENABLE);																							  //使能DMA通道
}
/*******************************************************************************
* 函数名		:	ADC1_Cmd
* 功能描述	:	开启ADC1转换 
* 输入		:	
* 输出		:
* 返回 		:
*******************************************************************************/
void ADC1_Cmd(FunctionalState NewState)		//开启ADC1转换
{
//	assert_param(IS_FUNCTIONAL_STATE(ENABLE));
	assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {		
    ADC_DMACmd(ADC1, ENABLE); 									//开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数）ADC_DMACmd(ADC1, ENABLE);
		DMA_Cmd(DMA1_Channel1,ENABLE);
		ADC_Cmd(ADC1, ENABLE); 											//使能指定的ADC1
		ADC_SoftwareStartConvCmd(ADC1,ENABLE);
		ADC_ResetCalibration(ADC1); 								//复位指定的ADC1的校准寄存器
		
		while(ADC_GetResetCalibrationStatus(ADC1)); //获取ADC1复位校准寄存器的状态,设置状态则等待
		ADC_StartCalibration(ADC1); 								//开始指定ADC1的校准状态
		while(ADC_GetCalibrationStatus(ADC1)); 			//获取指定ADC1的校准程序,设置状态则等待	
  }
  else
  {
    ADC_SoftwareStartConvCmd(ADC1,DISABLE);
    ADC_DMACmd(ADC1, DISABLE); 	//开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数）ADC_DMACmd(ADC1, ENABLE);
		ADC_Cmd(ADC1, DISABLE); 		//使能指定的ADC1	
  }
}









