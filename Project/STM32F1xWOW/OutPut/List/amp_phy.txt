; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\amp_phy.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\amp_phy.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\amp_phy.crf ..\..\Driver\Protocol\AMP_PHY.C]
                          THUMB

                          AREA ||i.API_AmpCheckFrame||, CODE, READONLY, ALIGN=1

                  API_AmpCheckFrame PROC
;;;49     *******************************************************************************/
;;;50     unsigned char API_AmpCheckFrame(unsigned char* pbuffer,unsigned short* length)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;51     {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;52       unsigned  char  Cmd         = 0;
000008  f04f0b00          MOV      r11,#0
;;;53       unsigned  char* headaddr    = NULL;
00000c  2400              MOVS     r4,#0
;;;54       unsigned  char* endaddr     = NULL;
00000e  2600              MOVS     r6,#0
;;;55       unsigned short	HeadCodeValidLength	=	*length;    //头标识有效查找长度
000010  f8b5a000          LDRH     r10,[r5,#0]
;;;56       unsigned short	EndCodeValidLength	=	*length;    //尾标识有效查找长度
000014  882f              LDRH     r7,[r5,#0]
;;;57       unsigned short	FrameValidLength	  =	*length;    //当前帧最大有效长度
000016  8828              LDRH     r0,[r5,#0]
000018  9000              STR      r0,[sp,#0]
;;;58       unsigned short	DataValidLength	    =	*length;    //当前缓存数据长度
00001a  f8b59000          LDRH     r9,[r5,#0]
;;;59       
;;;60       stampphydef* ampframe;
;;;61       
;;;62       //=====================基本检查(空地址或者长度不足最小帧)
;;;63       if(NULL  ==  pbuffer)
00001e  f1b80f00          CMP      r8,#0
000022  d100              BNE      |L1.38|
;;;64       {
;;;65         goto ExitAmpCheckFrame;   //退出此函数--空地址
000024  e05b              B        |L1.222|
                  |L1.38|
;;;66       }
;;;67       if(FrameValidLength<7)  //小于最小帧长度
000026  f8bd0000          LDRH     r0,[sp,#0]
00002a  2807              CMP      r0,#7
00002c  da00              BGE      |L1.48|
;;;68       {
;;;69         goto ExitAmpCheckFrame;   //退出此函数--帧长度不够
00002e  e056              B        |L1.222|
                  |L1.48|
;;;70       }  
;;;71       FrameGetHeadCodeAddr:
;;;72       //=====================查找头标识地址
;;;73       headaddr	=	(unsigned char*)memchr(pbuffer,headcode,HeadCodeValidLength);   //找头标识
000030  4652              MOV      r2,r10
000032  217e              MOVS     r1,#0x7e
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       memchr
00003a  4604              MOV      r4,r0
;;;74       if(NULL==headaddr)
00003c  b904              CBNZ     r4,|L1.64|
;;;75       {
;;;76         goto ExitAmpCheckFrame;   //退出此函数--未找到头标识符
00003e  e04e              B        |L1.222|
                  |L1.64|
;;;77       }
;;;78       
;;;79       
;;;80       //=====================查找尾标识地址
;;;81       //---------------------剩余有效数据长度
;;;82       DataValidLength  = FrameValidLength-((unsigned long)headaddr-(unsigned long)pbuffer); //剩余数据长度
000040  eba40008          SUB      r0,r4,r8
000044  f8bd1000          LDRH     r1,[sp,#0]
000048  1a08              SUBS     r0,r1,r0
00004a  fa1ff980          UXTH     r9,r0
;;;83       if(DataValidLength<7)
00004e  f1b90f07          CMP      r9,#7
000052  da00              BGE      |L1.86|
;;;84       {
;;;85         goto ExitAmpCheckFrame;   //退出此函数--帧长度不够
000054  e043              B        |L1.222|
                  |L1.86|
;;;86       }
;;;87       
;;;88       EndCodeValidLength  = DataValidLength-1; //剩余数据内结束符可查找的范围
000056  f1a90001          SUB      r0,r9,#1
00005a  b287              UXTH     r7,r0
;;;89       endaddr=&headaddr[1];        //从下一个位置开始查找
00005c  1c66              ADDS     r6,r4,#1
;;;90       
;;;91       FrameGetEndCodeAddr:
00005e  bf00              NOP      
                  |L1.96|
;;;92       //---------------------查找结束符
;;;93       endaddr		=	(unsigned char*)memchr(endaddr,endcode,EndCodeValidLength);   //找尾标识---从头标识后开始查找
000060  463a              MOV      r2,r7
000062  217f              MOVS     r1,#0x7f
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       memchr
00006a  4606              MOV      r6,r0
;;;94       if(NULL==endaddr)
00006c  b906              CBNZ     r6,|L1.112|
;;;95       {
;;;96         goto ExitAmpCheckFrame;   //退出此函数--未找到尾标识符
00006e  e036              B        |L1.222|
                  |L1.112|
;;;97       }
;;;98       //======================================查找到结束符，检查协议格式
;;;99       else
;;;100      {
;;;101        FrameValidLength  = (unsigned long)endaddr-(unsigned long)headaddr+1;
000070  1b30              SUBS     r0,r6,r4
000072  1c40              ADDS     r0,r0,#1
000074  b280              UXTH     r0,r0
000076  9000              STR      r0,[sp,#0]
;;;102        //------------------------------------检查帧长度
;;;103        if(AmpMinFrameSize>FrameValidLength)      //小于最小帧长度，重新查找结束符
000078  f8bd0000          LDRH     r0,[sp,#0]
00007c  2807              CMP      r0,#7
00007e  da08              BGE      |L1.146|
;;;104        {
;;;105          if(AmpMinFrameSize<EndCodeValidLength)  //数据还有未查找完-继续查找
000080  2f07              CMP      r7,#7
000082  dd05              BLE      |L1.144|
;;;106          {
;;;107            endaddr=&endaddr[1];        //从下一个位置开始查找
000084  1c76              ADDS     r6,r6,#1
;;;108            EndCodeValidLength=EndCodeValidLength-FrameValidLength;      //可查找的范围减1
000086  f8bd0000          LDRH     r0,[sp,#0]
00008a  1a38              SUBS     r0,r7,r0
00008c  b287              UXTH     r7,r0
;;;109            goto FrameGetEndCodeAddr;   //重新查找结束符---
00008e  e7e7              B        |L1.96|
                  |L1.144|
;;;110          }
;;;111          else
;;;112          {
;;;113            goto ExitAmpCheckFrame;   //退出此函数--剩余未检查的数据长度为0
000090  e025              B        |L1.222|
                  |L1.146|
;;;114          }
;;;115        }
;;;116        //------------------------------------检查是否为应答帧
;;;117        else if(AmpMinFrameSize==FrameValidLength)  //应答帧长度
000092  f8bd0000          LDRH     r0,[sp,#0]
000096  2807              CMP      r0,#7
000098  d10f              BNE      |L1.186|
;;;118        {
;;;119          if(AmpCrc16Check(headaddr,&FrameValidLength))  //检查CRC--通过检查
00009a  4669              MOV      r1,sp
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       AmpCrc16Check
0000a2  b120              CBZ      r0,|L1.174|
;;;120          {
;;;121            pbuffer = headaddr;
0000a4  46a0              MOV      r8,r4
;;;122            return DataValidLength;
0000a6  f00900ff          AND      r0,r9,#0xff
                  |L1.170|
;;;123          }
;;;124          else    //不是应答帧，重新查找结束符
;;;125          {
;;;126            endaddr=&endaddr[1];        //从下一个位置开始查找
;;;127            EndCodeValidLength=EndCodeValidLength-FrameValidLength;      //可查找的范围减1
;;;128            goto FrameGetEndCodeAddr;   //重新查找结束符---
;;;129          }
;;;130        }
;;;131        else
;;;132        {
;;;133        }
;;;134        
;;;135    //    //======================================根据协议做CRC校验
;;;136    //    //--------------------------------------应答帧校验
;;;137        if(AmpCmdAck  ==  ampframe->msg.cmd.cmd)  //应答帧
;;;138        {
;;;139        }
;;;140        if(AmpCrc16Check(headaddr,&FrameValidLength))
;;;141        {
;;;142          *length = FrameValidLength;
;;;143        }
;;;144        else
;;;145        {
;;;146          pbuffer = &headaddr[1];
;;;147          FrameValidLength = FrameValidLength-1;
;;;148          goto FrameGetEndCodeAddr;
;;;149        }    
;;;150      }
;;;151      ExitAmpCheckFrame:  //退出此函数
;;;152      return  0;
;;;153    }
0000aa  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.174|
0000ae  1c76              ADDS     r6,r6,#1              ;126
0000b0  f8bd0000          LDRH     r0,[sp,#0]            ;127
0000b4  1a38              SUBS     r0,r7,r0              ;127
0000b6  b287              UXTH     r7,r0                 ;127
0000b8  e7d2              B        |L1.96|
                  |L1.186|
0000ba  4669              MOV      r1,sp                 ;140
0000bc  4620              MOV      r0,r4                 ;140
0000be  f7fffffe          BL       AmpCrc16Check
0000c2  b118              CBZ      r0,|L1.204|
0000c4  f8bd0000          LDRH     r0,[sp,#0]            ;142
0000c8  8028              STRH     r0,[r5,#0]            ;142
0000ca  e007              B        |L1.220|
                  |L1.204|
0000cc  f1040801          ADD      r8,r4,#1              ;146
0000d0  f8bd0000          LDRH     r0,[sp,#0]            ;147
0000d4  1e40              SUBS     r0,r0,#1              ;147
0000d6  b280              UXTH     r0,r0                 ;147
0000d8  9000              STR      r0,[sp,#0]            ;147
0000da  e7c1              B        |L1.96|
                  |L1.220|
0000dc  bf00              NOP                            ;151
                  |L1.222|
0000de  2000              MOVS     r0,#0                 ;152
0000e0  e7e3              B        |L1.170|
;;;154    /*******************************************************************************
                          ENDP


                          AREA ||i.AddSendBuffer||, CODE, READONLY, ALIGN=2

                  AddSendBuffer PROC
;;;760    *******************************************************************************/
;;;761    unsigned short AddSendBuffer(enCCPortDef Port,unsigned char* pBuffer,unsigned short length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;762    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;763      unsigned  char  i  = 0;
00000a  2400              MOVS     r4,#0
;;;764      unsigned  char  lastarry  = 0;
00000c  2700              MOVS     r7,#0
;;;765      
;;;766      stTxdef* Txd  = NULL;
00000e  2500              MOVS     r5,#0
;;;767      
;;;768      switch(Port)
000010  f1b80f05          CMP      r8,#5
000014  d20f              BCS      |L2.54|
000016  e8dff008          TBB      [pc,r8]
00001a  0306              DCB      0x03,0x06
00001c  080a0c00          DCB      0x08,0x0a,0x0c,0x00
;;;769      {
;;;770        case  NonPort   : return 0;   //不继续执行
000020  2000              MOVS     r0,#0
                  |L2.34|
;;;771        case  PcPort    : Txd=AMPPro.buffer.PcTx;    //PC接口发送缓存
;;;772          break;
;;;773        case  CabPort   : Txd=AMPPro.buffer.CabTx;   //柜接口发送缓存
;;;774          break;
;;;775        case  LayPort   : Txd=AMPPro.buffer.LayTx;   //层接口发送缓存
;;;776          break;
;;;777        case  CardPort  : Txd=AMPPro.buffer.CardTx;  //读卡器接口发送缓存
;;;778          break;
;;;779        default :return 0;      //不继续执行 
;;;780      }
;;;781      //-------------------------给当前待发送队列编号(最尾号)
;;;782      for(i=0;i<arrysize;i++)
;;;783      {
;;;784        if(Txd[i].arry>lastarry)
;;;785        {
;;;786          lastarry  = Txd[i].arry;
;;;787          //---------------------检查发送队列中是否有相同的指令，如果有，则退出
;;;788          if(0  ==  memcmp(Txd[i].data,pBuffer,length)) //比较相同
;;;789          {
;;;790            if(length ==  Txd[i].size)    //待发送长度一样
;;;791              return  length;
;;;792          }
;;;793        }
;;;794      }
;;;795      if(lastarry>=arrysize)  //缓存满
;;;796        return 0;     //不继续执行
;;;797      lastarry=lastarry+1;      //最后的队列编号
;;;798      //-------------------------将数据存储到空队列
;;;799      for(i=0;i<arrysize;i++)
;;;800      {
;;;801        if(0  ==  Txd[i].arry)  //0编号表示此为空缓存
;;;802        {
;;;803          memcpy(Txd[i].data,pBuffer,length);
;;;804          Txd[i].arry = lastarry;             //此缓存在发送队列中的排序
;;;805          Txd[i].size = length; 
;;;806          return  length;
;;;807        }
;;;808      }
;;;809      return  0;
;;;810    }
000022  e8bd87f0          POP      {r4-r10,pc}
000026  4d2a              LDR      r5,|L2.208|
000028  e007              B        |L2.58|
00002a  4d2a              LDR      r5,|L2.212|
00002c  e005              B        |L2.58|
00002e  4d2a              LDR      r5,|L2.216|
000030  e003              B        |L2.58|
000032  4d2a              LDR      r5,|L2.220|
000034  e001              B        |L2.58|
                  |L2.54|
000036  2000              MOVS     r0,#0                 ;779
000038  e7f3              B        |L2.34|
                  |L2.58|
00003a  bf00              NOP                            ;772
00003c  2400              MOVS     r4,#0                 ;782
00003e  e01e              B        |L2.126|
                  |L2.64|
000040  eb041084          ADD      r0,r4,r4,LSL #6       ;784
000044  f8150010          LDRB     r0,[r5,r0,LSL #1]     ;784
000048  42b8              CMP      r0,r7                 ;784
00004a  dd16              BLE      |L2.122|
00004c  eb041084          ADD      r0,r4,r4,LSL #6       ;786
000050  f8157010          LDRB     r7,[r5,r0,LSL #1]     ;786
000054  eb041184          ADD      r1,r4,r4,LSL #6       ;788
000058  eb050141          ADD      r1,r5,r1,LSL #1       ;788
00005c  1c88              ADDS     r0,r1,#2              ;788
00005e  4632              MOV      r2,r6                 ;788
000060  4649              MOV      r1,r9                 ;788
000062  f7fffffe          BL       memcmp
000066  b940              CBNZ     r0,|L2.122|
000068  eb041084          ADD      r0,r4,r4,LSL #6       ;790
00006c  eb050040          ADD      r0,r5,r0,LSL #1       ;790
000070  7840              LDRB     r0,[r0,#1]            ;790
000072  42b0              CMP      r0,r6                 ;790
000074  d101              BNE      |L2.122|
000076  4630              MOV      r0,r6                 ;791
000078  e7d3              B        |L2.34|
                  |L2.122|
00007a  1c60              ADDS     r0,r4,#1              ;782
00007c  b2c4              UXTB     r4,r0                 ;782
                  |L2.126|
00007e  2c14              CMP      r4,#0x14              ;782
000080  dbde              BLT      |L2.64|
000082  2f14              CMP      r7,#0x14              ;795
000084  db01              BLT      |L2.138|
000086  2000              MOVS     r0,#0                 ;796
000088  e7cb              B        |L2.34|
                  |L2.138|
00008a  1c78              ADDS     r0,r7,#1              ;797
00008c  b2c7              UXTB     r7,r0                 ;797
00008e  2400              MOVS     r4,#0                 ;799
000090  e01a              B        |L2.200|
                  |L2.146|
000092  eb041084          ADD      r0,r4,r4,LSL #6       ;801
000096  f8150010          LDRB     r0,[r5,r0,LSL #1]     ;801
00009a  b998              CBNZ     r0,|L2.196|
00009c  eb041184          ADD      r1,r4,r4,LSL #6       ;803
0000a0  eb050141          ADD      r1,r5,r1,LSL #1       ;803
0000a4  1c88              ADDS     r0,r1,#2              ;803
0000a6  4632              MOV      r2,r6                 ;803
0000a8  4649              MOV      r1,r9                 ;803
0000aa  f7fffffe          BL       __aeabi_memcpy
0000ae  eb041084          ADD      r0,r4,r4,LSL #6       ;804
0000b2  f8057010          STRB     r7,[r5,r0,LSL #1]     ;804
0000b6  eb041184          ADD      r1,r4,r4,LSL #6       ;805
0000ba  eb050141          ADD      r1,r5,r1,LSL #1       ;805
0000be  704e              STRB     r6,[r1,#1]            ;805
0000c0  4630              MOV      r0,r6                 ;806
0000c2  e7ae              B        |L2.34|
                  |L2.196|
0000c4  1c60              ADDS     r0,r4,#1              ;799
0000c6  b2c4              UXTB     r4,r0                 ;799
                  |L2.200|
0000c8  2c14              CMP      r4,#0x14              ;799
0000ca  dbe2              BLT      |L2.146|
0000cc  2000              MOVS     r0,#0                 ;809
0000ce  e7a8              B        |L2.34|
;;;811    
                          ENDP

                  |L2.208|
                          DCD      AMPPro+0x98
                  |L2.212|
                          DCD      AMPPro+0xac0
                  |L2.216|
                          DCD      AMPPro+0x14e8
                  |L2.220|
                          DCD      AMPPro+0x1f10

                          AREA ||i.AmpCrc16Check||, CODE, READONLY, ALIGN=2

                  AmpCrc16Check PROC
;;;236    *******************************************************************************/
;;;237    unsigned char AmpCrc16Check(unsigned char* pframe,unsigned short* length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;238    {  
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;239      unsigned  short msglen  = 0;  
000008  2500              MOVS     r5,#0
;;;240      unsigned  short	ValidLength	=	*length; 
00000a  f8b78000          LDRH     r8,[r7,#0]
;;;241      unsigned  short crc16; 
;;;242      
;;;243      if(NULL  ==  pframe)
00000e  b914              CBNZ     r4,|L3.22|
;;;244      {
;;;245        return 0;
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;246      }
;;;247      phy  = (stampphydef*)pframe;
;;;248      //crc16 = pbuffer->
;;;249      msglen  = phy->msg.length;
;;;250      if(2==msglen) //应答
;;;251      {
;;;252        phy->crc16.crcl = pframe[4];
;;;253        phy->crc16.crch = pframe[5];
;;;254      }
;;;255      else
;;;256      {
;;;257        if(msglen>ValidLength)     //帧长度不够
;;;258          return  0;
;;;259        else if(msglen>2)     //排除应答帧长度判断
;;;260          if(msglen+5>ValidLength) //消息帧长度不够 
;;;261            return 0;
;;;262        phy->crc16.crcl = pframe[msglen+2];
;;;263        phy->crc16.crch = pframe[msglen+3];
;;;264      }
;;;265      crc16 = CRC16_MODBUS(&pframe[1],msglen+1);
;;;266      if(((crc16&0xFF)==phy->crc16.crcl)&&(((crc16>>8)&0xFF)==phy->crc16.crch))
;;;267      {
;;;268        *length = msglen+5;
;;;269        return 1;
;;;270      }
;;;271      return 0;
;;;272    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L3.22|
000016  4820              LDR      r0,|L3.152|
000018  6004              STR      r4,[r0,#0]            ;247  ; phy
00001a  6800              LDR      r0,[r0,#0]            ;249  ; phy
00001c  7845              LDRB     r5,[r0,#1]            ;249
00001e  2d02              CMP      r5,#2                 ;250
000020  d10a              BNE      |L3.56|
000022  7920              LDRB     r0,[r4,#4]            ;252
000024  491c              LDR      r1,|L3.152|
000026  6809              LDR      r1,[r1,#0]            ;252  ; phy
000028  f8810086          STRB     r0,[r1,#0x86]         ;252
00002c  7961              LDRB     r1,[r4,#5]            ;253
00002e  481a              LDR      r0,|L3.152|
000030  6800              LDR      r0,[r0,#0]            ;253  ; phy
000032  f8801087          STRB     r1,[r0,#0x87]         ;253
000036  e016              B        |L3.102|
                  |L3.56|
000038  4545              CMP      r5,r8                 ;257
00003a  dd01              BLE      |L3.64|
00003c  2000              MOVS     r0,#0                 ;258
00003e  e7e8              B        |L3.18|
                  |L3.64|
000040  2d02              CMP      r5,#2                 ;259
000042  dd04              BLE      |L3.78|
000044  1d68              ADDS     r0,r5,#5              ;260
000046  4540              CMP      r0,r8                 ;260
000048  dd01              BLE      |L3.78|
00004a  2000              MOVS     r0,#0                 ;261
00004c  e7e1              B        |L3.18|
                  |L3.78|
00004e  1ca8              ADDS     r0,r5,#2              ;262
000050  5c20              LDRB     r0,[r4,r0]            ;262
000052  4911              LDR      r1,|L3.152|
000054  6809              LDR      r1,[r1,#0]            ;262  ; phy
000056  f8810086          STRB     r0,[r1,#0x86]         ;262
00005a  1ce8              ADDS     r0,r5,#3              ;263
00005c  5c21              LDRB     r1,[r4,r0]            ;263
00005e  480e              LDR      r0,|L3.152|
000060  6800              LDR      r0,[r0,#0]            ;263  ; phy
000062  f8801087          STRB     r1,[r0,#0x87]         ;263
                  |L3.102|
000066  1c69              ADDS     r1,r5,#1              ;265
000068  1c60              ADDS     r0,r4,#1              ;265
00006a  f7fffffe          BL       CRC16_MODBUS
00006e  4606              MOV      r6,r0                 ;265
000070  b2f0              UXTB     r0,r6                 ;266
000072  4909              LDR      r1,|L3.152|
000074  6809              LDR      r1,[r1,#0]            ;266  ; phy
000076  f8911086          LDRB     r1,[r1,#0x86]         ;266
00007a  4288              CMP      r0,r1                 ;266
00007c  d10a              BNE      |L3.148|
00007e  4806              LDR      r0,|L3.152|
000080  6800              LDR      r0,[r0,#0]            ;266  ; phy
000082  f8900087          LDRB     r0,[r0,#0x87]         ;266
000086  ebb02f16          CMP      r0,r6,LSR #8          ;266
00008a  d103              BNE      |L3.148|
00008c  1d68              ADDS     r0,r5,#5              ;268
00008e  8038              STRH     r0,[r7,#0]            ;268
000090  2001              MOVS     r0,#1                 ;269
000092  e7be              B        |L3.18|
                  |L3.148|
000094  2000              MOVS     r0,#0                 ;271
000096  e7bc              B        |L3.18|
;;;273    /*******************************************************************************
                          ENDP

                  |L3.152|
                          DCD      phy

                          AREA ||i.Check_SendBuff||, CODE, READONLY, ALIGN=2

                  Check_SendBuff PROC
;;;624    *******************************************************************************/
;;;625    unsigned short Check_SendBuff(enCCPortDef Port)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;626    { 
000004  4605              MOV      r5,r0
;;;627      unsigned  char  i  = 0;
000006  2600              MOVS     r6,#0
;;;628      unsigned  short  SendLen  = 0;
000008  2700              MOVS     r7,#0
;;;629      unsigned  char  ackflag =0;
00000a  46b3              MOV      r11,r6
;;;630      unsigned  char  ackdir =0;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;631      unsigned  char* SendAddr = NULL;  
000010  4682              MOV      r10,r0
;;;632      unsigned  char*  ReSendCount;      //PC上传重发计数
;;;633      
;;;634      unsigned  short*  SendTime=NULL;
000012  4680              MOV      r8,r0
;;;635      
;;;636      stTxdef* Txd  = NULL;
000014  4681              MOV      r9,r0
;;;637      
;;;638    
;;;639      //------------------------------检查重发
;;;640      switch(Port)
000016  2d05              CMP      r5,#5
000018  d249              BCS      |L4.174|
00001a  e8dff005          TBB      [pc,r5]
00001e  0306              DCB      0x03,0x06
000020  17293d00          DCB      0x17,0x29,0x3d,0x00
;;;641      {
;;;642        case  NonPort   : return 0;   //不继续执行
000024  2000              MOVS     r0,#0
                  |L4.38|
;;;643        case  PcPort    : ReSendCount = &AMPPro.ReSend.PcCount;
;;;644                          Txd=AMPPro.buffer.PcTx;    //PC接口发送缓存
;;;645                          SendTime  = &AMPPro.Time.PcSendTime;
;;;646                          ackflag = AMPPro.AckQ.PcAck;
;;;647                          ackdir  = AMPPro.AckQ.PcDir;
;;;648          break;
;;;649        case  CabPort   : ReSendCount = &AMPPro.ReSend.CabCount;
;;;650                          Txd=AMPPro.buffer.CabTx;   //柜接口发送缓存
;;;651                          SendTime  = &AMPPro.Time.CabSendTime;
;;;652                          ackflag = AMPPro.AckQ.CabAck;
;;;653                          ackdir  = AMPPro.AckQ.CabDir;
;;;654          break;
;;;655        case  LayPort   : ReSendCount = &AMPPro.ReSend.LayCount;
;;;656                          Txd=AMPPro.buffer.LayTx;   //层接口发送缓存
;;;657                          SendTime  = &AMPPro.Time.LaySendTime;
;;;658                          ackflag = AMPPro.AckQ.LayAck;
;;;659                          ackdir  = AMPPro.AckQ.LayDir;
;;;660          break;
;;;661        case  CardPort  : ReSendCount = &AMPPro.ReSend.CardCount;
;;;662                          Txd=AMPPro.buffer.CardTx;  //读卡器接口发送缓存
;;;663                          SendTime  = &AMPPro.Time.CardSendTime;
;;;664                          ackflag = 0;
;;;665          break;
;;;666        default :return 0;      //不继续执行 
;;;667      }
;;;668      if(ackflag) //有应答请求，先应答
;;;669      {
;;;670        if(ackdir)  //向上应答
;;;671          SendLen = HW_SendBuff(Port,ackupfarme,sizeof(ackupfarme));   //返回已发送字节
;;;672        else
;;;673          SendLen = HW_SendBuff(Port,ackdownfarme,sizeof(ackdownfarme));   //返回已发送字节
;;;674        if(SendLen)   //应答发送成功---清除标志请求
;;;675        {
;;;676          switch(Port)
;;;677          {
;;;678            case  NonPort   : return 0;   //不继续执行
;;;679            case  PcPort    : AMPPro.AckQ.PcAck = 0;
;;;680              break;
;;;681            case  CabPort   : AMPPro.AckQ.CabAck = 0;
;;;682              break;
;;;683            case  LayPort   : AMPPro.AckQ.LayAck = 0;
;;;684              break;
;;;685            case  CardPort  : AMPPro.AckQ.CardAck  = 0;
;;;686              break;
;;;687            default :return 0;      //不继续执行 
;;;688          }
;;;689        }
;;;690        *SendTime  = 10;
;;;691        return  0;
;;;692      }
;;;693      if(*SendTime>0)   //不到重发时间，退出
;;;694      {
;;;695        return  0;
;;;696      }
;;;697      
;;;698      //------------------------------检查发送缓存:先发送排序为1的缓存
;;;699      for(i=0;i<arrysize;i++)
;;;700      {
;;;701        if(1  ==  Txd[i].arry)
;;;702        {
;;;703          SendAddr  = Txd[i].data;    //起始地址
;;;704          SendLen   = Txd[i].size;    //大小
;;;705          break;
;;;706        }
;;;707      }
;;;708      //-----------------------------有发数据 
;;;709      if(NULL!= SendAddr)
;;;710      {
;;;711        SendLen = HW_SendBuff(Port,SendAddr,SendLen);   //返回已发送字节
;;;712        if(SendLen)   //成功发送到缓存
;;;713        {
;;;714          *ReSendCount +=1;
;;;715          *SendTime = ReSendWaitTime;
;;;716          
;;;717          if(*ReSendCount>=maxresendcount) //超出重发次数：放弃发送
;;;718          {
;;;719            
;;;720            SendTimeOut(Port);      //发送超时
;;;721            //Releas_OneBuffer(Port);
;;;722            *ReSendCount  = 0;      //重发清零
;;;723          }
;;;724          if(PcPort ==  Port) //上传到上位机不做重发
;;;725          {
;;;726            Releas_OneBuffer(Port);
;;;727            *ReSendCount  = 0;      //重发清零
;;;728          }
;;;729        }
;;;730        else
;;;731        {
;;;732          *SendTime = ReSendWaitTime;
;;;733        }
;;;734        return  SendLen;
;;;735      }
;;;736      return  0;
;;;737    }
000026  e8bd8ff8          POP      {r3-r11,pc}
00002a  4c69              LDR      r4,|L4.464|
00002c  f8df91a4          LDR      r9,|L4.468|
000030  f1a90890          SUB      r8,r9,#0x90           ;645
000034  f1a80008          SUB      r0,r8,#8              ;646
000038  7d80              LDRB     r0,[r0,#0x16]         ;646  ; AMPPro
00003a  f0000b01          AND      r11,r0,#1             ;646
00003e  f1a80008          SUB      r0,r8,#8              ;647
000042  7d80              LDRB     r0,[r0,#0x16]         ;647  ; AMPPro
000044  f3c00040          UBFX     r0,r0,#1,#1           ;647
000048  9000              STR      r0,[sp,#0]            ;647
00004a  e032              B        |L4.178|
00004c  4c60              LDR      r4,|L4.464|
00004e  1c64              ADDS     r4,r4,#1              ;649
000050  f8df9184          LDR      r9,|L4.472|
000054  f6a928b6          SUB      r8,r9,#0xab6          ;651
000058  f1a8000a          SUB      r0,r8,#0xa            ;652
00005c  7d80              LDRB     r0,[r0,#0x16]         ;652  ; AMPPro
00005e  f3c00b80          UBFX     r11,r0,#2,#1          ;652
000062  f1a8000a          SUB      r0,r8,#0xa            ;653
000066  7d80              LDRB     r0,[r0,#0x16]         ;653  ; AMPPro
000068  f3c000c0          UBFX     r0,r0,#3,#1           ;653
00006c  9000              STR      r0,[sp,#0]            ;653
00006e  e020              B        |L4.178|
000070  4c57              LDR      r4,|L4.464|
000072  1ca4              ADDS     r4,r4,#2              ;655
000074  f8df9164          LDR      r9,|L4.476|
000078  f8df8158          LDR      r8,|L4.468|
00007c  f1a8088c          SUB      r8,r8,#0x8c           ;657
000080  f1a8000c          SUB      r0,r8,#0xc            ;658
000084  7d80              LDRB     r0,[r0,#0x16]         ;658  ; AMPPro
000086  f3c01b00          UBFX     r11,r0,#4,#1          ;658
00008a  f1a8000c          SUB      r0,r8,#0xc            ;659
00008e  7d80              LDRB     r0,[r0,#0x16]         ;659  ; AMPPro
000090  f3c01040          UBFX     r0,r0,#5,#1           ;659
000094  9000              STR      r0,[sp,#0]            ;659
000096  e00c              B        |L4.178|
000098  4c4d              LDR      r4,|L4.464|
00009a  1ce4              ADDS     r4,r4,#3              ;661
00009c  f6a4292b          SUB      r9,r4,#0xa2b          ;662
0000a0  f8df8130          LDR      r8,|L4.468|
0000a4  f1a8088a          SUB      r8,r8,#0x8a           ;663
0000a8  f04f0b00          MOV      r11,#0                ;664
0000ac  e001              B        |L4.178|
                  |L4.174|
0000ae  2000              MOVS     r0,#0                 ;666
0000b0  e7b9              B        |L4.38|
                  |L4.178|
0000b2  bf00              NOP                            ;648
0000b4  f1bb0f00          CMP      r11,#0                ;668
0000b8  d044              BEQ      |L4.324|
0000ba  9800              LDR      r0,[sp,#0]            ;670
0000bc  b130              CBZ      r0,|L4.204|
0000be  2207              MOVS     r2,#7                 ;671
0000c0  4947              LDR      r1,|L4.480|
0000c2  4628              MOV      r0,r5                 ;671
0000c4  f7fffffe          BL       HW_SendBuff
0000c8  b287              UXTH     r7,r0                 ;671
0000ca  e005              B        |L4.216|
                  |L4.204|
0000cc  2207              MOVS     r2,#7                 ;673
0000ce  4945              LDR      r1,|L4.484|
0000d0  4628              MOV      r0,r5                 ;673
0000d2  f7fffffe          BL       HW_SendBuff
0000d6  b287              UXTH     r7,r0                 ;673
                  |L4.216|
0000d8  b37f              CBZ      r7,|L4.314|
0000da  2d05              CMP      r5,#5                 ;676
0000dc  d22a              BCS      |L4.308|
0000de  e8dff005          TBB      [pc,r5]               ;676
0000e2  0305              DCB      0x03,0x05
0000e4  0e172000          DCB      0x0e,0x17,0x20,0x00
0000e8  2000              MOVS     r0,#0                 ;678
0000ea  e79c              B        |L4.38|
0000ec  4839              LDR      r0,|L4.468|
0000ee  3898              SUBS     r0,r0,#0x98           ;679
0000f0  7d80              LDRB     r0,[r0,#0x16]         ;679  ; AMPPro
0000f2  f0200001          BIC      r0,r0,#1              ;679
0000f6  4937              LDR      r1,|L4.468|
0000f8  3998              SUBS     r1,r1,#0x98           ;679
0000fa  7588              STRB     r0,[r1,#0x16]         ;679
0000fc  e01c              B        |L4.312|
0000fe  4835              LDR      r0,|L4.468|
000100  3898              SUBS     r0,r0,#0x98           ;681
000102  7d80              LDRB     r0,[r0,#0x16]         ;681  ; AMPPro
000104  f0200004          BIC      r0,r0,#4              ;681
000108  4932              LDR      r1,|L4.468|
00010a  3998              SUBS     r1,r1,#0x98           ;681
00010c  7588              STRB     r0,[r1,#0x16]         ;681
00010e  e013              B        |L4.312|
000110  4830              LDR      r0,|L4.468|
000112  3898              SUBS     r0,r0,#0x98           ;683
000114  7d80              LDRB     r0,[r0,#0x16]         ;683  ; AMPPro
000116  f0200010          BIC      r0,r0,#0x10           ;683
00011a  492e              LDR      r1,|L4.468|
00011c  3998              SUBS     r1,r1,#0x98           ;683
00011e  7588              STRB     r0,[r1,#0x16]         ;683
000120  e00a              B        |L4.312|
000122  482c              LDR      r0,|L4.468|
000124  3898              SUBS     r0,r0,#0x98           ;685
000126  7d80              LDRB     r0,[r0,#0x16]         ;685  ; AMPPro
000128  f0200040          BIC      r0,r0,#0x40           ;685
00012c  4929              LDR      r1,|L4.468|
00012e  3998              SUBS     r1,r1,#0x98           ;685
000130  7588              STRB     r0,[r1,#0x16]         ;685
000132  e001              B        |L4.312|
                  |L4.308|
000134  2000              MOVS     r0,#0                 ;687
000136  e776              B        |L4.38|
                  |L4.312|
000138  bf00              NOP                            ;680
                  |L4.314|
00013a  200a              MOVS     r0,#0xa               ;690
00013c  f8a80000          STRH     r0,[r8,#0]            ;690
000140  2000              MOVS     r0,#0                 ;691
000142  e770              B        |L4.38|
                  |L4.324|
000144  f8b80000          LDRH     r0,[r8,#0]            ;693
000148  2800              CMP      r0,#0                 ;693
00014a  dd01              BLE      |L4.336|
00014c  2000              MOVS     r0,#0                 ;695
00014e  e76a              B        |L4.38|
                  |L4.336|
000150  2600              MOVS     r6,#0                 ;699
000152  e013              B        |L4.380|
                  |L4.340|
000154  eb061086          ADD      r0,r6,r6,LSL #6       ;701
000158  f8190010          LDRB     r0,[r9,r0,LSL #1]     ;701
00015c  2801              CMP      r0,#1                 ;701
00015e  d10b              BNE      |L4.376|
000160  eb061086          ADD      r0,r6,r6,LSL #6       ;703
000164  eb090040          ADD      r0,r9,r0,LSL #1       ;703
000168  f1000a02          ADD      r10,r0,#2             ;703
00016c  eb061086          ADD      r0,r6,r6,LSL #6       ;704
000170  eb090040          ADD      r0,r9,r0,LSL #1       ;704
000174  7847              LDRB     r7,[r0,#1]            ;704
000176  e003              B        |L4.384|
                  |L4.376|
000178  1c70              ADDS     r0,r6,#1              ;699
00017a  b2c6              UXTB     r6,r0                 ;699
                  |L4.380|
00017c  2e14              CMP      r6,#0x14              ;699
00017e  dbe9              BLT      |L4.340|
                  |L4.384|
000180  bf00              NOP                            ;705
000182  f1ba0f00          CMP      r10,#0                ;709
000186  d021              BEQ      |L4.460|
000188  463a              MOV      r2,r7                 ;711
00018a  4651              MOV      r1,r10                ;711
00018c  4628              MOV      r0,r5                 ;711
00018e  f7fffffe          BL       HW_SendBuff
000192  b287              UXTH     r7,r0                 ;711
000194  b1af              CBZ      r7,|L4.450|
000196  7820              LDRB     r0,[r4,#0]            ;714
000198  1c40              ADDS     r0,r0,#1              ;714
00019a  7020              STRB     r0,[r4,#0]            ;714
00019c  2032              MOVS     r0,#0x32              ;715
00019e  f8a80000          STRH     r0,[r8,#0]            ;715
0001a2  7820              LDRB     r0,[r4,#0]            ;717
0001a4  2805              CMP      r0,#5                 ;717
0001a6  db04              BLT      |L4.434|
0001a8  4628              MOV      r0,r5                 ;720
0001aa  f7fffffe          BL       SendTimeOut
0001ae  2000              MOVS     r0,#0                 ;722
0001b0  7020              STRB     r0,[r4,#0]            ;722
                  |L4.434|
0001b2  2d01              CMP      r5,#1                 ;724
0001b4  d108              BNE      |L4.456|
0001b6  4628              MOV      r0,r5                 ;726
0001b8  f7fffffe          BL       Releas_OneBuffer
0001bc  2000              MOVS     r0,#0                 ;727
0001be  7020              STRB     r0,[r4,#0]            ;727
0001c0  e002              B        |L4.456|
                  |L4.450|
0001c2  2032              MOVS     r0,#0x32              ;732
0001c4  f8a80000          STRH     r0,[r8,#0]            ;732
                  |L4.456|
0001c8  4638              MOV      r0,r7                 ;734
0001ca  e72c              B        |L4.38|
                  |L4.460|
0001cc  2000              MOVS     r0,#0                 ;736
0001ce  e72a              B        |L4.38|
;;;738    /*******************************************************************************
                          ENDP

                  |L4.464|
                          DCD      AMPPro+0x2938
                  |L4.468|
                          DCD      AMPPro+0x98
                  |L4.472|
                          DCD      AMPPro+0xac0
                  |L4.476|
                          DCD      AMPPro+0x14e8
                  |L4.480|
                          DCD      ackupfarme
                  |L4.484|
                          DCD      ackdownfarme

                          AREA ||i.PaketDownMsg||, CODE, READONLY, ALIGN=1

                  PaketDownMsg PROC
;;;340    *******************************************************************************/
;;;341    unsigned	short PaketDownMsg(unsigned	char* pbuffer,eucmddef cmd,unsigned	short* length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;342    {
000004  b0a4              SUB      sp,sp,#0x90
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4615              MOV      r5,r2
;;;343      unsigned  short framlength  = 0;  //msg段数据长度：1字节命令+3字节地址
00000c  2400              MOVS     r4,#0
;;;344      unsigned  char* temp  = NULL;
00000e  46a0              MOV      r8,r4
;;;345    //  stcmddef*  Cmd = NULL;
;;;346      stampphydef ampframe;
;;;347      
;;;348      framlength  = *length+4;  //msg段数据长度：1字节命令+3字节地址
000010  8828              LDRH     r0,[r5,#0]
000012  1d00              ADDS     r0,r0,#4
000014  b284              UXTH     r4,r0
;;;349      temp  = (unsigned  char*)&ampframe.msg.cmd;   //设置命令
000016  f10d0806          ADD      r8,sp,#6
;;;350      *temp = (unsigned  char)cmd;
00001a  f8887000          STRB     r7,[r8,#0]
;;;351      ampframe.msg.cmd.dir  = 0;      //设置此消息为下发类型消息
00001e  f89d0006          LDRB     r0,[sp,#6]
000022  f0200180          BIC      r1,r0,#0x80
000026  f88d1006          STRB     r1,[sp,#6]
;;;352      
;;;353      ampframe.head = headcode;
00002a  207e              MOVS     r0,#0x7e
00002c  f88d0004          STRB     r0,[sp,#4]
;;;354      ampframe.msg.length = framlength;           //设置msg段长度
000030  b2e0              UXTB     r0,r4
000032  f88d0005          STRB     r0,[sp,#5]
;;;355      memcpy(ampframe.msg.data,pbuffer,*length);  //复制数据
000036  882a              LDRH     r2,[r5,#0]
000038  4631              MOV      r1,r6
00003a  f10d000a          ADD      r0,sp,#0xa
00003e  f7fffffe          BL       __aeabi_memcpy
;;;356      
;;;357      framlength  = framlength+5;   //完整帧长度，head,length,crc16,end为5个字节
000042  1d60              ADDS     r0,r4,#5
000044  b284              UXTH     r4,r0
;;;358      
;;;359      memcpy(pbuffer,&ampframe,framlength);   //更新pbuffer内容
000046  4622              MOV      r2,r4
000048  a901              ADD      r1,sp,#4
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       __aeabi_memcpy
;;;360      *length = framlength;   //打包完成后的消息长度
000050  802c              STRH     r4,[r5,#0]
;;;361      return framlength;
000052  4620              MOV      r0,r4
;;;362    }
000054  b024              ADD      sp,sp,#0x90
000056  e8bd81f0          POP      {r4-r8,pc}
;;;363    /*******************************************************************************
                          ENDP


                          AREA ||i.PaketUpMsg||, CODE, READONLY, ALIGN=1

                  PaketUpMsg PROC
;;;309    *******************************************************************************/
;;;310    unsigned	short PaketUpMsg(unsigned	char* pbuffer,eucmddef cmd,unsigned	short* length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;311    {
000004  b0a4              SUB      sp,sp,#0x90
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4615              MOV      r5,r2
;;;312      unsigned  short framlength  = 0;  //msg段数据长度：1字节命令+3字节地址
00000c  2400              MOVS     r4,#0
;;;313      unsigned  char* temp  = NULL;
00000e  46a0              MOV      r8,r4
;;;314    //  stcmddef*  Cmd = NULL;
;;;315      stampphydef ampframe;
;;;316      
;;;317      framlength  = *length+4;  //msg段数据长度：1字节命令+3字节地址
000010  8828              LDRH     r0,[r5,#0]
000012  1d00              ADDS     r0,r0,#4
000014  b284              UXTH     r4,r0
;;;318      temp  = (unsigned  char*)&ampframe.msg.cmd;   //设置命令
000016  f10d0806          ADD      r8,sp,#6
;;;319      *temp = (unsigned  char)cmd;
00001a  f8887000          STRB     r7,[r8,#0]
;;;320      ampframe.msg.cmd.dir  = 1;      //设置此消息为上传类型消息
00001e  f89d0006          LDRB     r0,[sp,#6]
000022  f0200080          BIC      r0,r0,#0x80
000026  3080              ADDS     r0,r0,#0x80
000028  f88d0006          STRB     r0,[sp,#6]
;;;321      
;;;322      ampframe.head = headcode;
00002c  207e              MOVS     r0,#0x7e
00002e  f88d0004          STRB     r0,[sp,#4]
;;;323      ampframe.msg.length = framlength;           //设置msg段长度
000032  b2e0              UXTB     r0,r4
000034  f88d0005          STRB     r0,[sp,#5]
;;;324      memcpy(ampframe.msg.data,pbuffer,*length);  //复制数据
000038  882a              LDRH     r2,[r5,#0]
00003a  4631              MOV      r1,r6
00003c  f10d000a          ADD      r0,sp,#0xa
000040  f7fffffe          BL       __aeabi_memcpy
;;;325      
;;;326      framlength  = framlength+5;   //完整帧长度，head,length,crc16,end为5个字节
000044  1d60              ADDS     r0,r4,#5
000046  b284              UXTH     r4,r0
;;;327      
;;;328      memcpy(pbuffer,&ampframe,framlength);   //更新pbuffer内容
000048  4622              MOV      r2,r4
00004a  a901              ADD      r1,sp,#4
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       __aeabi_memcpy
;;;329      *length = framlength;   //打包完成后的消息长度
000052  802c              STRH     r4,[r5,#0]
;;;330      return framlength;
000054  4620              MOV      r0,r4
;;;331    }
000056  b024              ADD      sp,sp,#0x90
000058  e8bd81f0          POP      {r4-r8,pc}
;;;332    /*******************************************************************************
                          ENDP


                          AREA ||i.Releas_OneBuffer||, CODE, READONLY, ALIGN=2

                  Releas_OneBuffer PROC
;;;511    *******************************************************************************/
;;;512    unsigned short Releas_OneBuffer(enCCPortDef Port)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
000002  4603              MOV      r3,r0
;;;514      unsigned  char  i  = 0;
000004  2100              MOVS     r1,#0
;;;515      stTxdef* Txd  = NULL;
000006  2400              MOVS     r4,#0
;;;516      unsigned  char*  ReSendCount;      //PC上传重发计数
;;;517      unsigned  short*  SendTime=NULL;
000008  2500              MOVS     r5,#0
;;;518      
;;;519      switch(Port)
00000a  2b05              CMP      r3,#5
00000c  d21e              BCS      |L7.76|
00000e  e8dff003          TBB      [pc,r3]
000012  0305              DCB      0x03,0x05
000014  0a101600          DCB      0x0a,0x10,0x16,0x00
;;;520      {
;;;521        case  NonPort   : return 0;   //不继续执行
000018  2000              MOVS     r0,#0
                  |L7.26|
;;;522        case  PcPort    : ReSendCount = &AMPPro.ReSend.PcCount;
;;;523                          Txd=AMPPro.buffer.PcTx;    //PC接口发送缓存
;;;524                          SendTime  = &AMPPro.Time.PcSendTime;
;;;525          break;
;;;526        case  CabPort   : ReSendCount = &AMPPro.ReSend.CabCount;
;;;527                          Txd=AMPPro.buffer.CabTx;   //柜接口发送缓存
;;;528                          SendTime  = &AMPPro.Time.CabSendTime;
;;;529          break;
;;;530        case  LayPort   : ReSendCount = &AMPPro.ReSend.LayCount;
;;;531                          Txd=AMPPro.buffer.LayTx;   //层接口发送缓存
;;;532                          SendTime  = &AMPPro.Time.LaySendTime;
;;;533          break;
;;;534        case  CardPort  : ReSendCount = &AMPPro.ReSend.CardCount;
;;;535                          Txd=AMPPro.buffer.CardTx;  //读卡器接口发送缓存
;;;536                          SendTime  = &AMPPro.Time.CardSendTime;
;;;537          break;
;;;538        default :return 0;      //不继续执行 
;;;539      }
;;;540      for(i=0;i<arrysize;i++)
;;;541      {
;;;542        if(Txd[i].arry>0)
;;;543        {
;;;544          Txd[i].arry--;
;;;545          *SendTime  = SendNopTime;   //释放一个缓存后等待SendNopTime时间后再发下一帧
;;;546          *ReSendCount  = 0;
;;;547        }
;;;548      }
;;;549      return  0;
;;;550    }
00001a  bd70              POP      {r4-r6,pc}
00001c  4a1a              LDR      r2,|L7.136|
00001e  4c1b              LDR      r4,|L7.140|
000020  f1a40590          SUB      r5,r4,#0x90           ;524
000024  e014              B        |L7.80|
000026  4a18              LDR      r2,|L7.136|
000028  1c52              ADDS     r2,r2,#1              ;526
00002a  4c19              LDR      r4,|L7.144|
00002c  f6a425b6          SUB      r5,r4,#0xab6          ;528
000030  e00e              B        |L7.80|
000032  4a15              LDR      r2,|L7.136|
000034  1c92              ADDS     r2,r2,#2              ;530
000036  4c17              LDR      r4,|L7.148|
000038  4d14              LDR      r5,|L7.140|
00003a  3d8c              SUBS     r5,r5,#0x8c           ;532
00003c  e008              B        |L7.80|
00003e  4a12              LDR      r2,|L7.136|
000040  1cd2              ADDS     r2,r2,#3              ;534
000042  f6a2242b          SUB      r4,r2,#0xa2b          ;535
000046  4d11              LDR      r5,|L7.140|
000048  3d8a              SUBS     r5,r5,#0x8a           ;536
00004a  e001              B        |L7.80|
                  |L7.76|
00004c  2000              MOVS     r0,#0                 ;538
00004e  e7e4              B        |L7.26|
                  |L7.80|
000050  bf00              NOP                            ;525
000052  2100              MOVS     r1,#0                 ;540
000054  e014              B        |L7.128|
                  |L7.86|
000056  eb011081          ADD      r0,r1,r1,LSL #6       ;542
00005a  f8140010          LDRB     r0,[r4,r0,LSL #1]     ;542
00005e  2800              CMP      r0,#0                 ;542
000060  dd0c              BLE      |L7.124|
000062  eb011081          ADD      r0,r1,r1,LSL #6       ;544
000066  f8140010          LDRB     r0,[r4,r0,LSL #1]     ;544
00006a  1e40              SUBS     r0,r0,#1              ;544
00006c  eb011681          ADD      r6,r1,r1,LSL #6       ;544
000070  f8040016          STRB     r0,[r4,r6,LSL #1]     ;544
000074  2003              MOVS     r0,#3                 ;545
000076  8028              STRH     r0,[r5,#0]            ;545
000078  2000              MOVS     r0,#0                 ;546
00007a  7010              STRB     r0,[r2,#0]            ;546
                  |L7.124|
00007c  1c48              ADDS     r0,r1,#1              ;540
00007e  b2c1              UXTB     r1,r0                 ;540
                  |L7.128|
000080  2914              CMP      r1,#0x14              ;540
000082  dbe8              BLT      |L7.86|
000084  2000              MOVS     r0,#0                 ;549
000086  e7c8              B        |L7.26|
;;;551    /*******************************************************************************
                          ENDP

                  |L7.136|
                          DCD      AMPPro+0x2938
                  |L7.140|
                          DCD      AMPPro+0x98
                  |L7.144|
                          DCD      AMPPro+0xac0
                  |L7.148|
                          DCD      AMPPro+0x14e8

                          AREA ||i.SendTimeOut||, CODE, READONLY, ALIGN=2

                  SendTimeOut PROC
;;;470    *******************************************************************************/
;;;471    unsigned short SendTimeOut(enCCPortDef Port)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;472    {
000004  4605              MOV      r5,r0
;;;473      unsigned  char  i  = 0;
000006  2400              MOVS     r4,#0
;;;474      stTxdef* Txd  = NULL;
000008  2600              MOVS     r6,#0
;;;475      unsigned  char*  ReSendCount;      //PC上传重发计数
;;;476      unsigned  short*  SendTime=NULL;
00000a  46a0              MOV      r8,r4
;;;477      stampphydef* ampframe=NULL;
00000c  2700              MOVS     r7,#0
;;;478      
;;;479      switch(Port)
00000e  2d05              CMP      r5,#5
000010  d20f              BCS      |L8.50|
000012  e8dff005          TBB      [pc,r5]
000016  0306              DCB      0x03,0x06
000018  080a0c00          DCB      0x08,0x0a,0x0c,0x00
;;;480      {
;;;481        case  NonPort   : return 0;   //不继续执行
00001c  2000              MOVS     r0,#0
                  |L8.30|
;;;482        case  PcPort    : Txd=AMPPro.buffer.PcTx;    //PC接口发送缓存
;;;483          break;
;;;484        case  CabPort   : Txd=AMPPro.buffer.CabTx;   //柜接口发送缓存
;;;485          break;
;;;486        case  LayPort   : Txd=AMPPro.buffer.LayTx;   //层接口发送缓存
;;;487          break;
;;;488        case  CardPort  : Txd=AMPPro.buffer.CardTx;  //读卡器接口发送缓存
;;;489          break;
;;;490        default :return 0;      //不继续执行 
;;;491      }
;;;492      for(i=0;i<arrysize;i++)
;;;493      {
;;;494        if(1==Txd[i].arry>0)  //当前已发送超时的消息
;;;495        {
;;;496          ampframe  = (stampphydef*)Txd[i].data;
;;;497          CommTimeOutUpdata(Port,ampframe->msg.addr);   //设置超时
;;;498          Releas_OneBuffer(Port);     //释放缓存
;;;499        }
;;;500      }
;;;501      return  0;
;;;502    }
00001e  e8bd83f8          POP      {r3-r9,pc}
000022  4e18              LDR      r6,|L8.132|
000024  e007              B        |L8.54|
000026  4e18              LDR      r6,|L8.136|
000028  e005              B        |L8.54|
00002a  4e18              LDR      r6,|L8.140|
00002c  e003              B        |L8.54|
00002e  4e18              LDR      r6,|L8.144|
000030  e001              B        |L8.54|
                  |L8.50|
000032  2000              MOVS     r0,#0                 ;490
000034  e7f3              B        |L8.30|
                  |L8.54|
000036  bf00              NOP                            ;483
000038  2400              MOVS     r4,#0                 ;492
00003a  e01f              B        |L8.124|
                  |L8.60|
00003c  eb041084          ADD      r0,r4,r4,LSL #6       ;494
000040  f8160010          LDRB     r0,[r6,r0,LSL #1]     ;494
000044  2800              CMP      r0,#0                 ;494
000046  dd01              BLE      |L8.76|
000048  2001              MOVS     r0,#1                 ;494
00004a  e000              B        |L8.78|
                  |L8.76|
00004c  2000              MOVS     r0,#0                 ;494
                  |L8.78|
00004e  2801              CMP      r0,#1                 ;494
000050  d112              BNE      |L8.120|
000052  eb041084          ADD      r0,r4,r4,LSL #6       ;496
000056  eb060040          ADD      r0,r6,r0,LSL #1       ;496
00005a  1c87              ADDS     r7,r0,#2              ;496
00005c  f8b71003          LDRH     r1,[r7,#3]            ;497
000060  f8ad1000          STRH     r1,[sp,#0]            ;497
000064  7978              LDRB     r0,[r7,#5]            ;497
000066  f88d0002          STRB     r0,[sp,#2]            ;497
00006a  4628              MOV      r0,r5                 ;497
00006c  9900              LDR      r1,[sp,#0]            ;497
00006e  f7fffffe          BL       CommTimeOutUpdata
000072  4628              MOV      r0,r5                 ;498
000074  f7fffffe          BL       Releas_OneBuffer
                  |L8.120|
000078  1c60              ADDS     r0,r4,#1              ;492
00007a  b2c4              UXTB     r4,r0                 ;492
                  |L8.124|
00007c  2c14              CMP      r4,#0x14              ;492
00007e  dbdd              BLT      |L8.60|
000080  2000              MOVS     r0,#0                 ;501
000082  e7cc              B        |L8.30|
;;;503    /*******************************************************************************
                          ENDP

                  |L8.132|
                          DCD      AMPPro+0x98
                  |L8.136|
                          DCD      AMPPro+0xac0
                  |L8.140|
                          DCD      AMPPro+0x14e8
                  |L8.144|
                          DCD      AMPPro+0x1f10

                          AREA ||i.Send_ConnectErr||, CODE, READONLY, ALIGN=1

                  Send_ConnectErr PROC
;;;746    *******************************************************************************/
;;;747    void Send_ConnectErr(enCCPortDef Port,unsigned char* pBuffer,unsigned short length)
000000  4770              BX       lr
;;;748    {
;;;749    
;;;750    }
;;;751    
                          ENDP


                          AREA ||i.Send_Server||, CODE, READONLY, ALIGN=2

                  Send_Server PROC
;;;592    *******************************************************************************/
;;;593    void Send_Server(void)
000000  b510              PUSH     {r4,lr}
;;;594    {
;;;595        //----------------PC发送
;;;596        if(0  ==  AMPPro.Time.PcSendTime)
000002  480c              LDR      r0,|L10.52|
000004  8900              LDRH     r0,[r0,#8]  ; AMPPro
000006  b910              CBNZ     r0,|L10.14|
;;;597        {
;;;598          Check_SendBuff(PcPort);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       Check_SendBuff
                  |L10.14|
;;;599        }
;;;600        //----------------柜发送
;;;601        if(0  ==  AMPPro.Time.CabSendTime)
00000e  4809              LDR      r0,|L10.52|
000010  8940              LDRH     r0,[r0,#0xa]  ; AMPPro
000012  b910              CBNZ     r0,|L10.26|
;;;602        {
;;;603          Check_SendBuff(CabPort);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       Check_SendBuff
                  |L10.26|
;;;604        }
;;;605        //----------------层发送
;;;606        if(0  ==  AMPPro.Time.LaySendTime)
00001a  4806              LDR      r0,|L10.52|
00001c  8980              LDRH     r0,[r0,#0xc]  ; AMPPro
00001e  b910              CBNZ     r0,|L10.38|
;;;607        {
;;;608          Check_SendBuff(LayPort);
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       Check_SendBuff
                  |L10.38|
;;;609        }
;;;610        //----------------读卡器发送
;;;611        if(0  ==  AMPPro.Time.CardSendTime)
000026  4803              LDR      r0,|L10.52|
000028  89c0              LDRH     r0,[r0,#0xe]  ; AMPPro
00002a  b910              CBNZ     r0,|L10.50|
;;;612        {
;;;613          Check_SendBuff(CardPort);
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       Check_SendBuff
                  |L10.50|
;;;614        }
;;;615    }
000032  bd10              POP      {r4,pc}
;;;616    /*******************************************************************************
                          ENDP

                  |L10.52|
                          DCD      AMPPro

                          AREA ||i.SetFrame||, CODE, READONLY, ALIGN=1

                  SetFrame PROC
;;;281    *******************************************************************************/
;;;282    unsigned short SetFrame(unsigned char* pframe,unsigned short* length)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;283    {  
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;284      unsigned short msglen = 0;    //消息段长度
000008  2700              MOVS     r7,#0
;;;285      unsigned short datalen = 0;   //data长度
00000a  46b8              MOV      r8,r7
;;;286      unsigned short crclen = 0;    //要参与CRC计数的字节数
00000c  46b9              MOV      r9,r7
;;;287      unsigned short crc16 = 0;     //计算的CRC16
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
;;;288      
;;;289      stampphydef* ampframe;
;;;290      
;;;291      ampframe  = (stampphydef*)pframe;
000012  4625              MOV      r5,r4
;;;292      msglen  = ampframe->msg.length;
000014  786f              LDRB     r7,[r5,#1]
;;;293      datalen = msglen-4;   //一字节命令，三字节地址
000016  1f38              SUBS     r0,r7,#4
000018  fa1ff880          UXTH     r8,r0
;;;294      crclen  = msglen+1;   //msg.length需要参与CRC计算
00001c  f1070901          ADD      r9,r7,#1
;;;295      crc16 = CRC16_MODBUS(&ampframe->msg.length,crclen);
000020  4649              MOV      r1,r9
000022  1c68              ADDS     r0,r5,#1
000024  f7fffffe          BL       CRC16_MODBUS
000028  9000              STR      r0,[sp,#0]
;;;296      memcpy(&ampframe->msg.data[datalen],&crc16,2);       //复制CRC数据
00002a  1da8              ADDS     r0,r5,#6
00002c  4440              ADD      r0,r0,r8
00002e  f8bd1000          LDRH     r1,[sp,#0]
000032  8001              STRH     r1,[r0,#0]
;;;297      ampframe->msg.data[datalen+2]  = endcode;      //增加结束符
000034  227f              MOVS     r2,#0x7f
000036  1da8              ADDS     r0,r5,#6
000038  f1080102          ADD      r1,r8,#2
00003c  5442              STRB     r2,[r0,r1]
;;;298      return *length;
00003e  8830              LDRH     r0,[r6,#0]
;;;299    }
000040  e8bd83f8          POP      {r3-r9,pc}
;;;300    
                          ENDP


                          AREA ||i.ackFrame||, CODE, READONLY, ALIGN=2

                  ackFrame PROC
;;;559    *******************************************************************************/
;;;560    void ackFrame(enCCPortDef Port,unsigned char dir)
000000  2805              CMP      r0,#5
;;;561    {
;;;562      switch(Port)
000002  d241              BCS      |L12.136|
000004  e8dff000          TBB      [pc,r0]
000008  03041322          DCB      0x03,0x04,0x13,0x22
00000c  3100              DCB      0x31,0x00
                  |L12.14|
;;;563      {
;;;564        case  NonPort   : return;   //不继续执行
;;;565        case  PcPort    : AMPPro.AckQ.PcAck     = 1;
;;;566                          AMPPro.AckQ.PcDir     = dir;
;;;567                          AMPPro.Time.PcSendTime=SendNopTime;   //等待发送时间
;;;568          break;
;;;569        case  CabPort   : AMPPro.AckQ.CabAck    = 1;
;;;570                          AMPPro.AckQ.CabDir    = dir;
;;;571                          AMPPro.Time.CabSendTime=SendNopTime;   //等待发送时间
;;;572          break;
;;;573        case  LayPort   : AMPPro.AckQ.LayAck    = 1;
;;;574                          AMPPro.AckQ.LayDir    = dir;
;;;575                          AMPPro.Time.LaySendTime=SendNopTime;   //等待发送时间
;;;576          break;
;;;577        case  CardPort  : AMPPro.AckQ.CardAck   = 1;
;;;578                          AMPPro.AckQ.CardDir   = dir;
;;;579                          AMPPro.Time.CardSendTime=SendNopTime;   //等待发送时间
;;;580          break;
;;;581        default :return;      //不继续执行 
;;;582      }
;;;583    }
00000e  4770              BX       lr
000010  4a1f              LDR      r2,|L12.144|
000012  7d92              LDRB     r2,[r2,#0x16]         ;565  ; AMPPro
000014  f0220201          BIC      r2,r2,#1              ;565
000018  1c52              ADDS     r2,r2,#1              ;565
00001a  4b1d              LDR      r3,|L12.144|
00001c  759a              STRB     r2,[r3,#0x16]         ;565
00001e  461a              MOV      r2,r3                 ;566
000020  7d92              LDRB     r2,[r2,#0x16]         ;566  ; AMPPro
000022  f3610241          BFI      r2,r1,#1,#1           ;566
000026  759a              STRB     r2,[r3,#0x16]         ;566
000028  2203              MOVS     r2,#3                 ;567
00002a  811a              STRH     r2,[r3,#8]            ;567
00002c  e02d              B        |L12.138|
00002e  4a18              LDR      r2,|L12.144|
000030  7d92              LDRB     r2,[r2,#0x16]         ;569  ; AMPPro
000032  f0220204          BIC      r2,r2,#4              ;569
000036  1d12              ADDS     r2,r2,#4              ;569
000038  4b15              LDR      r3,|L12.144|
00003a  759a              STRB     r2,[r3,#0x16]         ;569
00003c  461a              MOV      r2,r3                 ;570
00003e  7d92              LDRB     r2,[r2,#0x16]         ;570  ; AMPPro
000040  f36102c3          BFI      r2,r1,#3,#1           ;570
000044  759a              STRB     r2,[r3,#0x16]         ;570
000046  2203              MOVS     r2,#3                 ;571
000048  815a              STRH     r2,[r3,#0xa]          ;571
00004a  e01e              B        |L12.138|
00004c  4a10              LDR      r2,|L12.144|
00004e  7d92              LDRB     r2,[r2,#0x16]         ;573  ; AMPPro
000050  f0220210          BIC      r2,r2,#0x10           ;573
000054  3210              ADDS     r2,r2,#0x10           ;573
000056  4b0e              LDR      r3,|L12.144|
000058  759a              STRB     r2,[r3,#0x16]         ;573
00005a  461a              MOV      r2,r3                 ;574
00005c  7d92              LDRB     r2,[r2,#0x16]         ;574  ; AMPPro
00005e  f3611245          BFI      r2,r1,#5,#1           ;574
000062  759a              STRB     r2,[r3,#0x16]         ;574
000064  2203              MOVS     r2,#3                 ;575
000066  819a              STRH     r2,[r3,#0xc]          ;575
000068  e00f              B        |L12.138|
00006a  4a09              LDR      r2,|L12.144|
00006c  7d92              LDRB     r2,[r2,#0x16]         ;577  ; AMPPro
00006e  f0220240          BIC      r2,r2,#0x40           ;577
000072  3240              ADDS     r2,r2,#0x40           ;577
000074  4b06              LDR      r3,|L12.144|
000076  759a              STRB     r2,[r3,#0x16]         ;577
000078  461a              MOV      r2,r3                 ;578
00007a  7d92              LDRB     r2,[r2,#0x16]         ;578  ; AMPPro
00007c  f36112c7          BFI      r2,r1,#7,#1           ;578
000080  759a              STRB     r2,[r3,#0x16]         ;578
000082  2203              MOVS     r2,#3                 ;579
000084  81da              STRH     r2,[r3,#0xe]          ;579
000086  e000              B        |L12.138|
                  |L12.136|
000088  e7c1              B        |L12.14|
                  |L12.138|
00008a  bf00              NOP                            ;568
00008c  bf00              NOP      
00008e  e7be              B        |L12.14|
;;;584    /*******************************************************************************
                          ENDP

                  |L12.144|
                          DCD      AMPPro

                          AREA ||i.ackcheck||, CODE, READONLY, ALIGN=1

                  ackcheck PROC
;;;371    *******************************************************************************/
;;;372    unsigned char ackcheck(unsigned char* pframe)
000000  4601              MOV      r1,r0
;;;373    { 
;;;374      unsigned  char Cmd  = 0;
000002  2200              MOVS     r2,#0
;;;375      stampphydef *ampframe;
;;;376      
;;;377      if(NULL ==  pframe)
000004  b909              CBNZ     r1,|L13.10|
;;;378        return  0;
000006  2000              MOVS     r0,#0
                  |L13.8|
;;;379      
;;;380      ampframe = (stampphydef*)pframe;
;;;381      Cmd = (unsigned  char)ampframe->msg.cmd.cmd;
;;;382      Cmd&=0x3F;            //去掉高2位
;;;383      
;;;384      if(AmpCmdAck  ==  Cmd)
;;;385        return  1;        //应答消息
;;;386      return 0;
;;;387    }
000008  4770              BX       lr
                  |L13.10|
00000a  460b              MOV      r3,r1                 ;380
00000c  7898              LDRB     r0,[r3,#2]            ;381
00000e  f000023f          AND      r2,r0,#0x3f           ;381
000012  bf00              NOP                            ;382
000014  2a01              CMP      r2,#1                 ;384
000016  d101              BNE      |L13.28|
000018  2001              MOVS     r0,#1                 ;385
00001a  e7f5              B        |L13.8|
                  |L13.28|
00001c  2000              MOVS     r0,#0                 ;386
00001e  e7f3              B        |L13.8|
;;;388    /*******************************************************************************
                          ENDP


                          AREA ||i.addr1check||, CODE, READONLY, ALIGN=2

                  addr1check PROC
;;;396    *******************************************************************************/
;;;397    unsigned char addr1check(unsigned char* pframe,unsigned char addr1)
000000  4602              MOV      r2,r0
;;;398    { 
;;;399      unsigned addrck=0;
000002  2300              MOVS     r3,#0
;;;400      if(NULL ==  pframe)
000004  b90a              CBNZ     r2,|L14.10|
;;;401        return  0;
000006  2000              MOVS     r0,#0
                  |L14.8|
;;;402      phy = (stampphydef*)pframe;
;;;403      addrck  = phy->msg.addr.address1;
;;;404      if((addrck==addr1)||(addrck==0xFF))
;;;405        return  1;
;;;406      return 0;
;;;407    }
000008  4770              BX       lr
                  |L14.10|
00000a  4806              LDR      r0,|L14.36|
00000c  6002              STR      r2,[r0,#0]            ;402  ; phy
00000e  6800              LDR      r0,[r0,#0]            ;403  ; phy
000010  78c3              LDRB     r3,[r0,#3]            ;403
000012  428b              CMP      r3,r1                 ;404
000014  d001              BEQ      |L14.26|
000016  2bff              CMP      r3,#0xff              ;404
000018  d101              BNE      |L14.30|
                  |L14.26|
00001a  2001              MOVS     r0,#1                 ;405
00001c  e7f4              B        |L14.8|
                  |L14.30|
00001e  2000              MOVS     r0,#0                 ;406
000020  e7f2              B        |L14.8|
;;;408    /*******************************************************************************
                          ENDP

000022  0000              DCW      0x0000
                  |L14.36|
                          DCD      phy

                          AREA ||i.addr2check||, CODE, READONLY, ALIGN=2

                  addr2check PROC
;;;416    *******************************************************************************/
;;;417    unsigned char addr2check(unsigned char* pframe,unsigned char addr2)
000000  4602              MOV      r2,r0
;;;418    { 
;;;419      unsigned addrck=0;
000002  2300              MOVS     r3,#0
;;;420      if(NULL ==  pframe)
000004  b90a              CBNZ     r2,|L15.10|
;;;421        return  0;
000006  2000              MOVS     r0,#0
                  |L15.8|
;;;422      phy = (stampphydef*)pframe;
;;;423      addrck  = phy->msg.addr.address2;
;;;424      if((addrck==addr2)||(addrck==0xFF))
;;;425        return  1;
;;;426      return 0;
;;;427    }
000008  4770              BX       lr
                  |L15.10|
00000a  4806              LDR      r0,|L15.36|
00000c  6002              STR      r2,[r0,#0]            ;422  ; phy
00000e  6800              LDR      r0,[r0,#0]            ;423  ; phy
000010  7903              LDRB     r3,[r0,#4]            ;423
000012  428b              CMP      r3,r1                 ;424
000014  d001              BEQ      |L15.26|
000016  2bff              CMP      r3,#0xff              ;424
000018  d101              BNE      |L15.30|
                  |L15.26|
00001a  2001              MOVS     r0,#1                 ;425
00001c  e7f4              B        |L15.8|
                  |L15.30|
00001e  2000              MOVS     r0,#0                 ;426
000020  e7f2              B        |L15.8|
;;;428    /*******************************************************************************
                          ENDP

000022  0000              DCW      0x0000
                  |L15.36|
                          DCD      phy

                          AREA ||i.addr3check||, CODE, READONLY, ALIGN=2

                  addr3check PROC
;;;436    *******************************************************************************/
;;;437    unsigned char addr3check(unsigned char* pframe,unsigned char addr3)
000000  4602              MOV      r2,r0
;;;438    { 
;;;439      unsigned addrck=0;
000002  2300              MOVS     r3,#0
;;;440      if(NULL ==  pframe)
000004  b90a              CBNZ     r2,|L16.10|
;;;441        return  0;
000006  2000              MOVS     r0,#0
                  |L16.8|
;;;442      phy = (stampphydef*)pframe;
;;;443      addrck  = phy->msg.addr.address3;
;;;444      if((addrck==addr3)||(addrck==0xFF))
;;;445        return  1;
;;;446      return 0;
;;;447    }
000008  4770              BX       lr
                  |L16.10|
00000a  4806              LDR      r0,|L16.36|
00000c  6002              STR      r2,[r0,#0]            ;442  ; phy
00000e  6800              LDR      r0,[r0,#0]            ;443  ; phy
000010  7943              LDRB     r3,[r0,#5]            ;443
000012  428b              CMP      r3,r1                 ;444
000014  d001              BEQ      |L16.26|
000016  2bff              CMP      r3,#0xff              ;444
000018  d101              BNE      |L16.30|
                  |L16.26|
00001a  2001              MOVS     r0,#1                 ;445
00001c  e7f4              B        |L16.8|
                  |L16.30|
00001e  2000              MOVS     r0,#0                 ;446
000020  e7f2              B        |L16.8|
;;;448    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      phy

                          AREA ||i.getframe||, CODE, READONLY, ALIGN=1

                  getframe PROC
;;;162    *******************************************************************************/
;;;163    unsigned short getframe(unsigned char* pbuffer,unsigned short* length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;164    {  
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;165      unsigned  char* headaddr  = NULL;
000008  2500              MOVS     r5,#0
;;;166      unsigned  short farmelength = 0;
00000a  2700              MOVS     r7,#0
;;;167      headaddr  = getheadaddr(pbuffer,length);
00000c  4621              MOV      r1,r4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       getheadaddr
000014  4605              MOV      r5,r0
;;;168      if(NULL==headaddr)
000016  b915              CBNZ     r5,|L17.30|
;;;169      {
;;;170        return  0;
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;171      }
;;;172      pbuffer = headaddr;
;;;173      farmelength = *length;
;;;174      return  farmelength;
;;;175    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L17.30|
00001e  462e              MOV      r6,r5                 ;172
000020  8827              LDRH     r7,[r4,#0]            ;173
000022  4638              MOV      r0,r7                 ;174
000024  e7f9              B        |L17.26|
;;;176    /*******************************************************************************
                          ENDP


                          AREA ||i.getheadaddr||, CODE, READONLY, ALIGN=1

                  getheadaddr PROC
;;;184    *******************************************************************************/
;;;185    unsigned char* getheadaddr(unsigned char* pbuffer,unsigned short* length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;186    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;187      unsigned  char* headaddr  = NULL;
000006  2500              MOVS     r5,#0
;;;188      unsigned  char* endaddr   = NULL;
000008  2700              MOVS     r7,#0
;;;189      
;;;190      unsigned short	ValidLength	=	*length;
00000a  8820              LDRH     r0,[r4,#0]
00000c  9000              STR      r0,[sp,#0]
;;;191    //  unsigned short	framelength	=	0;
;;;192      
;;;193      if(NULL  ==  pbuffer)
00000e  b90e              CBNZ     r6,|L18.20|
;;;194      {
;;;195        return NULL;
000010  2000              MOVS     r0,#0
                  |L18.18|
;;;196      }
;;;197      startcheckdata:
;;;198      headaddr	=	(unsigned char*)memchr(pbuffer,headcode,ValidLength);
;;;199    	endaddr		=	(unsigned char*)memchr(headaddr,endcode,ValidLength);
;;;200      ValidLength = ValidLength-((unsigned long)headaddr-(unsigned long)pbuffer);
;;;201      if(ValidLength<7)   //小于最小帧长度
;;;202      {
;;;203        *length = 0;
;;;204        return  NULL;
;;;205      }
;;;206      if((NULL==headaddr)||(NULL==endaddr))
;;;207      {
;;;208        *length = 0;
;;;209        return  NULL;
;;;210      }
;;;211      else
;;;212      {    
;;;213        if(AmpCrc16Check(headaddr,&ValidLength))
;;;214        {
;;;215          *length = ValidLength;
;;;216          return headaddr;
;;;217        }
;;;218        else
;;;219        {
;;;220          pbuffer = &headaddr[1];
;;;221          ValidLength = ValidLength-1;
;;;222          goto startcheckdata;
;;;223        }    
;;;224      }
;;;225    //  return  NULL;
;;;226    }
000012  bdf8              POP      {r3-r7,pc}
                  |L18.20|
000014  bf00              NOP                            ;197
                  |L18.22|
000016  f8bd2000          LDRH     r2,[sp,#0]            ;198
00001a  217e              MOVS     r1,#0x7e              ;198
00001c  4630              MOV      r0,r6                 ;198
00001e  f7fffffe          BL       memchr
000022  4605              MOV      r5,r0                 ;198
000024  f8bd2000          LDRH     r2,[sp,#0]            ;199
000028  217f              MOVS     r1,#0x7f              ;199
00002a  4628              MOV      r0,r5                 ;199
00002c  f7fffffe          BL       memchr
000030  4607              MOV      r7,r0                 ;199
000032  1ba8              SUBS     r0,r5,r6              ;200
000034  f8bd1000          LDRH     r1,[sp,#0]            ;200
000038  1a08              SUBS     r0,r1,r0              ;200
00003a  b280              UXTH     r0,r0                 ;200
00003c  9000              STR      r0,[sp,#0]            ;200
00003e  f8bd0000          LDRH     r0,[sp,#0]            ;201
000042  2807              CMP      r0,#7                 ;201
000044  da02              BGE      |L18.76|
000046  2000              MOVS     r0,#0                 ;203
000048  8020              STRH     r0,[r4,#0]            ;203
00004a  e7e2              B        |L18.18|
                  |L18.76|
00004c  b105              CBZ      r5,|L18.80|
00004e  b917              CBNZ     r7,|L18.86|
                  |L18.80|
000050  2000              MOVS     r0,#0                 ;208
000052  8020              STRH     r0,[r4,#0]            ;208
000054  e7dd              B        |L18.18|
                  |L18.86|
000056  4669              MOV      r1,sp                 ;213
000058  4628              MOV      r0,r5                 ;213
00005a  f7fffffe          BL       AmpCrc16Check
00005e  b120              CBZ      r0,|L18.106|
000060  f8bd0000          LDRH     r0,[sp,#0]            ;215
000064  8020              STRH     r0,[r4,#0]            ;215
000066  4628              MOV      r0,r5                 ;216
000068  e7d3              B        |L18.18|
                  |L18.106|
00006a  1c6e              ADDS     r6,r5,#1              ;220
00006c  f8bd0000          LDRH     r0,[sp,#0]            ;221
000070  1e40              SUBS     r0,r0,#1              ;221
000072  b280              UXTH     r0,r0                 ;221
000074  9000              STR      r0,[sp,#0]            ;221
000076  e7ce              B        |L18.22|
;;;227    
                          ENDP


                          AREA ||i.sendbuffer||, CODE, READONLY, ALIGN=1

                  sendbuffer PROC
;;;457    *******************************************************************************/
;;;458    unsigned short sendbuffer(unsigned char* pbuffer,unsigned short length)
000000  4602              MOV      r2,r0
;;;459    {
;;;460      return  0;
000002  2000              MOVS     r0,#0
;;;461    }
000004  4770              BX       lr
;;;462    /*******************************************************************************
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AmpBaket
                          %        134
                  AMPPro
                          %        10556

                          AREA ||.data||, DATA, ALIGN=2

                  phy
                          DCD      0x00000000
                  ackupfarme
000004  7e028100          DCB      0x7e,0x02,0x81,0x00
000008  b0507f            DCB      0xb0,0x50,0x7f
                  ackdownfarme
00000b  7e                DCB      0x7e
00000c  020100d1          DCB      0x02,0x01,0x00,0xd1
000010  907f              DCB      0x90,0x7f
