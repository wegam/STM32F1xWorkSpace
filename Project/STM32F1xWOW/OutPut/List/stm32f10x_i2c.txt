; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32f10x_i2c.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32f10x_i2c.crf ..\..\Library\STM32F10x_StdPeriph_Driver\SCR\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;814    *******************************************************************************/
;;;815    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;816    {
;;;817      /* Check the parameters */
;;;818      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;819      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;820    
;;;821      if (NewState != DISABLE)
;;;822      {
;;;823        /* Enable the selected I2C ARP */
;;;824        I2Cx->CR1 |= CR1_ENARP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420210          ORR      r2,r2,#0x10
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L1.22|
                  |L1.12|
;;;825      }
;;;826      else
;;;827      {
;;;828        /* Disable the selected I2C ARP */
;;;829        I2Cx->CR1 &= CR1_ENARP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L1.22|
;;;830      }
;;;831    }
000016  4770              BX       lr
;;;832    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;422    *******************************************************************************/
;;;423    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;427      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;428    
;;;429      if (NewState != DISABLE)
;;;430      {
;;;431        /* Enable the acknowledgement */
;;;432        I2Cx->CR1 |= CR1_ACK_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4426280          ORR      r2,r2,#0x400
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;433      }
;;;434      else
;;;435      {
;;;436        /* Disable the acknowledgement */
;;;437        I2Cx->CR1 &= CR1_ACK_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f33ff          MOV      r3,#0xfbff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L2.22|
;;;438      }
;;;439    }
000016  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;771    *******************************************************************************/
;;;772    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;773    {
;;;774      /* Check the parameters */
;;;775      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;776      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;777    
;;;778      if (NewState != DISABLE)
;;;779      {
;;;780        /* Enable the selected I2C PEC calculation */
;;;781        I2Cx->CR1 |= CR1_ENPEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420220          ORR      r2,r2,#0x20
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;782      }
;;;783      else
;;;784      {
;;;785        /* Disable the selected I2C PEC calculation */
;;;786        I2Cx->CR1 &= CR1_ENPEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L3.22|
;;;787      }
;;;788    }
000016  4770              BX       lr
;;;789    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;937    *******************************************************************************/
;;;938    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;939    {
000002  4602              MOV      r2,r0
;;;940      u32 lastevent = 0;
000004  2400              MOVS     r4,#0
;;;941      u32 flag1 = 0, flag2 = 0;
000006  2500              MOVS     r5,#0
000008  2300              MOVS     r3,#0
;;;942      ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;943    
;;;944      /* Check the parameters */
;;;945      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;946      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;947    
;;;948      /* Read the I2Cx status register */
;;;949      flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;950      flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;951      flag2 = flag2 << 16;
000010  041b              LSLS     r3,r3,#16
;;;952    
;;;953      /* Get the last event value from I2C status register */
;;;954      lastevent = (flag1 | flag2) & FLAG_Mask;
000012  ea450603          ORR      r6,r5,r3
000016  f026447f          BIC      r4,r6,#0xff000000
;;;955    
;;;956      /* Check whether the last event is equal to I2C_EVENT */
;;;957      if (lastevent == I2C_EVENT )
00001a  428c              CMP      r4,r1
00001c  d101              BNE      |L4.34|
;;;958      {
;;;959        /* SUCCESS: last event is equal to I2C_EVENT */
;;;960        status = SUCCESS;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L4.36|
                  |L4.34|
;;;961      }
;;;962      else
;;;963      {
;;;964        /* ERROR: last event is different from I2C_EVENT */
;;;965        status = ERROR;
000022  2000              MOVS     r0,#0
                  |L4.36|
;;;966      }
;;;967    
;;;968      /* Return status */
;;;969      return status;
;;;970    }
000024  bd70              POP      {r4-r6,pc}
;;;971    
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1060   *******************************************************************************/
;;;1061   void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1062   {
;;;1063     u32 flagpos = 0;
000002  2300              MOVS     r3,#0
;;;1064     u32 flagindex = 0;
000004  2200              MOVS     r2,#0
;;;1065   
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1068     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1069   
;;;1070     /* Get the I2C flag position */
;;;1071     flagpos = I2C_FLAG & FLAG_Mask;
000006  f021437f          BIC      r3,r1,#0xff000000
;;;1072   
;;;1073     /* Get the I2C flag index */
;;;1074     flagindex = I2C_FLAG >> 28;
00000a  0f0a              LSRS     r2,r1,#28
;;;1075   
;;;1076     /* Clear the flag by writing 0 */
;;;1077     if (flagindex == 1)
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L5.22|
;;;1078     {
;;;1079       /* Clear the selected I2C flag */
;;;1080       I2Cx->SR1 = (u16)~flagpos;
000010  43dc              MVNS     r4,r3
000012  8284              STRH     r4,[r0,#0x14]
000014  e00d              B        |L5.50|
                  |L5.22|
;;;1081     }
;;;1082     /* Flags that need a read of the SR1 register to be cleared */
;;;1083     else if (flagindex == 2)
000016  2a02              CMP      r2,#2
000018  d101              BNE      |L5.30|
;;;1084     {
;;;1085       /* Read the SR1 register */
;;;1086       (void)I2Cx->SR1;
00001a  8a84              LDRH     r4,[r0,#0x14]
00001c  e009              B        |L5.50|
                  |L5.30|
;;;1087     }
;;;1088     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1089     else if (flagindex == 6)
00001e  2a06              CMP      r2,#6
000020  d105              BNE      |L5.46|
;;;1090     {
;;;1091       /* Read the SR1 register */
;;;1092       (void)I2Cx->SR1;
000022  8a84              LDRH     r4,[r0,#0x14]
;;;1093   
;;;1094       /* Write on the CR1 register */
;;;1095       I2Cx->CR1 |= CR1_PE_Set;
000024  8804              LDRH     r4,[r0,#0]
000026  f0440401          ORR      r4,r4,#1
00002a  8004              STRH     r4,[r0,#0]
00002c  e001              B        |L5.50|
                  |L5.46|
;;;1096     }
;;;1097     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1098     else /*flagindex == 0xA*/
;;;1099     {
;;;1100       /* Read the SR1 register */
;;;1101       (void)I2Cx->SR1;
00002e  8a84              LDRH     r4,[r0,#0x14]
;;;1102   
;;;1103       /* Read the SR2 register */
;;;1104       (void)I2Cx->SR2;
000030  8b04              LDRH     r4,[r0,#0x18]
                  |L5.50|
;;;1105     }
;;;1106   }
000032  bd10              POP      {r4,pc}
;;;1107   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1189   *******************************************************************************/
;;;1190   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1191   {
;;;1192     u32 flagpos = 0;
000002  2300              MOVS     r3,#0
;;;1193     u32 flagindex = 0;
000004  2200              MOVS     r2,#0
;;;1194   
;;;1195     /* Check the parameters */
;;;1196     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1197     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1198   
;;;1199     /* Get the I2C flag position */
;;;1200     flagpos = I2C_IT & FLAG_Mask;
000006  f021437f          BIC      r3,r1,#0xff000000
;;;1201   
;;;1202     /* Get the I2C flag index */
;;;1203     flagindex = I2C_IT >> 28;
00000a  0f0a              LSRS     r2,r1,#28
;;;1204   
;;;1205     /* Clear the flag by writing 0 */
;;;1206     if (flagindex == 1)
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L6.22|
;;;1207     {
;;;1208       /* Clear the selected I2C flag */
;;;1209       I2Cx->SR1 = (u16)~flagpos;
000010  43dc              MVNS     r4,r3
000012  8284              STRH     r4,[r0,#0x14]
000014  e00d              B        |L6.50|
                  |L6.22|
;;;1210     }
;;;1211     /* Flags that need a read of the SR1 register to be cleared */
;;;1212     else if (flagindex == 2)
000016  2a02              CMP      r2,#2
000018  d101              BNE      |L6.30|
;;;1213     {
;;;1214       /* Read the SR1 register */
;;;1215       (void)I2Cx->SR1;
00001a  8a84              LDRH     r4,[r0,#0x14]
00001c  e009              B        |L6.50|
                  |L6.30|
;;;1216     }
;;;1217     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1218     else if (flagindex == 6)
00001e  2a06              CMP      r2,#6
000020  d105              BNE      |L6.46|
;;;1219     {
;;;1220       /* Read the SR1 register */
;;;1221       (void)I2Cx->SR1;
000022  8a84              LDRH     r4,[r0,#0x14]
;;;1222   
;;;1223       /* Write on the CR1 register */
;;;1224       I2Cx->CR1 |= CR1_PE_Set;
000024  8804              LDRH     r4,[r0,#0]
000026  f0440401          ORR      r4,r4,#1
00002a  8004              STRH     r4,[r0,#0]
00002c  e001              B        |L6.50|
                  |L6.46|
;;;1225     }
;;;1226     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1227     else /*flagindex == 0xA*/
;;;1228     {
;;;1229       /* Read the SR1 register */
;;;1230       (void)I2Cx->SR1;
00002e  8a84              LDRH     r4,[r0,#0x14]
;;;1231   
;;;1232       /* Read the SR2 register */
;;;1233       (void)I2Cx->SR2;
000030  8b04              LDRH     r4,[r0,#0x18]
                  |L6.50|
;;;1234     }
;;;1235   }
000032  bd10              POP      {r4,pc}
;;;1236   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;287    *******************************************************************************/
;;;288    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L7.12|
;;;289    {
;;;290      /* Check the parameters */
;;;291      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;292      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;293    
;;;294      if (NewState != DISABLE)
;;;295      {
;;;296        /* Enable the selected I2C peripheral */
;;;297        I2Cx->CR1 |= CR1_PE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L7.22|
                  |L7.12|
;;;298      }
;;;299      else
;;;300      {
;;;301        /* Disable the selected I2C peripheral */
;;;302        I2Cx->CR1 &= CR1_PE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L7.22|
;;;303      }
;;;304    }
000016  4770              BX       lr
;;;305    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;314    *******************************************************************************/
;;;315    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;316    {
;;;317      /* Check the parameters */
;;;318      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;319      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;320    
;;;321      if (NewState != DISABLE)
;;;322      {
;;;323        /* Enable the selected I2C DMA requests */
;;;324        I2Cx->CR2 |= CR2_DMAEN_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;325      }
;;;326      else
;;;327      {
;;;328        /* Disable the selected I2C DMA requests */
;;;329        I2Cx->CR2 &= CR2_DMAEN_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;330      }
;;;331    }
000016  4770              BX       lr
;;;332    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;341    *******************************************************************************/
;;;342    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;346      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;347    
;;;348      if (NewState != DISABLE)
;;;349      {
;;;350        /* Next DMA transfer is the last transfer */
;;;351        I2Cx->CR2 |= CR2_LAST_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L9.22|
                  |L9.12|
;;;352      }
;;;353      else
;;;354      {
;;;355        /* Next DMA transfer is not the last transfer */
;;;356        I2Cx->CR2 &= CR2_LAST_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L9.22|
;;;357      }
;;;358    }
000016  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;108    *******************************************************************************/
;;;109    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;110    {
000002  4604              MOV      r4,r0
;;;111      /* Check the parameters */
;;;112      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;113    
;;;114      switch (*(u32*)&I2Cx)
000004  480e              LDR      r0,|L10.64|
000006  4420              ADD      r0,r0,r4
000008  b118              CBZ      r0,|L10.18|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d114              BNE      |L10.58|
000010  e009              B        |L10.38|
                  |L10.18|
;;;115      {
;;;116        case I2C1_BASE:
;;;117          /* Enable I2C1 reset state */
;;;118          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000012  2101              MOVS     r1,#1
000014  0548              LSLS     r0,r1,#21
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;119          /* Release I2C1 from reset state */
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
00001a  2100              MOVS     r1,#0
00001c  f44f1000          MOV      r0,#0x200000
000020  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;121          break;
000024  e00a              B        |L10.60|
                  |L10.38|
;;;122    
;;;123        case I2C2_BASE:
;;;124          /* Enable I2C2 reset state */
;;;125          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000026  2101              MOVS     r1,#1
000028  0588              LSLS     r0,r1,#22
00002a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;126          /* Release I2C2 from reset state */
;;;127          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00002e  2100              MOVS     r1,#0
000030  f44f0080          MOV      r0,#0x400000
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;128          break;
000038  e000              B        |L10.60|
                  |L10.58|
;;;129    
;;;130        default:
;;;131          break;
00003a  bf00              NOP      
                  |L10.60|
00003c  bf00              NOP                            ;121
;;;132      }
;;;133    }
00003e  bd10              POP      {r4,pc}
;;;134    
                          ENDP

                  |L10.64|
                          DCD      0xbfffac00

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;474    *******************************************************************************/
;;;475    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;476    {
;;;477      /* Check the parameters */
;;;478      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;479      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;480    
;;;481      if (NewState != DISABLE)
;;;482      {
;;;483        /* Enable dual addressing mode */
;;;484        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L11.22|
                  |L11.12|
;;;485      }
;;;486      else
;;;487      {
;;;488        /* Disable dual addressing mode */
;;;489        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L11.22|
;;;490      }
;;;491    }
000016  4770              BX       lr
;;;492    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;870    *******************************************************************************/
;;;871    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;872    {
;;;873      /* Check the parameters */
;;;874      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;875      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;876    
;;;877      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d005              BEQ      |L12.18|
;;;878      {
;;;879        /* I2C fast mode Tlow/Thigh=2 */
;;;880        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b82              LDRH     r2,[r0,#0x1c]
000008  f64b73ff          MOV      r3,#0xbfff
00000c  401a              ANDS     r2,r2,r3
00000e  8382              STRH     r2,[r0,#0x1c]
000010  e003              B        |L12.26|
                  |L12.18|
;;;881      }
;;;882      else
;;;883      {
;;;884        /* I2C fast mode Tlow/Thigh=16/9 */
;;;885        I2Cx->CCR |= I2C_DutyCycle_16_9;
000012  8b82              LDRH     r2,[r0,#0x1c]
000014  f4424280          ORR      r2,r2,#0x4000
000018  8382              STRH     r2,[r0,#0x1c]
                  |L12.26|
;;;886      }
;;;887    }
00001a  4770              BX       lr
;;;888    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;501    *******************************************************************************/
;;;502    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;503    {
;;;504      /* Check the parameters */
;;;505      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;506      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;507    
;;;508      if (NewState != DISABLE)
;;;509      {
;;;510        /* Enable generall call */
;;;511        I2Cx->CR1 |= CR1_ENGC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420240          ORR      r2,r2,#0x40
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;512      }
;;;513      else
;;;514      {
;;;515        /* Disable generall call */
;;;516        I2Cx->CR1 &= CR1_ENGC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73bf          MOV      r3,#0xffbf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L13.22|
;;;517      }
;;;518    }
000016  4770              BX       lr
;;;519    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;368    *******************************************************************************/
;;;369    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L14.12|
;;;370    {
;;;371      /* Check the parameters */
;;;372      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374    
;;;375      if (NewState != DISABLE)
;;;376      {
;;;377        /* Generate a START condition */
;;;378        I2Cx->CR1 |= CR1_START_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427280          ORR      r2,r2,#0x100
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L14.22|
                  |L14.12|
;;;379      }
;;;380      else
;;;381      {
;;;382        /* Disable the START condition generation */
;;;383        I2Cx->CR1 &= CR1_START_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f63ff          MOV      r3,#0xfeff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L14.22|
;;;384      }
;;;385    }
000016  4770              BX       lr
;;;386    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;395    *******************************************************************************/
;;;396    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;397    {
;;;398      /* Check the parameters */
;;;399      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;400      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;401    
;;;402      if (NewState != DISABLE)
;;;403      {
;;;404        /* Generate a STOP condition */
;;;405        I2Cx->CR1 |= CR1_STOP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427200          ORR      r2,r2,#0x200
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L15.22|
                  |L15.12|
;;;406      }
;;;407      else
;;;408      {
;;;409        /* Disable the STOP condition generation */
;;;410        I2Cx->CR1 &= CR1_STOP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f53ff          MOV      r3,#0xfdff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L15.22|
;;;411      }
;;;412    }
000016  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1002   *******************************************************************************/
;;;1003   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000000  b570              PUSH     {r4-r6,lr}
;;;1004   {
000002  4602              MOV      r2,r0
;;;1005     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1006     u32 i2cstatus = 0;
000006  2400              MOVS     r4,#0
;;;1007     u32 flag1 = 0, flag2 = 0;
000008  2500              MOVS     r5,#0
00000a  2300              MOVS     r3,#0
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1011     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1012   
;;;1013     /* Read the I2Cx status register */
;;;1014     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1015     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1016     flag2 = (flag2 & FLAG_Mask) << 16;
000010  041b              LSLS     r3,r3,#16
;;;1017   
;;;1018     /* Get the I2C status value */
;;;1019     i2cstatus = flag1 | flag2;
000012  ea450403          ORR      r4,r5,r3
;;;1020   
;;;1021     /* Get bit[23:0] of the flag */
;;;1022     I2C_FLAG &= FLAG_Mask;
000016  f021417f          BIC      r1,r1,#0xff000000
;;;1023   
;;;1024     /* Check the status of the specified I2C flag */
;;;1025     if ((i2cstatus & I2C_FLAG) != (u32)RESET)
00001a  ea040601          AND      r6,r4,r1
00001e  b10e              CBZ      r6,|L16.36|
;;;1026     {
;;;1027       /* I2C_FLAG is set */
;;;1028       bitstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L16.38|
                  |L16.36|
;;;1029     }
;;;1030     else
;;;1031     {
;;;1032       /* I2C_FLAG is reset */
;;;1033       bitstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L16.38|
;;;1034     }
;;;1035     /* Return the I2C_FLAG status */
;;;1036     return  bitstatus;
;;;1037   }
000026  bd70              POP      {r4-r6,pc}
;;;1038   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1131   *******************************************************************************/
;;;1132   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1133   {
000002  4602              MOV      r2,r0
;;;1134     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1135     u32 i2cstatus = 0;
000006  2400              MOVS     r4,#0
;;;1136     u32 flag1 = 0, flag2 = 0;
000008  2500              MOVS     r5,#0
00000a  2300              MOVS     r3,#0
;;;1137   
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1140     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1141   
;;;1142     /* Read the I2Cx status register */
;;;1143     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1144     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1145     flag2 = (flag2 & FLAG_Mask) << 16;
000010  041b              LSLS     r3,r3,#16
;;;1146   
;;;1147     /* Get the I2C status value */
;;;1148     i2cstatus = flag1 | flag2;
000012  ea450403          ORR      r4,r5,r3
;;;1149   
;;;1150     /* Get bit[23:0] of the flag */
;;;1151     I2C_IT &= FLAG_Mask;
000016  f021417f          BIC      r1,r1,#0xff000000
;;;1152   
;;;1153     /* Check the status of the specified I2C flag */
;;;1154     if ((i2cstatus & I2C_IT) != (u32)RESET)
00001a  ea040601          AND      r6,r4,r1
00001e  b10e              CBZ      r6,|L17.36|
;;;1155     {
;;;1156       /* I2C_IT is set */
;;;1157       bitstatus = SET;
000020  2001              MOVS     r0,#1
000022  e000              B        |L17.38|
                  |L17.36|
;;;1158     }
;;;1159     else
;;;1160     {
;;;1161       /* I2C_IT is reset */
;;;1162       bitstatus = RESET;
000024  2000              MOVS     r0,#0
                  |L17.38|
;;;1163     }
;;;1164     /* Return the I2C_IT status */
;;;1165     return  bitstatus;
;;;1166   }
000026  bd70              POP      {r4-r6,pc}
;;;1167   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;895    *******************************************************************************/
;;;896    u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;897    {
000002  4601              MOV      r1,r0
;;;898      u32 lastevent = 0;
000004  2000              MOVS     r0,#0
;;;899      u32 flag1 = 0, flag2 = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;900    
;;;901      /* Check the parameters */
;;;902      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;903    
;;;904      /* Read the I2Cx status register */
;;;905      flag1 = I2Cx->SR1;
00000a  8a8b              LDRH     r3,[r1,#0x14]
;;;906      flag2 = I2Cx->SR2;
00000c  8b0a              LDRH     r2,[r1,#0x18]
;;;907      flag2 = flag2 << 16;
00000e  0412              LSLS     r2,r2,#16
;;;908    
;;;909      /* Get the last event value from I2C status register */
;;;910      lastevent = (flag1 | flag2) & FLAG_Mask;
000010  ea430402          ORR      r4,r3,r2
000014  f024407f          BIC      r0,r4,#0xff000000
;;;911    
;;;912      /* Return status */
;;;913      return lastevent;
;;;914    }
000018  bd10              POP      {r4,pc}
;;;915    
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;796    *******************************************************************************/
;;;797    u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;798    {
;;;799      /* Check the parameters */
;;;800      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;801    
;;;802      /* Return the selected I2C PEC value */
;;;803      return ((I2Cx->SR2) >> 8);
000002  8b08              LDRH     r0,[r1,#0x18]
000004  1200              ASRS     r0,r0,#8
;;;804    }
000006  4770              BX       lr
;;;805    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;534    *******************************************************************************/
;;;535    void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;541      
;;;542      if (NewState != DISABLE)
;;;543      {
;;;544        /* Enable the selected I2C interrupts */
;;;545        I2Cx->CR2 |= I2C_IT;
000002  8883              LDRH     r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  8083              STRH     r3,[r0,#4]
000008  e002              B        |L20.16|
                  |L20.10|
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Disable the selected I2C interrupts */
;;;550        I2Cx->CR2 &= (u16)~I2C_IT;
00000a  8883              LDRH     r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  8083              STRH     r3,[r0,#4]
                  |L20.16|
;;;551      }
;;;552    }
000010  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;145    ******************************************************************************/
;;;146    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;147    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;148      u16 tmpreg = 0, freqrange = 0;
00000a  2600              MOVS     r6,#0
00000c  46b1              MOV      r9,r6
;;;149      u16 result = 0x04;
00000e  2704              MOVS     r7,#4
;;;150      u32 pclk1 = 8000000;
000010  f8df80cc          LDR      r8,|L21.224|
;;;151      RCC_ClocksTypeDef  rcc_clocks;
;;;152    
;;;153      /* Check the parameters */
;;;154      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;155      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;156      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;157      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;158      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;159      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;160      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;161    
;;;162    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;163      /* Get the I2Cx CR2 value */
;;;164      tmpreg = I2Cx->CR2;
000014  88a6              LDRH     r6,[r4,#4]
;;;165      /* Clear frequency FREQ[5:0] bits */
;;;166      tmpreg &= CR2_FREQ_Reset;
000016  f64f70c0          MOV      r0,#0xffc0
00001a  4006              ANDS     r6,r6,r0
;;;167      /* Get pclk1 frequency value */
;;;168      RCC_GetClocksFreq(&rcc_clocks);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       RCC_GetClocksFreq
;;;169      pclk1 = rcc_clocks.PCLK1_Frequency;
000022  f8dd8008          LDR      r8,[sp,#8]
;;;170      /* Set frequency bits depending on pclk1 value */
;;;171      freqrange = (u16)(pclk1 / 1000000);
000026  482f              LDR      r0,|L21.228|
000028  fbb8f0f0          UDIV     r0,r8,r0
00002c  fa1ff980          UXTH     r9,r0
;;;172      tmpreg |= freqrange;
000030  ea460609          ORR      r6,r6,r9
;;;173      /* Write to I2Cx CR2 */
;;;174      I2Cx->CR2 = tmpreg;
000034  80a6              STRH     r6,[r4,#4]
;;;175    
;;;176    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;177      /* Disable the selected I2C peripheral to configure TRISE */
;;;178      I2Cx->CR1 &= CR1_PE_Reset;
000036  8820              LDRH     r0,[r4,#0]
000038  f64f71fe          MOV      r1,#0xfffe
00003c  4008              ANDS     r0,r0,r1
00003e  8020              STRH     r0,[r4,#0]
;;;179    
;;;180      /* Reset tmpreg value */
;;;181      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;182      tmpreg = 0;
000040  2600              MOVS     r6,#0
;;;183    
;;;184      /* Configure speed in standard mode */
;;;185      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000042  4929              LDR      r1,|L21.232|
000044  68e8              LDR      r0,[r5,#0xc]
000046  4288              CMP      r0,r1
000048  d80c              BHI      |L21.100|
;;;186      {
;;;187        /* Standard mode speed calculate */
;;;188        result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00004a  68e8              LDR      r0,[r5,#0xc]
00004c  0040              LSLS     r0,r0,#1
00004e  fbb8f0f0          UDIV     r0,r8,r0
000052  b287              UXTH     r7,r0
;;;189        /* Test if CCR value is under 0x4*/
;;;190        if (result < 0x04)
000054  2f04              CMP      r7,#4
000056  da00              BGE      |L21.90|
;;;191        {
;;;192          /* Set minimum allowed value */
;;;193          result = 0x04;  
000058  2704              MOVS     r7,#4
                  |L21.90|
;;;194        }
;;;195        /* Set speed value for standard mode */
;;;196        tmpreg |= result;	  
00005a  433e              ORRS     r6,r6,r7
;;;197        /* Set Maximum Rise Time for standard mode */
;;;198        I2Cx->TRISE = freqrange + 1; 
00005c  f1090001          ADD      r0,r9,#1
000060  8420              STRH     r0,[r4,#0x20]
000062  e027              B        |L21.180|
                  |L21.100|
;;;199      }
;;;200      /* Configure speed in fast mode */
;;;201      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;202      {
;;;203        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000064  8868              LDRH     r0,[r5,#2]
000066  f64b71ff          MOV      r1,#0xbfff
00006a  4288              CMP      r0,r1
00006c  d106              BNE      |L21.124|
;;;204        {
;;;205          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;206          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00006e  68e8              LDR      r0,[r5,#0xc]
000070  eb000040          ADD      r0,r0,r0,LSL #1
000074  fbb8f0f0          UDIV     r0,r8,r0
000078  b287              UXTH     r7,r0
00007a  e009              B        |L21.144|
                  |L21.124|
;;;207        }
;;;208        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;209        {
;;;210          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;211          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00007c  68e8              LDR      r0,[r5,#0xc]
00007e  eb0001c0          ADD      r1,r0,r0,LSL #3
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  fbb8f0f0          UDIV     r0,r8,r0
00008a  b287              UXTH     r7,r0
;;;212          /* Set DUTY bit */
;;;213          result |= I2C_DutyCycle_16_9;
00008c  f4474780          ORR      r7,r7,#0x4000
                  |L21.144|
;;;214        }
;;;215        /* Test if CCR value is under 0x1*/
;;;216        if ((result & CCR_CCR_Set) == 0)
000090  f3c7000b          UBFX     r0,r7,#0,#12
000094  b908              CBNZ     r0,|L21.154|
;;;217        {
;;;218          /* Set minimum allowed value */
;;;219          result |= (u16)0x0001;  
000096  f0470701          ORR      r7,r7,#1
                  |L21.154|
;;;220        }
;;;221        /* Set speed value and set F/S bit for fast mode */
;;;222        tmpreg |= result | CCR_FS_Set;
00009a  f4474000          ORR      r0,r7,#0x8000
00009e  4306              ORRS     r6,r6,r0
;;;223        /* Set Maximum Rise Time for fast mode */
;;;224        I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
0000a0  f44f7096          MOV      r0,#0x12c
0000a4  fb09f000          MUL      r0,r9,r0
0000a8  f44f717a          MOV      r1,#0x3e8
0000ac  fb90f0f1          SDIV     r0,r0,r1
0000b0  1c40              ADDS     r0,r0,#1
0000b2  8420              STRH     r0,[r4,#0x20]
                  |L21.180|
;;;225      }
;;;226      /* Write to I2Cx CCR */
;;;227      I2Cx->CCR = tmpreg;
0000b4  83a6              STRH     r6,[r4,#0x1c]
;;;228    
;;;229      /* Enable the selected I2C peripheral */
;;;230      I2Cx->CR1 |= CR1_PE_Set;
0000b6  8820              LDRH     r0,[r4,#0]
0000b8  f0400001          ORR      r0,r0,#1
0000bc  8020              STRH     r0,[r4,#0]
;;;231    
;;;232    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;233      /* Get the I2Cx CR1 value */
;;;234      tmpreg = I2Cx->CR1;
0000be  8826              LDRH     r6,[r4,#0]
;;;235      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;236      tmpreg &= CR1_CLEAR_Mask;
0000c0  f64f30f5          MOV      r0,#0xfbf5
0000c4  4006              ANDS     r6,r6,r0
;;;237      /* Configure I2Cx: mode and acknowledgement */
;;;238      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;239      /* Set ACK bit according to I2C_Ack value */
;;;240      tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000c6  8828              LDRH     r0,[r5,#0]
0000c8  88e9              LDRH     r1,[r5,#6]
0000ca  4308              ORRS     r0,r0,r1
0000cc  4306              ORRS     r6,r6,r0
;;;241      /* Write to I2Cx CR1 */
;;;242      I2Cx->CR1 = tmpreg;
0000ce  8026              STRH     r6,[r4,#0]
;;;243    
;;;244    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;245      /* Set I2Cx Own Address1 and acknowledged address */
;;;246      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000d0  8928              LDRH     r0,[r5,#8]
0000d2  88a9              LDRH     r1,[r5,#4]
0000d4  4308              ORRS     r0,r0,r1
0000d6  8120              STRH     r0,[r4,#8]
;;;247    }
0000d8  b005              ADD      sp,sp,#0x14
0000da  e8bd83f0          POP      {r4-r9,pc}
;;;248    
                          ENDP

0000de  0000              DCW      0x0000
                  |L21.224|
                          DCD      0x007a1200
                  |L21.228|
                          DCD      0x000f4240
                  |L21.232|
                          DCD      0x000186a0

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;448    *******************************************************************************/
;;;449    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
000000  460a              MOV      r2,r1
;;;450    {
;;;451      u16 tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;452    
;;;453      /* Check the parameters */
;;;454      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;455    
;;;456      /* Get the old register value */
;;;457      tmpreg = I2Cx->OAR2;
000004  8981              LDRH     r1,[r0,#0xc]
;;;458      /* Reset I2Cx Own address2 bit [7:1] */
;;;459      tmpreg &= OAR2_ADD2_Reset;
000006  f64f7301          MOV      r3,#0xff01
00000a  4019              ANDS     r1,r1,r3
;;;460      /* Set I2Cx Own address2 */
;;;461      tmpreg |= (u16)(Address & (u16)0x00FE);
00000c  f00203fe          AND      r3,r2,#0xfe
000010  4319              ORRS     r1,r1,r3
;;;462      /* Store the new register value */
;;;463      I2Cx->OAR2 = tmpreg;
000012  8181              STRH     r1,[r0,#0xc]
;;;464    }
000014  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;743    *******************************************************************************/
;;;744    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;745    {
;;;746      /* Check the parameters */
;;;747      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;748      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;749    
;;;750      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d104              BNE      |L23.16|
;;;751      {
;;;752        /* Next byte in shift register is PEC */
;;;753        I2Cx->CR1 |= I2C_PECPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L23.26|
                  |L23.16|
;;;754      }
;;;755      else
;;;756      {
;;;757        /* Current byte in shift register is PEC */
;;;758        I2Cx->CR1 &= I2C_PECPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L23.26|
;;;759      }
;;;760    }
00001a  4770              BX       lr
;;;761    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;637    *******************************************************************************/
;;;638    u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
000000  4602              MOV      r2,r0
;;;639    {
;;;640      /* Check the parameters */
;;;641      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;642      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;643    
;;;644      /* Return the selected register value */
;;;645      return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
000002  5a50              LDRH     r0,[r2,r1]
;;;646    }
000004  4770              BX       lr
;;;647    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;577    *******************************************************************************/
;;;578    u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;582    
;;;583      /* Return the data in the DR register */
;;;584      return (u8)I2Cx->DR;
000002  8a08              LDRH     r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;585    }
000006  4770              BX       lr
;;;586    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;685    *******************************************************************************/
;;;686    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;687    {
;;;688      /* Check the parameters */
;;;689      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;690      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;691    
;;;692      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d104              BNE      |L26.16|
;;;693      {
;;;694        /* Drive the SMBusAlert pin Low */
;;;695        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000006  8802              LDRH     r2,[r0,#0]
000008  f4425200          ORR      r2,r2,#0x2000
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L26.26|
                  |L26.16|
;;;696      }
;;;697      else
;;;698      {
;;;699        /* Drive the SMBusAlert pin High  */
;;;700        I2Cx->CR1 &= I2C_SMBusAlert_High;
000010  8802              LDRH     r2,[r0,#0]
000012  f64d73ff          MOV      r3,#0xdfff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L26.26|
;;;701      }
;;;702    }
00001a  4770              BX       lr
;;;703    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;599    *******************************************************************************/
;;;600    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
000000  b112              CBZ      r2,|L27.8|
;;;601    {
;;;602      /* Check the parameters */
;;;603      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;604      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;605    
;;;606      /* Test on the direction to set/reset the read/write bit */
;;;607      if (I2C_Direction != I2C_Direction_Transmitter)
;;;608      {
;;;609        /* Set the address bit0 for read */
;;;610        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e002              B        |L27.14|
                  |L27.8|
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Reset the address bit0 for write */
;;;615        Address &= OAR1_ADD0_Reset;
000008  f64f73fe          MOV      r3,#0xfffe
00000c  4019              ANDS     r1,r1,r3
                  |L27.14|
;;;616      }
;;;617      /* Send the address */
;;;618      I2Cx->DR = Address;
00000e  8201              STRH     r1,[r0,#0x10]
;;;619    }
000010  4770              BX       lr
;;;620    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;561    *******************************************************************************/
;;;562    void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;566    
;;;567      /* Write in the DR register the data to be sent */
;;;568      I2Cx->DR = Data;
;;;569    }
000002  4770              BX       lr
;;;570    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;656    *******************************************************************************/
;;;657    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L29.12|
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;661      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;662    
;;;663      if (NewState != DISABLE)
;;;664      {
;;;665        /* Peripheral under reset */
;;;666        I2Cx->CR1 |= CR1_SWRST_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8002              STRH     r2,[r0,#0]
00000a  e003              B        |L29.20|
                  |L29.12|
;;;667      }
;;;668      else
;;;669      {
;;;670        /* Peripheral not under reset */
;;;671        I2Cx->CR1 &= CR1_SWRST_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8002              STRH     r2,[r0,#0]
                  |L29.20|
;;;672      }
;;;673    }
000014  4770              BX       lr
;;;674    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;841    *******************************************************************************/
;;;842    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b921              CBNZ     r1,|L30.12|
;;;843    {
;;;844      /* Check the parameters */
;;;845      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;846      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;847    
;;;848      if (NewState == DISABLE)
;;;849      {
;;;850        /* Enable the selected I2C Clock stretching */
;;;851        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L30.22|
                  |L30.12|
;;;852      }
;;;853      else
;;;854      {
;;;855        /* Disable the selected I2C Clock stretching */
;;;856        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L30.22|
;;;857      }
;;;858    }
000016  4770              BX       lr
;;;859    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;256    *******************************************************************************/
;;;257    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;258    {
;;;259    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;260      /* Initialize the I2C_Mode member */
;;;261      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000002  8001              STRH     r1,[r0,#0]
;;;262    
;;;263      /* Initialize the I2C_DutyCycle member */
;;;264      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000004  f64b71ff          MOV      r1,#0xbfff
000008  8041              STRH     r1,[r0,#2]
;;;265    
;;;266      /* Initialize the I2C_OwnAddress1 member */
;;;267      I2C_InitStruct->I2C_OwnAddress1 = 0;
00000a  2100              MOVS     r1,#0
00000c  8081              STRH     r1,[r0,#4]
;;;268    
;;;269      /* Initialize the I2C_Ack member */
;;;270      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00000e  80c1              STRH     r1,[r0,#6]
;;;271    
;;;272      /* Initialize the I2C_AcknowledgedAddress member */
;;;273      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000010  f44f4180          MOV      r1,#0x4000
000014  8101              STRH     r1,[r0,#8]
;;;274    
;;;275      /* initialize the I2C_ClockSpeed member */
;;;276      I2C_InitStruct->I2C_ClockSpeed = 5000;
000016  f2413188          MOV      r1,#0x1388
00001a  60c1              STR      r1,[r0,#0xc]
;;;277    }
00001c  4770              BX       lr
;;;278    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;712    *******************************************************************************/
;;;713    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L32.12|
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;717      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;718    
;;;719      if (NewState != DISABLE)
;;;720      {
;;;721        /* Enable the selected I2C PEC transmission */
;;;722        I2Cx->CR1 |= CR1_PEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L32.22|
                  |L32.12|
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Disable the selected I2C PEC transmission */
;;;727        I2Cx->CR1 &= CR1_PEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L32.22|
;;;728      }
;;;729    }
000016  4770              BX       lr
;;;730    
                          ENDP

