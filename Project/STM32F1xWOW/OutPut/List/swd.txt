; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\swd.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\swd.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\swd.crf ..\..\Driver\Protocol\swd.c]
                          THUMB

                          AREA ||i.Line_Rest||, CODE, READONLY, ALIGN=2

                  Line_Rest PROC
;;;312    *******************************************************************************/
;;;313    void Line_Rest(void)
000000  b510              PUSH     {r4,lr}
;;;314    {
;;;315    	unsigned long i;
;;;316      SWDIO_SET_OUTPUT();
000002  f44f6180          MOV      r1,#0x400
000006  480a              LDR      r0,|L1.48|
000008  f7fffffe          BL       GPIO_Configuration_OPP50
;;;317    	SWDIO_SET();//SWDIO_OUT(1)
00000c  f44f6080          MOV      r0,#0x400
000010  4907              LDR      r1,|L1.48|
000012  3110              ADDS     r1,r1,#0x10
000014  6008              STR      r0,[r1,#0]
;;;318      SWDIO_CLR();//SWDIO_OUT(0)
000016  1d09              ADDS     r1,r1,#4
000018  6008              STR      r0,[r1,#0]
;;;319      SWDIO_SET();//SWDIO_OUT(1)
00001a  1f09              SUBS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
;;;320    	for(i = 0; i < 51; i++)
00001e  2400              MOVS     r4,#0
000020  e002              B        |L1.40|
                  |L1.34|
;;;321    	{
;;;322    		SW_CLOCK_CYCLE();
000022  f7fffffe          BL       SW_CLOCK_CYCLE
000026  1c64              ADDS     r4,r4,#1              ;320
                  |L1.40|
000028  2c33              CMP      r4,#0x33              ;320
00002a  d3fa              BCC      |L1.34|
;;;323    	}
;;;324    	
;;;325    }
00002c  bd10              POP      {r4,pc}
;;;326    
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40010800

                          AREA ||i.SWD_TransRequest||, CODE, READONLY, ALIGN=2

                  SWD_TransRequest PROC
;;;50     *******************************************************************************/
;;;51     unsigned char SWD_TransRequest(unsigned char request)
000000  e92d43f1          PUSH     {r0,r4-r9,lr}
;;;52     {
;;;53     	unsigned char ack 		= 0;
000004  2700              MOVS     r7,#0
;;;54     	unsigned char bit 		= 0;
000006  46b9              MOV      r9,r7
;;;55     	unsigned char parity	=	0;
000008  2600              MOVS     r6,#0
;;;56     	unsigned char num 		= 0;
00000a  2500              MOVS     r5,#0
;;;57       unsigned char temp 		= 0;
00000c  46a8              MOV      r8,r5
;;;58       SWJRequestDef *Request=(SWJRequestDef*)&request;
00000e  466c              MOV      r4,sp
;;;59       
;;;60       request=request<<1;
000010  f89d0000          LDRB     r0,[sp,#0]
000014  0640              LSLS     r0,r0,#25
000016  0e00              LSRS     r0,r0,#24
000018  9000              STR      r0,[sp,#0]
;;;61     	//=============计算校验位：request低4位1的个数为奇数校验为1，否则为0
;;;62       temp  = request&0x0F;
00001a  f89d0000          LDRB     r0,[sp,#0]
00001e  f000080f          AND      r8,r0,#0xf
;;;63     	for(num=0;num<4;num++)
000022  bf00              NOP      
000024  e007              B        |L2.54|
                  |L2.38|
;;;64     	{
;;;65         parity  += temp&0x01;
000026  f0080001          AND      r0,r8,#1
00002a  4430              ADD      r0,r0,r6
00002c  b2c6              UXTB     r6,r0
;;;66         temp>>=1;
00002e  ea4f0868          ASR      r8,r8,#1
000032  1c68              ADDS     r0,r5,#1              ;63
000034  b2c5              UXTB     r5,r0                 ;63
                  |L2.54|
000036  2d04              CMP      r5,#4                 ;63
000038  dbf5              BLT      |L2.38|
;;;67       }
;;;68       Request->Start  = 0x01;
00003a  7820              LDRB     r0,[r4,#0]
00003c  f0200001          BIC      r0,r0,#1
000040  1c40              ADDS     r0,r0,#1
000042  7020              STRB     r0,[r4,#0]
;;;69       Request->Parity = parity&0x01;  
000044  7820              LDRB     r0,[r4,#0]
000046  f3661045          BFI      r0,r6,#5,#1
00004a  7020              STRB     r0,[r4,#0]
;;;70       Request->Stop   = 0x00;
00004c  7820              LDRB     r0,[r4,#0]
00004e  f0200040          BIC      r0,r0,#0x40
000052  7020              STRB     r0,[r4,#0]
;;;71       Request->Park   = 0x01;
000054  7820              LDRB     r0,[r4,#0]
000056  f0200080          BIC      r0,r0,#0x80
00005a  3080              ADDS     r0,r0,#0x80
00005c  7020              STRB     r0,[r4,#0]
;;;72       
;;;73     	SWDIO_SET_OUTPUT();		//SWDIO设置为输出
00005e  f44f6180          MOV      r1,#0x400
000062  4825              LDR      r0,|L2.248|
000064  f7fffffe          BL       GPIO_Configuration_OPP50
;;;74     	SWDIO_SET();//SWDIO_OUT(1)
000068  f44f6080          MOV      r0,#0x400
00006c  4922              LDR      r1,|L2.248|
00006e  3110              ADDS     r1,r1,#0x10
000070  6008              STR      r0,[r1,#0]
;;;75       SWDIO_CLR();//SWDIO_OUT(0)
000072  1d09              ADDS     r1,r1,#4
000074  6008              STR      r0,[r1,#0]
;;;76       SWDIO_SET();//SWDIO_OUT(1)
000076  1f09              SUBS     r1,r1,#4
000078  6008              STR      r0,[r1,#0]
;;;77     	/* Packet Request */
;;;78     	SW_WRITE_BIT(Request->Start);     /* Start Bit */		//起始位：值为1
00007a  7821              LDRB     r1,[r4,#0]
00007c  f0010001          AND      r0,r1,#1
000080  f7fffffe          BL       SW_WRITE_BIT
;;;79     	SW_WRITE_BIT(Request->APnDP);     /* APnDP Bit */		//寄存器访问方式：0-DPACC访问，1-APACC访问
000084  7821              LDRB     r1,[r4,#0]
000086  f3c10040          UBFX     r0,r1,#1,#1
00008a  f7fffffe          BL       SW_WRITE_BIT
;;;80     	SW_WRITE_BIT(Request->RnW);       /* RnW Bit */			//读写位：0-写，1-读
00008e  7821              LDRB     r1,[r4,#0]
000090  f3c10080          UBFX     r0,r1,#2,#1
000094  f7fffffe          BL       SW_WRITE_BIT
;;;81     	SW_WRITE_BIT(Request->Addr0);     /* Addr2 Bit */				//DP或者AP寄存器的地址区域，低位先发送--低位
000098  7821              LDRB     r1,[r4,#0]
00009a  f3c100c0          UBFX     r0,r1,#3,#1
00009e  f7fffffe          BL       SW_WRITE_BIT
;;;82     	SW_WRITE_BIT(Request->Addr1);     /* Addr3 Bit */				//DP或者AP寄存器的地址区域，低位先发送--高位
0000a2  7821              LDRB     r1,[r4,#0]
0000a4  f3c11000          UBFX     r0,r1,#4,#1
0000a8  f7fffffe          BL       SW_WRITE_BIT
;;;83     	SW_WRITE_BIT(Request->Parity);    /* Parity Bit */		//奇偶校验位：0-APnDP到Addr中1的个数为偶数；1--APnDP到Addr中1的个数为奇数
0000ac  7821              LDRB     r1,[r4,#0]
0000ae  f3c11040          UBFX     r0,r1,#5,#1
0000b2  f7fffffe          BL       SW_WRITE_BIT
;;;84     	SW_WRITE_BIT(Request->Stop);      /* Stop Bit */			//停止位：值为0
0000b6  7821              LDRB     r1,[r4,#0]
0000b8  f3c11080          UBFX     r0,r1,#6,#1
0000bc  f7fffffe          BL       SW_WRITE_BIT
;;;85     	SW_WRITE_BIT(Request->Park);      /* Park Bit */			//单一位：传输该位时，主机拉高然后不再驱动该位
0000c0  7821              LDRB     r1,[r4,#0]
0000c2  09c8              LSRS     r0,r1,#7
0000c4  f7fffffe          BL       SW_WRITE_BIT
;;;86       
;;;87     	SWDIO_SET_INPUT();			//SWDIO设置为输入
0000c8  f44f6180          MOV      r1,#0x400
0000cc  480a              LDR      r0,|L2.248|
0000ce  f7fffffe          BL       GPIO_Configuration_IPU
;;;88     
;;;89     	/* Turnaround */
;;;90     	//    for(n = 1; n; n--)
;;;91     	//    {
;;;92     	//        SW_CLOCK_CYCLE();
;;;93     	//    }
;;;94     	SW_CLOCK_CYCLE();
0000d2  f7fffffe          BL       SW_CLOCK_CYCLE
;;;95     	/* Acknowledge response */	//读应答
;;;96     	for(num = 0; num < 3; num++)
0000d6  2500              MOVS     r5,#0
0000d8  e009              B        |L2.238|
                  |L2.218|
;;;97     	{
;;;98     			bit = SW_READ_BIT();		//读一位数据
0000da  f7fffffe          BL       SW_READ_BIT
0000de  f00009ff          AND      r9,r0,#0xff
;;;99     			ack  |= bit << num;
0000e2  fa09f005          LSL      r0,r9,r5
0000e6  4338              ORRS     r0,r0,r7
0000e8  b2c7              UXTB     r7,r0
0000ea  1c68              ADDS     r0,r5,#1              ;96
0000ec  b2c5              UXTB     r5,r0                 ;96
                  |L2.238|
0000ee  2d03              CMP      r5,#3                 ;96
0000f0  dbf3              BLT      |L2.218|
;;;100    	}
;;;101    	return ack;
0000f2  4638              MOV      r0,r7
;;;102    }
0000f4  e8bd83f8          POP      {r3-r9,pc}
;;;103    
                          ENDP

                  |L2.248|
                          DCD      0x40010800

                          AREA ||i.SWD_Transfer||, CODE, READONLY, ALIGN=1

                  SWD_Transfer PROC
;;;256    *******************************************************************************/
;;;257    unsigned char SWD_Transfer(unsigned long request, unsigned long *data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;259        unsigned char i, ack;
;;;260    
;;;261        for(i = 0; i < MAX_SWD_RETRY; i++)
000008  2500              MOVS     r5,#0
00000a  e00b              B        |L3.36|
                  |L3.12|
;;;262        {
;;;263            ack = SWD_TransferOnce(request, data);		//单次传输：读/写传输
00000c  4639              MOV      r1,r7
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       SWD_TransferOnce
000014  4604              MOV      r4,r0
;;;264    
;;;265            // if ack != WAIT
;;;266            if(ack != DAP_TRANSFER_WAIT)
000016  2c02              CMP      r4,#2
000018  d002              BEQ      |L3.32|
;;;267            {
;;;268                return ack;
00001a  4620              MOV      r0,r4
                  |L3.28|
;;;269            }
;;;270        }
;;;271        return ack;
;;;272    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.32|
000020  1c68              ADDS     r0,r5,#1              ;261
000022  b2c5              UXTB     r5,r0                 ;261
                  |L3.36|
000024  2d05              CMP      r5,#5                 ;261
000026  dbf1              BLT      |L3.12|
000028  4620              MOV      r0,r4                 ;271
00002a  e7f7              B        |L3.28|
;;;273    
                          ENDP


                          AREA ||i.SWD_TransferOnce||, CODE, READONLY, ALIGN=2

                  SWD_TransferOnce PROC
;;;112    *******************************************************************************/
;;;113    unsigned char SWD_TransferOnce(unsigned long request, unsigned long *data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;114    {
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
;;;115        unsigned long ack = 0;
000008  f04f0900          MOV      r9,#0
;;;116        unsigned long bit;
;;;117        unsigned long val;
;;;118        unsigned long parity;
;;;119        unsigned long n;
;;;120    
;;;121    		ack = SWD_TransRequest(request);
00000c  f00a00ff          AND      r0,r10,#0xff
000010  f7fffffe          BL       SWD_TransRequest
000014  4681              MOV      r9,r0
;;;122      
;;;123        switch(ack)
000016  f1b90f01          CMP      r9,#1
00001a  d006              BEQ      |L4.42|
00001c  f1b90f02          CMP      r9,#2
000020  d062              BEQ      |L4.232|
000022  f1b90f04          CMP      r9,#4
000026  d17f              BNE      |L4.296|
000028  e05f              B        |L4.234|
                  |L4.42|
;;;124        {
;;;125            case DAP_TRANSFER_OK:			//应答OK，根据请求类型执行相应操作
;;;126    						//读数据请求
;;;127                if(request & DAP_TRANSFER_RnW)  /* read data */
00002a  f00a0002          AND      r0,r10,#2
00002e  b348              CBZ      r0,|L4.132|
;;;128                {
;;;129                    val = 0;
000030  2500              MOVS     r5,#0
;;;130                    parity = 0;
000032  2600              MOVS     r6,#0
;;;131    
;;;132                    for(n = 32; n; n--)
000034  2420              MOVS     r4,#0x20
000036  e007              B        |L4.72|
                  |L4.56|
;;;133                    {
;;;134                        bit = SW_READ_BIT();  /* Read RDATA[0:31] */
000038  f7fffffe          BL       SW_READ_BIT
00003c  4607              MOV      r7,r0
;;;135                        parity += bit;
00003e  443e              ADD      r6,r6,r7
;;;136                        val >>= 1;
000040  086d              LSRS     r5,r5,#1
;;;137                        val  |= bit << 31;
000042  ea4575c7          ORR      r5,r5,r7,LSL #31
000046  1e64              SUBS     r4,r4,#1              ;132
                  |L4.72|
000048  2c00              CMP      r4,#0                 ;132
00004a  d1f5              BNE      |L4.56|
;;;138                    }
;;;139    
;;;140                    bit = SW_READ_BIT();    /* Read Parity */
00004c  f7fffffe          BL       SW_READ_BIT
000050  4607              MOV      r7,r0
;;;141    
;;;142                    if((parity ^ bit) & 1)
000052  ea860007          EOR      r0,r6,r7
000056  f0000001          AND      r0,r0,#1
00005a  b108              CBZ      r0,|L4.96|
;;;143                    {
;;;144                        ack = DAP_TRANSFER_ERROR;		//0x08传输错误--校验错误	
00005c  f04f0908          MOV      r9,#8
                  |L4.96|
;;;145                    }
;;;146    
;;;147                    if(data) 
000060  f1b80f00          CMP      r8,#0
000064  d001              BEQ      |L4.106|
;;;148    									*data = val;
000066  f8c85000          STR      r5,[r8,#0]
                  |L4.106|
;;;149    
;;;150                    /* Turnaround */
;;;151                    for(n = 1; n; n--)
00006a  2401              MOVS     r4,#1
00006c  e002              B        |L4.116|
                  |L4.110|
;;;152                    {
;;;153                        SW_CLOCK_CYCLE();
00006e  f7fffffe          BL       SW_CLOCK_CYCLE
000072  1e64              SUBS     r4,r4,#1              ;151
                  |L4.116|
000074  2c00              CMP      r4,#0                 ;151
000076  d1fa              BNE      |L4.110|
;;;154                    }
;;;155    
;;;156                    SWDIO_SET_OUTPUT();		//SWDIO设置为输出
000078  f44f6180          MOV      r1,#0x400
00007c  4839              LDR      r0,|L4.356|
00007e  f7fffffe          BL       GPIO_Configuration_OPP50
000082  e01b              B        |L4.188|
                  |L4.132|
;;;157                }
;;;158    						//写数据请求
;;;159                else    /* write data */
;;;160                {
;;;161                    /* Turnaround */
;;;162                    for(n = 1; n; n--)
000084  2401              MOVS     r4,#1
000086  e002              B        |L4.142|
                  |L4.136|
;;;163                    {
;;;164                        SW_CLOCK_CYCLE();
000088  f7fffffe          BL       SW_CLOCK_CYCLE
00008c  1e64              SUBS     r4,r4,#1              ;162
                  |L4.142|
00008e  2c00              CMP      r4,#0                 ;162
000090  d1fa              BNE      |L4.136|
;;;165                    }
;;;166    
;;;167                    SWDIO_SET_OUTPUT();	//SWDIO设置为输出
000092  f44f6180          MOV      r1,#0x400
000096  4833              LDR      r0,|L4.356|
000098  f7fffffe          BL       GPIO_Configuration_OPP50
;;;168                    /* Write data */
;;;169                    val = *data;
00009c  f8d85000          LDR      r5,[r8,#0]
;;;170                    parity = 0;
0000a0  2600              MOVS     r6,#0
;;;171    
;;;172                    for(n = 32; n; n--)
0000a2  2420              MOVS     r4,#0x20
0000a4  e005              B        |L4.178|
                  |L4.166|
;;;173                    {
;;;174                        SW_WRITE_BIT(val); /* Write WDATA[0:31] */
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       SW_WRITE_BIT
;;;175                        parity += val;
0000ac  442e              ADD      r6,r6,r5
;;;176                        val >>= 1;
0000ae  086d              LSRS     r5,r5,#1
0000b0  1e64              SUBS     r4,r4,#1              ;172
                  |L4.178|
0000b2  2c00              CMP      r4,#0                 ;172
0000b4  d1f7              BNE      |L4.166|
;;;177                    }
;;;178    
;;;179                    SW_WRITE_BIT(parity);/* Write Parity Bit */
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       SW_WRITE_BIT
                  |L4.188|
;;;180                }
;;;181    
;;;182                /* Idle cycles */
;;;183                SWDIO_SET_OUTPUT();		//SWDIO设置为输出
0000bc  f44f6180          MOV      r1,#0x400
0000c0  4828              LDR      r0,|L4.356|
0000c2  f7fffffe          BL       GPIO_Configuration_OPP50
;;;184                
;;;185                for(n = 0; n < 8; n++)
0000c6  2400              MOVS     r4,#0
0000c8  e003              B        |L4.210|
                  |L4.202|
;;;186                {
;;;187                    SW_WRITE_BIT(0);
0000ca  2000              MOVS     r0,#0
0000cc  f7fffffe          BL       SW_WRITE_BIT
0000d0  1c64              ADDS     r4,r4,#1              ;185
                  |L4.210|
0000d2  2c08              CMP      r4,#8                 ;185
0000d4  d3f9              BCC      |L4.202|
;;;188                }
;;;189    						SWDIO_SET();
0000d6  f44f6080          MOV      r0,#0x400
0000da  4922              LDR      r1,|L4.356|
0000dc  3110              ADDS     r1,r1,#0x10
0000de  6008              STR      r0,[r1,#0]
;;;190                return (ack);
0000e0  f00900ff          AND      r0,r9,#0xff
                  |L4.228|
;;;191    
;;;192            case DAP_TRANSFER_WAIT:
;;;193            case DAP_TRANSFER_FAULT:
;;;194    
;;;195                /* WAIT or FAULT response */
;;;196                if(0 && ((request & DAP_TRANSFER_RnW) != 0))
;;;197                {
;;;198                    for(n = 32 + 1; n; n--)
;;;199                    {
;;;200                        SW_CLOCK_CYCLE();  /* Dummy Read RDATA[0:31] + Parity */
;;;201                    }
;;;202                }
;;;203    
;;;204                /* Turnaround */
;;;205                for(n = 1; n; n--)
;;;206                {
;;;207                    SW_CLOCK_CYCLE();
;;;208                }
;;;209    
;;;210                SWDIO_SET_OUTPUT();		//SWDIO设置为输出
;;;211    
;;;212                if(0 && ((request & DAP_TRANSFER_RnW) == 0))
;;;213                {
;;;214                    SWCLK_CLR();
;;;215    
;;;216                    for(n = 32 + 1; n; n--)
;;;217                    {
;;;218                        SW_CLOCK_CYCLE();  /* Dummy Write WDATA[0:31] + Parity */
;;;219                    }
;;;220                }
;;;221    
;;;222                SWDIO_SET();
;;;223                for(n = 0; n < 8; n++)
;;;224                {
;;;225                    SW_WRITE_BIT(0);
;;;226                }
;;;227                return (ack);
;;;228    
;;;229            default:
;;;230                break;
;;;231        }
;;;232    
;;;233        /* Protocol error */
;;;234        for(n = 1 + 32 + 1; n; n--)
;;;235        {
;;;236            SW_CLOCK_CYCLE();      /* Back off data phase */
;;;237        }
;;;238    
;;;239        SWDIO_SET_OUTPUT();		//SWDIO设置为输出
;;;240        
;;;241        for(n = 0; n < 8; n++)
;;;242        {
;;;243            SW_WRITE_BIT(0);
;;;244        }
;;;245    		SWDIO_SET();
;;;246        return (ack);
;;;247    }
0000e4  e8bd87f0          POP      {r4-r10,pc}
                  |L4.232|
0000e8  bf00              NOP                            ;193
                  |L4.234|
0000ea  bf00              NOP                            ;196
0000ec  2401              MOVS     r4,#1                 ;205
0000ee  e002              B        |L4.246|
                  |L4.240|
0000f0  f7fffffe          BL       SW_CLOCK_CYCLE
0000f4  1e64              SUBS     r4,r4,#1              ;205
                  |L4.246|
0000f6  2c00              CMP      r4,#0                 ;205
0000f8  d1fa              BNE      |L4.240|
0000fa  f44f6180          MOV      r1,#0x400             ;210
0000fe  4819              LDR      r0,|L4.356|
000100  f7fffffe          BL       GPIO_Configuration_OPP50
000104  bf00              NOP                            ;212
000106  f44f6080          MOV      r0,#0x400             ;222
00010a  4916              LDR      r1,|L4.356|
00010c  3110              ADDS     r1,r1,#0x10           ;222
00010e  6008              STR      r0,[r1,#0]            ;222
000110  bf00              NOP                            ;223
000112  e004              B        |L4.286|
000114  e008              B        |L4.296|
                  |L4.278|
000116  2000              MOVS     r0,#0                 ;225
000118  f7fffffe          BL       SW_WRITE_BIT
00011c  1c64              ADDS     r4,r4,#1              ;223
                  |L4.286|
00011e  2c08              CMP      r4,#8                 ;223
000120  d3f9              BCC      |L4.278|
000122  f00900ff          AND      r0,r9,#0xff           ;227
000126  e7dd              B        |L4.228|
                  |L4.296|
000128  bf00              NOP                            ;230
00012a  bf00              NOP                            ;230
00012c  2422              MOVS     r4,#0x22              ;234
00012e  e002              B        |L4.310|
                  |L4.304|
000130  f7fffffe          BL       SW_CLOCK_CYCLE
000134  1e64              SUBS     r4,r4,#1              ;234
                  |L4.310|
000136  2c00              CMP      r4,#0                 ;234
000138  d1fa              BNE      |L4.304|
00013a  f44f6180          MOV      r1,#0x400             ;239
00013e  4809              LDR      r0,|L4.356|
000140  f7fffffe          BL       GPIO_Configuration_OPP50
000144  bf00              NOP                            ;241
000146  e003              B        |L4.336|
                  |L4.328|
000148  2000              MOVS     r0,#0                 ;243
00014a  f7fffffe          BL       SW_WRITE_BIT
00014e  1c64              ADDS     r4,r4,#1              ;241
                  |L4.336|
000150  2c08              CMP      r4,#8                 ;241
000152  d3f9              BCC      |L4.328|
000154  f44f6080          MOV      r0,#0x400             ;245
000158  4902              LDR      r1,|L4.356|
00015a  3110              ADDS     r1,r1,#0x10           ;245
00015c  6008              STR      r0,[r1,#0]            ;245
00015e  f00900ff          AND      r0,r9,#0xff           ;246
000162  e7bf              B        |L4.228|
;;;248    /*******************************************************************************
                          ENDP

                  |L4.356|
                          DCD      0x40010800

                          AREA ||i.SWJ_InitDebug||, CODE, READONLY, ALIGN=2

                  SWJ_InitDebug PROC
;;;1144   //1故障 0正常
;;;1145   unsigned char SWJ_InitDebug(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;1146   {
;;;1147     unsigned long tmp = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
;;;1148     unsigned long val;
;;;1149     unsigned char ack;
;;;1150       /*JTAG 转到 SWD*/
;;;1151       SWJ_JTAG2SWD();
000006  f7fffffe          BL       SWJ_JTAG2SWD
;;;1152   	
;;;1153       if(SWJ_ReadDP(DP_IDCODE, &val))		//读DPACC
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       SWJ_ReadDP
000012  b108              CBZ      r0,|L5.24|
;;;1154       {
;;;1155           return 1;
000014  2001              MOVS     r0,#1
                  |L5.22|
;;;1156       }
;;;1157   		
;;;1158       SWD_TRACE("DP_IDCODE:0x%X\r\n", val);
;;;1159   
;;;1160       SWJ_WriteDP(DP_ABORT, STKCMPCLR	|	STKERRCLR	|	WDERRCLR	|	ORUNERRCLR);
;;;1161   
;;;1162       /* Ensure CTRL/STAT register selected in DPBANKSEL */
;;;1163       //SWJ_WriteDP(DP_SELECT, 0);
;;;1164   
;;;1165       /* Power ups */
;;;1166       SWJ_WriteDP(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ);   // System Power-up Request  // Debug Power-up Request
;;;1167       
;;;1168       //等待上电成功
;;;1169       do
;;;1170       { 
;;;1171           ack = SWJ_ReadDP(DP_CTRL_STAT, &tmp);
;;;1172           if(0!=ack)
;;;1173           {
;;;1174               return 0;
;;;1175           }
;;;1176       }
;;;1177       while((tmp & (CDBGPWRUPACK | CSYSPWRUPACK)) != (CDBGPWRUPACK | CSYSPWRUPACK));
;;;1178   
;;;1179       SWJ_WriteDP(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE);
;;;1180   		
;;;1181   		SWDIO_SET_OUTPUT();
;;;1182   		SWDIO_SET();
;;;1183       return 0;
;;;1184   }
000016  bd1c              POP      {r2-r4,pc}
                  |L5.24|
000018  211e              MOVS     r1,#0x1e              ;1160
00001a  2000              MOVS     r0,#0                 ;1160
00001c  f7fffffe          BL       SWJ_WriteDP
000020  f04f41a0          MOV      r1,#0x50000000        ;1166
000024  2004              MOVS     r0,#4                 ;1166
000026  f7fffffe          BL       SWJ_WriteDP
00002a  bf00              NOP                            ;1169
                  |L5.44|
00002c  a901              ADD      r1,sp,#4              ;1171
00002e  2004              MOVS     r0,#4                 ;1171
000030  f7fffffe          BL       SWJ_ReadDP
000034  4604              MOV      r4,r0                 ;1171
000036  b10c              CBZ      r4,|L5.60|
000038  2000              MOVS     r0,#0                 ;1174
00003a  e7ec              B        |L5.22|
                  |L5.60|
00003c  9801              LDR      r0,[sp,#4]            ;1177
00003e  f0004020          AND      r0,r0,#0xa0000000     ;1177
000042  f1b04f20          CMP      r0,#0xa0000000        ;1177
000046  d1f1              BNE      |L5.44|
000048  4907              LDR      r1,|L5.104|
00004a  2004              MOVS     r0,#4                 ;1179
00004c  f7fffffe          BL       SWJ_WriteDP
000050  f44f6180          MOV      r1,#0x400             ;1181
000054  4805              LDR      r0,|L5.108|
000056  f7fffffe          BL       GPIO_Configuration_OPP50
00005a  f44f6080          MOV      r0,#0x400             ;1182
00005e  4903              LDR      r1,|L5.108|
000060  3110              ADDS     r1,r1,#0x10           ;1182
000062  6008              STR      r0,[r1,#0]            ;1182
000064  2000              MOVS     r0,#0                 ;1183
000066  e7d6              B        |L5.22|
;;;1185   
                          ENDP

                  |L5.104|
                          DCD      0x50000f00
                  |L5.108|
                          DCD      0x40010800

                          AREA ||i.SWJ_JTAG2SWD||, CODE, READONLY, ALIGN=2

                  SWJ_JTAG2SWD PROC
;;;342    *******************************************************************************/
;;;343    static unsigned char SWJ_JTAG2SWD(void)
000000  b510              PUSH     {r4,lr}
;;;344    {
;;;345        unsigned long i;
;;;346    	SWDIO_SET_OUTPUT();
000002  f44f6180          MOV      r1,#0x400
000006  4814              LDR      r0,|L6.88|
000008  f7fffffe          BL       GPIO_Configuration_OPP50
;;;347    	SWDIO_SET();
00000c  f44f6080          MOV      r0,#0x400
000010  4911              LDR      r1,|L6.88|
000012  3110              ADDS     r1,r1,#0x10
000014  6008              STR      r0,[r1,#0]
;;;348    	//1,需要先发送JTAG到SWD的切换命令：至少50个时钟的1
;;;349    	Line_Rest();	//线路复位,56个时钟的1
000016  f7fffffe          BL       Line_Rest
;;;350    	//2,然后是16bit的切换序列0xE79E（低位在前）强制切换到SWD模式
;;;351    	SWJ_SendData(0xE79E);//发送16bit的切换序列0xE79E（低位在前）强制切换到SWD模式
00001a  f24e709e          MOV      r0,#0xe79e
00001e  f7fffffe          BL       SWJ_SendData
;;;352    	//3,继续发送至少50个时钟的1，令SWD进入线复位状态（line reset）
;;;353    	Line_Rest();	//线路复位,56个时钟的1
000022  f7fffffe          BL       Line_Rest
;;;354    	//2.1,然后是16bit的切换序列0x6DB7（低位在前）老版本ARM强制切换到SWD模式
;;;355    	SWJ_SendData(0x6DB7);//发送切换序列0x6DB7（低位在前）老版本ARM强制切换到SWD模式
000026  f64650b7          MOV      r0,#0x6db7
00002a  f7fffffe          BL       SWJ_SendData
;;;356    	Line_Rest();	//线路复位,56个时钟的1	
00002e  f7fffffe          BL       Line_Rest
;;;357    	SWDIO_CLR();
000032  f44f6080          MOV      r0,#0x400
000036  4908              LDR      r1,|L6.88|
000038  3114              ADDS     r1,r1,#0x14
00003a  6008              STR      r0,[r1,#0]
;;;358    	for(i = 0; i < 16; i++)
00003c  2400              MOVS     r4,#0
00003e  e002              B        |L6.70|
                  |L6.64|
;;;359    	{
;;;360    			SW_CLOCK_CYCLE();
000040  f7fffffe          BL       SW_CLOCK_CYCLE
000044  1c64              ADDS     r4,r4,#1              ;358
                  |L6.70|
000046  2c10              CMP      r4,#0x10              ;358
000048  d3fa              BCC      |L6.64|
;;;361    	}
;;;362    	SWDIO_SET();//(swdio)PB3输出1
00004a  f44f6080          MOV      r0,#0x400
00004e  4902              LDR      r1,|L6.88|
000050  3110              ADDS     r1,r1,#0x10
000052  6008              STR      r0,[r1,#0]
;;;363    	return 0;
000054  2000              MOVS     r0,#0
;;;364    }
000056  bd10              POP      {r4,pc}
;;;365    /*******************************************************************************
                          ENDP

                  |L6.88|
                          DCD      0x40010800

                          AREA ||i.SWJ_ReadAP||, CODE, READONLY, ALIGN=1

                  SWJ_ReadAP PROC
;;;415    *******************************************************************************/
;;;416    unsigned char SWJ_ReadAP(unsigned long adr, unsigned long *val)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;417    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;418        unsigned char tmp_in, ack, err;
;;;419    
;;;420        unsigned long apsel = adr & APSEL;
000008  f004497f          AND      r9,r4,#0xff000000
;;;421        unsigned long bank_sel = adr & APBANKSEL;
00000c  f0040af0          AND      r10,r4,#0xf0
;;;422    
;;;423        if(SWJ_WriteDP(DP_SELECT, apsel | bank_sel))
000010  ea49010a          ORR      r1,r9,r10
000014  2008              MOVS     r0,#8
000016  f7fffffe          BL       SWJ_WriteDP
00001a  b110              CBZ      r0,|L7.34|
;;;424        {
;;;425            return 1;
00001c  2001              MOVS     r0,#1
                  |L7.30|
;;;426        }
;;;427    
;;;428        tmp_in = SWD_REG_AP | SWD_REG_R | SWD_REG_ADR(adr);
;;;429    
;;;430        /* first dummy read */
;;;431        ack = SWD_Transfer(tmp_in, val);
;;;432        ack = SWD_Transfer(tmp_in, val);
;;;433    
;;;434        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
;;;435        return err;
;;;436    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L7.34|
000022  f004000c          AND      r0,r4,#0xc            ;428
000026  f0400603          ORR      r6,r0,#3              ;428
00002a  4639              MOV      r1,r7                 ;431
00002c  4630              MOV      r0,r6                 ;431
00002e  f7fffffe          BL       SWD_Transfer
000032  4680              MOV      r8,r0                 ;431
000034  4639              MOV      r1,r7                 ;432
000036  4630              MOV      r0,r6                 ;432
000038  f7fffffe          BL       SWD_Transfer
00003c  4680              MOV      r8,r0                 ;432
00003e  f1b80f01          CMP      r8,#1                 ;434
000042  d101              BNE      |L7.72|
000044  2500              MOVS     r5,#0                 ;434
000046  e000              B        |L7.74|
                  |L7.72|
000048  2501              MOVS     r5,#1                 ;434
                  |L7.74|
00004a  4628              MOV      r0,r5                 ;435
00004c  e7e7              B        |L7.30|
;;;437    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_ReadBlock||, CODE, READONLY, ALIGN=2

                  SWJ_ReadBlock PROC
;;;684    //1故障 0正常
;;;685    static unsigned char SWJ_ReadBlock(unsigned long addr, unsigned char *buf, unsigned long len)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;686    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;687        unsigned char err, req;
;;;688        unsigned long size_in_words;
;;;689        unsigned long i, ack;
;;;690    
;;;691        if(len == 0)  return 0;
00000a  b915              CBNZ     r5,|L8.18|
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;692    
;;;693        err = 0;
;;;694        size_in_words = len / 4;
;;;695    
;;;696    
;;;697        err += SWJ_WriteAP(AP_CSW, CSW_VALUE | CSW_SIZE32);
;;;698        err += SWJ_WriteAP(AP_TAR, addr);
;;;699    
;;;700        if(err) return err;
;;;701    
;;;702        req = SWD_REG_AP | SWD_REG_R | (3 << 2);
;;;703    
;;;704        /* dummy read */
;;;705        if(SWD_Transfer(req, (unsigned long *)buf) != 0x01)
;;;706        {
;;;707            return 1;
;;;708        }
;;;709    
;;;710        for(i = 0; i < size_in_words; i++)
;;;711        {
;;;712            if(SWD_Transfer(req, (unsigned long *)buf) != DAP_TRANSFER_OK)
;;;713            {
;;;714                return 1;
;;;715            }
;;;716    
;;;717            buf += 4;
;;;718        }
;;;719    
;;;720        /* read DP buff */
;;;721        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
;;;722        ack = SWD_Transfer(req, NULL);
;;;723    
;;;724        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
;;;725        return err;
;;;726    }
00000e  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.18|
000012  2400              MOVS     r4,#0                 ;693
000014  ea4f0b95          LSR      r11,r5,#2             ;694
000018  491a              LDR      r1,|L8.132|
00001a  2000              MOVS     r0,#0                 ;697
00001c  f7fffffe          BL       SWJ_WriteAP
000020  4420              ADD      r0,r0,r4              ;697
000022  b2c4              UXTB     r4,r0                 ;697
000024  4641              MOV      r1,r8                 ;698
000026  2004              MOVS     r0,#4                 ;698
000028  f7fffffe          BL       SWJ_WriteAP
00002c  4420              ADD      r0,r0,r4              ;698
00002e  b2c4              UXTB     r4,r0                 ;698
000030  b10c              CBZ      r4,|L8.54|
000032  4620              MOV      r0,r4                 ;700
000034  e7eb              B        |L8.14|
                  |L8.54|
000036  f04f0a0f          MOV      r10,#0xf              ;702
00003a  4649              MOV      r1,r9                 ;705
00003c  4650              MOV      r0,r10                ;705
00003e  f7fffffe          BL       SWD_Transfer
000042  2801              CMP      r0,#1                 ;705
000044  d001              BEQ      |L8.74|
000046  2001              MOVS     r0,#1                 ;707
000048  e7e1              B        |L8.14|
                  |L8.74|
00004a  2600              MOVS     r6,#0                 ;710
00004c  e00a              B        |L8.100|
                  |L8.78|
00004e  4649              MOV      r1,r9                 ;712
000050  4650              MOV      r0,r10                ;712
000052  f7fffffe          BL       SWD_Transfer
000056  2801              CMP      r0,#1                 ;712
000058  d001              BEQ      |L8.94|
00005a  2001              MOVS     r0,#1                 ;714
00005c  e7d7              B        |L8.14|
                  |L8.94|
00005e  f1090904          ADD      r9,r9,#4              ;717
000062  1c76              ADDS     r6,r6,#1              ;710
                  |L8.100|
000064  455e              CMP      r6,r11                ;710
000066  d3f2              BCC      |L8.78|
000068  f04f0a0e          MOV      r10,#0xe              ;721
00006c  2100              MOVS     r1,#0                 ;722
00006e  4650              MOV      r0,r10                ;722
000070  f7fffffe          BL       SWD_Transfer
000074  4607              MOV      r7,r0                 ;722
000076  2f01              CMP      r7,#1                 ;724
000078  d101              BNE      |L8.126|
00007a  2400              MOVS     r4,#0                 ;724
00007c  e000              B        |L8.128|
                  |L8.126|
00007e  2401              MOVS     r4,#1                 ;724
                  |L8.128|
000080  4620              MOV      r0,r4                 ;725
000082  e7c4              B        |L8.14|
;;;727    
                          ENDP

                  |L8.132|
                          DCD      0x23000052

                          AREA ||i.SWJ_ReadCoreReg||, CODE, READONLY, ALIGN=2

                  SWJ_ReadCoreReg PROC
;;;1005   //1故障 0正常
;;;1006   static unsigned char SWJ_ReadCoreReg(unsigned long n, unsigned long *val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1007   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1008       int i = 0, timeout = MAX_TIMEOUT, err;
000008  2500              MOVS     r5,#0
00000a  f04f0801          MOV      r8,#1
;;;1009   
;;;1010       if(SWJ_WriteMem32(DCRSR, n))
00000e  4631              MOV      r1,r6
000010  4812              LDR      r0,|L9.92|
000012  f7fffffe          BL       SWJ_WriteMem32
000016  b110              CBZ      r0,|L9.30|
;;;1011           return 1;
000018  2001              MOVS     r0,#1
                  |L9.26|
;;;1012   
;;;1013       // wait for S_REGRDY
;;;1014       for(i = 0; i < timeout; i++)
;;;1015       {
;;;1016   
;;;1017           if(SWJ_ReadMem32(DHCSR, val))
;;;1018               return 1;
;;;1019   
;;;1020           if(*val & S_REGRDY)
;;;1021               break;
;;;1022       }
;;;1023   
;;;1024       if(i == timeout)
;;;1025           return 1;
;;;1026   
;;;1027       err = SWJ_ReadMem32(DCRDR, val);
;;;1028   
;;;1029       return err;
;;;1030   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.30|
00001e  2500              MOVS     r5,#0                 ;1014
000020  e00d              B        |L9.62|
                  |L9.34|
000022  4639              MOV      r1,r7                 ;1017
000024  480d              LDR      r0,|L9.92|
000026  1f00              SUBS     r0,r0,#4              ;1017
000028  f7fffffe          BL       SWJ_ReadMem32
00002c  b108              CBZ      r0,|L9.50|
00002e  2001              MOVS     r0,#1                 ;1018
000030  e7f3              B        |L9.26|
                  |L9.50|
000032  6838              LDR      r0,[r7,#0]            ;1020
000034  f4003080          AND      r0,r0,#0x10000        ;1020
000038  b100              CBZ      r0,|L9.60|
00003a  e002              B        |L9.66|
                  |L9.60|
00003c  1c6d              ADDS     r5,r5,#1              ;1014
                  |L9.62|
00003e  4545              CMP      r5,r8                 ;1014
000040  dbef              BLT      |L9.34|
                  |L9.66|
000042  bf00              NOP                            ;1021
000044  4545              CMP      r5,r8                 ;1024
000046  d101              BNE      |L9.76|
000048  2001              MOVS     r0,#1                 ;1025
00004a  e7e6              B        |L9.26|
                  |L9.76|
00004c  4639              MOV      r1,r7                 ;1027
00004e  4803              LDR      r0,|L9.92|
000050  1d00              ADDS     r0,r0,#4              ;1027
000052  f7fffffe          BL       SWJ_ReadMem32
000056  4604              MOV      r4,r0                 ;1027
000058  4620              MOV      r0,r4                 ;1029
00005a  e7de              B        |L9.26|
;;;1031   /*******************************************************************************
                          ENDP

                  |L9.92|
                          DCD      0xe000edf4

                          AREA ||i.SWJ_ReadDP||, CODE, READONLY, ALIGN=1

                  SWJ_ReadDP PROC
;;;373    *******************************************************************************/
;;;374    static unsigned char SWJ_ReadDP(unsigned char adr, unsigned long *val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;375    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;376    	unsigned long tmp_in;
;;;377    	unsigned char ack;
;;;378    	unsigned char err;
;;;379    
;;;380    	tmp_in = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(adr);
000008  f005000c          AND      r0,r5,#0xc
00000c  f0400702          ORR      r7,r0,#2
;;;381    	ack = SWD_Transfer(tmp_in, val);
000010  4631              MOV      r1,r6
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       SWD_Transfer
000018  4680              MOV      r8,r0
;;;382    
;;;383    	(ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
00001a  f1b80f01          CMP      r8,#1
00001e  d101              BNE      |L10.36|
000020  2400              MOVS     r4,#0
000022  e000              B        |L10.38|
                  |L10.36|
000024  2401              MOVS     r4,#1
                  |L10.38|
;;;384    	return err;
000026  4620              MOV      r0,r4
;;;385    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;386    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_ReadData||, CODE, READONLY, ALIGN=1

                  SWJ_ReadData PROC
;;;612    //1故障 0正常
;;;613    static unsigned char SWJ_ReadData(unsigned long addr, unsigned long *val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;614    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;615        unsigned char req, ack, err;
;;;616    
;;;617        SWJ_WriteAP(AP_TAR, addr);
000008  4629              MOV      r1,r5
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       SWJ_WriteAP
;;;618    
;;;619        /* read data */
;;;620        req = SWD_REG_AP | SWD_REG_R | AP_DRW;
000010  270f              MOVS     r7,#0xf
;;;621        ack = SWD_Transfer(req, val);
000012  4631              MOV      r1,r6
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       SWD_Transfer
00001a  4680              MOV      r8,r0
;;;622    
;;;623        /* dummy read */
;;;624        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
00001c  270e              MOVS     r7,#0xe
;;;625        ack = SWD_Transfer(req, val);
00001e  4631              MOV      r1,r6
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       SWD_Transfer
000026  4680              MOV      r8,r0
;;;626    
;;;627        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
000028  f1b80f01          CMP      r8,#1
00002c  d101              BNE      |L11.50|
00002e  2400              MOVS     r4,#0
000030  e000              B        |L11.52|
                  |L11.50|
000032  2401              MOVS     r4,#1
                  |L11.52|
;;;628        return err;
000034  4620              MOV      r0,r4
;;;629    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;630    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_ReadMem||, CODE, READONLY, ALIGN=1

                  SWJ_ReadMem PROC
;;;857    //1故障 0正常
;;;858    unsigned char SWJ_ReadMem(unsigned long addr, unsigned char *buf, unsigned long len)
000000  b570              PUSH     {r4-r6,lr}
;;;859    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;860        return swd_read_memory(addr, buf, len);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       swd_read_memory
;;;861    }
000012  bd70              POP      {r4-r6,pc}
;;;862    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_ReadMem32||, CODE, READONLY, ALIGN=2

                  SWJ_ReadMem32 PROC
;;;640    //1故障 0正常
;;;641    static unsigned char SWJ_ReadMem32(unsigned long addr, unsigned long *val)
000000  b570              PUSH     {r4-r6,lr}
;;;642    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;643        unsigned char err;
;;;644        SWJ_WriteAP(AP_CSW, CSW_VALUE | CSW_SIZE32);
000006  4905              LDR      r1,|L13.28|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SWJ_WriteAP
;;;645        err = SWJ_ReadData(addr, val);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SWJ_ReadData
000016  4606              MOV      r6,r0
;;;646        return err;
000018  4630              MOV      r0,r6
;;;647    }
00001a  bd70              POP      {r4-r6,pc}
;;;648    /*******************************************************************************
                          ENDP

                  |L13.28|
                          DCD      0x23000052

                          AREA ||i.SWJ_ReadMem8||, CODE, READONLY, ALIGN=2

                  SWJ_ReadMem8 PROC
;;;658    //1故障 0正常
;;;659    static unsigned char SWJ_ReadMem8(unsigned long addr, unsigned char *val)
000000  b5f8              PUSH     {r3-r7,lr}
;;;660    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;661        unsigned long tmp;
;;;662        unsigned char err;
;;;663    
;;;664        SWJ_WriteAP(AP_CSW, CSW_VALUE | CSW_SIZE8);
000006  4908              LDR      r1,|L14.40|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SWJ_WriteAP
;;;665    
;;;666        err = SWJ_ReadData(addr, &tmp);
00000e  4669              MOV      r1,sp
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SWJ_ReadData
000016  4606              MOV      r6,r0
;;;667    
;;;668        *val = (unsigned char)(tmp >> ((addr & 0x03) << 3));
000018  07a0              LSLS     r0,r4,#30
00001a  0ec1              LSRS     r1,r0,#27
00001c  9800              LDR      r0,[sp,#0]
00001e  40c8              LSRS     r0,r0,r1
000020  7028              STRB     r0,[r5,#0]
;;;669    
;;;670        return err;
000022  4630              MOV      r0,r6
;;;671    }
000024  bdf8              POP      {r3-r7,pc}
;;;672    /*******************************************************************************
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x23000050

                          AREA ||i.SWJ_SendData||, CODE, READONLY, ALIGN=1

                  SWJ_SendData PROC
;;;293    *******************************************************************************/
;;;294    static void SWJ_SendData(uint16_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4604              MOV      r4,r0
;;;296        unsigned char i;
;;;297    
;;;298        for(i = 0; i < 16; i++)
000004  2500              MOVS     r5,#0
000006  e006              B        |L15.22|
                  |L15.8|
;;;299        {
;;;300            SW_WRITE_BIT(((data & 0x1) == 1) ? (1) : (0));
000008  f0040001          AND      r0,r4,#1
00000c  f7fffffe          BL       SW_WRITE_BIT
;;;301            data >>= 1;
000010  1064              ASRS     r4,r4,#1
000012  1c68              ADDS     r0,r5,#1              ;298
000014  b2c5              UXTB     r5,r0                 ;298
                  |L15.22|
000016  2d10              CMP      r5,#0x10              ;298
000018  dbf6              BLT      |L15.8|
;;;302        }
;;;303    }
00001a  bd70              POP      {r4-r6,pc}
;;;304    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_SetTargetState||, CODE, READONLY, ALIGN=2

                  SWJ_SetTargetState PROC
;;;920    //1故障 0正常
;;;921    unsigned char SWJ_SetTargetState(TARGET_RESET_STATE state)
000000  b510              PUSH     {r4,lr}
;;;922    {
000002  4604              MOV      r4,r0
;;;923        switch(state)
000004  b124              CBZ      r4,|L16.16|
000006  2c01              CMP      r4,#1
000008  d016              BEQ      |L16.56|
00000a  2c02              CMP      r4,#2
00000c  d131              BNE      |L16.114|
00000e  e003              B        |L16.24|
                  |L16.16|
;;;924        {
;;;925            case RESET_HOLD:
;;;926                RESET_CLR();		//REST	=	LOW
000010  2004              MOVS     r0,#4
000012  491a              LDR      r1,|L16.124|
000014  6008              STR      r0,[r1,#0]
;;;927                break;
000016  e02d              B        |L16.116|
                  |L16.24|
;;;928    
;;;929            case RESET_RUN:	
;;;930                RESET_CLR();		//REST	=	LOW
000018  2004              MOVS     r0,#4
00001a  4918              LDR      r1,|L16.124|
00001c  6008              STR      r0,[r1,#0]
;;;931                DELAY_US(20 * 1000);
00001e  f6446020          MOV      r0,#0x4e20
000022  f7fffffe          BL       DELAY_US
;;;932                RESET_SET();		//REST	=	HIGH
000026  2004              MOVS     r0,#4
000028  4914              LDR      r1,|L16.124|
00002a  1f09              SUBS     r1,r1,#4
00002c  6008              STR      r0,[r1,#0]
;;;933                DELAY_US(20 * 1000);
00002e  f6446020          MOV      r0,#0x4e20
000032  f7fffffe          BL       DELAY_US
;;;934                break;
000036  e01d              B        |L16.116|
                  |L16.56|
;;;935    
;;;936            case RESET_PROGRAM:
;;;937                RESET_CLR();		//REST	=	LOW
000038  2004              MOVS     r0,#4
00003a  4910              LDR      r1,|L16.124|
00003c  6008              STR      r0,[r1,#0]
;;;938                DELAY_US(20);
00003e  2014              MOVS     r0,#0x14
000040  f7fffffe          BL       DELAY_US
;;;939                //   RESET_SET();
;;;940                //   DelayMs(20);
;;;941    
;;;942                SWJ_InitDebug();
000044  f7fffffe          BL       SWJ_InitDebug
;;;943    
;;;944                // Enable debug
;;;945                SWJ_WriteMem32(DBG_HCSR, DBGKEY | C_DEBUGEN);
000048  490d              LDR      r1,|L16.128|
00004a  480e              LDR      r0,|L16.132|
00004c  f7fffffe          BL       SWJ_WriteMem32
;;;946    
;;;947                // Enable halt on reset
;;;948                SWJ_WriteMem32(DBG_EMCR, VC_CORERESET);
000050  2101              MOVS     r1,#1
000052  480c              LDR      r0,|L16.132|
000054  300c              ADDS     r0,r0,#0xc
000056  f7fffffe          BL       SWJ_WriteMem32
;;;949    
;;;950                // Reset again
;;;951                RESET_CLR();		//REST	=	LOW
00005a  2004              MOVS     r0,#4
00005c  4907              LDR      r1,|L16.124|
00005e  6008              STR      r0,[r1,#0]
;;;952                DELAY_US(20 * 1000);
000060  f6446020          MOV      r0,#0x4e20
000064  f7fffffe          BL       DELAY_US
;;;953                RESET_SET();		//REST	=	HIGH
000068  2004              MOVS     r0,#4
00006a  4904              LDR      r1,|L16.124|
00006c  1f09              SUBS     r1,r1,#4
00006e  6008              STR      r0,[r1,#0]
;;;954    
;;;955                break;
000070  e000              B        |L16.116|
                  |L16.114|
;;;956    
;;;957            default:
;;;958                break;
000072  bf00              NOP      
                  |L16.116|
000074  bf00              NOP                            ;927
;;;959        }
;;;960    
;;;961        return 0;
000076  2000              MOVS     r0,#0
;;;962    }
000078  bd10              POP      {r4,pc}
;;;963    /*******************************************************************************
                          ENDP

00007a  0000              DCW      0x0000
                  |L16.124|
                          DCD      0x40010c14
                  |L16.128|
                          DCD      0xa05f0001
                  |L16.132|
                          DCD      0xe000edf0

                          AREA ||i.SWJ_WaitUntilHalted||, CODE, READONLY, ALIGN=2

                  SWJ_WaitUntilHalted PROC
;;;888    //1故障 0正常
;;;889    static unsigned char SWJ_WaitUntilHalted(void)
000000  b538              PUSH     {r3-r5,lr}
;;;890    {
;;;891        // Wait for target to stop
;;;892        unsigned long val, i, timeout = MAX_TIMEOUT;
000002  2501              MOVS     r5,#1
;;;893    
;;;894        for(i = 0; i < timeout; i++)
000004  2400              MOVS     r4,#0
000006  e00d              B        |L17.36|
                  |L17.8|
;;;895        {
;;;896    
;;;897            if(SWJ_ReadMem32(DBG_HCSR, &val))
000008  4669              MOV      r1,sp
00000a  4808              LDR      r0,|L17.44|
00000c  f7fffffe          BL       SWJ_ReadMem32
000010  b108              CBZ      r0,|L17.22|
;;;898            {
;;;899                return 1;
000012  2001              MOVS     r0,#1
                  |L17.20|
;;;900            }
;;;901    
;;;902            if(val & S_HALT)
;;;903            {
;;;904                return 0;
;;;905            }
;;;906        }
;;;907    
;;;908        return DAP_TRANSFER_ERROR;		//0x08传输错误--校验错误	
;;;909    }
000014  bd38              POP      {r3-r5,pc}
                  |L17.22|
000016  9800              LDR      r0,[sp,#0]            ;902
000018  f4003000          AND      r0,r0,#0x20000        ;902
00001c  b108              CBZ      r0,|L17.34|
00001e  2000              MOVS     r0,#0                 ;904
000020  e7f8              B        |L17.20|
                  |L17.34|
000022  1c64              ADDS     r4,r4,#1              ;894
                  |L17.36|
000024  42ac              CMP      r4,r5                 ;894
000026  d3ef              BCC      |L17.8|
000028  2008              MOVS     r0,#8                 ;908
00002a  e7f3              B        |L17.20|
;;;910    /*******************************************************************************
                          ENDP

                  |L17.44|
                          DCD      0xe000edf0

                          AREA ||i.SWJ_WriteAP||, CODE, READONLY, ALIGN=1

                  SWJ_WriteAP PROC
;;;445    *******************************************************************************/
;;;446    unsigned char SWJ_WriteAP(unsigned long adr, unsigned long val)
000000  e92d47f3          PUSH     {r0,r1,r4-r10,lr}
;;;447    {
000004  4604              MOV      r4,r0
;;;448        unsigned char req, ack, err;
;;;449    
;;;450        unsigned long apsel = adr & APSEL;
000006  f004487f          AND      r8,r4,#0xff000000
;;;451        unsigned long bank_sel = adr & APBANKSEL;
00000a  f00409f0          AND      r9,r4,#0xf0
;;;452    
;;;453        /* write DP select */
;;;454        if(SWJ_WriteDP(DP_SELECT, apsel | bank_sel))
00000e  ea480109          ORR      r1,r8,r9
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       SWJ_WriteDP
;;;455        {
;;;456    
;;;457        }
;;;458    
;;;459        /* write AP data */
;;;460        req = SWD_REG_AP | SWD_REG_W | SWD_REG_ADR(adr);
000018  f004000c          AND      r0,r4,#0xc
00001c  f0400601          ORR      r6,r0,#1
;;;461        ack = SWD_Transfer(req, &val);
000020  a901              ADD      r1,sp,#4
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       SWD_Transfer
000028  4607              MOV      r7,r0
;;;462    
;;;463        /* read DP buff */
;;;464        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
00002a  260e              MOVS     r6,#0xe
;;;465        ack = SWD_Transfer(req, NULL);
00002c  2100              MOVS     r1,#0
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       SWD_Transfer
000034  4607              MOV      r7,r0
;;;466        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
000036  2f01              CMP      r7,#1
000038  d101              BNE      |L18.62|
00003a  2500              MOVS     r5,#0
00003c  e000              B        |L18.64|
                  |L18.62|
00003e  2501              MOVS     r5,#1
                  |L18.64|
;;;467    
;;;468        return err;
000040  4628              MOV      r0,r5
;;;469    }
000042  e8bd87fc          POP      {r2-r10,pc}
;;;470    
                          ENDP


                          AREA ||i.SWJ_WriteBlock||, CODE, READONLY, ALIGN=2

                  SWJ_WriteBlock PROC
;;;557    //1故障 0正常
;;;558    static unsigned char SWJ_WriteBlock(unsigned long addr, unsigned char *buf, unsigned long len)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;559    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;560        unsigned char err, req;
;;;561        unsigned long size_in_words;
;;;562        unsigned long i, ack;
;;;563    
;;;564        if(len == 0)  return 0;
00000a  b915              CBNZ     r5,|L19.18|
00000c  2000              MOVS     r0,#0
                  |L19.14|
;;;565    
;;;566        err = 0;
;;;567        size_in_words = len / 4;
;;;568    
;;;569    
;;;570        err += SWJ_WriteAP(AP_CSW, CSW_VALUE | CSW_SIZE32);
;;;571    
;;;572        if(err)
;;;573        {
;;;574            //SWD_TRACE("AP_CSW, CSW_VALUE | CSW_SIZE32 failed\r\n");
;;;575        }
;;;576    
;;;577        err += SWJ_WriteAP(AP_TAR, addr);
;;;578    
;;;579        if(err) return err;
;;;580    
;;;581        /* DRW write */
;;;582        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
;;;583    
;;;584        for(i = 0; i < size_in_words; i++)
;;;585        {
;;;586            if(SWD_Transfer(req, (unsigned long *)buf) != DAP_TRANSFER_OK)
;;;587            {
;;;588                return 1;
;;;589            }
;;;590    
;;;591            buf += 4;
;;;592        }
;;;593    
;;;594        /* read DP buff */
;;;595        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
;;;596        ack = SWD_Transfer(req, NULL);
;;;597    
;;;598        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
;;;599        return 0;
;;;600    }
00000e  e8bd9ff0          POP      {r4-r12,pc}
                  |L19.18|
000012  2400              MOVS     r4,#0                 ;566
000014  ea4f0b95          LSR      r11,r5,#2             ;567
000018  4916              LDR      r1,|L19.116|
00001a  2000              MOVS     r0,#0                 ;570
00001c  f7fffffe          BL       SWJ_WriteAP
000020  4420              ADD      r0,r0,r4              ;570
000022  b2c4              UXTB     r4,r0                 ;570
000024  4641              MOV      r1,r8                 ;577
000026  2004              MOVS     r0,#4                 ;577
000028  f7fffffe          BL       SWJ_WriteAP
00002c  4420              ADD      r0,r0,r4              ;577
00002e  b2c4              UXTB     r4,r0                 ;577
000030  b10c              CBZ      r4,|L19.54|
000032  4620              MOV      r0,r4                 ;579
000034  e7eb              B        |L19.14|
                  |L19.54|
000036  f04f0a0d          MOV      r10,#0xd              ;582
00003a  2600              MOVS     r6,#0                 ;584
00003c  e00a              B        |L19.84|
                  |L19.62|
00003e  4649              MOV      r1,r9                 ;586
000040  4650              MOV      r0,r10                ;586
000042  f7fffffe          BL       SWD_Transfer
000046  2801              CMP      r0,#1                 ;586
000048  d001              BEQ      |L19.78|
00004a  2001              MOVS     r0,#1                 ;588
00004c  e7df              B        |L19.14|
                  |L19.78|
00004e  f1090904          ADD      r9,r9,#4              ;591
000052  1c76              ADDS     r6,r6,#1              ;584
                  |L19.84|
000054  455e              CMP      r6,r11                ;584
000056  d3f2              BCC      |L19.62|
000058  f04f0a0e          MOV      r10,#0xe              ;595
00005c  2100              MOVS     r1,#0                 ;596
00005e  4650              MOV      r0,r10                ;596
000060  f7fffffe          BL       SWD_Transfer
000064  4607              MOV      r7,r0                 ;596
000066  2f01              CMP      r7,#1                 ;598
000068  d101              BNE      |L19.110|
00006a  2400              MOVS     r4,#0                 ;598
00006c  e000              B        |L19.112|
                  |L19.110|
00006e  2401              MOVS     r4,#1                 ;598
                  |L19.112|
000070  2000              MOVS     r0,#0                 ;599
000072  e7cc              B        |L19.14|
;;;601    /*******************************************************************************
                          ENDP

                  |L19.116|
                          DCD      0x23000052

                          AREA ||i.SWJ_WriteCoreReg||, CODE, READONLY, ALIGN=2

                  SWJ_WriteCoreReg PROC
;;;973    //1故障 0正常
;;;974    static unsigned char SWJ_WriteCoreReg(unsigned long n, unsigned long val)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;975    {
000002  4604              MOV      r4,r0
;;;976        int i = 0, timeout = MAX_TIMEOUT;
000004  2500              MOVS     r5,#0
000006  2601              MOVS     r6,#1
;;;977    
;;;978        SWJ_WriteMem32(DCRDR, val);
000008  480d              LDR      r0,|L20.64|
00000a  9901              LDR      r1,[sp,#4]
00000c  f7fffffe          BL       SWJ_WriteMem32
;;;979    
;;;980        SWJ_WriteMem32(DCRSR, n | REGWnR);
000010  f4443180          ORR      r1,r4,#0x10000
000014  480a              LDR      r0,|L20.64|
000016  1f00              SUBS     r0,r0,#4
000018  f7fffffe          BL       SWJ_WriteMem32
;;;981    
;;;982        // wait for S_REGRDY
;;;983        for(i = 0; i < timeout; i++)
00001c  bf00              NOP      
00001e  e00b              B        |L20.56|
                  |L20.32|
;;;984        {
;;;985            SWJ_ReadMem32(DHCSR, &val);
000020  a901              ADD      r1,sp,#4
000022  4807              LDR      r0,|L20.64|
000024  3808              SUBS     r0,r0,#8
000026  f7fffffe          BL       SWJ_ReadMem32
;;;986    
;;;987            if(val & S_REGRDY)
00002a  9801              LDR      r0,[sp,#4]
00002c  f4003080          AND      r0,r0,#0x10000
000030  b108              CBZ      r0,|L20.54|
;;;988            {
;;;989                return 0;
000032  2000              MOVS     r0,#0
                  |L20.52|
;;;990            }
;;;991        }
;;;992    
;;;993        return 1;
;;;994    }
000034  bd7c              POP      {r2-r6,pc}
                  |L20.54|
000036  1c6d              ADDS     r5,r5,#1              ;983
                  |L20.56|
000038  42b5              CMP      r5,r6                 ;983
00003a  dbf1              BLT      |L20.32|
00003c  2001              MOVS     r0,#1                 ;993
00003e  e7f9              B        |L20.52|
;;;995    /*******************************************************************************
                          ENDP

                  |L20.64|
                          DCD      0xe000edf8

                          AREA ||i.SWJ_WriteDP||, CODE, READONLY, ALIGN=1

                  SWJ_WriteDP PROC
;;;394    *******************************************************************************/
;;;395    unsigned char SWJ_WriteDP(unsigned char adr, unsigned long val)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;396    {
000004  4605              MOV      r5,r0
;;;397        unsigned long req;
;;;398        unsigned char ack;
;;;399        unsigned char err;
;;;400    
;;;401        req = SWD_REG_DP | SWD_REG_W | SWD_REG_ADR(adr);		//DP访问&写模式&adr
000006  f005060c          AND      r6,r5,#0xc
;;;402        ack = SWD_Transfer(req, &val);
00000a  a901              ADD      r1,sp,#4
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       SWD_Transfer
000012  4607              MOV      r7,r0
;;;403    
;;;404        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
000014  2f01              CMP      r7,#1
000016  d101              BNE      |L21.28|
000018  2400              MOVS     r4,#0
00001a  e000              B        |L21.30|
                  |L21.28|
00001c  2401              MOVS     r4,#1
                  |L21.30|
;;;405        return err;
00001e  4620              MOV      r0,r4
;;;406    }
000020  e8bd81fc          POP      {r2-r8,pc}
;;;407    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_WriteData||, CODE, READONLY, ALIGN=1

                  SWJ_WriteData PROC
;;;485    *******************************************************************************/
;;;486    static unsigned char SWJ_WriteData(unsigned long addr, unsigned long data)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;487    {
000004  4605              MOV      r5,r0
;;;488        unsigned char req, ack, err;
;;;489    
;;;490        SWJ_WriteAP(AP_TAR, addr);
000006  4629              MOV      r1,r5
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       SWJ_WriteAP
;;;491    
;;;492        /* write data */
;;;493        req = SWD_REG_AP | SWD_REG_W | AP_DRW;
00000e  260d              MOVS     r6,#0xd
;;;494        ack = SWD_Transfer(req, &data);
000010  a901              ADD      r1,sp,#4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SWD_Transfer
000018  4607              MOV      r7,r0
;;;495    
;;;496        /* read DP buff */
;;;497        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
00001a  260e              MOVS     r6,#0xe
;;;498        ack = SWD_Transfer(req, NULL);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SWD_Transfer
000024  4607              MOV      r7,r0
;;;499    
;;;500        (ack == DAP_TRANSFER_OK) ? (err = 0) : (err = 1);
000026  2f01              CMP      r7,#1
000028  d101              BNE      |L22.46|
00002a  2400              MOVS     r4,#0
00002c  e000              B        |L22.48|
                  |L22.46|
00002e  2401              MOVS     r4,#1
                  |L22.48|
;;;501        return err;
000030  4620              MOV      r0,r4
;;;502    }
000032  e8bd81fc          POP      {r2-r8,pc}
;;;503    /*******************************************************************************
                          ENDP


                          AREA ||i.SWJ_WriteMem||, CODE, READONLY, ALIGN=1

                  SWJ_WriteMem PROC
;;;872    //1故障 0正常
;;;873    unsigned char SWJ_WriteMem(unsigned long addr, unsigned char *buf, unsigned long len)
000000  b570              PUSH     {r4-r6,lr}
;;;874    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;875        return swd_write_memory(addr, buf, len);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       swd_write_memory
;;;876    }
000012  bd70              POP      {r4-r6,pc}
;;;877    
                          ENDP


                          AREA ||i.SWJ_WriteMem32||, CODE, READONLY, ALIGN=2

                  SWJ_WriteMem32 PROC
;;;535    //1故障 0正常
;;;536    unsigned char SWJ_WriteMem32(unsigned long addr, unsigned long val)
000000  b570              PUSH     {r4-r6,lr}
;;;537    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;538        unsigned char err;
;;;539    
;;;540        SWJ_WriteAP(AP_CSW, CSW_VALUE | CSW_SIZE32);
000006  4905              LDR      r1,|L24.28|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SWJ_WriteAP
;;;541        err = SWJ_WriteData(addr, val);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SWJ_WriteData
000016  4606              MOV      r6,r0
;;;542        return err;
000018  4630              MOV      r0,r6
;;;543    }
00001a  bd70              POP      {r4-r6,pc}
;;;544    
                          ENDP

                  |L24.28|
                          DCD      0x23000052

                          AREA ||i.SWJ_WriteMem8||, CODE, READONLY, ALIGN=2

                  SWJ_WriteMem8 PROC
;;;513    //1故障 0正常
;;;514    static unsigned char SWJ_WriteMem8(unsigned long addr, unsigned char val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;515    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;516        unsigned long tmp;
;;;517        unsigned char err;
;;;518    
;;;519        SWJ_WriteAP(AP_CSW, CSW_VALUE | CSW_SIZE8);
000008  4907              LDR      r1,|L25.40|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       SWJ_WriteAP
;;;520    
;;;521        tmp = val << ((addr & 0x03) << 3);
000010  07a0              LSLS     r0,r4,#30
000012  0ec0              LSRS     r0,r0,#27
000014  fa05f600          LSL      r6,r5,r0
;;;522        err = SWJ_WriteData(addr, tmp);
000018  4631              MOV      r1,r6
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SWJ_WriteData
000020  4607              MOV      r7,r0
;;;523        return err;
000022  4638              MOV      r0,r7
;;;524    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;525    /*******************************************************************************
                          ENDP

                  |L25.40|
                          DCD      0x23000050

                          AREA ||i.softdelay||, CODE, READONLY, ALIGN=1

                  softdelay PROC
;;;1185   
;;;1186   void softdelay(unsigned long us)
000000  b50c              PUSH     {r2,r3,lr}
;;;1187   {
;;;1188       volatile unsigned long i, j;
;;;1189   
;;;1190       for(i = 0; i < us; i++)
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
000006  e00c              B        |L26.34|
                  |L26.8|
;;;1191       {
;;;1192           for(j = 0; j < 30U; j++)
000008  2100              MOVS     r1,#0
00000a  9100              STR      r1,[sp,#0]
00000c  e003              B        |L26.22|
                  |L26.14|
;;;1193           {
;;;1194               __nop();
00000e  bf00              NOP      
000010  9900              LDR      r1,[sp,#0]            ;1192
000012  1c49              ADDS     r1,r1,#1              ;1192
000014  9100              STR      r1,[sp,#0]            ;1192
                  |L26.22|
000016  9900              LDR      r1,[sp,#0]            ;1192
000018  291e              CMP      r1,#0x1e              ;1192
00001a  d3f8              BCC      |L26.14|
00001c  9901              LDR      r1,[sp,#4]            ;1190
00001e  1c49              ADDS     r1,r1,#1              ;1190
000020  9101              STR      r1,[sp,#4]            ;1190
                  |L26.34|
000022  9901              LDR      r1,[sp,#4]            ;1190
000024  4281              CMP      r1,r0                 ;1190
000026  d3ef              BCC      |L26.8|
;;;1195           }
;;;1196       }
;;;1197   }
000028  bd0c              POP      {r2,r3,pc}
;;;1198   unsigned long sss[10];
                          ENDP


                          AREA ||i.swd_flash_syscall_exec||, CODE, READONLY, ALIGN=1

                  swd_flash_syscall_exec PROC
;;;1088   //1故障 0正常
;;;1089   unsigned char swd_flash_syscall_exec(const FLASH_SYSCALL *sysCallParam, unsigned long entry, unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1090   {
000004  b091              SUB      sp,sp,#0x44
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9dd8918          LDRD     r8,r9,[sp,#0x60]
;;;1091       DEBUG_STATE state;
;;;1092   
;;;1093       // Call flash algorithm function on target and wait for result.
;;;1094       state.xpsr     = 0x01000000;          // xPSR: T = 1, ISR = 0
000012  f04f7080          MOV      r0,#0x1000000
000016  9010              STR      r0,[sp,#0x40]
;;;1095       state.r[0]     = arg1;                   // R0: Argument 1
000018  9600              STR      r6,[sp,#0]
;;;1096       state.r[1]     = arg2;                   // R1: Argument 2
00001a  9701              STR      r7,[sp,#4]
;;;1097       state.r[2]     = arg3;                   // R2: Argument 3
00001c  f8cd8008          STR      r8,[sp,#8]
;;;1098       state.r[3]     = arg4;                   // R3: Argument 4
000020  f8cd900c          STR      r9,[sp,#0xc]
;;;1099   
;;;1100       state.r[9]     = sysCallParam->static_base;    // SB: Static Base
000024  6860              LDR      r0,[r4,#4]
000026  9009              STR      r0,[sp,#0x24]
;;;1101   
;;;1102       state.r[13]    = sysCallParam->stack_pointer;  // SP: Stack Pointer
000028  68a0              LDR      r0,[r4,#8]
00002a  900d              STR      r0,[sp,#0x34]
;;;1103       state.r[14]    = sysCallParam->breakpoint;       // LR: Exit Point
00002c  6820              LDR      r0,[r4,#0]
00002e  900e              STR      r0,[sp,#0x38]
;;;1104       state.r[15]    = entry;                           // PC: Entry Point
000030  950f              STR      r5,[sp,#0x3c]
;;;1105   
;;;1106       if(swd_write_debug_state(&state))
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       swd_write_debug_state
000038  b118              CBZ      r0,|L27.66|
;;;1107       {
;;;1108           SWD_TRACE("swd_write_debug_status failed\r\n");
;;;1109           return 1;
00003a  2001              MOVS     r0,#1
                  |L27.60|
;;;1110       }
;;;1111   
;;;1112       if(SWJ_WaitUntilHalted())
;;;1113       {
;;;1114           SWD_TRACE("SWJ_WaitUntilHalted failed\r\n");
;;;1115           return 1;
;;;1116       }
;;;1117   
;;;1118       if(SWJ_ReadCoreReg(0, &state.r[0]))
;;;1119       {
;;;1120           SWD_TRACE("SWJ_ReadCoreReg failed\r\n");
;;;1121           return 1;
;;;1122       }
;;;1123   
;;;1124   
;;;1125       // Flash functions return 0 if successful.
;;;1126       if(state.r[0] != 0)
;;;1127       {
;;;1128           SWD_TRACE("resutlt failed:0x%X\r\n", state.r[0]);
;;;1129           return 1;
;;;1130       }
;;;1131   
;;;1132       return 0;
;;;1133   }
00003c  b011              ADD      sp,sp,#0x44
00003e  e8bd83f0          POP      {r4-r9,pc}
                  |L27.66|
000042  f7fffffe          BL       SWJ_WaitUntilHalted
000046  b108              CBZ      r0,|L27.76|
000048  2001              MOVS     r0,#1                 ;1115
00004a  e7f7              B        |L27.60|
                  |L27.76|
00004c  4669              MOV      r1,sp                 ;1118
00004e  2000              MOVS     r0,#0                 ;1118
000050  f7fffffe          BL       SWJ_ReadCoreReg
000054  b108              CBZ      r0,|L27.90|
000056  2001              MOVS     r0,#1                 ;1121
000058  e7f0              B        |L27.60|
                  |L27.90|
00005a  9800              LDR      r0,[sp,#0]            ;1126
00005c  b108              CBZ      r0,|L27.98|
00005e  2001              MOVS     r0,#1                 ;1129
000060  e7ec              B        |L27.60|
                  |L27.98|
000062  2000              MOVS     r0,#0                 ;1132
000064  e7ea              B        |L27.60|
;;;1134   /*******************************************************************************
                          ENDP


                          AREA ||i.swd_read_memory||, CODE, READONLY, ALIGN=1

                  swd_read_memory PROC
;;;801    //1故障 0正常
;;;802    unsigned char swd_read_memory(unsigned long address, unsigned char *data, unsigned long size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;803    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;804        unsigned long n;
;;;805    
;;;806        // Read bytes until word aligned
;;;807        while((size > 0) && (address & 0x3))
00000a  e006              B        |L28.26|
                  |L28.12|
;;;808        {
;;;809            SWJ_ReadMem8(address, data);
00000c  4639              MOV      r1,r7
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       SWJ_ReadMem8
;;;810            address++;
000014  1c6d              ADDS     r5,r5,#1
;;;811            data++;
000016  1c7f              ADDS     r7,r7,#1
;;;812            size--;
000018  1e64              SUBS     r4,r4,#1
                  |L28.26|
00001a  b11c              CBZ      r4,|L28.36|
00001c  f0050003          AND      r0,r5,#3              ;807
000020  2800              CMP      r0,#0                 ;807
000022  d1f3              BNE      |L28.12|
                  |L28.36|
;;;813        }
;;;814    
;;;815        // Read word aligned blocks
;;;816        while(size > 3)
000024  e013              B        |L28.78|
                  |L28.38|
;;;817        {
;;;818            // Limit to auto increment page size
;;;819            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000026  f3c50009          UBFX     r0,r5,#0,#10
00002a  f5c06680          RSB      r6,r0,#0x400
;;;820    
;;;821            if(size < n)
00002e  42b4              CMP      r4,r6
000030  d201              BCS      |L28.54|
;;;822            {
;;;823                n = size & 0xFFFFFFFC; // Only count complete words remaining
000032  f0240603          BIC      r6,r4,#3
                  |L28.54|
;;;824            }
;;;825    
;;;826            if(SWJ_ReadBlock(address, data, n))
000036  4632              MOV      r2,r6
000038  4639              MOV      r1,r7
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       SWJ_ReadBlock
000040  b110              CBZ      r0,|L28.72|
;;;827            {
;;;828                return 1;
000042  2001              MOVS     r0,#1
                  |L28.68|
;;;829            }
;;;830    
;;;831            address += n;
;;;832            data += n;
;;;833            size -= n;
;;;834        }
;;;835    
;;;836        // Read remaining bytes
;;;837        while(size > 0)
;;;838        {
;;;839            SWJ_ReadMem8(address, data);
;;;840            address++;
;;;841            data++;
;;;842            size--;
;;;843        }
;;;844    
;;;845        return 0;
;;;846    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L28.72|
000048  4435              ADD      r5,r5,r6              ;831
00004a  4437              ADD      r7,r7,r6              ;832
00004c  1ba4              SUBS     r4,r4,r6              ;833
                  |L28.78|
00004e  2c03              CMP      r4,#3                 ;816
000050  d8e9              BHI      |L28.38|
000052  e006              B        |L28.98|
                  |L28.84|
000054  4639              MOV      r1,r7                 ;839
000056  4628              MOV      r0,r5                 ;839
000058  f7fffffe          BL       SWJ_ReadMem8
00005c  1c6d              ADDS     r5,r5,#1              ;840
00005e  1c7f              ADDS     r7,r7,#1              ;841
000060  1e64              SUBS     r4,r4,#1              ;842
                  |L28.98|
000062  2c00              CMP      r4,#0                 ;837
000064  d1f6              BNE      |L28.84|
000066  2000              MOVS     r0,#0                 ;845
000068  e7ec              B        |L28.68|
;;;847    /*******************************************************************************
                          ENDP


                          AREA ||i.swd_write_debug_state||, CODE, READONLY, ALIGN=2

                  swd_write_debug_state PROC
;;;1041   //1故障 0正常
;;;1042   unsigned char swd_write_debug_state(DEBUG_STATE *state)
000000  b538              PUSH     {r3-r5,lr}
;;;1043   {
000002  4605              MOV      r5,r0
;;;1044       unsigned long i, status;
;;;1045   
;;;1046       SWJ_WriteDP(DP_SELECT, 0);
000004  2100              MOVS     r1,#0
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       SWJ_WriteDP
;;;1047   
;;;1048       // R0, R1, R2, R3
;;;1049       for(i = 0; i < 4; i++)
00000c  2400              MOVS     r4,#0
00000e  e005              B        |L29.28|
                  |L29.16|
;;;1050       {
;;;1051           SWJ_WriteCoreReg(i, state->r[i]);
000010  f8551024          LDR      r1,[r5,r4,LSL #2]
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SWJ_WriteCoreReg
00001a  1c64              ADDS     r4,r4,#1              ;1049
                  |L29.28|
00001c  2c04              CMP      r4,#4                 ;1049
00001e  d3f7              BCC      |L29.16|
;;;1052       }
;;;1053   
;;;1054       // R9
;;;1055       SWJ_WriteCoreReg(9, state->r[9]);
000020  2009              MOVS     r0,#9
000022  6a69              LDR      r1,[r5,#0x24]
000024  f7fffffe          BL       SWJ_WriteCoreReg
;;;1056   
;;;1057       // R13, R14, R15
;;;1058       for(i = 13; i < 16; i++)
000028  240d              MOVS     r4,#0xd
00002a  e005              B        |L29.56|
                  |L29.44|
;;;1059       {
;;;1060           SWJ_WriteCoreReg(i, state->r[i]);
00002c  f8551024          LDR      r1,[r5,r4,LSL #2]
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       SWJ_WriteCoreReg
000036  1c64              ADDS     r4,r4,#1              ;1058
                  |L29.56|
000038  2c10              CMP      r4,#0x10              ;1058
00003a  d3f7              BCC      |L29.44|
;;;1061       }
;;;1062   
;;;1063       // xPSR
;;;1064       SWJ_WriteCoreReg(16, state->xpsr);
00003c  2010              MOVS     r0,#0x10
00003e  6c29              LDR      r1,[r5,#0x40]
000040  f7fffffe          BL       SWJ_WriteCoreReg
;;;1065       SWJ_WriteMem32(DBG_HCSR, DBGKEY | C_DEBUGEN);
000044  4907              LDR      r1,|L29.100|
000046  4808              LDR      r0,|L29.104|
000048  f7fffffe          BL       SWJ_WriteMem32
;;;1066   
;;;1067       // check status
;;;1068       SWJ_ReadDP(DP_CTRL_STAT, &status);
00004c  4669              MOV      r1,sp
00004e  2004              MOVS     r0,#4
000050  f7fffffe          BL       SWJ_ReadDP
;;;1069   
;;;1070       if(status & (STICKYERR | WDATAERR))
000054  9800              LDR      r0,[sp,#0]
000056  f00000a0          AND      r0,r0,#0xa0
00005a  b108              CBZ      r0,|L29.96|
;;;1071       {
;;;1072           SWD_TRACE("write debug states failed\r\n");
;;;1073           return 1;
00005c  2001              MOVS     r0,#1
                  |L29.94|
;;;1074       }
;;;1075   
;;;1076       return 0;
;;;1077   }
00005e  bd38              POP      {r3-r5,pc}
                  |L29.96|
000060  2000              MOVS     r0,#0                 ;1076
000062  e7fc              B        |L29.94|
;;;1078   /*******************************************************************************
                          ENDP

                  |L29.100|
                          DCD      0xa05f0001
                  |L29.104|
                          DCD      0xe000edf0

                          AREA ||i.swd_write_memory||, CODE, READONLY, ALIGN=1

                  swd_write_memory PROC
;;;741    //1故障 0正常
;;;742    unsigned char swd_write_memory(unsigned long address, unsigned char *data, unsigned long size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;743    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;744        unsigned long n;
;;;745    
;;;746        // Write bytes until word aligned
;;;747        while((size > 0) && (address & 0x3))
00000a  e006              B        |L30.26|
                  |L30.12|
;;;748        {
;;;749            SWJ_WriteMem8(address, *data);
00000c  7831              LDRB     r1,[r6,#0]
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       SWJ_WriteMem8
;;;750            address++;
000014  1c6d              ADDS     r5,r5,#1
;;;751            data++;
000016  1c76              ADDS     r6,r6,#1
;;;752            size--;
000018  1e64              SUBS     r4,r4,#1
                  |L30.26|
00001a  b11c              CBZ      r4,|L30.36|
00001c  f0050003          AND      r0,r5,#3              ;747
000020  2800              CMP      r0,#0                 ;747
000022  d1f3              BNE      |L30.12|
                  |L30.36|
;;;753        }
;;;754    
;;;755        // Write word aligned blocks
;;;756        while(size > 3)
000024  e013              B        |L30.78|
                  |L30.38|
;;;757        {
;;;758            // Limit to auto increment page size
;;;759            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000026  f3c50009          UBFX     r0,r5,#0,#10
00002a  f5c06780          RSB      r7,r0,#0x400
;;;760    
;;;761            if(size < n)
00002e  42bc              CMP      r4,r7
000030  d201              BCS      |L30.54|
;;;762            {
;;;763                n = size & 0xFFFFFFFC; // Only count complete words remaining
000032  f0240703          BIC      r7,r4,#3
                  |L30.54|
;;;764            }
;;;765    
;;;766            if(SWJ_WriteBlock(address, data, n))
000036  463a              MOV      r2,r7
000038  4631              MOV      r1,r6
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       SWJ_WriteBlock
000040  b110              CBZ      r0,|L30.72|
;;;767            {
;;;768                SWD_TRACE("SWJ write block failed\r\n");
;;;769                return 1;
000042  2001              MOVS     r0,#1
                  |L30.68|
;;;770            }
;;;771    
;;;772            address += n;
;;;773            data += n;
;;;774            size -= n;
;;;775        }
;;;776    
;;;777        // Write remaining bytes
;;;778        while(size > 0)
;;;779        {
;;;780            SWJ_WriteMem8(address, *data);
;;;781    
;;;782            address++;
;;;783            data++;
;;;784            size--;
;;;785        }
;;;786    
;;;787        return 0;
;;;788    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L30.72|
000048  443d              ADD      r5,r5,r7              ;772
00004a  443e              ADD      r6,r6,r7              ;773
00004c  1be4              SUBS     r4,r4,r7              ;774
                  |L30.78|
00004e  2c03              CMP      r4,#3                 ;756
000050  d8e9              BHI      |L30.38|
000052  e006              B        |L30.98|
                  |L30.84|
000054  7831              LDRB     r1,[r6,#0]            ;780
000056  4628              MOV      r0,r5                 ;780
000058  f7fffffe          BL       SWJ_WriteMem8
00005c  1c6d              ADDS     r5,r5,#1              ;782
00005e  1c76              ADDS     r6,r6,#1              ;783
000060  1e64              SUBS     r4,r4,#1              ;784
                  |L30.98|
000062  2c00              CMP      r4,#0                 ;778
000064  d1f6              BNE      |L30.84|
000066  2000              MOVS     r0,#0                 ;787
000068  e7ec              B        |L30.68|
;;;789    /*******************************************************************************
                          ENDP


                          AREA ||i.test||, CODE, READONLY, ALIGN=2

                  test PROC
;;;1198   unsigned long sss[10];
;;;1199   void test(void)
000000  b508              PUSH     {r3,lr}
;;;1200   {
;;;1201   	unsigned long i = 10, val;
000002  240a              MOVS     r4,#0xa
;;;1202   	
;;;1203       SWDIO_SET_OUTPUT();		//SWDIO设置为输出
000004  f44f6180          MOV      r1,#0x400
000008  4811              LDR      r0,|L31.80|
00000a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1204       SWCLK_SET_OUTPUT();		//SWCLK设置为输出
00000e  f44f7100          MOV      r1,#0x200
000012  480f              LDR      r0,|L31.80|
000014  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1205   
;;;1206       SWCLK_CLR();
000018  f44f7000          MOV      r0,#0x200
00001c  490c              LDR      r1,|L31.80|
00001e  3114              ADDS     r1,r1,#0x14
000020  6008              STR      r0,[r1,#0]
;;;1207       SWDIO_SET();
000022  0040              LSLS     r0,r0,#1
000024  1f09              SUBS     r1,r1,#4
000026  6008              STR      r0,[r1,#0]
;;;1208   
;;;1209       
;;;1210       SWJ_InitDebug();
000028  f7fffffe          BL       SWJ_InitDebug
;;;1211   
;;;1212       while(i--)
00002c  e00a              B        |L31.68|
                  |L31.46|
;;;1213       {
;;;1214           SWJ_ReadDP(DP_IDCODE, &val);
00002e  4669              MOV      r1,sp
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       SWJ_ReadDP
;;;1215           sss[i] = val;
000036  4907              LDR      r1,|L31.84|
000038  9800              LDR      r0,[sp,#0]
00003a  f8410024          STR      r0,[r1,r4,LSL #2]
;;;1216   
;;;1217   
;;;1218           softdelay(100);
00003e  2064              MOVS     r0,#0x64
000040  f7fffffe          BL       softdelay
                  |L31.68|
000044  1e20              SUBS     r0,r4,#0              ;1212
000046  f1a40401          SUB      r4,r4,#1              ;1212
00004a  d1f0              BNE      |L31.46|
;;;1219           //SWJ_WriteAP(0XAA,0X55);
;;;1220           //SWJ_InitDebug();
;;;1221       }
;;;1222       while(1);
00004c  bf00              NOP      
                  |L31.78|
00004e  e7fe              B        |L31.78|
;;;1223   }
                          ENDP

                  |L31.80|
                          DCD      0x40010800
                  |L31.84|
                          DCD      ||sss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||sss||
                          %        40
