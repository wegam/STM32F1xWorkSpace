; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_usart.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_usart.crf ..\..\Driver\WOW\SCR\STM32_USART.C]
                          THUMB

                          AREA ||i.RS485_DMAPrintf||, CODE, READONLY, ALIGN=1

                  RS485_DMAPrintf PROC
;;;1583   *******************************************************************************/
;;;1584   u16	RS485_DMAPrintf(RS485Def *pRS485,const char *format,...)						//自定义printf串口DMA发送程序,后边的省略号就是可变参数
000000  b40f              PUSH     {r0-r3}
;;;1585   {
000002  b570              PUSH     {r4-r6,lr}
000004  b0c2              SUB      sp,sp,#0x108
000006  4605              MOV      r5,r0
;;;1586   		
;;;1587   //		va_list ap; 										//VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：#include <stdarg.h>,用于获取不确定个数的参数
;;;1588   //    static char string[ 256 ];			//定义数组，
;;;1589   //    va_start( ap, format );
;;;1590   //    vsprintf( string , format, ap );    
;;;1591   //    va_end( ap );
;;;1592   	
;;;1593   //8)**********将等发送缓冲区大小（数据个数）及缓冲区地址发给DMA开启发送
;;;1594   //8)**********DMA发送完成后注意应该释放缓冲区：free(USART_BUFFER);
;;;1595   //	if(DMAPrintf_Buffer!=NULL)
;;;1596   //	{
;;;1597   //		free(DMAPrintf_Buffer);						//释放动态空间
;;;1598   //	}
;;;1599   //	u8	*USART_BUFFER;
;;;1600   	//1)**********获取数据宽度
;;;1601   	u32 num=strlen((const char*)format);		//获取数据宽度
000008  9847              LDR      r0,[sp,#0x11c]
00000a  f7fffffe          BL       strlen
00000e  4606              MOV      r6,r0
;;;1602   	//2)**********定义缓冲区大小变量
;;;1603   	unsigned int BufferSize;
;;;1604   	unsigned char DMAPrintf_Buffer[256]={0};
000010  f44f7180          MOV      r1,#0x100
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       __aeabi_memclr4
;;;1605   	//3)**********args为定义的一个指向可变参数的变量，va_list以及下边要用到的va_start,va_end都是是在定义，可变参数函数中必须要用到宏， 在stdarg.h头文件中定义
;;;1606   	va_list args;  
;;;1607   	free(DMAPrintf_Buffer);						//释放动态空间
00001a  a802              ADD      r0,sp,#8
00001c  f7fffffe          BL       free
;;;1608   //	DMAPrintf_Buffer=NULL;
;;;1609   	//4)**********申请动态空间
;;;1610   //	DMAPrintf_Buffer = (char*)malloc(sizeof(char) * num);	
;;;1611   	//5)**********初始化args的函数，使其指向可变参数的第一个参数，format是可变参数的前一个参数
;;;1612   	va_start(args, format);
000020  a848              ADD      r0,sp,#0x120
000022  9001              STR      r0,[sp,#4]
;;;1613   	//6)**********正常情况下返回生成字串的长度(除去\0),错误情况返回负值
;;;1614   	BufferSize = vsprintf((char*)DMAPrintf_Buffer, format, args);
000024  a802              ADD      r0,sp,#8
000026  9a01              LDR      r2,[sp,#4]
000028  9947              LDR      r1,[sp,#0x11c]
00002a  f7fffffe          BL       __c89vsprintf
00002e  4604              MOV      r4,r0
;;;1615   	//7)**********结束可变参数的获取
;;;1616   	va_end(args); 
000030  2000              MOVS     r0,#0
000032  9001              STR      r0,[sp,#4]
;;;1617   	//8)**********将等发送缓冲区大小（数据个数）及缓冲区地址发给DMA开启发送
;;;1618   	//8)**********DMA发送完成后注意应该释放缓冲区：free(USART_BUFFER);
;;;1619   	BufferSize=RS485_DMASend(pRS485,(u8*)DMAPrintf_Buffer,BufferSize);	//RS485-DMA发送程序
000034  b2a2              UXTH     r2,r4
000036  a902              ADD      r1,sp,#8
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       RS485_DMASend
00003e  4604              MOV      r4,r0
;;;1620   	return BufferSize;			//返回发送数据大小
000040  4620              MOV      r0,r4
;;;1621   
;;;1622   }
000042  b042              ADD      sp,sp,#0x108
000044  bc70              POP      {r4-r6}
000046  f85dfb14          LDR      pc,[sp],#0x14
;;;1623   /*******************************************************************************
                          ENDP


                          AREA ||i.RS485_DMASend||, CODE, READONLY, ALIGN=1

                  RS485_DMASend PROC
;;;1628   *******************************************************************************/
;;;1629   u16 RS485_DMASend(
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1630   									RS485Def *pRS485,		//包含RS485选用的串口号和收发控制脚信息
;;;1631   									u8 *tx_buffer,								//待发送数据缓冲区地址
;;;1632   									u16 BufferSize								//设定发送数据大小
;;;1633   )		//RS485-DMA发送程序
;;;1634   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1635   	//----发送前检查相关串口发送状态，如果下在发送其它数据，则等待（返回0），否则清除相关标志位后开启发送
;;;1636   	
;;;1637   //	u32	DMA_status=0;			//DMA状态
;;;1638     unsigned short sendedlen  =0;
00000a  2700              MOVS     r7,#0
;;;1639   	USARTStatusDef	Status;
;;;1640   	USART_TypeDef* USARTx=pRS485->USARTx;
00000c  f8d48000          LDR      r8,[r4,#0]
;;;1641   	
;;;1642   	Status	=	USART_Status(USARTx);		//串口状态检查
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       USART_Status
000016  9000              STR      r0,[sp,#0]
;;;1643   	if(1  ==  Status.USART_IDLESTD)   //bit[0] 0-串口空闲；1-串口非空闲，状态根据以下位定义
000018  f89d0000          LDRB     r0,[sp,#0]
00001c  f0000001          AND      r0,r0,#1
000020  b110              CBZ      r0,|L2.40|
;;;1644   	{
;;;1645   		return BufferSize;
000022  4628              MOV      r0,r5
                  |L2.36|
;;;1646   	}
;;;1647   //	SysTick_DeleymS(1);				//SysTick延时nmS
;;;1648   	RS485_TX_EN(pRS485);
;;;1649   //	USART_DMASend	(USARTx,(u8*)tx_buffer,BufferSize);		//串口DMA发送程序
;;;1650   	sendedlen = USART_DMASend(USARTx,(u8*)tx_buffer,BufferSize);		//串口DMA发送程序
;;;1651   	return sendedlen;
;;;1652   }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L2.40|
000028  4620              MOV      r0,r4                 ;1648
00002a  f7fffffe          BL       RS485_TX_EN
00002e  462a              MOV      r2,r5                 ;1650
000030  4631              MOV      r1,r6                 ;1650
000032  4640              MOV      r0,r8                 ;1650
000034  f7fffffe          BL       USART_DMASend
000038  4607              MOV      r7,r0                 ;1650
00003a  4638              MOV      r0,r7                 ;1651
00003c  e7f2              B        |L2.36|
;;;1653   
                          ENDP


                          AREA ||i.RS485_DMA_ConfigurationNR||, CODE, READONLY, ALIGN=1

                  RS485_DMA_ConfigurationNR PROC
;;;1526   *******************************************************************************/
;;;1527   void	RS485_DMA_ConfigurationNR(
000000  b570              PUSH     {r4-r6,lr}
;;;1528   																RS485Def *pRS485,	//包含RS485选用的串口号和收发控制脚信息
;;;1529   																u32 USART_BaudRate,					//波特率
;;;1530   																u16 BufferSize							//设定接收缓冲区大小
;;;1531   )	//USART_DMA配置--查询方式，不开中断,配置完默认为接收状态
;;;1532   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1533     GPIO_Configuration_OPP50	(pRS485->RS485_CTL_PORT,pRS485->RS485_CTL_Pin);			//将GPIO相应管脚配置为APP(复用推挽)输出模式，最大速度50MHz----V20170605
000008  8921              LDRH     r1,[r4,#8]
00000a  6860              LDR      r0,[r4,#4]
00000c  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1534   	pRS485->RS485_CTL_PORT->BRR 		= pRS485->RS485_CTL_Pin;				//RS485接收开启
000010  8920              LDRH     r0,[r4,#8]
000012  6861              LDR      r1,[r4,#4]
000014  6148              STR      r0,[r1,#0x14]
;;;1535   	USART_DMA_ConfigurationNR	(pRS485->USARTx,USART_BaudRate,BufferSize);		//USART_DMA配置--查询方式，不开中断
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       USART_DMA_ConfigurationNR
;;;1536   	GPIO_Configuration_OPP50	(pRS485->RS485_CTL_PORT,pRS485->RS485_CTL_Pin);			//将GPIO相应管脚配置为APP(复用推挽)输出模式，最大速度50MHz----V20170605
000020  8921              LDRH     r1,[r4,#8]
000022  6860              LDR      r0,[r4,#4]
000024  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1537   	pRS485->RS485_CTL_PORT->BRR 		= pRS485->RS485_CTL_Pin;				//RS485接收开启
000028  8920              LDRH     r0,[r4,#8]
00002a  6861              LDR      r1,[r4,#4]
00002c  6148              STR      r0,[r1,#0x14]
;;;1538   }
00002e  bd70              POP      {r4-r6,pc}
;;;1539   /*******************************************************************************
                          ENDP


                          AREA ||i.RS485_DMA_ConfigurationNRRemap||, CODE, READONLY, ALIGN=1

                  RS485_DMA_ConfigurationNRRemap PROC
;;;1544   *******************************************************************************/
;;;1545   void	RS485_DMA_ConfigurationNRRemap(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1546   																RS485Def *pRS485,	//包含RS485选用的串口号和收发控制脚信息
;;;1547   																u32 USART_BaudRate,					//波特率
;;;1548   																u32 *RXDBuffer,							//接收缓冲区地址::发送缓冲区地址在发送数据时设定，串口配置时借用接收缓冲区地址
;;;1549   																u32 BufferSize							//设定接收缓冲区大小
;;;1550   )	//USART_DMA配置--查询方式，不开中断,配置完默认为接收状态
;;;1551   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1552   	USART_DMA_ConfigurationNRRemap	(pRS485->USARTx,USART_BaudRate,RXDBuffer,BufferSize);		//USART_DMA配置--查询方式，不开中断
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USART_DMA_ConfigurationNRRemap
;;;1553   	GPIO_Configuration_OPP50				(pRS485->RS485_CTL_PORT,pRS485->RS485_CTL_Pin);			//将GPIO相应管脚配置为APP(复用推挽)输出模式，最大速度50MHz----V20170605
000018  8921              LDRH     r1,[r4,#8]
00001a  6860              LDR      r0,[r4,#4]
00001c  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1554   	pRS485->RS485_CTL_PORT->BRR 		= pRS485->RS485_CTL_Pin;				//RS485接收开启
000020  8920              LDRH     r0,[r4,#8]
000022  6861              LDR      r1,[r4,#4]
000024  6148              STR      r0,[r1,#0x14]
;;;1555   }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;1556   /*******************************************************************************
                          ENDP


                          AREA ||i.RS485_RX_EN||, CODE, READONLY, ALIGN=1

                  RS485_RX_EN PROC
;;;1515   *******************************************************************************/
;;;1516   void RS485_RX_EN(RS485Def *pRS485)
000000  8901              LDRH     r1,[r0,#8]
;;;1517   {
;;;1518   	pRS485->RS485_CTL_PORT->BRR 		= pRS485->RS485_CTL_Pin;	
000002  6842              LDR      r2,[r0,#4]
000004  6151              STR      r1,[r2,#0x14]
;;;1519   }
000006  4770              BX       lr
;;;1520   
                          ENDP


                          AREA ||i.RS485_ReadBufferIDLE||, CODE, READONLY, ALIGN=1

                  RS485_ReadBufferIDLE PROC
;;;1561   *******************************************************************************/
;;;1562   u16	RS485_ReadBufferIDLE(
000000  b5f8              PUSH     {r3-r7,lr}
;;;1563   												RS485Def *pRS485,	//包含RS485选用的串口号和收发控制脚信息
;;;1564   												u8 *RevBuffer								//数据保存缓冲区地址，如果串口的接收到数据，将数据拷贝到RevBuffer
;;;1565   )	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer，
;;;1566   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1567   	u16 length=0;
000006  2600              MOVS     r6,#0
;;;1568   	USARTStatusDef	Status;
;;;1569   	Status	=	USART_Status(pRS485->USARTx);		//串口状态检查	
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_Status
00000e  9000              STR      r0,[sp,#0]
;;;1570   	if(0  ==  Status.USART_IDLESTD)		//bit[0] 0-串口空闲；1-串口非空闲，状态根据以下位定义
000010  f89d0000          LDRB     r0,[sp,#0]
000014  f0000001          AND      r0,r0,#1
000018  b938              CBNZ     r0,|L6.42|
;;;1571   	{
;;;1572   		RS485_RX_EN(pRS485);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RS485_RX_EN
;;;1573   		length=USART_ReadBufferIDLE(pRS485->USARTx,RevBuffer);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
000020  4629              MOV      r1,r5
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       USART_ReadBufferIDLE
000028  4606              MOV      r6,r0
                  |L6.42|
;;;1574   	}
;;;1575   	return length;
00002a  4630              MOV      r0,r6
;;;1576   }
00002c  bdf8              POP      {r3-r7,pc}
;;;1577   
                          ENDP


                          AREA ||i.RS485_TX_EN||, CODE, READONLY, ALIGN=1

                  RS485_TX_EN PROC
;;;1504   *******************************************************************************/
;;;1505   void RS485_TX_EN(RS485Def *pRS485)
000000  8901              LDRH     r1,[r0,#8]
;;;1506   {
;;;1507   	pRS485->RS485_CTL_PORT->BSRR		= pRS485->RS485_CTL_Pin;
000002  6842              LDR      r2,[r0,#4]
000004  6111              STR      r1,[r2,#0x10]
;;;1508   //	GPIO_SetBits(RS485_Info->RS485_CTL_PORT,RS485_Info->RS485_CTL_Pin);
;;;1509   }
000006  4770              BX       lr
;;;1510   /*******************************************************************************
                          ENDP


                          AREA ||i.UART5ReceiveData||, CODE, READONLY, ALIGN=2

                  UART5ReceiveData PROC
;;;2043   *******************************************************************************/
;;;2044   unsigned char UART5ReceiveData(unsigned char* RecByte)			//串口5读数据,返回0-无中断，返回1有中断无数据（发送中断），返回2-有中断有接收到数据
000000  b510              PUSH     {r4,lr}
;;;2045   {
000002  4604              MOV      r4,r0
;;;2046   	//==============================Port5
;;;2047   	if(USART_GetITStatus(UART5, USART_IT_RXNE))
000004  f2405125          MOV      r1,#0x525
000008  480e              LDR      r0,|L8.68|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b150              CBZ      r0,|L8.38|
;;;2048     {
;;;2049   		*RecByte	=	USART_ReceiveData(UART5);
000010  480c              LDR      r0,|L8.68|
000012  f7fffffe          BL       USART_ReceiveData
000016  7020              STRB     r0,[r4,#0]
;;;2050   	
;;;2051   		USART_ClearITPendingBit(UART5, USART_IT_RXNE);
000018  f2405125          MOV      r1,#0x525
00001c  4809              LDR      r0,|L8.68|
00001e  f7fffffe          BL       USART_ClearITPendingBit
;;;2052   		return 2;
000022  2002              MOVS     r0,#2
                  |L8.36|
;;;2053   	}
;;;2054   	else if(USART_GetITStatus(UART5, USART_IT_TC))
;;;2055     {   
;;;2056       USART_ClearITPendingBit(UART5, USART_IT_TC);
;;;2057   		return 1;
;;;2058     }
;;;2059   	return 0;
;;;2060   }
000024  bd10              POP      {r4,pc}
                  |L8.38|
000026  f2406126          MOV      r1,#0x626             ;2054
00002a  4806              LDR      r0,|L8.68|
00002c  f7fffffe          BL       USART_GetITStatus
000030  b130              CBZ      r0,|L8.64|
000032  f2406126          MOV      r1,#0x626             ;2056
000036  4803              LDR      r0,|L8.68|
000038  f7fffffe          BL       USART_ClearITPendingBit
00003c  2001              MOVS     r0,#1                 ;2057
00003e  e7f1              B        |L8.36|
                  |L8.64|
000040  2000              MOVS     r0,#0                 ;2059
000042  e7ef              B        |L8.36|
;;;2061   
                          ENDP

                  |L8.68|
                          DCD      0x40005000

                          AREA ||i.USART_ConfigurationIT||, CODE, READONLY, ALIGN=2

                  USART_ConfigurationIT PROC
;;;1665   *******************************************************************************/
;;;1666   void	USART_ConfigurationIT(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1667   																USART_TypeDef* USARTx,			//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;1668   																u32 USART_BaudRate,					//波特率
;;;1669   																u8 PreemptionPriority,			//中断优先级
;;;1670   																u8 SubPriority							//抢占优先级
;;;1671   )	//USART_DMA配置--查询方式，不开中断--奇校验
;;;1672   {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;1673   	//1)**********定义变量	
;;;1674   
;;;1675   	NVIC_InitTypeDef NVIC_InitStructure;
;;;1676   	USART_InitTypeDef USART_InitStructure;				//USART结构体	
;;;1677   	GPIO_InitTypeDef GPIO_InitStructure;					//GPIO结构体
;;;1678   
;;;1679   	
;;;1680   	u16 TXD_Pin=0;																//串口发送脚
00000e  f04f0800          MOV      r8,#0
;;;1681   	u16 RXD_Pin=0;																//串口接收脚
000012  46c1              MOV      r9,r8
;;;1682   	GPIO_TypeDef* GPIO_TX=0;
000014  46c2              MOV      r10,r8
;;;1683   	GPIO_TypeDef* GPIO_RX=0;
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
;;;1684   	
;;;1685   	u8 USARTx_IRQChannel=0;
00001a  4683              MOV      r11,r0
;;;1686   	//2)******************************配置相关GPIO/串口时钟打开
;;;1687   	//2.1)**********USART1
;;;1688   	if(USARTx==USART1)
00001c  4867              LDR      r0,|L9.444|
00001e  4284              CMP      r4,r0
000020  d116              BNE      |L9.80|
;;;1689   	{
;;;1690   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);				//关闭AFIO时钟,为关闭JTAG功能
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1691   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
00002a  2101              MOVS     r1,#1
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1692   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//USART1时钟开启
000032  2101              MOVS     r1,#1
000034  0388              LSLS     r0,r1,#14
000036  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1693   		
;;;1694   		TXD_Pin=GPIO_Pin_9;											//USART1-TX>PA9
00003a  f44f7800          MOV      r8,#0x200
;;;1695   		RXD_Pin=GPIO_Pin_10;										//USART1-RX>PA10
00003e  f44f6980          MOV      r9,#0x400
;;;1696   		
;;;1697   		GPIO_TX=GPIOA;
000042  f8dfa17c          LDR      r10,|L9.448|
;;;1698   		GPIO_RX=GPIOA;
000046  4650              MOV      r0,r10
000048  9000              STR      r0,[sp,#0]
;;;1699   		
;;;1700   		USARTx_IRQChannel=USART1_IRQChannel;		//中断
00004a  f04f0b25          MOV      r11,#0x25
00004e  e072              B        |L9.310|
                  |L9.80|
;;;1701   		
;;;1702   
;;;1703   	}
;;;1704   	//2.2)**********USART2
;;;1705   	else if(USARTx==USART2)
000050  485c              LDR      r0,|L9.452|
000052  4284              CMP      r4,r0
000054  d116              BNE      |L9.132|
;;;1706   	{
;;;1707   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);				//关闭AFIO时钟,为关闭JTAG功能
000056  2101              MOVS     r1,#1
000058  4608              MOV      r0,r1
00005a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1708   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
00005e  2101              MOVS     r1,#1
000060  2004              MOVS     r0,#4
000062  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1709   		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	//USART1时钟开启
000066  2101              MOVS     r1,#1
000068  0448              LSLS     r0,r1,#17
00006a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1710   		
;;;1711   		TXD_Pin=GPIO_Pin_2;		//USART2-TX>PA2
00006e  f04f0804          MOV      r8,#4
;;;1712   		RXD_Pin=GPIO_Pin_3;		//USART2-RX>PA3
000072  f04f0908          MOV      r9,#8
;;;1713   		
;;;1714   		GPIO_TX=GPIOA;
000076  f8dfa148          LDR      r10,|L9.448|
;;;1715   		GPIO_RX=GPIOA;
00007a  4650              MOV      r0,r10
00007c  9000              STR      r0,[sp,#0]
;;;1716   		
;;;1717   		USARTx_IRQChannel=USART2_IRQChannel;		//中断
00007e  f04f0b26          MOV      r11,#0x26
000082  e058              B        |L9.310|
                  |L9.132|
;;;1718   	}
;;;1719   	//2.3)**********USART3
;;;1720   	else if(USARTx==USART3)
000084  4850              LDR      r0,|L9.456|
000086  4284              CMP      r4,r0
000088  d11a              BNE      |L9.192|
;;;1721   	{
;;;1722   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);				//关闭AFIO时钟,为关闭JTAG功能
00008a  2101              MOVS     r1,#1
00008c  4608              MOV      r0,r1
00008e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1723   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
000092  2101              MOVS     r1,#1
000094  2008              MOVS     r0,#8
000096  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1724   		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);	//USART1时钟开启
00009a  2101              MOVS     r1,#1
00009c  0488              LSLS     r0,r1,#18
00009e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1725   		GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  //关闭JTAG功能
0000a2  2101              MOVS     r1,#1
0000a4  4849              LDR      r0,|L9.460|
0000a6  f7fffffe          BL       GPIO_PinRemapConfig
;;;1726   		
;;;1727   		TXD_Pin=GPIO_Pin_10;	//USART3-TX>PB10
0000aa  f44f6880          MOV      r8,#0x400
;;;1728   		RXD_Pin=GPIO_Pin_11;	//USART3-RX>PB11
0000ae  f44f6900          MOV      r9,#0x800
;;;1729   		
;;;1730   		GPIO_TX=GPIOB;
0000b2  f8dfa11c          LDR      r10,|L9.464|
;;;1731   		GPIO_RX=GPIOB;
0000b6  4650              MOV      r0,r10
0000b8  9000              STR      r0,[sp,#0]
;;;1732   		
;;;1733   		USARTx_IRQChannel=USART3_IRQChannel;		//中断
0000ba  f04f0b27          MOV      r11,#0x27
0000be  e03a              B        |L9.310|
                  |L9.192|
;;;1734   	}
;;;1735   	//2.4)**********USART4
;;;1736   	else if(USARTx==UART4)
0000c0  4844              LDR      r0,|L9.468|
0000c2  4284              CMP      r4,r0
0000c4  d116              BNE      |L9.244|
;;;1737   	{
;;;1738   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
0000c6  2101              MOVS     r1,#1
0000c8  4608              MOV      r0,r1
0000ca  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1739   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
0000ce  2101              MOVS     r1,#1
0000d0  2010              MOVS     r0,#0x10
0000d2  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1740   		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);	//USART1时钟开启
0000d6  2101              MOVS     r1,#1
0000d8  04c8              LSLS     r0,r1,#19
0000da  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1741   		
;;;1742   		TXD_Pin=GPIO_Pin_10;	//USART1-TX>PC10
0000de  f44f6880          MOV      r8,#0x400
;;;1743   		RXD_Pin=GPIO_Pin_11;	//USART1-RX>PC11
0000e2  f44f6900          MOV      r9,#0x800
;;;1744   		
;;;1745   		GPIO_TX=GPIOC;
0000e6  f8dfa0f0          LDR      r10,|L9.472|
;;;1746   		GPIO_RX=GPIOC;
0000ea  4650              MOV      r0,r10
0000ec  9000              STR      r0,[sp,#0]
;;;1747   		
;;;1748   		USARTx_IRQChannel=UART4_IRQChannel;		//中断
0000ee  f04f0b34          MOV      r11,#0x34
0000f2  e020              B        |L9.310|
                  |L9.244|
;;;1749   		
;;;1750   	}
;;;1751   	//2.5)**********USART5
;;;1752   	else if(USARTx==UART5)
0000f4  4839              LDR      r0,|L9.476|
0000f6  4284              CMP      r4,r0
0000f8  d11d              BNE      |L9.310|
;;;1753   	{
;;;1754   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
0000fa  2101              MOVS     r1,#1
0000fc  4608              MOV      r0,r1
0000fe  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1755   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
000102  2101              MOVS     r1,#1
000104  2010              MOVS     r0,#0x10
000106  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1756   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);
00010a  2101              MOVS     r1,#1
00010c  2020              MOVS     r0,#0x20
00010e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1757   		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
000112  2101              MOVS     r1,#1
000114  4608              MOV      r0,r1
000116  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1758   		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);	//USART1时钟开启
00011a  2101              MOVS     r1,#1
00011c  0508              LSLS     r0,r1,#20
00011e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1759   		
;;;1760   		TXD_Pin=GPIO_Pin_12;	//USART1-TX>PC12
000122  f44f5880          MOV      r8,#0x1000
;;;1761   		RXD_Pin=GPIO_Pin_2;		//USART1-RX>PD2
000126  f04f0904          MOV      r9,#4
;;;1762   		
;;;1763   		GPIO_TX=GPIOC;
00012a  f8dfa0ac          LDR      r10,|L9.472|
;;;1764   		GPIO_RX=GPIOD;
00012e  482c              LDR      r0,|L9.480|
000130  9000              STR      r0,[sp,#0]
;;;1765   		
;;;1766   		USARTx_IRQChannel=UART5_IRQChannel;		//中断		
000132  f04f0b35          MOV      r11,#0x35
                  |L9.310|
;;;1767   	}
;;;1768   	
;;;1769   //	/* Configure the NVIC Preemption Priority Bits */  
;;;1770   //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
;;;1771   	/* Enable the USART2 Interrupt */
;;;1772     NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQChannel;
000136  f88db018          STRB     r11,[sp,#0x18]
;;;1773   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority	=	PreemptionPriority;			//中断优先级
00013a  f88d6019          STRB     r6,[sp,#0x19]
;;;1774     NVIC_InitStructure.NVIC_IRQChannelSubPriority = SubPriority;										//抢占优先级
00013e  f88d701a          STRB     r7,[sp,#0x1a]
;;;1775     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000142  2001              MOVS     r0,#1
000144  f88d001b          STRB     r0,[sp,#0x1b]
;;;1776     NVIC_Init(&NVIC_InitStructure);
000148  a806              ADD      r0,sp,#0x18
00014a  f7fffffe          BL       NVIC_Init
;;;1777   	
;;;1778   	//3)**********初始化串口
;;;1779   	//3.1)**********初始化TXD引脚
;;;1780   	GPIO_InitStructure.GPIO_Pin = TXD_Pin;
00014e  f8ad8004          STRH     r8,[sp,#4]
;;;1781   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000152  2018              MOVS     r0,#0x18
000154  f88d0007          STRB     r0,[sp,#7]
;;;1782   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000158  2003              MOVS     r0,#3
00015a  f88d0006          STRB     r0,[sp,#6]
;;;1783   	GPIO_Init(GPIO_TX,&GPIO_InitStructure);
00015e  a901              ADD      r1,sp,#4
000160  4650              MOV      r0,r10
000162  f7fffffe          BL       GPIO_Init
;;;1784   
;;;1785   	//3.2)**********初始化RXD引脚
;;;1786   	GPIO_InitStructure.GPIO_Pin = RXD_Pin;
000166  f8ad9004          STRH     r9,[sp,#4]
;;;1787   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;							//上拉输入
00016a  2004              MOVS     r0,#4
00016c  f88d0007          STRB     r0,[sp,#7]
;;;1788   	GPIO_Init(GPIO_RX,&GPIO_InitStructure);
000170  a901              ADD      r1,sp,#4
000172  9800              LDR      r0,[sp,#0]
000174  f7fffffe          BL       GPIO_Init
;;;1789   	
;;;1790   	//3.3)**********初始化串口参数
;;;1791   	USART_DeInit(USARTx);
000178  4620              MOV      r0,r4
00017a  f7fffffe          BL       USART_DeInit
;;;1792   	USART_InitStructure.USART_BaudRate = USART_BaudRate; 					//波特率
00017e  9502              STR      r5,[sp,#8]
;;;1793   	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//数据位
000180  2000              MOVS     r0,#0
000182  f8ad000c          STRH     r0,[sp,#0xc]
;;;1794   	USART_InitStructure.USART_StopBits = USART_StopBits_1;				//停止位
000186  f8ad000e          STRH     r0,[sp,#0xe]
;;;1795   	USART_InitStructure.USART_Parity = USART_Parity_No ; 					//奇偶校验
00018a  f8ad0010          STRH     r0,[sp,#0x10]
;;;1796   	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00018e  200c              MOVS     r0,#0xc
000190  f8ad0012          STRH     r0,[sp,#0x12]
;;;1797   	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//流控
000194  2000              MOVS     r0,#0
000196  f8ad0014          STRH     r0,[sp,#0x14]
;;;1798   	USART_Init(USARTx, &USART_InitStructure);											//初始化串口
00019a  a902              ADD      r1,sp,#8
00019c  4620              MOV      r0,r4
00019e  f7fffffe          BL       USART_Init
;;;1799   	
;;;1800   	
;;;1801   	
;;;1802   	
;;;1803   	
;;;1804   
;;;1805   	/* Enable USART1 Receive and Transmit interrupts */
;;;1806     USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
0001a2  2201              MOVS     r2,#1
0001a4  f2405125          MOV      r1,#0x525
0001a8  4620              MOV      r0,r4
0001aa  f7fffffe          BL       USART_ITConfig
;;;1807   //  USART_ITConfig(USARTx, USART_IT_TXE, ENABLE);
;;;1808   //	USART_ITConfig(USARTx, USART_IT_TC, ENABLE);
;;;1809   	
;;;1810   //	USART_ClearITPendingBit(USARTx, USART_IT_RXNE);
;;;1811   //	USART_ClearITPendingBit(USARTx, USART_IT_TC);
;;;1812   	
;;;1813   	USART_Cmd(USARTx, ENABLE);
0001ae  2101              MOVS     r1,#1
0001b0  4620              MOV      r0,r4
0001b2  f7fffffe          BL       USART_Cmd
;;;1814   
;;;1815   }
0001b6  b007              ADD      sp,sp,#0x1c
0001b8  e8bd8ff0          POP      {r4-r11,pc}
;;;1816   /*******************************************************************************
                          ENDP

                  |L9.444|
                          DCD      0x40013800
                  |L9.448|
                          DCD      0x40010800
                  |L9.452|
                          DCD      0x40004400
                  |L9.456|
                          DCD      0x40004800
                  |L9.460|
                          DCD      0x00300200
                  |L9.464|
                          DCD      0x40010c00
                  |L9.468|
                          DCD      0x40004c00
                  |L9.472|
                          DCD      0x40011000
                  |L9.476|
                          DCD      0x40005000
                  |L9.480|
                          DCD      0x40011400

                          AREA ||i.USART_DMAPrintf||, CODE, READONLY, ALIGN=1

                  USART_DMAPrintf PROC
;;;896    *******************************************************************************/
;;;897    u16 USART_DMAPrintf(USART_TypeDef* USARTx,const char *format,...)		//后边的省略号就是可变参数
000000  b40f              PUSH     {r0-r3}
;;;898    {
000002  b530              PUSH     {r4,r5,lr}
000004  b0c1              SUB      sp,sp,#0x104
000006  4605              MOV      r5,r0
;;;899    	
;;;900    //		va_list ap; 										//VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：#include <stdarg.h>,用于获取不确定个数的参数
;;;901    //    static char string[ 256 ];			//定义数组，
;;;902    //    va_start( ap, format );
;;;903    //    vsprintf( string , format, ap );    
;;;904    //    va_end( ap );
;;;905    	
;;;906    	
;;;907    //8)**********将等发送缓冲区大小（数据个数）及缓冲区地址发给DMA开启发送
;;;908    //8)**********DMA发送完成后注意应该释放缓冲区：free(USART_BUFFER);
;;;909    //	if(DMAPrintf_Buffer!=NULL)
;;;910    //	{
;;;911    //		free(DMAPrintf_Buffer);						//释放动态空间
;;;912    //	}
;;;913    //	u8	*USART_BUFFER;
;;;914    	//1)**********获取数据宽度
;;;915    //	u32 num=strlen((const char*)format);		//获取数据宽度
;;;916    	//2)**********定义缓冲区大小变量
;;;917    	unsigned int BufferSize=0;
000008  2400              MOVS     r4,#0
;;;918    	unsigned char DMAPrintf_Buffer[256]={0};
00000a  f44f7180          MOV      r1,#0x100
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;919    	//3)**********args为定义的一个指向可变参数的变量，va_list以及下边要用到的va_start,va_end都是是在定义，可变参数函数中必须要用到宏， 在stdarg.h头文件中定义
;;;920    	va_list args;  
;;;921    //	free(DMAPrintf_Buffer);						//释放动态空间
;;;922    //	DMAPrintf_Buffer=NULL;
;;;923    	//4)**********申请动态空间
;;;924    //	DMAPrintf_Buffer = (char*)malloc(sizeof(char) * num);	
;;;925    	//5)**********初始化args的函数，使其指向可变参数的第一个参数，format是可变参数的前一个参数
;;;926    	va_start(args, format);
000014  a846              ADD      r0,sp,#0x118
000016  9000              STR      r0,[sp,#0]
;;;927    	//6)**********正常情况下返回生成字串的长度(除去\0),错误情况返回负值
;;;928    	BufferSize = vsprintf((char*)DMAPrintf_Buffer, format, args);
000018  a801              ADD      r0,sp,#4
00001a  9a00              LDR      r2,[sp,#0]
00001c  9945              LDR      r1,[sp,#0x114]
00001e  f7fffffe          BL       __c89vsprintf
000022  4604              MOV      r4,r0
;;;929    	//7)**********结束可变参数的获取
;;;930    	va_end(args); 
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;931    	//8)**********将等发送缓冲区大小（数据个数）及缓冲区地址发给DMA开启发送
;;;932    	//8)**********DMA发送完成后注意应该释放缓冲区：free(USART_BUFFER);
;;;933    
;;;934      BufferSize=USART_DMASend(USARTx,(u8*)DMAPrintf_Buffer,BufferSize);	//串口DMA发送程序
000028  b2a2              UXTH     r2,r4
00002a  a901              ADD      r1,sp,#4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       USART_DMASend
000032  4604              MOV      r4,r0
;;;935    
;;;936    	return BufferSize;			//返回发送数据大小
000034  4620              MOV      r0,r4
;;;937    }
000036  b041              ADD      sp,sp,#0x104
000038  bc30              POP      {r4,r5}
00003a  f85dfb14          LDR      pc,[sp],#0x14
;;;938    /*******************************************************************************
                          ENDP


                          AREA ||i.USART_DMAPrintfList||, CODE, READONLY, ALIGN=1

                  USART_DMAPrintfList PROC
;;;947    *******************************************************************************/
;;;948    u16 USART_DMAPrintfList(USART_TypeDef* USARTx,const char *format,...)		//后边的省略号就是可变参数
000000  b40f              PUSH     {r0-r3}
;;;949    {
000002  b530              PUSH     {r4,r5,lr}
000004  b0c1              SUB      sp,sp,#0x104
000006  4605              MOV      r5,r0
;;;950    	
;;;951    //		va_list ap; 										//VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：#include <stdarg.h>,用于获取不确定个数的参数
;;;952    //    static char string[ 256 ];			//定义数组，
;;;953    //    va_start( ap, format );
;;;954    //    vsprintf( string , format, ap );    
;;;955    //    va_end( ap );
;;;956    	
;;;957    
;;;958    	//1)**********获取数据宽度
;;;959    	//2)**********定义缓冲区大小变量
;;;960    	unsigned int BufferSize=0;
000008  2400              MOVS     r4,#0
;;;961    	unsigned char DMAPrintf_Buffer[256]={0};
00000a  f44f7180          MOV      r1,#0x100
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;962    	//3)**********args为定义的一个指向可变参数的变量，va_list以及下边要用到的va_start,va_end都是是在定义，可变参数函数中必须要用到宏， 在stdarg.h头文件中定义
;;;963    	va_list args;  
;;;964    //	free(DMAPrintf_Buffer);						//释放动态空间
;;;965    //	DMAPrintf_Buffer=NULL;
;;;966    	//4)**********申请动态空间
;;;967    //	DMAPrintf_Buffer = (char*)malloc(sizeof(char) * num);	
;;;968    	//5)**********初始化args的函数，使其指向可变参数的第一个参数，format是可变参数的前一个参数
;;;969    	va_start(args, format);
000014  a846              ADD      r0,sp,#0x118
000016  9000              STR      r0,[sp,#0]
;;;970    	//6)**********正常情况下返回生成字串的长度(除去\0),错误情况返回负值
;;;971    	BufferSize = vsprintf((char*)DMAPrintf_Buffer, format, args);
000018  a801              ADD      r0,sp,#4
00001a  9a00              LDR      r2,[sp,#0]
00001c  9945              LDR      r1,[sp,#0x114]
00001e  f7fffffe          BL       __c89vsprintf
000022  4604              MOV      r4,r0
;;;972    	//7)**********结束可变参数的获取
;;;973    	va_end(args); 
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;974    	//8)**********将等发送缓冲区大小（数据个数）及缓冲区地址发给DMA开启发送
;;;975    	//8)**********DMA发送完成后注意应该释放缓冲区：free(USART_BUFFER);
;;;976    
;;;977      BufferSize=USART_DMASendList(USARTx,(u8*)DMAPrintf_Buffer,BufferSize);	//串口DMA发送程序
000028  b2a2              UXTH     r2,r4
00002a  a901              ADD      r1,sp,#4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       USART_DMASendList
000032  4604              MOV      r4,r0
;;;978    
;;;979    	return BufferSize;			//返回发送数据大小
000034  4620              MOV      r0,r4
;;;980    }
000036  b041              ADD      sp,sp,#0x104
000038  bc30              POP      {r4,r5}
00003a  f85dfb14          LDR      pc,[sp],#0x14
;;;981    /*******************************************************************************
                          ENDP


                          AREA ||i.USART_DMASend||, CODE, READONLY, ALIGN=2

                  USART_DMASend PROC
;;;986    *******************************************************************************/
;;;987    u16 USART_DMASend(
000000  b570              PUSH     {r4-r6,lr}
;;;988    									USART_TypeDef* USARTx,									//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;989    									u8 *tx_buffer,													//待发送数据缓冲区地址
;;;990    									u16 BufferSize													//设定发送数据大小
;;;991    )		//串口DMA发送程序
;;;992    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;993    	switch(*(u32*)&USARTx)
000008  4960              LDR      r1,|L12.396|
00000a  1a70              SUBS     r0,r6,r1
00000c  428e              CMP      r6,r1
00000e  d07d              BEQ      |L12.268|
000010  dc06              BGT      |L12.32|
000012  485f              LDR      r0,|L12.400|
000014  4430              ADD      r0,r0,r6
000016  b368              CBZ      r0,|L12.116|
000018  f5b06f80          CMP      r0,#0x400
                  |L12.28|
00001c  d177              BNE      |L12.270|
00001e  e057              B        |L12.208|
                  |L12.32|
000020  f5b06f80          CMP      r0,#0x400
000024  d074              BEQ      |L12.272|
000026  f5b04f6c          CMP      r0,#0xec00
00002a  d1f7              BNE      |L12.28|
;;;994    	{
;;;995    		case USART1_BASE:
;;;996    					if(
00002c  4859              LDR      r0,|L12.404|
00002e  6c80              LDR      r0,[r0,#0x48]
000030  b120              CBZ      r0,|L12.60|
;;;997    							(DMA1_Channel4->CNDTR==0)								  //通道空闲--已发完数据
;;;998    						||((DMA1_Channel4->CCR&0x00000001)==0)				//通道未开启
000032  4858              LDR      r0,|L12.404|
000034  6c40              LDR      r0,[r0,#0x44]
000036  f0000001          AND      r0,r0,#1
00003a  b9d0              CBNZ     r0,|L12.114|
                  |L12.60|
;;;999    						)
;;;1000   					{
;;;1001               if(SET  ==  USART_GetFlagStatus(USART1,USART_FLAG_TC))    //发送完成
00003c  2140              MOVS     r1,#0x40
00003e  4856              LDR      r0,|L12.408|
000040  f7fffffe          BL       USART_GetFlagStatus
000044  2801              CMP      r0,#1
000046  d114              BNE      |L12.114|
;;;1002               {
;;;1003                 USART_ClearFlag(USART1, USART_FLAG_TC);
000048  2140              MOVS     r1,#0x40
00004a  4853              LDR      r0,|L12.408|
00004c  f7fffffe          BL       USART_ClearFlag
;;;1004                 DMA1_Channel4->CCR    &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel4,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
000050  4850              LDR      r0,|L12.404|
000052  6c40              LDR      r0,[r0,#0x44]
000054  f0200001          BIC      r0,r0,#1
000058  494e              LDR      r1,|L12.404|
00005a  6448              STR      r0,[r1,#0x44]
;;;1005                 DMA1->IFCR            =   DMA1_FLAG_GL4;										//DMA_ClearFlag(DMA1_FLAG_TC4);	//清除标志						
00005c  1488              ASRS     r0,r1,#18
00005e  6048              STR      r0,[r1,#4]
;;;1006                 DMA1_Channel4->CNDTR 	=   BufferSize;					  //设定待发送缓冲区大小
000060  4608              MOV      r0,r1
000062  6484              STR      r4,[r0,#0x48]
;;;1007                 DMA1_Channel4->CMAR 	=   (u32)tx_buffer;			  //发送缓冲区
000064  6505              STR      r5,[r0,#0x50]
;;;1008                 DMA1_Channel4->CCR    |=  (u32)0x00000001;			  //DMA_Cmd(DMA1_Channel4,ENABLE);//DMA发送开启3
000066  6c40              LDR      r0,[r0,#0x44]
000068  f0400001          ORR      r0,r0,#1
00006c  6448              STR      r0,[r1,#0x44]
;;;1009                 return BufferSize;
00006e  4620              MOV      r0,r4
                  |L12.112|
;;;1010               }
;;;1011   					}
;;;1012   			break;
;;;1013   			case USART2_BASE:
;;;1014   					if(
;;;1015   							(DMA1_Channel7->CNDTR==0)										//通道空闲--已发完数据
;;;1016   						||((DMA1_Channel7->CCR&0x00000001)==0)				//通道未开启
;;;1017   						)
;;;1018   					{
;;;1019               if(SET  ==  USART_GetFlagStatus(USART2,USART_FLAG_TC))    //发送完成
;;;1020               {
;;;1021                 USART_ClearFlag(USART2, USART_FLAG_TC);
;;;1022                 DMA1_Channel7->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel7,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1023                 DMA1->IFCR = DMA1_FLAG_GL7;										//DMA_ClearFlag(DMA1_FLAG_TC7);	//清除标志						
;;;1024                 DMA1_Channel7->CNDTR 	=BufferSize;						    //设定待发送缓冲区大小
;;;1025                 DMA1_Channel7->CMAR 	=(u32)tx_buffer;				  //发送缓冲区
;;;1026                 DMA1_Channel7->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel7,ENABLE);//DMA发送开启3
;;;1027                 return BufferSize;
;;;1028               }
;;;1029             }
;;;1030   			break;
;;;1031   			case USART3_BASE:
;;;1032   					if(
;;;1033   							(DMA1_Channel2->CNDTR==0)										//通道空闲--已发完数据
;;;1034   						||((DMA1_Channel2->CCR&0x00000001)==0)				//通道未开启
;;;1035   						)
;;;1036   					{
;;;1037               if(SET  ==  USART_GetFlagStatus(USART3,USART_FLAG_TC))    //发送完成
;;;1038               {
;;;1039                 USART_ClearFlag(USART3, USART_FLAG_TC);
;;;1040                 DMA1_Channel2->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel2,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1041                 DMA1->IFCR = DMA1_FLAG_GL2;										//DMA_ClearFlag(DMA1_FLAG_TC2);	//清除标志						
;;;1042                 DMA1_Channel2->CNDTR 	=BufferSize;						//设定待发送缓冲区大小
;;;1043                 DMA1_Channel2->CMAR 	=(u32)tx_buffer;				//发送缓冲区
;;;1044                 DMA1_Channel2->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel2,ENABLE);//DMA发送开启3
;;;1045                 return BufferSize;
;;;1046               }
;;;1047   					}
;;;1048   			break;
;;;1049   			case UART4_BASE:
;;;1050   					if(
;;;1051   							(DMA2_Channel5->CNDTR==0)										//通道空闲--已发完数据
;;;1052   						||((DMA2_Channel5->CCR&0x00000001)==0)				//通道未开启
;;;1053   						)
;;;1054   					{
;;;1055               if(SET  ==  USART_GetFlagStatus(UART4,USART_FLAG_TC))    //发送完成
;;;1056               {
;;;1057                 USART_ClearFlag(UART4, USART_FLAG_TC);
;;;1058                 DMA2_Channel5->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel2,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1059                 DMA2->IFCR = DMA2_FLAG_GL5;										//DMA_ClearFlag(DMA2_FLAG_TC5);	//清除标志						
;;;1060                 DMA2_Channel5->CNDTR 	=BufferSize;						//设定待发送缓冲区大小
;;;1061                 DMA2_Channel5->CMAR 	=(u32)tx_buffer;				//发送缓冲区
;;;1062                 DMA2_Channel5->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA2_Channel5,ENABLE);//DMA发送开启3
;;;1063                 return BufferSize;
;;;1064               }
;;;1065   					}
;;;1066   			break;
;;;1067   			case UART5_BASE:
;;;1068   					//UART5不支持DMA
;;;1069   					return 0;
;;;1070   		default:break;
;;;1071   	}	
;;;1072   	return 0;
;;;1073   }
000070  bd70              POP      {r4-r6,pc}
                  |L12.114|
000072  e087              B        |L12.388|
                  |L12.116|
000074  4847              LDR      r0,|L12.404|
000076  3084              ADDS     r0,r0,#0x84           ;1014
000078  6800              LDR      r0,[r0,#0]            ;1014
00007a  b128              CBZ      r0,|L12.136|
00007c  4845              LDR      r0,|L12.404|
00007e  3080              ADDS     r0,r0,#0x80           ;1016
000080  6800              LDR      r0,[r0,#0]            ;1016
000082  f0000001          AND      r0,r0,#1              ;1016
000086  bb10              CBNZ     r0,|L12.206|
                  |L12.136|
000088  2140              MOVS     r1,#0x40              ;1019
00008a  4841              LDR      r0,|L12.400|
00008c  4240              RSBS     r0,r0,#0              ;1019
00008e  f7fffffe          BL       USART_GetFlagStatus
000092  2801              CMP      r0,#1                 ;1019
000094  d11b              BNE      |L12.206|
000096  2140              MOVS     r1,#0x40              ;1021
000098  483d              LDR      r0,|L12.400|
00009a  4240              RSBS     r0,r0,#0              ;1021
00009c  f7fffffe          BL       USART_ClearFlag
0000a0  483c              LDR      r0,|L12.404|
0000a2  3080              ADDS     r0,r0,#0x80           ;1022
0000a4  6800              LDR      r0,[r0,#0]            ;1022
0000a6  f0200001          BIC      r0,r0,#1              ;1022
0000aa  493a              LDR      r1,|L12.404|
0000ac  f8c10080          STR      r0,[r1,#0x80]         ;1022
0000b0  01c8              LSLS     r0,r1,#7              ;1023
0000b2  6048              STR      r0,[r1,#4]            ;1023
0000b4  4608              MOV      r0,r1                 ;1024
0000b6  f8c04084          STR      r4,[r0,#0x84]         ;1024
0000ba  f8c0508c          STR      r5,[r0,#0x8c]         ;1025
0000be  f8d00080          LDR      r0,[r0,#0x80]         ;1026
0000c2  f0400001          ORR      r0,r0,#1              ;1026
0000c6  f8c10080          STR      r0,[r1,#0x80]         ;1026
0000ca  4620              MOV      r0,r4                 ;1027
0000cc  e7d0              B        |L12.112|
                  |L12.206|
0000ce  e059              B        |L12.388|
                  |L12.208|
0000d0  4830              LDR      r0,|L12.404|
0000d2  6a00              LDR      r0,[r0,#0x20]         ;1032
0000d4  b120              CBZ      r0,|L12.224|
0000d6  482f              LDR      r0,|L12.404|
0000d8  69c0              LDR      r0,[r0,#0x1c]         ;1034
0000da  f0000001          AND      r0,r0,#1              ;1034
0000de  b9f0              CBNZ     r0,|L12.286|
                  |L12.224|
0000e0  2140              MOVS     r1,#0x40              ;1037
0000e2  482e              LDR      r0,|L12.412|
0000e4  f7fffffe          BL       USART_GetFlagStatus
0000e8  2801              CMP      r0,#1                 ;1037
0000ea  d118              BNE      |L12.286|
0000ec  2140              MOVS     r1,#0x40              ;1039
0000ee  482b              LDR      r0,|L12.412|
0000f0  f7fffffe          BL       USART_ClearFlag
0000f4  4827              LDR      r0,|L12.404|
0000f6  69c0              LDR      r0,[r0,#0x1c]         ;1040
0000f8  f0200001          BIC      r0,r0,#1              ;1040
0000fc  4925              LDR      r1,|L12.404|
0000fe  61c8              STR      r0,[r1,#0x1c]         ;1040
000100  2010              MOVS     r0,#0x10              ;1041
000102  6048              STR      r0,[r1,#4]            ;1041
000104  4608              MOV      r0,r1                 ;1042
000106  6204              STR      r4,[r0,#0x20]         ;1042
000108  6285              STR      r5,[r0,#0x28]         ;1043
00010a  e002              B        |L12.274|
                  |L12.268|
00010c  e008              B        |L12.288|
                  |L12.270|
00010e  e038              B        |L12.386|
                  |L12.272|
000110  e035              B        |L12.382|
                  |L12.274|
000112  69c0              LDR      r0,[r0,#0x1c]         ;1044
000114  f0400001          ORR      r0,r0,#1              ;1044
000118  61c8              STR      r0,[r1,#0x1c]         ;1044
00011a  4620              MOV      r0,r4                 ;1045
00011c  e7a8              B        |L12.112|
                  |L12.286|
00011e  e031              B        |L12.388|
                  |L12.288|
000120  481f              LDR      r0,|L12.416|
000122  6800              LDR      r0,[r0,#0]            ;1050
000124  b128              CBZ      r0,|L12.306|
000126  481e              LDR      r0,|L12.416|
000128  1f00              SUBS     r0,r0,#4              ;1052
00012a  6800              LDR      r0,[r0,#0]            ;1052
00012c  f0000001          AND      r0,r0,#1              ;1052
000130  bb20              CBNZ     r0,|L12.380|
                  |L12.306|
000132  2140              MOVS     r1,#0x40              ;1055
000134  4815              LDR      r0,|L12.396|
000136  f7fffffe          BL       USART_GetFlagStatus
00013a  2801              CMP      r0,#1                 ;1055
00013c  d11e              BNE      |L12.380|
00013e  2140              MOVS     r1,#0x40              ;1057
000140  4812              LDR      r0,|L12.396|
000142  f7fffffe          BL       USART_ClearFlag
000146  4816              LDR      r0,|L12.416|
000148  1f00              SUBS     r0,r0,#4              ;1058
00014a  6800              LDR      r0,[r0,#0]            ;1058
00014c  f0200001          BIC      r0,r0,#1              ;1058
000150  4913              LDR      r1,|L12.416|
000152  1f09              SUBS     r1,r1,#4              ;1058
000154  6008              STR      r0,[r1,#0]            ;1058
000156  4813              LDR      r0,|L12.420|
000158  4911              LDR      r1,|L12.416|
00015a  3958              SUBS     r1,r1,#0x58           ;1059
00015c  6008              STR      r0,[r1,#0]            ;1059
00015e  4810              LDR      r0,|L12.416|
000160  6004              STR      r4,[r0,#0]            ;1060
000162  480f              LDR      r0,|L12.416|
000164  3008              ADDS     r0,r0,#8              ;1061
000166  6005              STR      r5,[r0,#0]            ;1061
000168  480d              LDR      r0,|L12.416|
00016a  1f00              SUBS     r0,r0,#4              ;1062
00016c  6800              LDR      r0,[r0,#0]            ;1062
00016e  f0400001          ORR      r0,r0,#1              ;1062
000172  490b              LDR      r1,|L12.416|
000174  1f09              SUBS     r1,r1,#4              ;1062
000176  6008              STR      r0,[r1,#0]            ;1062
000178  4620              MOV      r0,r4                 ;1063
00017a  e779              B        |L12.112|
                  |L12.380|
00017c  e002              B        |L12.388|
                  |L12.382|
00017e  2000              MOVS     r0,#0                 ;1069
000180  e776              B        |L12.112|
                  |L12.386|
000182  bf00              NOP                            ;1070
                  |L12.388|
000184  bf00              NOP                            ;1012
000186  2000              MOVS     r0,#0                 ;1072
000188  e772              B        |L12.112|
;;;1074   /*******************************************************************************
                          ENDP

00018a  0000              DCW      0x0000
                  |L12.396|
                          DCD      0x40004c00
                  |L12.400|
                          DCD      0xbfffbc00
                  |L12.404|
                          DCD      0x40020000
                  |L12.408|
                          DCD      0x40013800
                  |L12.412|
                          DCD      0x40004800
                  |L12.416|
                          DCD      0x4002045c
                  |L12.420|
                          DCD      0x10010000

                          AREA ||i.USART_DMASendList||, CODE, READONLY, ALIGN=2

                  USART_DMASendList PROC
;;;1079   *******************************************************************************/
;;;1080   u16 USART_DMASendList(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1081   									USART_TypeDef* USARTx,									//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;1082   									u8 *tx_buffer,													//待发送数据缓冲区地址
;;;1083   									u16 BufferSize													//设定发送数据大小
;;;1084   )		//串口DMA发送程序
;;;1085   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1086   //	if(BufferSize>uTxSize)	//防止内存溢出
;;;1087   //		BufferSize	=	uTxSize;
;;;1088   	switch(*(u32*)&USARTx)
00000a  49ea              LDR      r1,|L13.948|
00000c  1a60              SUBS     r0,r4,r1
00000e  428c              CMP      r4,r1
000010  d076              BEQ      |L13.256|
000012  dc07              BGT      |L13.36|
000014  48e8              LDR      r0,|L13.952|
000016  4420              ADD      r0,r0,r4
000018  2800              CMP      r0,#0
00001a  d075              BEQ      |L13.264|
00001c  f5b06f80          CMP      r0,#0x400
                  |L13.32|
000020  d170              BNE      |L13.260|
000022  e0e6              B        |L13.498|
                  |L13.36|
000024  f5b06f80          CMP      r0,#0x400
000028  d06d              BEQ      |L13.262|
00002a  f5b04f6c          CMP      r0,#0xec00
00002e  d1f7              BNE      |L13.32|
;;;1089   	{
;;;1090   		case USART1_BASE:
;;;1091   					//检查USART有无配置
;;;1092   					if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未配置
000030  89a0              LDRH     r0,[r4,#0xc]
000032  f4005000          AND      r0,r0,#0x2000
000036  f5b05f00          CMP      r0,#0x2000
00003a  d006              BEQ      |L13.74|
;;;1093   					{
;;;1094   						USART_DMA_ConfigurationNR	(USART1,uBaudRate,uRxSize);	//USART_DMA配置--查询方式，不开中断
00003c  f44f7200          MOV      r2,#0x200
000040  f44f31e1          MOV      r1,#0x1c200
000044  48dd              LDR      r0,|L13.956|
000046  f7fffffe          BL       USART_DMA_ConfigurationNR
                  |L13.74|
;;;1095   					}
;;;1096   					if(
00004a  48dd              LDR      r0,|L13.960|
00004c  6c80              LDR      r0,[r0,#0x48]
00004e  b128              CBZ      r0,|L13.92|
;;;1097   							(DMA1_Channel4->CNDTR==0)										//通道空闲--已发完数据
;;;1098   						||((DMA1_Channel4->CCR&0x00000001)==0)				//通道未开启
000050  48db              LDR      r0,|L13.960|
000052  6c40              LDR      r0,[r0,#0x44]
000054  f0000001          AND      r0,r0,#1
000058  2800              CMP      r0,#0
00005a  d13f              BNE      |L13.220|
                  |L13.92|
;;;1099   						)
;;;1100   					{            
;;;1101               if(NULL ==  uTxLink1)
00005c  48d9              LDR      r0,|L13.964|
00005e  6800              LDR      r0,[r0,#0]  ; uTxLink1
000060  bb58              CBNZ     r0,|L13.186|
;;;1102               {
;;;1103                 if(NULL !=  uTx1Addr)
000062  48d9              LDR      r0,|L13.968|
000064  6800              LDR      r0,[r0,#0]  ; uTx1Addr
000066  b118              CBZ      r0,|L13.112|
;;;1104                   free(uTx1Addr);
000068  48d7              LDR      r0,|L13.968|
00006a  6800              LDR      r0,[r0,#0]  ; uTx1Addr
00006c  f7fffffe          BL       free
                  |L13.112|
;;;1105                 uTx1Addr  = (unsigned char*)malloc((unsigned int)BufferSize);
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       malloc
000076  49d4              LDR      r1,|L13.968|
000078  6008              STR      r0,[r1,#0]  ; uTx1Addr
;;;1106                 if(NULL ==  uTx1Addr)   //内存申请失败
00007a  4608              MOV      r0,r1
00007c  6800              LDR      r0,[r0,#0]  ; uTx1Addr
00007e  b910              CBNZ     r0,|L13.134|
;;;1107                 {
;;;1108                   return 0;
000080  2000              MOVS     r0,#0
                  |L13.130|
;;;1109                 }
;;;1110                 memcpy(uTx1Addr,tx_buffer,BufferSize);
;;;1111                 DMA1_Channel4->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel4,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1112                 DMA1->IFCR = DMA1_FLAG_GL4;										//DMA_ClearFlag(DMA1_FLAG_TC4);	//清除标志						
;;;1113                 DMA1_Channel4->CNDTR 	=BufferSize;						    //设定待发送缓冲区大小
;;;1114                 DMA1_Channel4->CMAR 	=(u32)uTx1Addr;				  //发送缓冲区
;;;1115                 DMA1_Channel4->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel4,ENABLE);//DMA发送开启3
;;;1116                 return BufferSize;
;;;1117               }
;;;1118               //===========有待发送链表，需要将待发数据加入待发队列等待发送
;;;1119               else
;;;1120               {
;;;1121                 unsigned short Result = 0;
;;;1122                 Result  = FIFO_IN(&uTxLink1,(char*)tx_buffer,BufferSize);
;;;1123                 //==========动态空间申请失败，需要发送一部分数据释放缓存
;;;1124                 if(0  ==  Result)
;;;1125                 {
;;;1126                   USART_TxServer(USART1);
;;;1127                   USART_DMASendList(USART1,tx_buffer,BufferSize);
;;;1128                 }
;;;1129               }
;;;1130   					}
;;;1131             //===========串口正在发送中：需要将待发数据加入待发队列等待发送
;;;1132   					else
;;;1133   					{
;;;1134               unsigned short Result = 0;
;;;1135               Result  = FIFO_IN(&uTxLink1,(char*)tx_buffer,BufferSize);
;;;1136               if(0  ==  Result)
;;;1137               {
;;;1138                 USART_TxServer(USART1);
;;;1139                 USART_DMASendList(USART1,tx_buffer,BufferSize);
;;;1140               }
;;;1141   					}
;;;1142   			break;
;;;1143   			case USART2_BASE:
;;;1144   					//检查USART有无配置
;;;1145   					if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未打开
;;;1146   					{
;;;1147   						USART_DMA_ConfigurationNR	(USART2,uBaudRate,uRxSize);	//USART_DMA配置--查询方式，不开中断
;;;1148   					}
;;;1149   					if(
;;;1150   							(DMA1_Channel7->CNDTR==0)										//通道空闲--已发完数据
;;;1151   						||((DMA1_Channel7->CCR&0x00000001)==0)				//通道未开启
;;;1152   						)
;;;1153   					{            
;;;1154               if(NULL ==  uTxLink2)
;;;1155               {
;;;1156                 if(NULL !=  uTx2Addr)
;;;1157                   free(uTx2Addr);
;;;1158                 uTx2Addr  = (unsigned char*)malloc((unsigned int)BufferSize);
;;;1159                 if(NULL ==  uTx2Addr)   //内存申请失败
;;;1160                 {
;;;1161                   return 0;
;;;1162                 }
;;;1163                 memcpy(uTx2Addr,tx_buffer,BufferSize);
;;;1164                 DMA1_Channel7->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel7,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1165                 DMA1->IFCR = DMA1_FLAG_GL7;										//DMA_ClearFlag(DMA1_FLAG_TC7);	//清除标志						
;;;1166                 DMA1_Channel7->CNDTR 	=BufferSize;						    //设定待发送缓冲区大小
;;;1167                 DMA1_Channel7->CMAR 	=(u32)uTx2Addr;				  //发送缓冲区
;;;1168                 DMA1_Channel7->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel7,ENABLE);//DMA发送开启3
;;;1169                 return BufferSize;
;;;1170               }
;;;1171               //===========有待发送链表，需要将待发数据加入待发队列等待发送
;;;1172               else
;;;1173               {
;;;1174                 unsigned short Result = 0;
;;;1175                 Result  = FIFO_IN(&uTxLink2,(char*)tx_buffer,BufferSize);
;;;1176                 //==========动态空间申请失败，需要发送一部分数据释放缓存
;;;1177                 if(0  ==  Result)
;;;1178                 {
;;;1179                   USART_TxServer(USART2);
;;;1180                   USART_DMASendList(USART2,tx_buffer,BufferSize);
;;;1181                 }
;;;1182               }              
;;;1183   					}
;;;1184             //===========串口正在发送中：需要将待发数据加入待发队列等待发送
;;;1185             else
;;;1186             {
;;;1187               unsigned short Result = 0;
;;;1188               Result  = FIFO_IN(&uTxLink2,(char*)tx_buffer,BufferSize);
;;;1189               if(0  ==  Result)
;;;1190               {
;;;1191                 USART_TxServer(USART2);
;;;1192                 USART_DMASendList(USART2,tx_buffer,BufferSize);
;;;1193               }
;;;1194             }
;;;1195   			break;
;;;1196   			case USART3_BASE:
;;;1197   					//检查USART有无配置
;;;1198   					if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未打开
;;;1199   					{
;;;1200   						USART_DMA_ConfigurationNR	(USART3,uBaudRate,uRxSize);	//USART_DMA配置--查询方式，不开中断
;;;1201   					}
;;;1202   					if(
;;;1203   							(DMA1_Channel2->CNDTR==0)										//通道空闲--已发完数据
;;;1204   						||((DMA1_Channel2->CCR&0x00000001)==0)				//通道未开启
;;;1205   						)
;;;1206   					{
;;;1207               if(NULL ==  uTxLink3)
;;;1208               {
;;;1209                 if(NULL !=  uTx3Addr)
;;;1210                   free(uTx3Addr);
;;;1211                 uTx3Addr  = (unsigned char*)malloc((unsigned int)BufferSize);
;;;1212                 if(NULL ==  uTx3Addr)   //内存申请失败
;;;1213                 {
;;;1214                   return 0;
;;;1215                 }
;;;1216                 memcpy(uTx3Addr,tx_buffer,BufferSize);
;;;1217                 DMA1_Channel2->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel2,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1218                 DMA1->IFCR = DMA1_FLAG_GL2;										//DMA_ClearFlag(DMA1_FLAG_TC2);	//清除标志						
;;;1219                 DMA1_Channel2->CNDTR 	=BufferSize;						//设定待发送缓冲区大小
;;;1220                 DMA1_Channel2->CMAR 	=(u32)uTx3Addr;				//发送缓冲区
;;;1221                 DMA1_Channel2->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel2,ENABLE);//DMA发送开启3
;;;1222                 return BufferSize;
;;;1223               }
;;;1224               //===========有待发送链表，需要将待发数据加入待发队列等待发送
;;;1225               else
;;;1226               {
;;;1227                 unsigned short Result = 0;
;;;1228                 Result  = FIFO_IN(&uTxLink3,(char*)tx_buffer,BufferSize);
;;;1229                 //==========动态空间申请失败，需要发送一部分数据释放缓存
;;;1230                 if(0  ==  Result)
;;;1231                 {
;;;1232                   USART_TxServer(USART3);
;;;1233                   USART_DMASendList(USART3,tx_buffer,BufferSize);
;;;1234                 }
;;;1235               }
;;;1236   					}
;;;1237             //===========串口正在发送中：需要将待发数据加入待发队列等待发送
;;;1238   					else
;;;1239   					{
;;;1240               unsigned short Result = 0;
;;;1241               Result  = FIFO_IN(&uTxLink3,(char*)tx_buffer,BufferSize);
;;;1242               if(0  ==  Result)
;;;1243               {
;;;1244                 USART_TxServer(USART3);
;;;1245                 USART_DMASendList(USART3,tx_buffer,BufferSize);
;;;1246               }
;;;1247   					}
;;;1248   			break;
;;;1249   			case UART4_BASE:
;;;1250   					//检查USART有无配置
;;;1251   					if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未打开
;;;1252   					{
;;;1253   						USART_DMA_ConfigurationNR	(UART4,uBaudRate,uRxSize);	//USART_DMA配置--查询方式，不开中断
;;;1254   					}
;;;1255   					if(
;;;1256   							(DMA2_Channel5->CNDTR==0)										//通道空闲--已发完数据
;;;1257   						||((DMA2_Channel5->CCR&0x00000001)==0)				//通道未开启
;;;1258   						)
;;;1259   					{
;;;1260               if(NULL ==  uTxLink4)
;;;1261               {
;;;1262                 if(NULL !=  uTx4Addr)
;;;1263                   free(uTx4Addr);
;;;1264                 uTx4Addr  = (unsigned char*)malloc((unsigned int)BufferSize);
;;;1265                 if(NULL ==  uTx4Addr)   //内存申请失败
;;;1266                 {
;;;1267                   return 0;
;;;1268                 }
;;;1269                 memcpy(uTx4Addr,tx_buffer,BufferSize);
;;;1270                 DMA2_Channel5->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel2,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1271                 DMA2->IFCR = DMA2_FLAG_GL5;										//DMA_ClearFlag(DMA2_FLAG_TC5);	//清除标志						
;;;1272                 DMA2_Channel5->CNDTR 	=BufferSize;						//设定待发送缓冲区大小
;;;1273                 DMA2_Channel5->CMAR 	=(u32)uTx4Addr;				//发送缓冲区
;;;1274                 DMA2_Channel5->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA2_Channel5,ENABLE);//DMA发送开启3
;;;1275                 return BufferSize;
;;;1276               }
;;;1277               //===========有待发送链表，需要将待发数据加入待发队列等待发送
;;;1278               else
;;;1279               {
;;;1280                 unsigned short Result = 0;
;;;1281                 Result  = FIFO_IN(&uTxLink4,(char*)tx_buffer,BufferSize);
;;;1282                 //==========动态空间申请失败，需要发送一部分数据释放缓存
;;;1283                 if(0  ==  Result)
;;;1284                 {
;;;1285                   USART_TxServer(UART4);
;;;1286                   USART_DMASendList(UART4,tx_buffer,BufferSize);
;;;1287                 }
;;;1288               }
;;;1289   					}
;;;1290             //===========串口正在发送中：需要将待发数据加入待发队列等待发送
;;;1291   					else
;;;1292   					{
;;;1293               unsigned short Result = 0;
;;;1294               Result  = FIFO_IN(&uTxLink4,(char*)tx_buffer,BufferSize);
;;;1295               if(0  ==  Result)
;;;1296               {
;;;1297                 USART_TxServer(UART4);
;;;1298                 USART_DMASendList(UART4,tx_buffer,BufferSize);
;;;1299               }
;;;1300   					}
;;;1301   			break;
;;;1302   			case UART5_BASE:
;;;1303   					//UART5不支持DMA
;;;1304   					return 0;
;;;1305   		default:break;
;;;1306   	}	
;;;1307   	return 0;
;;;1308   }
000082  e8bd81f0          POP      {r4-r8,pc}
                  |L13.134|
000086  462a              MOV      r2,r5                 ;1110
000088  4631              MOV      r1,r6                 ;1110
00008a  48cf              LDR      r0,|L13.968|
00008c  6800              LDR      r0,[r0,#0]            ;1110  ; uTx1Addr
00008e  f7fffffe          BL       __aeabi_memcpy
000092  48cb              LDR      r0,|L13.960|
000094  6c40              LDR      r0,[r0,#0x44]         ;1111
000096  f0200001          BIC      r0,r0,#1              ;1111
00009a  49c9              LDR      r1,|L13.960|
00009c  6448              STR      r0,[r1,#0x44]         ;1111
00009e  1488              ASRS     r0,r1,#18             ;1112
0000a0  6048              STR      r0,[r1,#4]            ;1112
0000a2  4608              MOV      r0,r1                 ;1113
0000a4  6485              STR      r5,[r0,#0x48]         ;1113
0000a6  48c8              LDR      r0,|L13.968|
0000a8  6800              LDR      r0,[r0,#0]            ;1114  ; uTx1Addr
0000aa  6508              STR      r0,[r1,#0x50]         ;1114
0000ac  4608              MOV      r0,r1                 ;1115
0000ae  6c40              LDR      r0,[r0,#0x44]         ;1115
0000b0  f0400001          ORR      r0,r0,#1              ;1115
0000b4  6448              STR      r0,[r1,#0x44]         ;1115
0000b6  4628              MOV      r0,r5                 ;1116
0000b8  e7e3              B        |L13.130|
                  |L13.186|
0000ba  2700              MOVS     r7,#0                 ;1121
0000bc  462a              MOV      r2,r5                 ;1122
0000be  4631              MOV      r1,r6                 ;1122
0000c0  48c0              LDR      r0,|L13.964|
0000c2  f7fffffe          BL       FIFO_IN
0000c6  4607              MOV      r7,r0                 ;1122
0000c8  b93f              CBNZ     r7,|L13.218|
0000ca  48bc              LDR      r0,|L13.956|
0000cc  f7fffffe          BL       USART_TxServer
0000d0  462a              MOV      r2,r5                 ;1127
0000d2  4631              MOV      r1,r6                 ;1127
0000d4  48b9              LDR      r0,|L13.956|
0000d6  f7fffffe          BL       USART_DMASendList
                  |L13.218|
0000da  e010              B        |L13.254|
                  |L13.220|
0000dc  2700              MOVS     r7,#0                 ;1134
0000de  462a              MOV      r2,r5                 ;1135
0000e0  4631              MOV      r1,r6                 ;1135
0000e2  48b8              LDR      r0,|L13.964|
0000e4  f7fffffe          BL       FIFO_IN
0000e8  4607              MOV      r7,r0                 ;1135
0000ea  b93f              CBNZ     r7,|L13.252|
0000ec  48b3              LDR      r0,|L13.956|
0000ee  f7fffffe          BL       USART_TxServer
0000f2  462a              MOV      r2,r5                 ;1139
0000f4  4631              MOV      r1,r6                 ;1139
0000f6  48b1              LDR      r0,|L13.956|
0000f8  f7fffffe          BL       USART_DMASendList
                  |L13.252|
0000fc  bf00              NOP                            ;1141
                  |L13.254|
0000fe  e155              B        |L13.940|
                  |L13.256|
000100  e0df              B        |L13.706|
000102  e001              B        |L13.264|
                  |L13.260|
000104  e151              B        |L13.938|
                  |L13.262|
000106  e14e              B        |L13.934|
                  |L13.264|
000108  89a0              LDRH     r0,[r4,#0xc]          ;1145
00010a  f4005000          AND      r0,r0,#0x2000         ;1145
00010e  f5b05f00          CMP      r0,#0x2000            ;1145
000112  d007              BEQ      |L13.292|
000114  f44f7200          MOV      r2,#0x200             ;1147
000118  f44f31e1          MOV      r1,#0x1c200           ;1147
00011c  48a6              LDR      r0,|L13.952|
00011e  4240              RSBS     r0,r0,#0              ;1147
000120  f7fffffe          BL       USART_DMA_ConfigurationNR
                  |L13.292|
000124  48a6              LDR      r0,|L13.960|
000126  3084              ADDS     r0,r0,#0x84           ;1149
000128  6800              LDR      r0,[r0,#0]            ;1149
00012a  b130              CBZ      r0,|L13.314|
00012c  48a4              LDR      r0,|L13.960|
00012e  3080              ADDS     r0,r0,#0x80           ;1151
000130  6800              LDR      r0,[r0,#0]            ;1151
000132  f0000001          AND      r0,r0,#1              ;1151
000136  2800              CMP      r0,#0                 ;1151
000138  d147              BNE      |L13.458|
                  |L13.314|
00013a  48a4              LDR      r0,|L13.972|
00013c  6800              LDR      r0,[r0,#0]            ;1154  ; uTxLink2
00013e  bb80              CBNZ     r0,|L13.418|
000140  48a3              LDR      r0,|L13.976|
000142  6800              LDR      r0,[r0,#0]            ;1156  ; uTx2Addr
000144  b118              CBZ      r0,|L13.334|
000146  48a2              LDR      r0,|L13.976|
000148  6800              LDR      r0,[r0,#0]            ;1157  ; uTx2Addr
00014a  f7fffffe          BL       free
                  |L13.334|
00014e  4628              MOV      r0,r5                 ;1158
000150  f7fffffe          BL       malloc
000154  499e              LDR      r1,|L13.976|
000156  6008              STR      r0,[r1,#0]            ;1158  ; uTx2Addr
000158  4608              MOV      r0,r1                 ;1159
00015a  6800              LDR      r0,[r0,#0]            ;1159  ; uTx2Addr
00015c  b908              CBNZ     r0,|L13.354|
00015e  2000              MOVS     r0,#0                 ;1161
000160  e78f              B        |L13.130|
                  |L13.354|
000162  462a              MOV      r2,r5                 ;1163
000164  4631              MOV      r1,r6                 ;1163
000166  489a              LDR      r0,|L13.976|
000168  6800              LDR      r0,[r0,#0]            ;1163  ; uTx2Addr
00016a  f7fffffe          BL       __aeabi_memcpy
00016e  4894              LDR      r0,|L13.960|
000170  3080              ADDS     r0,r0,#0x80           ;1164
000172  6800              LDR      r0,[r0,#0]            ;1164
000174  f0200001          BIC      r0,r0,#1              ;1164
000178  4991              LDR      r1,|L13.960|
00017a  f8c10080          STR      r0,[r1,#0x80]         ;1164
00017e  01c8              LSLS     r0,r1,#7              ;1165
000180  6048              STR      r0,[r1,#4]            ;1165
000182  4608              MOV      r0,r1                 ;1166
000184  f8c05084          STR      r5,[r0,#0x84]         ;1166
000188  4891              LDR      r0,|L13.976|
00018a  6800              LDR      r0,[r0,#0]            ;1167  ; uTx2Addr
00018c  f8c1008c          STR      r0,[r1,#0x8c]         ;1167
000190  4608              MOV      r0,r1                 ;1168
000192  f8d00080          LDR      r0,[r0,#0x80]         ;1168
000196  f0400001          ORR      r0,r0,#1              ;1168
00019a  f8c10080          STR      r0,[r1,#0x80]         ;1168
00019e  4628              MOV      r0,r5                 ;1169
0001a0  e76f              B        |L13.130|
                  |L13.418|
0001a2  e7ff              B        |L13.420|
                  |L13.420|
0001a4  2700              MOVS     r7,#0                 ;1174
0001a6  462a              MOV      r2,r5                 ;1175
0001a8  4631              MOV      r1,r6                 ;1175
0001aa  4888              LDR      r0,|L13.972|
0001ac  f7fffffe          BL       FIFO_IN
0001b0  4607              MOV      r7,r0                 ;1175
0001b2  b94f              CBNZ     r7,|L13.456|
0001b4  4880              LDR      r0,|L13.952|
0001b6  4240              RSBS     r0,r0,#0              ;1179
0001b8  f7fffffe          BL       USART_TxServer
0001bc  462a              MOV      r2,r5                 ;1180
0001be  4631              MOV      r1,r6                 ;1180
0001c0  487d              LDR      r0,|L13.952|
0001c2  4240              RSBS     r0,r0,#0              ;1180
0001c4  f7fffffe          BL       USART_DMASendList
                  |L13.456|
0001c8  e012              B        |L13.496|
                  |L13.458|
0001ca  2700              MOVS     r7,#0                 ;1187
0001cc  462a              MOV      r2,r5                 ;1188
0001ce  4631              MOV      r1,r6                 ;1188
0001d0  487e              LDR      r0,|L13.972|
0001d2  f7fffffe          BL       FIFO_IN
0001d6  4607              MOV      r7,r0                 ;1188
0001d8  b94f              CBNZ     r7,|L13.494|
0001da  4877              LDR      r0,|L13.952|
0001dc  4240              RSBS     r0,r0,#0              ;1191
0001de  f7fffffe          BL       USART_TxServer
0001e2  462a              MOV      r2,r5                 ;1192
0001e4  4631              MOV      r1,r6                 ;1192
0001e6  4874              LDR      r0,|L13.952|
0001e8  4240              RSBS     r0,r0,#0              ;1192
0001ea  f7fffffe          BL       USART_DMASendList
                  |L13.494|
0001ee  bf00              NOP                            ;1194
                  |L13.496|
0001f0  e0dc              B        |L13.940|
                  |L13.498|
0001f2  89a0              LDRH     r0,[r4,#0xc]          ;1198
0001f4  f4005000          AND      r0,r0,#0x2000         ;1198
0001f8  f5b05f00          CMP      r0,#0x2000            ;1198
0001fc  d006              BEQ      |L13.524|
0001fe  f44f7200          MOV      r2,#0x200             ;1200
000202  f44f31e1          MOV      r1,#0x1c200           ;1200
000206  4873              LDR      r0,|L13.980|
000208  f7fffffe          BL       USART_DMA_ConfigurationNR
                  |L13.524|
00020c  486c              LDR      r0,|L13.960|
00020e  6a00              LDR      r0,[r0,#0x20]         ;1202
000210  b120              CBZ      r0,|L13.540|
000212  486b              LDR      r0,|L13.960|
000214  69c0              LDR      r0,[r0,#0x1c]         ;1204
000216  f0000001          AND      r0,r0,#1              ;1204
00021a  bbe0              CBNZ     r0,|L13.662|
                  |L13.540|
00021c  486e              LDR      r0,|L13.984|
00021e  6800              LDR      r0,[r0,#0]            ;1207  ; uTxLink3
000220  bb50              CBNZ     r0,|L13.632|
000222  486e              LDR      r0,|L13.988|
000224  6800              LDR      r0,[r0,#0]            ;1209  ; uTx3Addr
000226  b118              CBZ      r0,|L13.560|
000228  486c              LDR      r0,|L13.988|
00022a  6800              LDR      r0,[r0,#0]            ;1210  ; uTx3Addr
00022c  f7fffffe          BL       free
                  |L13.560|
000230  4628              MOV      r0,r5                 ;1211
000232  f7fffffe          BL       malloc
000236  4969              LDR      r1,|L13.988|
000238  6008              STR      r0,[r1,#0]            ;1211  ; uTx3Addr
00023a  4608              MOV      r0,r1                 ;1212
00023c  6800              LDR      r0,[r0,#0]            ;1212  ; uTx3Addr
00023e  b908              CBNZ     r0,|L13.580|
000240  2000              MOVS     r0,#0                 ;1214
000242  e71e              B        |L13.130|
                  |L13.580|
000244  462a              MOV      r2,r5                 ;1216
000246  4631              MOV      r1,r6                 ;1216
000248  4864              LDR      r0,|L13.988|
00024a  6800              LDR      r0,[r0,#0]            ;1216  ; uTx3Addr
00024c  f7fffffe          BL       __aeabi_memcpy
000250  485b              LDR      r0,|L13.960|
000252  69c0              LDR      r0,[r0,#0x1c]         ;1217
000254  f0200001          BIC      r0,r0,#1              ;1217
000258  4959              LDR      r1,|L13.960|
00025a  61c8              STR      r0,[r1,#0x1c]         ;1217
00025c  2010              MOVS     r0,#0x10              ;1218
00025e  6048              STR      r0,[r1,#4]            ;1218
000260  4608              MOV      r0,r1                 ;1219
000262  6205              STR      r5,[r0,#0x20]         ;1219
000264  485d              LDR      r0,|L13.988|
000266  6800              LDR      r0,[r0,#0]            ;1220  ; uTx3Addr
000268  6288              STR      r0,[r1,#0x28]         ;1220
00026a  4608              MOV      r0,r1                 ;1221
00026c  69c0              LDR      r0,[r0,#0x1c]         ;1221
00026e  f0400001          ORR      r0,r0,#1              ;1221
000272  61c8              STR      r0,[r1,#0x1c]         ;1221
000274  4628              MOV      r0,r5                 ;1222
000276  e704              B        |L13.130|
                  |L13.632|
000278  2700              MOVS     r7,#0                 ;1227
00027a  462a              MOV      r2,r5                 ;1228
00027c  4631              MOV      r1,r6                 ;1228
00027e  4856              LDR      r0,|L13.984|
000280  f7fffffe          BL       FIFO_IN
000284  4607              MOV      r7,r0                 ;1228
000286  b94f              CBNZ     r7,|L13.668|
000288  4852              LDR      r0,|L13.980|
00028a  f7fffffe          BL       USART_TxServer
00028e  462a              MOV      r2,r5                 ;1233
000290  4631              MOV      r1,r6                 ;1233
000292  4850              LDR      r0,|L13.980|
000294  e000              B        |L13.664|
                  |L13.662|
000296  e002              B        |L13.670|
                  |L13.664|
000298  f7fffffe          BL       USART_DMASendList
                  |L13.668|
00029c  e010              B        |L13.704|
                  |L13.670|
00029e  2700              MOVS     r7,#0                 ;1240
0002a0  462a              MOV      r2,r5                 ;1241
0002a2  4631              MOV      r1,r6                 ;1241
0002a4  484c              LDR      r0,|L13.984|
0002a6  f7fffffe          BL       FIFO_IN
0002aa  4607              MOV      r7,r0                 ;1241
0002ac  b93f              CBNZ     r7,|L13.702|
0002ae  4849              LDR      r0,|L13.980|
0002b0  f7fffffe          BL       USART_TxServer
0002b4  462a              MOV      r2,r5                 ;1245
0002b6  4631              MOV      r1,r6                 ;1245
0002b8  4846              LDR      r0,|L13.980|
0002ba  f7fffffe          BL       USART_DMASendList
                  |L13.702|
0002be  bf00              NOP                            ;1247
                  |L13.704|
0002c0  e074              B        |L13.940|
                  |L13.706|
0002c2  89a0              LDRH     r0,[r4,#0xc]          ;1251
0002c4  f4005000          AND      r0,r0,#0x2000         ;1251
0002c8  f5b05f00          CMP      r0,#0x2000            ;1251
0002cc  d006              BEQ      |L13.732|
0002ce  f44f7200          MOV      r2,#0x200             ;1253
0002d2  f44f31e1          MOV      r1,#0x1c200           ;1253
0002d6  4837              LDR      r0,|L13.948|
0002d8  f7fffffe          BL       USART_DMA_ConfigurationNR
                  |L13.732|
0002dc  4840              LDR      r0,|L13.992|
0002de  6800              LDR      r0,[r0,#0]            ;1255
0002e0  b128              CBZ      r0,|L13.750|
0002e2  483f              LDR      r0,|L13.992|
0002e4  1f00              SUBS     r0,r0,#4              ;1257
0002e6  6800              LDR      r0,[r0,#0]            ;1257
0002e8  f0000001          AND      r0,r0,#1              ;1257
0002ec  bbb0              CBNZ     r0,|L13.860|
                  |L13.750|
0002ee  483d              LDR      r0,|L13.996|
0002f0  6800              LDR      r0,[r0,#0]            ;1260  ; uTxLink4
0002f2  bba0              CBNZ     r0,|L13.862|
0002f4  483c              LDR      r0,|L13.1000|
0002f6  6800              LDR      r0,[r0,#0]            ;1262  ; uTx4Addr
0002f8  b118              CBZ      r0,|L13.770|
0002fa  483b              LDR      r0,|L13.1000|
0002fc  6800              LDR      r0,[r0,#0]            ;1263  ; uTx4Addr
0002fe  f7fffffe          BL       free
                  |L13.770|
000302  4628              MOV      r0,r5                 ;1264
000304  f7fffffe          BL       malloc
000308  4937              LDR      r1,|L13.1000|
00030a  6008              STR      r0,[r1,#0]            ;1264  ; uTx4Addr
00030c  4608              MOV      r0,r1                 ;1265
00030e  6800              LDR      r0,[r0,#0]            ;1265  ; uTx4Addr
000310  b908              CBNZ     r0,|L13.790|
000312  2000              MOVS     r0,#0                 ;1267
000314  e6b5              B        |L13.130|
                  |L13.790|
000316  462a              MOV      r2,r5                 ;1269
000318  4631              MOV      r1,r6                 ;1269
00031a  4833              LDR      r0,|L13.1000|
00031c  6800              LDR      r0,[r0,#0]            ;1269  ; uTx4Addr
00031e  f7fffffe          BL       __aeabi_memcpy
000322  482f              LDR      r0,|L13.992|
000324  1f00              SUBS     r0,r0,#4              ;1270
000326  6800              LDR      r0,[r0,#0]            ;1270
000328  f0200001          BIC      r0,r0,#1              ;1270
00032c  492c              LDR      r1,|L13.992|
00032e  1f09              SUBS     r1,r1,#4              ;1270
000330  6008              STR      r0,[r1,#0]            ;1270
000332  482e              LDR      r0,|L13.1004|
000334  492a              LDR      r1,|L13.992|
000336  3958              SUBS     r1,r1,#0x58           ;1271
000338  6008              STR      r0,[r1,#0]            ;1271
00033a  4829              LDR      r0,|L13.992|
00033c  6005              STR      r5,[r0,#0]            ;1272
00033e  482a              LDR      r0,|L13.1000|
000340  6800              LDR      r0,[r0,#0]            ;1273  ; uTx4Addr
000342  4927              LDR      r1,|L13.992|
000344  3108              ADDS     r1,r1,#8              ;1273
000346  6008              STR      r0,[r1,#0]            ;1273
000348  4825              LDR      r0,|L13.992|
00034a  1f00              SUBS     r0,r0,#4              ;1274
00034c  6800              LDR      r0,[r0,#0]            ;1274
00034e  f0400001          ORR      r0,r0,#1              ;1274
000352  4923              LDR      r1,|L13.992|
000354  1f09              SUBS     r1,r1,#4              ;1274
000356  6008              STR      r0,[r1,#0]            ;1274
000358  4628              MOV      r0,r5                 ;1275
00035a  e692              B        |L13.130|
                  |L13.860|
00035c  e011              B        |L13.898|
                  |L13.862|
00035e  e7ff              B        |L13.864|
                  |L13.864|
000360  2700              MOVS     r7,#0                 ;1280
000362  462a              MOV      r2,r5                 ;1281
000364  4631              MOV      r1,r6                 ;1281
000366  481f              LDR      r0,|L13.996|
000368  f7fffffe          BL       FIFO_IN
00036c  4607              MOV      r7,r0                 ;1281
00036e  b93f              CBNZ     r7,|L13.896|
000370  4810              LDR      r0,|L13.948|
000372  f7fffffe          BL       USART_TxServer
000376  462a              MOV      r2,r5                 ;1286
000378  4631              MOV      r1,r6                 ;1286
00037a  480e              LDR      r0,|L13.948|
00037c  f7fffffe          BL       USART_DMASendList
                  |L13.896|
000380  e010              B        |L13.932|
                  |L13.898|
000382  2700              MOVS     r7,#0                 ;1293
000384  462a              MOV      r2,r5                 ;1294
000386  4631              MOV      r1,r6                 ;1294
000388  4816              LDR      r0,|L13.996|
00038a  f7fffffe          BL       FIFO_IN
00038e  4607              MOV      r7,r0                 ;1294
000390  b93f              CBNZ     r7,|L13.930|
000392  4808              LDR      r0,|L13.948|
000394  f7fffffe          BL       USART_TxServer
000398  462a              MOV      r2,r5                 ;1298
00039a  4631              MOV      r1,r6                 ;1298
00039c  4805              LDR      r0,|L13.948|
00039e  f7fffffe          BL       USART_DMASendList
                  |L13.930|
0003a2  bf00              NOP                            ;1300
                  |L13.932|
0003a4  e002              B        |L13.940|
                  |L13.934|
0003a6  2000              MOVS     r0,#0                 ;1304
0003a8  e66b              B        |L13.130|
                  |L13.938|
0003aa  bf00              NOP                            ;1305
                  |L13.940|
0003ac  bf00              NOP                            ;1142
0003ae  2000              MOVS     r0,#0                 ;1307
0003b0  e667              B        |L13.130|
;;;1309   /*******************************************************************************
                          ENDP

0003b2  0000              DCW      0x0000
                  |L13.948|
                          DCD      0x40004c00
                  |L13.952|
                          DCD      0xbfffbc00
                  |L13.956|
                          DCD      0x40013800
                  |L13.960|
                          DCD      0x40020000
                  |L13.964|
                          DCD      uTxLink1
                  |L13.968|
                          DCD      uTx1Addr
                  |L13.972|
                          DCD      uTxLink2
                  |L13.976|
                          DCD      uTx2Addr
                  |L13.980|
                          DCD      0x40004800
                  |L13.984|
                          DCD      uTxLink3
                  |L13.988|
                          DCD      uTx3Addr
                  |L13.992|
                          DCD      0x4002045c
                  |L13.996|
                          DCD      uTxLink4
                  |L13.1000|
                          DCD      uTx4Addr
                  |L13.1004|
                          DCD      0x10010000

                          AREA ||i.USART_DMA_ConfigurationEV||, CODE, READONLY, ALIGN=1

                  USART_DMA_ConfigurationEV PROC
;;;541    *******************************************************************************/
;;;542    void	USART_DMA_ConfigurationEV(
000000  b57f              PUSH     {r0-r6,lr}
;;;543    																USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;544    																u32 USART_BaudRate,			//波特率
;;;545    																u16 BufferSize					//设定接收缓冲区大小
;;;546    )	//USART_DMA配置--查询方式，不开中断,偶校验
;;;547    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;548    	//1)**********定义变量	
;;;549    	
;;;550    	USART_InitTypeDef USART_InitStructure;				//USART结构体
;;;551      //2)******************************GPIO配置	
;;;552    	USART_GPIO_Initialize(USARTx);	//串口GPIO配置
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       USART_GPIO_Initialize
;;;553    	
;;;554    	//3.3)**********初始化串口参数
;;;555    	USART_DeInit(USARTx);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       USART_DeInit
;;;556    	USART_InitStructure.USART_BaudRate 		= USART_BaudRate; 			//波特率
000014  9400              STR      r4,[sp,#0]
;;;557    	USART_InitStructure.USART_WordLength 	= USART_WordLength_9b;	//数据位
000016  f44f5080          MOV      r0,#0x1000
00001a  f8ad0004          STRH     r0,[sp,#4]
;;;558    	USART_InitStructure.USART_StopBits 		= USART_StopBits_1;			//停止位
00001e  2000              MOVS     r0,#0
000020  f8ad0006          STRH     r0,[sp,#6]
;;;559    	USART_InitStructure.USART_Parity 			= USART_Parity_Even ; 	//偶校验
000024  f44f6080          MOV      r0,#0x400
000028  f8ad0008          STRH     r0,[sp,#8]
;;;560    	USART_InitStructure.USART_Mode				= USART_Mode_Rx | USART_Mode_Tx;
00002c  200c              MOVS     r0,#0xc
00002e  f8ad000a          STRH     r0,[sp,#0xa]
;;;561    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//流控
000032  2000              MOVS     r0,#0
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;562    	USART_Init(USARTx, &USART_InitStructure);											//初始化串口
000038  4669              MOV      r1,sp
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       USART_Init
;;;563    	
;;;564    
;;;565    	USART_ITConfig(USARTx,USART_IT_IDLE, DISABLE);					//使用空闲中断，DMA自动接收，检测到总线空闲表示发送端已经发送完成，数据保存在DMA缓冲器中
000040  2200              MOVS     r2,#0
000042  f2404124          MOV      r1,#0x424
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       USART_ITConfig
;;;566    	USART_ClearITPendingBit(USARTx,USART_IT_IDLE); 					//清除空闲串口标志位
00004c  f2404124          MOV      r1,#0x424
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       USART_ClearITPendingBit
;;;567    	
;;;568    	USART_Cmd(USARTx, ENABLE);
000056  2101              MOVS     r1,#1
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       USART_Cmd
;;;569      
;;;570      //2)******************************DMA
;;;571      USART_DMA_Initialize	(USARTx,BufferSize);	//USART_DMA配置--查询方式，不开中断
00005e  4629              MOV      r1,r5
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       USART_DMA_Initialize
;;;572    }
000066  bd7f              POP      {r0-r6,pc}
;;;573    /*******************************************************************************
                          ENDP


                          AREA ||i.USART_DMA_ConfigurationIDLEIT||, CODE, READONLY, ALIGN=2

                  USART_DMA_ConfigurationIDLEIT PROC
;;;425    *******************************************************************************/
;;;426    void	USART_DMA_ConfigurationIDLEIT(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;427    																USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;428    																u32 USART_BaudRate,			//波特率
;;;429    																u16 BufferSize					//设定接收缓冲区大小
;;;430    )	//USART_DMA配置--查询方式，不开中断
;;;431    {
000004  b086              SUB      sp,sp,#0x18
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
;;;432    	//1)**********定义变量	
;;;433    	USART_InitTypeDef USART_InitStructure;				//USART结构体	
;;;434    	GPIO_InitTypeDef GPIO_InitStructure;					//GPIO结构体
;;;435    	
;;;436    	u16 TXD_Pin=0;																//串口发送脚
00000c  2700              MOVS     r7,#0
;;;437    	u16 RXD_Pin=0;																//串口接收脚
00000e  46b8              MOV      r8,r7
;;;438    
;;;439    	GPIO_TypeDef* GPIO_TX=0;
000010  46b9              MOV      r9,r7
;;;440    	GPIO_TypeDef* GPIO_RX=0;
000012  46ba              MOV      r10,r7
;;;441    	switch(*(u32*)&USARTx)
000014  4964              LDR      r1,|L15.424|
000016  1a68              SUBS     r0,r5,r1
000018  428d              CMP      r5,r1
00001a  d05c              BEQ      |L15.214|
00001c  dc06              BGT      |L15.44|
00001e  4863              LDR      r0,|L15.428|
000020  4428              ADD      r0,r0,r5
000022  b308              CBZ      r0,|L15.104|
000024  f5b06f80          CMP      r0,#0x400
000028  d171              BNE      |L15.270|
00002a  e034              B        |L15.150|
                  |L15.44|
00002c  f5b06f80          CMP      r0,#0x400
000030  d069              BEQ      |L15.262|
000032  f5b04f6c          CMP      r0,#0xec00
000036  d16a              BNE      |L15.270|
;;;442    	{
;;;443    		case 	USART1_BASE:
;;;444    					if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
000038  b924              CBNZ     r4,|L15.68|
;;;445    						SetDmaSize.nUSART1=uRxSize;
00003a  f44f7000          MOV      r0,#0x200
00003e  495c              LDR      r1,|L15.432|
000040  8008              STRH     r0,[r1,#0]
000042  e001              B        |L15.72|
                  |L15.68|
;;;446    					else
;;;447    						SetDmaSize.nUSART1=BufferSize;					
000044  485a              LDR      r0,|L15.432|
000046  8004              STRH     r4,[r0,#0]
                  |L15.72|
;;;448    
;;;449    					GPIO_TX=GPIOA;
000048  f8df9168          LDR      r9,|L15.436|
;;;450    					GPIO_RX=GPIOA;
00004c  46ca              MOV      r10,r9
;;;451    					TXD_Pin=GPIO_Pin_9;											//USART1-TX>PA9
00004e  f44f7700          MOV      r7,#0x200
;;;452    					RXD_Pin=GPIO_Pin_10;										//USART1-RX>PA10
000052  f44f6880          MOV      r8,#0x400
;;;453    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO,ENABLE);
000056  2101              MOVS     r1,#1
000058  2005              MOVS     r0,#5
00005a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;454    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//USART1时钟开启			
00005e  2101              MOVS     r1,#1
000060  0388              LSLS     r0,r1,#14
000062  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;455    					break;
000066  e053              B        |L15.272|
                  |L15.104|
;;;456    		case 	USART2_BASE:
;;;457    					if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
000068  b924              CBNZ     r4,|L15.116|
;;;458    						SetDmaSize.nUSART2=uRxSize;
00006a  f44f7000          MOV      r0,#0x200
00006e  4950              LDR      r1,|L15.432|
000070  8048              STRH     r0,[r1,#2]
000072  e001              B        |L15.120|
                  |L15.116|
;;;459    					else
;;;460    						SetDmaSize.nUSART2=BufferSize;
000074  484e              LDR      r0,|L15.432|
000076  8044              STRH     r4,[r0,#2]
                  |L15.120|
;;;461    
;;;462    					GPIO_TX=GPIOA;
000078  f8df9138          LDR      r9,|L15.436|
;;;463    					GPIO_RX=GPIOA;
00007c  46ca              MOV      r10,r9
;;;464    					TXD_Pin=GPIO_Pin_2;		//USART2-TX>PA2
00007e  2704              MOVS     r7,#4
;;;465    					RXD_Pin=GPIO_Pin_3;		//USART2-RX>PA3
000080  f04f0808          MOV      r8,#8
;;;466    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
000084  2101              MOVS     r1,#1
000086  2004              MOVS     r0,#4
000088  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;467    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	//USART2时钟开启		
00008c  2101              MOVS     r1,#1
00008e  0448              LSLS     r0,r1,#17
000090  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;468    					break;
000094  e03c              B        |L15.272|
                  |L15.150|
;;;469    		case 	USART3_BASE:
;;;470    					if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
000096  b924              CBNZ     r4,|L15.162|
;;;471    						SetDmaSize.nUSART3=uRxSize;
000098  f44f7000          MOV      r0,#0x200
00009c  4944              LDR      r1,|L15.432|
00009e  8088              STRH     r0,[r1,#4]
0000a0  e001              B        |L15.166|
                  |L15.162|
;;;472    					else
;;;473    						SetDmaSize.nUSART3=BufferSize;
0000a2  4843              LDR      r0,|L15.432|
0000a4  8084              STRH     r4,[r0,#4]
                  |L15.166|
;;;474    
;;;475    					GPIO_TX=GPIOB;
0000a6  f8df9110          LDR      r9,|L15.440|
;;;476    					GPIO_RX=GPIOB;
0000aa  46ca              MOV      r10,r9
;;;477    					TXD_Pin=GPIO_Pin_10;	//USART3-TX>PB10
0000ac  f44f6780          MOV      r7,#0x400
;;;478    					RXD_Pin=GPIO_Pin_11;	//USART3-RX>PB11
0000b0  f44f6800          MOV      r8,#0x800
;;;479    					
;;;480    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);				//关闭AFIO时钟,为关闭JTAG功能
0000b4  2101              MOVS     r1,#1
0000b6  4608              MOV      r0,r1
0000b8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;481    					GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  //关闭JTAG功能
0000bc  2101              MOVS     r1,#1
0000be  483f              LDR      r0,|L15.444|
0000c0  f7fffffe          BL       GPIO_PinRemapConfig
;;;482    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
0000c4  2101              MOVS     r1,#1
0000c6  2008              MOVS     r0,#8
0000c8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;483    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);	//USART3时钟开启		
0000cc  2101              MOVS     r1,#1
0000ce  0488              LSLS     r0,r1,#18
0000d0  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;484    					break;
0000d4  e01c              B        |L15.272|
                  |L15.214|
;;;485    		case 	UART4_BASE:
;;;486    					if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
0000d6  b924              CBNZ     r4,|L15.226|
;;;487    						SetDmaSize.nUART4=uRxSize;
0000d8  f44f7000          MOV      r0,#0x200
0000dc  4934              LDR      r1,|L15.432|
0000de  80c8              STRH     r0,[r1,#6]
0000e0  e001              B        |L15.230|
                  |L15.226|
;;;488    					else
;;;489    						SetDmaSize.nUART4=BufferSize;
0000e2  4833              LDR      r0,|L15.432|
0000e4  80c4              STRH     r4,[r0,#6]
                  |L15.230|
;;;490    
;;;491    					GPIO_TX=GPIOC;
0000e6  f8df90d8          LDR      r9,|L15.448|
;;;492    					GPIO_RX=GPIOC;
0000ea  46ca              MOV      r10,r9
;;;493    					TXD_Pin=GPIO_Pin_10;	//USART1-TX>PC10
0000ec  f44f6780          MOV      r7,#0x400
;;;494    					RXD_Pin=GPIO_Pin_11;	//USART1-RX>PC11
0000f0  f44f6800          MOV      r8,#0x800
;;;495    					
;;;496    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_AFIO,ENABLE);
0000f4  2101              MOVS     r1,#1
0000f6  2011              MOVS     r0,#0x11
0000f8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;497    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);	//UART4时钟开启	
0000fc  2101              MOVS     r1,#1
0000fe  04c8              LSLS     r0,r1,#19
000100  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;498    					break;
000104  e004              B        |L15.272|
                  |L15.262|
;;;499    		case 	UART5_BASE:
;;;500    					//UART5不支持DMA
;;;501    					return;
;;;502    		default :break;
;;;503    	}
;;;504    	//3)**********初始化串口
;;;505    	//3.1)**********初始化TXD引脚
;;;506    	GPIO_InitStructure.GPIO_Pin = TXD_Pin;
;;;507    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;508    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;509    	GPIO_Init(GPIO_TX,&GPIO_InitStructure);
;;;510    
;;;511    	//3.2)**********初始化RXD引脚
;;;512    	GPIO_InitStructure.GPIO_Pin = RXD_Pin;
;;;513    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;							//上拉输入
;;;514    	GPIO_Init(GPIO_RX,&GPIO_InitStructure);
;;;515    	
;;;516    	//3.3)**********初始化串口参数
;;;517    	USART_DeInit(USARTx);
;;;518    	USART_InitStructure.USART_BaudRate    = USART_BaudRate; 					      //波特率
;;;519    	USART_InitStructure.USART_WordLength  = USART_WordLength_8b;		        //数据位
;;;520    	USART_InitStructure.USART_StopBits    = USART_StopBits_1;				        //停止位
;;;521    	USART_InitStructure.USART_Parity      = USART_Parity_No ; 					    //奇偶校验
;;;522    	USART_InitStructure.USART_Mode        = USART_Mode_Rx | USART_Mode_Tx;
;;;523    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//流控
;;;524    	USART_Init(USARTx, &USART_InitStructure);											//初始化串口	
;;;525    
;;;526    	USART_ITConfig(USARTx,USART_IT_IDLE, ENABLE);				//使用空闲中断，DMA自动接收，检测到总线空闲表示发送端已经发送完成，数据保存在DMA缓冲器中
;;;527    	USART_ITConfig(USARTx,USART_IT_TC, ENABLE);					//发送完成中断
;;;528    	USART_ClearITPendingBit(USARTx,USART_IT_IDLE); 				//清除空闲串口标志位
;;;529    	USART_ClearITPendingBit(USARTx,USART_IT_TC); 					//清除发送完成中断标志位
;;;530    	
;;;531    	USART_Cmd(USARTx, ENABLE);
;;;532      //2)******************************DMA
;;;533      USART_DMA_Initialize	(USARTx,BufferSize);	//USART_DMA配置--查询方式，不开中断
;;;534    
;;;535    }
000106  b006              ADD      sp,sp,#0x18
000108  e8bd87f0          POP      {r4-r10,pc}
00010c  e7ff              B        |L15.270|
                  |L15.270|
00010e  bf00              NOP                            ;502
                  |L15.272|
000110  bf00              NOP                            ;455
000112  f8ad7004          STRH     r7,[sp,#4]            ;506
000116  2018              MOVS     r0,#0x18              ;507
000118  f88d0007          STRB     r0,[sp,#7]            ;507
00011c  2003              MOVS     r0,#3                 ;508
00011e  f88d0006          STRB     r0,[sp,#6]            ;508
000122  a901              ADD      r1,sp,#4              ;509
000124  4648              MOV      r0,r9                 ;509
000126  f7fffffe          BL       GPIO_Init
00012a  f8ad8004          STRH     r8,[sp,#4]            ;512
00012e  2048              MOVS     r0,#0x48              ;513
000130  f88d0007          STRB     r0,[sp,#7]            ;513
000134  a901              ADD      r1,sp,#4              ;514
000136  4650              MOV      r0,r10                ;514
000138  f7fffffe          BL       GPIO_Init
00013c  4628              MOV      r0,r5                 ;517
00013e  f7fffffe          BL       USART_DeInit
000142  9602              STR      r6,[sp,#8]            ;518
000144  2000              MOVS     r0,#0                 ;519
000146  f8ad000c          STRH     r0,[sp,#0xc]          ;519
00014a  f8ad000e          STRH     r0,[sp,#0xe]          ;520
00014e  f8ad0010          STRH     r0,[sp,#0x10]         ;521
000152  200c              MOVS     r0,#0xc               ;522
000154  f8ad0012          STRH     r0,[sp,#0x12]         ;522
000158  2000              MOVS     r0,#0                 ;523
00015a  f8ad0014          STRH     r0,[sp,#0x14]         ;523
00015e  a902              ADD      r1,sp,#8              ;524
000160  4628              MOV      r0,r5                 ;524
000162  f7fffffe          BL       USART_Init
000166  2201              MOVS     r2,#1                 ;526
000168  f2404124          MOV      r1,#0x424             ;526
00016c  4628              MOV      r0,r5                 ;526
00016e  f7fffffe          BL       USART_ITConfig
000172  2201              MOVS     r2,#1                 ;527
000174  f2406126          MOV      r1,#0x626             ;527
000178  4628              MOV      r0,r5                 ;527
00017a  f7fffffe          BL       USART_ITConfig
00017e  f2404124          MOV      r1,#0x424             ;528
000182  4628              MOV      r0,r5                 ;528
000184  f7fffffe          BL       USART_ClearITPendingBit
000188  f2406126          MOV      r1,#0x626             ;529
00018c  4628              MOV      r0,r5                 ;529
00018e  f7fffffe          BL       USART_ClearITPendingBit
000192  2101              MOVS     r1,#1                 ;531
000194  4628              MOV      r0,r5                 ;531
000196  f7fffffe          BL       USART_Cmd
00019a  4621              MOV      r1,r4                 ;533
00019c  4628              MOV      r0,r5                 ;533
00019e  f7fffffe          BL       USART_DMA_Initialize
0001a2  bf00              NOP      
0001a4  e7af              B        |L15.262|
;;;536    /*******************************************************************************
                          ENDP

0001a6  0000              DCW      0x0000
                  |L15.424|
                          DCD      0x40004c00
                  |L15.428|
                          DCD      0xbfffbc00
                  |L15.432|
                          DCD      SetDmaSize
                  |L15.436|
                          DCD      0x40010800
                  |L15.440|
                          DCD      0x40010c00
                  |L15.444|
                          DCD      0x00300200
                  |L15.448|
                          DCD      0x40011000

                          AREA ||i.USART_DMA_ConfigurationIT||, CODE, READONLY, ALIGN=1

                  USART_DMA_ConfigurationIT PROC
;;;613    *******************************************************************************/
;;;614    void	USART_DMA_ConfigurationIT(
000000  b570              PUSH     {r4-r6,lr}
;;;615    																USART_TypeDef* USARTx,			//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;616    																u32 USART_BaudRate,					//波特率
;;;617    																u32 BufferSize							//设定接收缓冲区大小
;;;618    )	//USART_DMA配置--中断方式
;;;619    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;620      //2)******************************GPIO配置
;;;621      USART_GPIO_Initialize(USARTx);                //串口GPIO配置
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_GPIO_Initialize
;;;622      //2)******************************中断配置
;;;623      USART_IT_Initialize(USARTx);	                //串口中断配置	
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       USART_IT_Initialize
;;;624    	
;;;625    	USART_ITConfig(USARTx,USART_IT_IDLE, ENABLE);					//使用空闲中断，DMA自动接收，检测到总线空闲表示发送端已经发送完成，数据保存在DMA缓冲器中
000014  2201              MOVS     r2,#1
000016  f2404124          MOV      r1,#0x424
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       USART_ITConfig
;;;626    	USART_ClearITPendingBit(USARTx,USART_IT_IDLE); 				//清除空闲串口标志位
000020  f2404124          MOV      r1,#0x424
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       USART_ClearITPendingBit
;;;627    	
;;;628    	USART_Cmd(USARTx, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       USART_Cmd
;;;629      
;;;630      //2)******************************DMA
;;;631      USART_DMA_Initialize	(USARTx,BufferSize);	//USART_DMA配置--查询方式，不开中断
000032  b2a1              UXTH     r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       USART_DMA_Initialize
;;;632    }
00003a  bd70              POP      {r4-r6,pc}
;;;633    
                          ENDP


                          AREA ||i.USART_DMA_ConfigurationNR||, CODE, READONLY, ALIGN=1

                  USART_DMA_ConfigurationNR PROC
;;;390    *******************************************************************************/
;;;391    void	USART_DMA_ConfigurationNR(
000000  b57f              PUSH     {r0-r6,lr}
;;;392    																USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;393    																u32 USART_BaudRate,			//波特率
;;;394    																u16 BufferSize					//设定接收缓冲区大小
;;;395    )	//USART_DMA配置--查询方式，不开中断
;;;396    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;397    	//1)**********定义变量	
;;;398    
;;;399    	USART_InitTypeDef USART_InitStructure;				//USART结构体	
;;;400      //2)******************************GPIO配置
;;;401      USART_GPIO_Initialize(USARTx);	//串口GPIO配置
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       USART_GPIO_Initialize
;;;402    	
;;;403    	//3.3)**********初始化串口参数
;;;404    	USART_DeInit(USARTx);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       USART_DeInit
;;;405    	USART_InitStructure.USART_BaudRate    = USART_BaudRate; 					  //波特率
000014  9400              STR      r4,[sp,#0]
;;;406    	USART_InitStructure.USART_WordLength  = USART_WordLength_8b;		    //数据位
000016  2000              MOVS     r0,#0
000018  f8ad0004          STRH     r0,[sp,#4]
;;;407    	USART_InitStructure.USART_StopBits    = USART_StopBits_1;				    //停止位
00001c  f8ad0006          STRH     r0,[sp,#6]
;;;408    	USART_InitStructure.USART_Parity      = USART_Parity_No ; 					//奇偶校验
000020  f8ad0008          STRH     r0,[sp,#8]
;;;409    	USART_InitStructure.USART_Mode        = USART_Mode_Rx | USART_Mode_Tx;
000024  200c              MOVS     r0,#0xc
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;410    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//流控
00002a  2000              MOVS     r0,#0
00002c  f8ad000c          STRH     r0,[sp,#0xc]
;;;411    	USART_Init(USARTx, &USART_InitStructure);											//初始化串口
000030  4669              MOV      r1,sp
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       USART_Init
;;;412    	
;;;413      USART_ITConfig(USARTx,USART_IT_IDLE, DISABLE);					//使用空闲中断，DMA自动接收，检测到总线空闲表示发送端已经发送完成，数据保存在DMA缓冲器中
000038  2200              MOVS     r2,#0
00003a  f2404124          MOV      r1,#0x424
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       USART_ITConfig
;;;414    	USART_ClearITPendingBit(USARTx,USART_IT_IDLE); 					//清除空闲串口标志位
000044  f2404124          MOV      r1,#0x424
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       USART_ClearITPendingBit
;;;415    //	
;;;416    	USART_Cmd(USARTx, ENABLE);
00004e  2101              MOVS     r1,#1
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       USART_Cmd
;;;417      //2)******************************DMA
;;;418    	USART_DMA_Initialize	(USARTx,BufferSize);	//USART_DMA配置--查询方式，不开中断
000056  4629              MOV      r1,r5
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       USART_DMA_Initialize
;;;419    }
00005e  bd7f              POP      {r0-r6,pc}
;;;420    /*******************************************************************************
                          ENDP


                          AREA ||i.USART_DMA_ConfigurationNRRemap||, CODE, READONLY, ALIGN=2

                  USART_DMA_ConfigurationNRRemap PROC
;;;639    *******************************************************************************/
;;;640    void	USART_DMA_ConfigurationNRRemap(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;641    																USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;642    																u32 USART_BaudRate,			//波特率
;;;643    																u32 *RXDBuffer,					//接收缓冲区地址::发送缓冲区地址在发送数据时设定，串口配置时借用接收缓冲区地址
;;;644    																u32 BufferSize					//设定接收缓冲区大小
;;;645    )	//USART_DMA配置--查询方式，不开中断
;;;646    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4693              MOV      r11,r2
00000c  461d              MOV      r5,r3
;;;647    	//1)**********定义变量	
;;;648    	USART_InitTypeDef USART_InitStructure;				//USART结构体	
;;;649    	GPIO_InitTypeDef GPIO_InitStructure;					//GPIO结构体
;;;650    	
;;;651    	u16 TXD_Pin=0;																//串口发送脚
00000e  2700              MOVS     r7,#0
;;;652    	u16 RXD_Pin=0;																//串口接收脚
000010  46b8              MOV      r8,r7
;;;653    	GPIO_TypeDef* GPIO_TX=0;
000012  46b9              MOV      r9,r7
;;;654    	GPIO_TypeDef* GPIO_RX=0;
000014  46ba              MOV      r10,r7
;;;655    //	u8 USARTx_IRQChannel=0;
;;;656    	//2)******************************配置相关GPIO/串口时钟打开
;;;657    	//2.1)**********USART1
;;;658    	if(USARTx==USART1)
000016  485b              LDR      r0,|L18.388|
000018  4284              CMP      r4,r0
00001a  d114              BNE      |L18.70|
;;;659    	{
;;;660    		
;;;661    		SetDmaSize.nUSART1=BufferSize;
00001c  495a              LDR      r1,|L18.392|
00001e  800d              STRH     r5,[r1,#0]
;;;662    		
;;;663    		TXD_Pin=GPIO_Pin_6;									  //USART1-TX>PA9
000020  2740              MOVS     r7,#0x40
;;;664    		RXD_Pin=GPIO_Pin_7;										//USART1-RX>PA10
000022  f04f0880          MOV      r8,#0x80
;;;665    		
;;;666    		GPIO_TX=GPIOB;
000026  f8df9164          LDR      r9,|L18.396|
;;;667    		GPIO_RX=GPIOB;
00002a  46ca              MOV      r10,r9
;;;668    		
;;;669    //		USARTx_IRQChannel=USART1_IRQChannel;		//中断
;;;670    		
;;;671    		GPIO_PinRemapConfig(GPIO_Remap_USART1,ENABLE);				//I/O口重映射开启
00002c  2101              MOVS     r1,#1
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       GPIO_PinRemapConfig
;;;672    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO,ENABLE);
000034  2101              MOVS     r1,#1
000036  2009              MOVS     r0,#9
000038  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;673    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//USART1时钟开启
00003c  2101              MOVS     r1,#1
00003e  0388              LSLS     r0,r1,#14
000040  f7fffffe          BL       RCC_APB2PeriphClockCmd
000044  e05d              B        |L18.258|
                  |L18.70|
;;;674    
;;;675    	}
;;;676    	//2.2)**********USART2
;;;677    	else if(USARTx==USART2)
000046  4852              LDR      r0,|L18.400|
000048  4284              CMP      r4,r0
00004a  d110              BNE      |L18.110|
;;;678    	{
;;;679    		SetDmaSize.nUSART2=BufferSize;
00004c  494e              LDR      r1,|L18.392|
00004e  804d              STRH     r5,[r1,#2]
;;;680    		
;;;681    		TXD_Pin=GPIO_Pin_2;		//USART2-TX>PA2
000050  2704              MOVS     r7,#4
;;;682    		RXD_Pin=GPIO_Pin_3;		//USART2-RX>PA3
000052  f04f0808          MOV      r8,#8
;;;683    		
;;;684    		GPIO_TX=GPIOA;
000056  f8df913c          LDR      r9,|L18.404|
;;;685    		GPIO_RX=GPIOA;
00005a  46ca              MOV      r10,r9
;;;686    		
;;;687    //		USARTx_IRQChannel=USART2_IRQChannel;		//中断
;;;688    		
;;;689    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
00005c  2101              MOVS     r1,#1
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;690    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	//USART1时钟开启
000064  2101              MOVS     r1,#1
000066  0448              LSLS     r0,r1,#17
000068  f7fffffe          BL       RCC_APB1PeriphClockCmd
00006c  e049              B        |L18.258|
                  |L18.110|
;;;691    
;;;692    	}
;;;693    	//2.3)**********USART3
;;;694    	else if(USARTx==USART3)
00006e  484a              LDR      r0,|L18.408|
000070  4284              CMP      r4,r0
000072  d118              BNE      |L18.166|
;;;695    	{
;;;696    		SetDmaSize.nUSART3=BufferSize;
000074  4944              LDR      r1,|L18.392|
000076  808d              STRH     r5,[r1,#4]
;;;697    		
;;;698    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);				//关闭AFIO时钟,为关闭JTAG功能
000078  2101              MOVS     r1,#1
00007a  4608              MOV      r0,r1
00007c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;699    		GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  //关闭JTAG功能
000080  2101              MOVS     r1,#1
000082  4846              LDR      r0,|L18.412|
000084  f7fffffe          BL       GPIO_PinRemapConfig
;;;700    //		GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);  		//关闭SWD功能
;;;701    		
;;;702    		
;;;703    		TXD_Pin=GPIO_Pin_10;	//USART3-TX>PB10
000088  1527              ASRS     r7,r4,#20
;;;704    		RXD_Pin=GPIO_Pin_11;	//USART3-RX>PB11
00008a  f44f6800          MOV      r8,#0x800
;;;705    		
;;;706    		GPIO_TX=GPIOB;
00008e  f8df90fc          LDR      r9,|L18.396|
;;;707    		GPIO_RX=GPIOB;
000092  46ca              MOV      r10,r9
;;;708    		
;;;709    //		USARTx_IRQChannel=USART3_IRQChannel;		//中断
;;;710    		
;;;711    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
000094  2101              MOVS     r1,#1
000096  2008              MOVS     r0,#8
000098  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;712    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);	//USART1时钟开启
00009c  2101              MOVS     r1,#1
00009e  0488              LSLS     r0,r1,#18
0000a0  f7fffffe          BL       RCC_APB1PeriphClockCmd
0000a4  e02d              B        |L18.258|
                  |L18.166|
;;;713    		
;;;714    
;;;715    	}
;;;716    	//2.4)**********USART4
;;;717    	else if(USARTx==UART4)
0000a6  483e              LDR      r0,|L18.416|
0000a8  4284              CMP      r4,r0
0000aa  d110              BNE      |L18.206|
;;;718    	{
;;;719    		SetDmaSize.nUART4=BufferSize;
0000ac  4936              LDR      r1,|L18.392|
0000ae  80cd              STRH     r5,[r1,#6]
;;;720    		
;;;721    		TXD_Pin=GPIO_Pin_10;	//USART1-TX>PC10
0000b0  1507              ASRS     r7,r0,#20
;;;722    		RXD_Pin=GPIO_Pin_11;	//USART1-RX>PC11
0000b2  f44f6800          MOV      r8,#0x800
;;;723    		
;;;724    		GPIO_TX=GPIOC;
0000b6  f8df90ec          LDR      r9,|L18.420|
;;;725    		GPIO_RX=GPIOC;
0000ba  46ca              MOV      r10,r9
;;;726    		
;;;727    //		USARTx_IRQChannel=UART4_IRQChannel;		//中断
;;;728    		
;;;729    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_AFIO,ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  2011              MOVS     r0,#0x11
0000c0  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;730    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);	//USART1时钟开启
0000c4  2101              MOVS     r1,#1
0000c6  04c8              LSLS     r0,r1,#19
0000c8  f7fffffe          BL       RCC_APB1PeriphClockCmd
0000cc  e019              B        |L18.258|
                  |L18.206|
;;;731    	}
;;;732    	//2.5)**********USART5
;;;733    	else if(USARTx==UART5)
0000ce  4836              LDR      r0,|L18.424|
0000d0  4284              CMP      r4,r0
0000d2  d116              BNE      |L18.258|
;;;734    	{
;;;735    //		gUART5_BufferSizebac=BufferSize;		//-----串口5无DMA
;;;736    		
;;;737    		TXD_Pin=GPIO_Pin_12;	//USART1-TX>PC12
0000d4  1487              ASRS     r7,r0,#18
;;;738    		RXD_Pin=GPIO_Pin_2;		//USART1-RX>PD2
0000d6  f04f0804          MOV      r8,#4
;;;739    		
;;;740    		GPIO_TX=GPIOC;
0000da  f8df90c8          LDR      r9,|L18.420|
;;;741    		GPIO_RX=GPIOD;
0000de  f8dfa0cc          LDR      r10,|L18.428|
;;;742    		
;;;743    //		USARTx_IRQChannel=UART5_IRQChannel;		//中断
;;;744    		
;;;745    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
0000e2  2101              MOVS     r1,#1
0000e4  2010              MOVS     r0,#0x10
0000e6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;746    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);
0000ea  2101              MOVS     r1,#1
0000ec  2020              MOVS     r0,#0x20
0000ee  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;747    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
0000f2  2101              MOVS     r1,#1
0000f4  4608              MOV      r0,r1
0000f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;748    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);	//USART1时钟开启
0000fa  2101              MOVS     r1,#1
0000fc  0508              LSLS     r0,r1,#20
0000fe  f7fffffe          BL       RCC_APB1PeriphClockCmd
                  |L18.258|
;;;749    	}
;;;750    	//3)**********初始化串口
;;;751    	//3.1)**********初始化TXD引脚
;;;752    	GPIO_InitStructure.GPIO_Pin = TXD_Pin;
000102  f8ad7000          STRH     r7,[sp,#0]
;;;753    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000106  2018              MOVS     r0,#0x18
000108  f88d0003          STRB     r0,[sp,#3]
;;;754    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00010c  2003              MOVS     r0,#3
00010e  f88d0002          STRB     r0,[sp,#2]
;;;755    	GPIO_Init(GPIO_TX,&GPIO_InitStructure);
000112  4669              MOV      r1,sp
000114  4648              MOV      r0,r9
000116  f7fffffe          BL       GPIO_Init
;;;756    
;;;757    	//3.2)**********初始化RXD引脚
;;;758    	GPIO_InitStructure.GPIO_Pin = RXD_Pin;
00011a  f8ad8000          STRH     r8,[sp,#0]
;;;759    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;							//上拉输入
00011e  2048              MOVS     r0,#0x48
000120  f88d0003          STRB     r0,[sp,#3]
;;;760    	GPIO_Init(GPIO_RX,&GPIO_InitStructure);
000124  4669              MOV      r1,sp
000126  4650              MOV      r0,r10
000128  f7fffffe          BL       GPIO_Init
;;;761    	
;;;762    	//3.3)**********初始化串口参数
;;;763    	USART_DeInit(USARTx);
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       USART_DeInit
;;;764    	USART_InitStructure.USART_BaudRate = USART_BaudRate; 					//波特率
000132  9601              STR      r6,[sp,#4]
;;;765    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//数据位
000134  2000              MOVS     r0,#0
000136  f8ad0008          STRH     r0,[sp,#8]
;;;766    	USART_InitStructure.USART_StopBits = USART_StopBits_1;				//停止位
00013a  f8ad000a          STRH     r0,[sp,#0xa]
;;;767    	USART_InitStructure.USART_Parity = USART_Parity_No ; 					//奇偶校验
00013e  f8ad000c          STRH     r0,[sp,#0xc]
;;;768    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000142  200c              MOVS     r0,#0xc
000144  f8ad000e          STRH     r0,[sp,#0xe]
;;;769    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//流控
000148  2000              MOVS     r0,#0
00014a  f8ad0010          STRH     r0,[sp,#0x10]
;;;770    	USART_Init(USARTx, &USART_InitStructure);											//初始化串口
00014e  a901              ADD      r1,sp,#4
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       USART_Init
;;;771    	
;;;772    	USART_ITConfig(USARTx,USART_IT_IDLE, DISABLE);					//使用空闲中断，DMA自动接收，检测到总线空闲表示发送端已经发送完成，数据保存在DMA缓冲器中
000156  2200              MOVS     r2,#0
000158  f2404124          MOV      r1,#0x424
00015c  4620              MOV      r0,r4
00015e  f7fffffe          BL       USART_ITConfig
;;;773    	USART_ClearITPendingBit(USARTx,USART_IT_IDLE); 					//清除空闲串口标志位
000162  f2404124          MOV      r1,#0x424
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       USART_ClearITPendingBit
;;;774    	
;;;775    	USART_Cmd(USARTx, ENABLE);
00016c  2101              MOVS     r1,#1
00016e  4620              MOV      r0,r4
000170  f7fffffe          BL       USART_Cmd
;;;776      
;;;777      //2)******************************DMA
;;;778      USART_DMA_Initialize	(USARTx,BufferSize);	//USART_DMA配置--查询方式，不开中断
000174  b2a9              UXTH     r1,r5
000176  4620              MOV      r0,r4
000178  f7fffffe          BL       USART_DMA_Initialize
;;;779    }
00017c  b005              ADD      sp,sp,#0x14
00017e  e8bd8ff0          POP      {r4-r11,pc}
;;;780    /*******************************************************************************
                          ENDP

000182  0000              DCW      0x0000
                  |L18.388|
                          DCD      0x40013800
                  |L18.392|
                          DCD      SetDmaSize
                  |L18.396|
                          DCD      0x40010c00
                  |L18.400|
                          DCD      0x40004400
                  |L18.404|
                          DCD      0x40010800
                  |L18.408|
                          DCD      0x40004800
                  |L18.412|
                          DCD      0x00300200
                  |L18.416|
                          DCD      0x40004c00
                  |L18.420|
                          DCD      0x40011000
                  |L18.424|
                          DCD      0x40005000
                  |L18.428|
                          DCD      0x40011400

                          AREA ||i.USART_DMA_ConfigurationOD||, CODE, READONLY, ALIGN=1

                  USART_DMA_ConfigurationOD PROC
;;;578    *******************************************************************************/
;;;579    void	USART_DMA_ConfigurationOD(
000000  b57f              PUSH     {r0-r6,lr}
;;;580    																USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;581    																u32 USART_BaudRate,			//波特率
;;;582    																u16 BufferSize					//设定接收缓冲区大小
;;;583    )	//USART_DMA配置--查询方式，不开中断--奇校验
;;;584    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;585    	//1)**********定义变量	
;;;586    	USART_InitTypeDef USART_InitStructure;				//USART结构体
;;;587      //2)******************************GPIO配置	
;;;588    	USART_GPIO_Initialize(USARTx);	//串口GPIO配置
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       USART_GPIO_Initialize
;;;589    		
;;;590    	//3.3)**********初始化串口参数
;;;591    	USART_DeInit(USARTx);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       USART_DeInit
;;;592    	USART_InitStructure.USART_BaudRate = USART_BaudRate; 					//波特率
000014  9400              STR      r4,[sp,#0]
;;;593    	USART_InitStructure.USART_WordLength = USART_WordLength_9b;		//数据位
000016  f44f5080          MOV      r0,#0x1000
00001a  f8ad0004          STRH     r0,[sp,#4]
;;;594    	USART_InitStructure.USART_StopBits = USART_StopBits_1;				//停止位
00001e  2000              MOVS     r0,#0
000020  f8ad0006          STRH     r0,[sp,#6]
;;;595    	USART_InitStructure.USART_Parity = USART_Parity_Odd ; 				//奇偶校验-奇校验
000024  f44f60c0          MOV      r0,#0x600
000028  f8ad0008          STRH     r0,[sp,#8]
;;;596    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00002c  200c              MOVS     r0,#0xc
00002e  f8ad000a          STRH     r0,[sp,#0xa]
;;;597    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//流控
000032  2000              MOVS     r0,#0
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;598    	USART_Init(USARTx, &USART_InitStructure);											//初始化串口
000038  4669              MOV      r1,sp
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       USART_Init
;;;599    	
;;;600    	USART_ITConfig(USARTx,USART_IT_IDLE, DISABLE);					//使用空闲中断，DMA自动接收，检测到总线空闲表示发送端已经发送完成，数据保存在DMA缓冲器中
000040  2200              MOVS     r2,#0
000042  f2404124          MOV      r1,#0x424
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       USART_ITConfig
;;;601    	USART_ClearITPendingBit(USARTx,USART_IT_IDLE); 					//清除空闲串口标志位
00004c  f2404124          MOV      r1,#0x424
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       USART_ClearITPendingBit
;;;602    	
;;;603    	USART_Cmd(USARTx, ENABLE);
000056  2101              MOVS     r1,#1
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       USART_Cmd
;;;604      //2)******************************DMA
;;;605      USART_DMA_Initialize	(USARTx,BufferSize);	//USART_DMA配置--查询方式，不开中断
00005e  4629              MOV      r1,r5
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       USART_DMA_Initialize
;;;606    }
000066  bd7f              POP      {r0-r6,pc}
;;;607    
                          ENDP


                          AREA ||i.USART_DMA_Initialize||, CODE, READONLY, ALIGN=2

                  USART_DMA_Initialize PROC
;;;135    *******************************************************************************/
;;;136    void	USART_DMA_Initialize(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;137    																USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;138    																u16 BufferSize					//设定接收缓冲区大小
;;;139    )	//USART_DMA配置--查询方式，不开中断
;;;140    {
000004  b08c              SUB      sp,sp,#0x30
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;141    	//1)**********定义变量	
;;;142    	DMA_InitTypeDef DMA_Initstructure;
;;;143    	
;;;144    	DMA_Channel_TypeDef* DMAx_Channeltx=0;			//DMA发送通道请求信号---当DMA串口发送数据完成时，会发起DMA中断
00000a  2700              MOVS     r7,#0
;;;145    	DMA_Channel_TypeDef* DMAx_Channelrx=0;			//DMA接收通道请求信号---DMA串口接收由串口发起中断，因此此处接收通道中断不使用
00000c  46b8              MOV      r8,r7
;;;146    
;;;147    	u32 DMAx_FLAG_GLtx=0;												//DMA串口发送中断全局变量			
00000e  46b9              MOV      r9,r7
;;;148    	u32 DMAx_FLAG_GLrx=0;												//DMA串口接收中断全局变量
000010  46ba              MOV      r10,r7
;;;149    	
;;;150    	u8*	RXDBuffer	=	0;
000012  2600              MOVS     r6,#0
;;;151      
;;;152     
;;;153    	
;;;154    	//2)******************************DMA
;;;155    	//4)**********根据串口索引相关DMA通道及其它参数
;;;156    	switch(*(u32*)&USARTx)
000014  4960              LDR      r1,|L20.408|
000016  1a68              SUBS     r0,r5,r1
000018  428d              CMP      r5,r1
00001a  d054              BEQ      |L20.198|
00001c  dc06              BGT      |L20.44|
00001e  485f              LDR      r0,|L20.412|
000020  4428              ADD      r0,r0,r5
000022  b300              CBZ      r0,|L20.102|
000024  f5b06f80          CMP      r0,#0x400
000028  d167              BNE      |L20.250|
00002a  e034              B        |L20.150|
                  |L20.44|
00002c  f5b06f80          CMP      r0,#0x400
000030  d060              BEQ      |L20.244|
000032  f5b04f6c          CMP      r0,#0xec00
000036  d160              BNE      |L20.250|
;;;157    	{
;;;158    		case 	USART1_BASE:
;;;159               if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
000038  b924              CBNZ     r4,|L20.68|
;;;160    						SetDmaSize.nUSART1=uRxSize;
00003a  f44f7000          MOV      r0,#0x200
00003e  4958              LDR      r1,|L20.416|
000040  8008              STRH     r0,[r1,#0]
000042  e001              B        |L20.72|
                  |L20.68|
;;;161    					else
;;;162    						SetDmaSize.nUSART1=BufferSize;
000044  4856              LDR      r0,|L20.416|
000046  8004              STRH     r4,[r0,#0]
                  |L20.72|
;;;163              RXDBuffer	=	uRx1Addr;
000048  4e56              LDR      r6,|L20.420|
;;;164    					DMAx_Channeltx=DMA1_Channel4;
00004a  4f57              LDR      r7,|L20.424|
;;;165    					DMAx_Channelrx=DMA1_Channel5;
00004c  f8df8158          LDR      r8,|L20.424|
000050  f1080814          ADD      r8,r8,#0x14
;;;166    					DMAx_FLAG_GLtx=DMA1_FLAG_GL4;
000054  f44f5980          MOV      r9,#0x1000
;;;167    					DMAx_FLAG_GLrx=DMA1_FLAG_GL5;
000058  f44f3a80          MOV      r10,#0x10000
;;;168    					RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);	
00005c  2101              MOVS     r1,#1
00005e  4608              MOV      r0,r1
000060  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;169    					break;
000064  e04a              B        |L20.252|
                  |L20.102|
;;;170    		case 	USART2_BASE:
;;;171               if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
000066  b924              CBNZ     r4,|L20.114|
;;;172    						SetDmaSize.nUSART2=uRxSize;
000068  f44f7000          MOV      r0,#0x200
00006c  494c              LDR      r1,|L20.416|
00006e  8048              STRH     r0,[r1,#2]
000070  e001              B        |L20.118|
                  |L20.114|
;;;173    					else
;;;174    						SetDmaSize.nUSART2=BufferSize;
000072  484b              LDR      r0,|L20.416|
000074  8044              STRH     r4,[r0,#2]
                  |L20.118|
;;;175              RXDBuffer	=	uRx2Addr;
000076  4e4d              LDR      r6,|L20.428|
;;;176    					DMAx_Channeltx=DMA1_Channel7;
000078  4f4b              LDR      r7,|L20.424|
00007a  373c              ADDS     r7,r7,#0x3c
;;;177    					DMAx_Channelrx=DMA1_Channel6;
00007c  f8df8128          LDR      r8,|L20.424|
000080  f1080828          ADD      r8,r8,#0x28
;;;178    					DMAx_FLAG_GLtx=DMA1_FLAG_GL7;
000084  f04f7980          MOV      r9,#0x1000000
;;;179    					DMAx_FLAG_GLrx=DMA1_FLAG_GL6;
000088  f44f1a80          MOV      r10,#0x100000
;;;180    					RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
00008c  2101              MOVS     r1,#1
00008e  4608              MOV      r0,r1
000090  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;181    					break;
000094  e032              B        |L20.252|
                  |L20.150|
;;;182    		case 	USART3_BASE:
;;;183               if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
000096  b924              CBNZ     r4,|L20.162|
;;;184    						SetDmaSize.nUSART3=uRxSize;
000098  f44f7000          MOV      r0,#0x200
00009c  4940              LDR      r1,|L20.416|
00009e  8088              STRH     r0,[r1,#4]
0000a0  e001              B        |L20.166|
                  |L20.162|
;;;185    					else
;;;186    						SetDmaSize.nUSART3=BufferSize;
0000a2  483f              LDR      r0,|L20.416|
0000a4  8084              STRH     r4,[r0,#4]
                  |L20.166|
;;;187              RXDBuffer	=	uRx3Addr;
0000a6  4e42              LDR      r6,|L20.432|
;;;188    					DMAx_Channeltx=DMA1_Channel2;
0000a8  4f3f              LDR      r7,|L20.424|
0000aa  3f28              SUBS     r7,r7,#0x28
;;;189    					DMAx_Channelrx=DMA1_Channel3;
0000ac  f8df80f8          LDR      r8,|L20.424|
0000b0  f1a80814          SUB      r8,r8,#0x14
;;;190    					DMAx_FLAG_GLtx=DMA1_FLAG_GL2;
0000b4  f04f0910          MOV      r9,#0x10
;;;191    					DMAx_FLAG_GLrx=DMA1_FLAG_GL3;
0000b8  f44f7a80          MOV      r10,#0x100
;;;192    					RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  4608              MOV      r0,r1
0000c0  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;193    					break;
0000c4  e01a              B        |L20.252|
                  |L20.198|
;;;194    		case 	UART4_BASE:
;;;195               if(BufferSize	==	0)	//如果未设定缓存大小，使用默认值
0000c6  b924              CBNZ     r4,|L20.210|
;;;196    						SetDmaSize.nUART4=uRxSize;
0000c8  f44f7000          MOV      r0,#0x200
0000cc  4934              LDR      r1,|L20.416|
0000ce  80c8              STRH     r0,[r1,#6]
0000d0  e001              B        |L20.214|
                  |L20.210|
;;;197    					else
;;;198    						SetDmaSize.nUART4=BufferSize;
0000d2  4833              LDR      r0,|L20.416|
0000d4  80c4              STRH     r4,[r0,#6]
                  |L20.214|
;;;199              RXDBuffer	=	uRx4Addr;
0000d6  4e37              LDR      r6,|L20.436|
;;;200    					DMAx_Channeltx=DMA2_Channel5;
0000d8  4f37              LDR      r7,|L20.440|
;;;201    					DMAx_Channelrx=DMA2_Channel3;
0000da  f8df80dc          LDR      r8,|L20.440|
0000de  f1a80828          SUB      r8,r8,#0x28
;;;202    					DMAx_FLAG_GLtx=DMA2_FLAG_GL5;
0000e2  f8df90d8          LDR      r9,|L20.444|
;;;203    					DMAx_FLAG_GLrx=DMA2_FLAG_GL3;
0000e6  ea4f5a39          ROR      r10,r9,#20
;;;204    					RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2,ENABLE);
0000ea  2101              MOVS     r1,#1
0000ec  2002              MOVS     r0,#2
0000ee  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;205    					break;
0000f2  e003              B        |L20.252|
                  |L20.244|
;;;206    		case 	UART5_BASE:
;;;207    					//UART5不支持DMA
;;;208    					return;
;;;209    		default :break;
;;;210    	}
;;;211    
;;;212    	//5)**********DMA发送初始化，外设作为DMA的目的端
;;;213    	DMA_Initstructure.DMA_PeripheralBaseAddr  = (u32)(&USARTx->DR);					//DMA外设源地址
;;;214    	DMA_Initstructure.DMA_MemoryBaseAddr      = (u32)RXDBuffer;							//DMA数据内存地址
;;;215    	DMA_Initstructure.DMA_DIR                 = DMA_DIR_PeripheralDST;			  //DMA_DIR_PeripheralDST（外设作为DMA的目的端），DMA_DIR_PeripheralSRC（外设作为数据传输的来源）
;;;216    	DMA_Initstructure.DMA_BufferSize          = BufferSize; 								  //指定DMA通道的DMA缓存的大小
;;;217    	DMA_Initstructure.DMA_PeripheralInc       = DMA_PeripheralInc_Disable;	  //DMA_PeripheralInc_Enable（外设地址寄存器递增），DMA_PeripheralInc_Disable（外设地址寄存器不变），
;;;218    	DMA_Initstructure.DMA_MemoryInc           = DMA_MemoryInc_Enable;				  //DMA_MemoryInc_Enable（内存地址寄存器递增），DMA_MemoryInc_Disable（内存地址寄存器不变）
;;;219    	DMA_Initstructure.DMA_PeripheralDataSize  = DMA_PeripheralDataSize_Byte;	//外设数据宽度--DMA_PeripheralDataSize_Byte（数据宽度为8位），DMA_PeripheralDataSize_HalfWord（数据宽度为16位），DMA_PeripheralDataSize_Word（数据宽度为32位）
;;;220    	DMA_Initstructure.DMA_MemoryDataSize      = DMA_MemoryDataSize_Byte;		  //内存数据宽度--DMA_MemoryDataSize_Byte（数据宽度为8位），DMA_MemoryDataSize_HalfWord（数据宽度为16位），DMA_MemoryDataSize_Word（数据宽度为32位）
;;;221    	DMA_Initstructure.DMA_Mode                = DMA_Mode_Normal;						  //DMA工作模式--DMA_Mode_Normal（只传送一次）, DMA_Mode_Circular（不停地传送）
;;;222    	DMA_Initstructure.DMA_Priority            = DMA_Priority_High; 					  //DMA通道的转输优先级--DMA_Priority_VeryHigh（非常高）DMA_Priority_High（高)，DMA_Priority_Medium（中），DMA_Priority_Low（低）
;;;223    	DMA_Initstructure.DMA_M2M                 = DMA_M2M_Disable;						  //DMA通道的内存到内存传输--DMA_M2M_Enable(设置为内存到内存传输)，DMA_M2M_Disable（非内存到内存传输）
;;;224    	DMA_Init(DMAx_Channeltx,&DMA_Initstructure);														  //初始化DMA
;;;225    
;;;226    	//6)**********DMA接收初始化，外设作为DMA的源端
;;;227    	DMA_Initstructure.DMA_PeripheralBaseAddr  = (u32)(&USARTx->DR);					//DMA外设源地址
;;;228    	DMA_Initstructure.DMA_MemoryBaseAddr      = (u32)RXDBuffer;						  //DMA数据内存地址
;;;229    	DMA_Initstructure.DMA_DIR                 = DMA_DIR_PeripheralSRC;			  //DMA_DIR_PeripheralDST（外设作为DMA的目的端），DMA_DIR_PeripheralSRC（外设作为数据传输的来源）
;;;230    	DMA_Initstructure.DMA_BufferSize          = BufferSize; 								  //指定DMA通道的DMA缓存的大小
;;;231    	DMA_Initstructure.DMA_PeripheralInc       = DMA_PeripheralInc_Disable;	  //DMA_PeripheralInc_Enable（外设地址寄存器递增），DMA_PeripheralInc_Disable（外设地址寄存器不变），
;;;232    	DMA_Initstructure.DMA_MemoryInc           = DMA_MemoryInc_Enable;				  //DMA_MemoryInc_Enable（内存地址寄存器递增），DMA_MemoryInc_Disable（内存地址寄存器不变）
;;;233    	DMA_Initstructure.DMA_PeripheralDataSize  = DMA_PeripheralDataSize_Byte; 	//外设数据宽度--DMA_PeripheralDataSize_Byte（数据宽度为8位），DMA_PeripheralDataSize_HalfWord（数据宽度为16位），DMA_PeripheralDataSize_Word（数据宽度为32位）
;;;234    	DMA_Initstructure.DMA_MemoryDataSize      = DMA_MemoryDataSize_Byte;		  //内存数据宽度--DMA_MemoryDataSize_Byte（数据宽度为8位），DMA_MemoryDataSize_HalfWord（数据宽度为16位），DMA_MemoryDataSize_Word（数据宽度为32位）
;;;235    	DMA_Initstructure.DMA_Mode                = DMA_Mode_Normal;						  //DMA工作模式--DMA_Mode_Normal（只传送一次）, DMA_Mode_Circular（不停地传送）
;;;236    	DMA_Initstructure.DMA_Priority            = DMA_Priority_High; 					  //DMA通道的转输优先级--DMA_Priority_VeryHigh（非常高）DMA_Priority_High（高)，DMA_Priority_Medium（中），DMA_Priority_Low（低）
;;;237    	DMA_Initstructure.DMA_M2M                 = DMA_M2M_Disable;						  //DMA通道的内存到内存传输--DMA_M2M_Enable(设置为内存到内存传输)，DMA_M2M_Disable（非内存到内存传输）
;;;238    	DMA_Init(DMAx_Channelrx,&DMA_Initstructure);														  //初始化DMA	
;;;239    	
;;;240    	//8)**********配置相关中断
;;;241    	//8.1)**********串口接收中断配置
;;;242    	//--将串口接收中断关闭，然后开启串口空闲中断，利用DMA自动接收串口数据
;;;243    	//--若DMA接收未开启，则使用串口接收中断
;;;244    	//--若DMA接收开启，串口接收中断应该关闭，在DMA配置中会将串口接收中断关闭
;;;245    
;;;246    	/* 启动DMA1通道5*/
;;;247    	DMA_Cmd(DMAx_Channeltx,DISABLE);				//关闭DMA发送----需要发送时再打开
;;;248    	//10.2)**********使能串口
;;;249    	DMA_Cmd(DMAx_Channelrx,ENABLE);					//打开DMA接收----自动接收串口数据	
;;;250    	//9.1)**********关闭DMA发送	
;;;251    	
;;;252    	//8.2)**********使能串口DMA方式接收
;;;253    	USART_DMACmd(USARTx,USART_DMAReq_Rx,ENABLE);
;;;254    	//8.3)**********使能串口DMA方式发送
;;;255    	USART_DMACmd(USARTx,USART_DMAReq_Tx,ENABLE);
;;;256    	//9)**********清除相关中断标志位	
;;;257    	//	DMA_Cmd(DMAx_Channeltx,ENABLE);
;;;258    	//9.2)**********使能相关DMA通道传输完成中断
;;;259    	DMA_ITConfig(DMAx_Channeltx,DMA_IT_TC, DISABLE);
;;;260    	//9.3)**********清除串口DMA方式发送中断全局标志
;;;261    	DMA_ClearFlag(DMAx_FLAG_GLtx);                                 					// 清除DMA所有标志
;;;262    	//9.3)**********清除串口DMA方式接收中断全局标志
;;;263    	DMA_ClearFlag(DMAx_FLAG_GLrx);                                 					// 清除DMA所有标志	
;;;264    }
0000f4  b00c              ADD      sp,sp,#0x30
0000f6  e8bd87f0          POP      {r4-r10,pc}
                  |L20.250|
0000fa  bf00              NOP                            ;209
                  |L20.252|
0000fc  bf00              NOP                            ;169
0000fe  1d28              ADDS     r0,r5,#4              ;213
000100  9001              STR      r0,[sp,#4]            ;213
000102  9602              STR      r6,[sp,#8]            ;214
000104  2010              MOVS     r0,#0x10              ;215
000106  9003              STR      r0,[sp,#0xc]          ;215
000108  9404              STR      r4,[sp,#0x10]         ;216
00010a  2000              MOVS     r0,#0                 ;217
00010c  9005              STR      r0,[sp,#0x14]         ;217
00010e  2080              MOVS     r0,#0x80              ;218
000110  9006              STR      r0,[sp,#0x18]         ;218
000112  2000              MOVS     r0,#0                 ;219
000114  9007              STR      r0,[sp,#0x1c]         ;219
000116  9008              STR      r0,[sp,#0x20]         ;220
000118  9009              STR      r0,[sp,#0x24]         ;221
00011a  f44f5000          MOV      r0,#0x2000            ;222
00011e  900a              STR      r0,[sp,#0x28]         ;222
000120  2000              MOVS     r0,#0                 ;223
000122  900b              STR      r0,[sp,#0x2c]         ;223
000124  a901              ADD      r1,sp,#4              ;224
000126  4638              MOV      r0,r7                 ;224
000128  f7fffffe          BL       DMA_Init
00012c  1d28              ADDS     r0,r5,#4              ;227
00012e  9001              STR      r0,[sp,#4]            ;227
000130  9602              STR      r6,[sp,#8]            ;228
000132  2000              MOVS     r0,#0                 ;229
000134  9003              STR      r0,[sp,#0xc]          ;229
000136  9404              STR      r4,[sp,#0x10]         ;230
000138  9005              STR      r0,[sp,#0x14]         ;231
00013a  2080              MOVS     r0,#0x80              ;232
00013c  9006              STR      r0,[sp,#0x18]         ;232
00013e  2000              MOVS     r0,#0                 ;233
000140  9007              STR      r0,[sp,#0x1c]         ;233
000142  9008              STR      r0,[sp,#0x20]         ;234
000144  9009              STR      r0,[sp,#0x24]         ;235
000146  f44f5000          MOV      r0,#0x2000            ;236
00014a  900a              STR      r0,[sp,#0x28]         ;236
00014c  2000              MOVS     r0,#0                 ;237
00014e  900b              STR      r0,[sp,#0x2c]         ;237
000150  a901              ADD      r1,sp,#4              ;238
000152  4640              MOV      r0,r8                 ;238
000154  f7fffffe          BL       DMA_Init
000158  2100              MOVS     r1,#0                 ;247
00015a  4638              MOV      r0,r7                 ;247
00015c  f7fffffe          BL       DMA_Cmd
000160  2101              MOVS     r1,#1                 ;249
000162  4640              MOV      r0,r8                 ;249
000164  f7fffffe          BL       DMA_Cmd
000168  2201              MOVS     r2,#1                 ;253
00016a  2140              MOVS     r1,#0x40              ;253
00016c  4628              MOV      r0,r5                 ;253
00016e  f7fffffe          BL       USART_DMACmd
000172  2201              MOVS     r2,#1                 ;255
000174  2180              MOVS     r1,#0x80              ;255
000176  4628              MOV      r0,r5                 ;255
000178  f7fffffe          BL       USART_DMACmd
00017c  2200              MOVS     r2,#0                 ;259
00017e  2102              MOVS     r1,#2                 ;259
000180  4638              MOV      r0,r7                 ;259
000182  f7fffffe          BL       DMA_ITConfig
000186  4648              MOV      r0,r9                 ;261
000188  f7fffffe          BL       DMA_ClearFlag
00018c  4650              MOV      r0,r10                ;263
00018e  f7fffffe          BL       DMA_ClearFlag
000192  bf00              NOP      
000194  e7ae              B        |L20.244|
;;;265    /*******************************************************************************
                          ENDP

000196  0000              DCW      0x0000
                  |L20.408|
                          DCD      0x40004c00
                  |L20.412|
                          DCD      0xbfffbc00
                  |L20.416|
                          DCD      SetDmaSize
                  |L20.420|
                          DCD      uRx1Addr
                  |L20.424|
                          DCD      0x40020044
                  |L20.428|
                          DCD      uRx2Addr
                  |L20.432|
                          DCD      uRx3Addr
                  |L20.436|
                          DCD      uRx4Addr
                  |L20.440|
                          DCD      0x40020458
                  |L20.444|
                          DCD      0x10010000

                          AREA ||i.USART_GPIO_Initialize||, CODE, READONLY, ALIGN=2

                  USART_GPIO_Initialize PROC
;;;270    *******************************************************************************/
;;;271    void	USART_GPIO_Initialize(USART_TypeDef* USARTx)	//串口GPIO配置
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;272    {
000004  4604              MOV      r4,r0
;;;273    	//1)**********定义变量	
;;;274    	GPIO_InitTypeDef GPIO_InitStructure;					//GPIO结构体
;;;275    	u16 TXD_Pin=0;																//串口发送脚
000006  2500              MOVS     r5,#0
;;;276    	u16 RXD_Pin=0;																//串口接收脚
000008  2700              MOVS     r7,#0
;;;277    	GPIO_TypeDef* GPIO_TX=0;
00000a  2600              MOVS     r6,#0
;;;278    	GPIO_TypeDef* GPIO_RX=0;
00000c  46a8              MOV      r8,r5
;;;279    	switch(*(u32*)&USARTx)
00000e  493a              LDR      r1,|L21.248|
000010  1a60              SUBS     r0,r4,r1
000012  428c              CMP      r4,r1
000014  d03c              BEQ      |L21.144|
000016  dc06              BGT      |L21.38|
000018  4838              LDR      r0,|L21.252|
00001a  4420              ADD      r0,r0,r4
00001c  b1b0              CBZ      r0,|L21.76|
00001e  f5b06f80          CMP      r0,#0x400
000022  d150              BNE      |L21.198|
000024  e01f              B        |L21.102|
                  |L21.38|
000026  f5b06f80          CMP      r0,#0x400
00002a  d03e              BEQ      |L21.170|
00002c  f5b04f6c          CMP      r0,#0xec00
000030  d149              BNE      |L21.198|
;;;280    	{
;;;281    		case 	USART1_BASE:
;;;282    					
;;;283    					GPIO_TX=GPIOA;
000032  4e33              LDR      r6,|L21.256|
;;;284    					GPIO_RX=GPIOA;
000034  46b0              MOV      r8,r6
;;;285    					TXD_Pin=GPIO_Pin_9;											//USART1-TX>PA9
000036  1575              ASRS     r5,r6,#21
;;;286    					RXD_Pin=GPIO_Pin_10;										//USART1-RX>PA10
000038  006f              LSLS     r7,r5,#1
;;;287    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO,ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2005              MOVS     r0,#5
00003e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;288    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//USART1时钟开启			
000042  2101              MOVS     r1,#1
000044  0388              LSLS     r0,r1,#14
000046  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;289    					break;
00004a  e03d              B        |L21.200|
                  |L21.76|
;;;290    		case 	USART2_BASE:
;;;291    
;;;292    					GPIO_TX=GPIOA;
00004c  4e2c              LDR      r6,|L21.256|
;;;293    					GPIO_RX=GPIOA;
00004e  46b0              MOV      r8,r6
;;;294    					TXD_Pin=GPIO_Pin_2;		//USART2-TX>PA2
000050  2504              MOVS     r5,#4
;;;295    					RXD_Pin=GPIO_Pin_3;		//USART2-RX>PA3
000052  2708              MOVS     r7,#8
;;;296    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;297    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	//USART2时钟开启		
00005c  2101              MOVS     r1,#1
00005e  0448              LSLS     r0,r1,#17
000060  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;298    					break;
000064  e030              B        |L21.200|
                  |L21.102|
;;;299    		case 	USART3_BASE:
;;;300    
;;;301    					GPIO_TX=GPIOB;
000066  4e27              LDR      r6,|L21.260|
;;;302    					GPIO_RX=GPIOB;
000068  46b0              MOV      r8,r6
;;;303    					TXD_Pin=GPIO_Pin_10;	//USART3-TX>PB10
00006a  1535              ASRS     r5,r6,#20
;;;304    					RXD_Pin=GPIO_Pin_11;	//USART3-RX>PB11
00006c  006f              LSLS     r7,r5,#1
;;;305    					
;;;306    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);				//关闭AFIO时钟,为关闭JTAG功能
00006e  2101              MOVS     r1,#1
000070  4608              MOV      r0,r1
000072  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;307    					GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  //关闭JTAG功能
000076  2101              MOVS     r1,#1
000078  4823              LDR      r0,|L21.264|
00007a  f7fffffe          BL       GPIO_PinRemapConfig
;;;308    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
00007e  2101              MOVS     r1,#1
000080  2008              MOVS     r0,#8
000082  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;309    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);	//USART3时钟开启		
000086  2101              MOVS     r1,#1
000088  0488              LSLS     r0,r1,#18
00008a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;310    					break;
00008e  e01b              B        |L21.200|
                  |L21.144|
;;;311    		case 	UART4_BASE:
;;;312    
;;;313    					GPIO_TX=GPIOC;
000090  4e1e              LDR      r6,|L21.268|
;;;314    					GPIO_RX=GPIOC;
000092  46b0              MOV      r8,r6
;;;315    					TXD_Pin=GPIO_Pin_10;	//USART1-TX>PC10
000094  1535              ASRS     r5,r6,#20
;;;316    					RXD_Pin=GPIO_Pin_11;	//USART1-RX>PC11
000096  006f              LSLS     r7,r5,#1
;;;317    					
;;;318    					RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_AFIO,ENABLE);
000098  2101              MOVS     r1,#1
00009a  2011              MOVS     r0,#0x11
00009c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;319    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);	//UART4时钟开启	
0000a0  2101              MOVS     r1,#1
0000a2  04c8              LSLS     r0,r1,#19
0000a4  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;320    					break;
0000a8  e00e              B        |L21.200|
                  |L21.170|
;;;321    		case 	UART5_BASE:   //UART5不支持DMA
;;;322              GPIO_TX=GPIOC;
0000aa  4e18              LDR      r6,|L21.268|
;;;323    					GPIO_RX=GPIOD;
0000ac  f8df8060          LDR      r8,|L21.272|
;;;324    					TXD_Pin=GPIO_Pin_10;	//USART1-TX>PC12
0000b0  1535              ASRS     r5,r6,#20
;;;325    					RXD_Pin=GPIO_Pin_2; 	//USART1-RX>PD2
0000b2  2704              MOVS     r7,#4
;;;326              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|RCC_APB2Periph_AFIO,ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  2031              MOVS     r0,#0x31
0000b8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;327    					RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);	//UART4时钟开启	
0000bc  2101              MOVS     r1,#1
0000be  0508              LSLS     r0,r1,#20
0000c0  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;328    					break;
0000c4  e000              B        |L21.200|
                  |L21.198|
;;;329    		default :break;
0000c6  bf00              NOP      
                  |L21.200|
0000c8  bf00              NOP                            ;289
;;;330    	}
;;;331    	//3)**********初始化串口
;;;332    	//3.1)**********初始化TXD引脚
;;;333    	GPIO_InitStructure.GPIO_Pin = TXD_Pin;
0000ca  f8ad5000          STRH     r5,[sp,#0]
;;;334    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000ce  2018              MOVS     r0,#0x18
0000d0  f88d0003          STRB     r0,[sp,#3]
;;;335    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000d4  2003              MOVS     r0,#3
0000d6  f88d0002          STRB     r0,[sp,#2]
;;;336    	GPIO_Init(GPIO_TX,&GPIO_InitStructure);
0000da  4669              MOV      r1,sp
0000dc  4630              MOV      r0,r6
0000de  f7fffffe          BL       GPIO_Init
;;;337    
;;;338    	//3.2)**********初始化RXD引脚
;;;339    	GPIO_InitStructure.GPIO_Pin = RXD_Pin;
0000e2  f8ad7000          STRH     r7,[sp,#0]
;;;340    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;							//上拉输入
0000e6  2048              MOVS     r0,#0x48
0000e8  f88d0003          STRB     r0,[sp,#3]
;;;341    	GPIO_Init(GPIO_RX,&GPIO_InitStructure);
0000ec  4669              MOV      r1,sp
0000ee  4640              MOV      r0,r8
0000f0  f7fffffe          BL       GPIO_Init
;;;342    }
0000f4  e8bd83f8          POP      {r3-r9,pc}
;;;343    /*******************************************************************************
                          ENDP

                  |L21.248|
                          DCD      0x40004c00
                  |L21.252|
                          DCD      0xbfffbc00
                  |L21.256|
                          DCD      0x40010800
                  |L21.260|
                          DCD      0x40010c00
                  |L21.264|
                          DCD      0x00300200
                  |L21.268|
                          DCD      0x40011000
                  |L21.272|
                          DCD      0x40011400

                          AREA ||i.USART_IT_Initialize||, CODE, READONLY, ALIGN=2

                  USART_IT_Initialize PROC
;;;348    *******************************************************************************/
;;;349    void	USART_IT_Initialize(USART_TypeDef* USARTx)	//串口GPIO配置
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;350    {
000004  4604              MOV      r4,r0
;;;351    	//1)**********定义变量
;;;352      NVIC_InitTypeDef 	NVIC_InitStructure; 					//NVIC结构体
;;;353      u8 USARTx_IRQChannel=0;
000006  2500              MOVS     r5,#0
;;;354      
;;;355    	GPIO_InitTypeDef GPIO_InitStructure;					//GPIO结构体
;;;356    	u16 TXD_Pin=0;																//串口发送脚
000008  2600              MOVS     r6,#0
;;;357    	u16 RXD_Pin=0;																//串口接收脚
00000a  2700              MOVS     r7,#0
;;;358    	GPIO_TypeDef* GPIO_TX=0;
00000c  46a8              MOV      r8,r5
;;;359    	GPIO_TypeDef* GPIO_RX=0;
00000e  46a9              MOV      r9,r5
;;;360    	switch(*(u32*)&USARTx)
000010  4915              LDR      r1,|L22.104|
000012  1a60              SUBS     r0,r4,r1
000014  428c              CMP      r4,r1
000016  d013              BEQ      |L22.64|
000018  dc06              BGT      |L22.40|
00001a  4814              LDR      r0,|L22.108|
00001c  4420              ADD      r0,r0,r4
00001e  b158              CBZ      r0,|L22.56|
000020  f5b06f80          CMP      r0,#0x400
000024  d110              BNE      |L22.72|
000026  e009              B        |L22.60|
                  |L22.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d00a              BEQ      |L22.68|
00002e  f5b04f6c          CMP      r0,#0xec00
000032  d109              BNE      |L22.72|
;;;361    	{
;;;362    		case 	USART1_BASE:
;;;363    					USARTx_IRQChannel=USART1_IRQChannel;		//中断			
000034  2525              MOVS     r5,#0x25
;;;364    					break;
000036  e008              B        |L22.74|
                  |L22.56|
;;;365    		case 	USART2_BASE:
;;;366              USARTx_IRQChannel=USART2_IRQChannel;		//中断	
000038  2526              MOVS     r5,#0x26
;;;367    					break;
00003a  e006              B        |L22.74|
                  |L22.60|
;;;368    		case 	USART3_BASE:
;;;369              USARTx_IRQChannel=USART3_IRQChannel;		//中断					break;
00003c  2527              MOVS     r5,#0x27
;;;370    		case 	UART4_BASE:
00003e  bf00              NOP      
                  |L22.64|
;;;371              USARTx_IRQChannel=UART4_IRQChannel;		//中断
000040  2534              MOVS     r5,#0x34
;;;372    					break;
000042  e002              B        |L22.74|
                  |L22.68|
;;;373    		case 	UART5_BASE:   //UART5不支持DMA
;;;374              USARTx_IRQChannel=UART5_IRQChannel;		//中断	
000044  2535              MOVS     r5,#0x35
;;;375    					break;
000046  e000              B        |L22.74|
                  |L22.72|
;;;376    		default :break;
000048  bf00              NOP      
                  |L22.74|
00004a  bf00              NOP                            ;364
;;;377    	}
;;;378    	//4)**********串口全局中断初始化
;;;379    	NVIC_InitStructure.NVIC_IRQChannel = USARTx_IRQChannel;
00004c  f88d5000          STRB     r5,[sp,#0]
;;;380    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;     //默认1
000050  2001              MOVS     r0,#1
000052  f88d0001          STRB     r0,[sp,#1]
;;;381    	NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;              //默认1
000056  f88d0002          STRB     r0,[sp,#2]
;;;382    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00005a  f88d0003          STRB     r0,[sp,#3]
;;;383    	NVIC_Init(&NVIC_InitStructure);
00005e  4668              MOV      r0,sp
000060  f7fffffe          BL       NVIC_Init
;;;384    }
000064  e8bd83f8          POP      {r3-r9,pc}
;;;385    /*******************************************************************************
                          ENDP

                  |L22.104|
                          DCD      0x40004c00
                  |L22.108|
                          DCD      0xbfffbc00

                          AREA ||i.USART_Process||, CODE, READONLY, ALIGN=2

                  USART_Process PROC
;;;1990   
;;;1991   void USART_Process(void)		//串口服务程序	
000000  b510              PUSH     {r4,lr}
;;;1992   {
;;;1993     USART_TxServer(USART1);
000002  4808              LDR      r0,|L23.36|
000004  f7fffffe          BL       USART_TxServer
;;;1994     USART_TxServer(USART2);
000008  4807              LDR      r0,|L23.40|
00000a  f7fffffe          BL       USART_TxServer
;;;1995     USART_TxServer(USART3);
00000e  4807              LDR      r0,|L23.44|
000010  f7fffffe          BL       USART_TxServer
;;;1996     USART_TxServer(UART4);
000014  4806              LDR      r0,|L23.48|
000016  f7fffffe          BL       USART_TxServer
;;;1997     USART_TxServer(UART5);
00001a  4806              LDR      r0,|L23.52|
00001c  f7fffffe          BL       USART_TxServer
;;;1998   }
000020  bd10              POP      {r4,pc}
;;;1999   
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      0x40013800
                  |L23.40|
                          DCD      0x40004400
                  |L23.44|
                          DCD      0x40004800
                  |L23.48|
                          DCD      0x40004c00
                  |L23.52|
                          DCD      0x40005000

                          AREA ||i.USART_ReadBufferIDLE||, CODE, READONLY, ALIGN=2

                  USART_ReadBufferIDLE PROC
;;;785    *******************************************************************************/
;;;786    u16	USART_ReadBufferIDLE(
000000  b570              PUSH     {r4-r6,lr}
;;;787    											USART_TypeDef* USARTx,	//串口号--USART1,USART2,USART3,UART4;//UART5不支持DMA
;;;788    											u8 *RevBuffer						//数据保存缓冲区地址，如果串口的接收到数据，将数据拷贝到RevBuffer
;;;789    )	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数
;;;790    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;791    	u16 length=0;
000006  2400              MOVS     r4,#0
;;;792    	switch(*(u32*)&USARTx)
000008  497f              LDR      r1,|L24.520|
00000a  1a68              SUBS     r0,r5,r1
00000c  428d              CMP      r5,r1
00000e  d07d              BEQ      |L24.268|
000010  dc07              BGT      |L24.34|
000012  487e              LDR      r0,|L24.524|
000014  4428              ADD      r0,r0,r5
000016  2800              CMP      r0,#0
000018  d040              BEQ      |L24.156|
00001a  f5b06f80          CMP      r0,#0x400
                  |L24.30|
00001e  d176              BNE      |L24.270|
000020  e07b              B        |L24.282|
                  |L24.34|
000022  f5b06f80          CMP      r0,#0x400
000026  d073              BEQ      |L24.272|
000028  f5b04f6c          CMP      r0,#0xec00
00002c  d1f7              BNE      |L24.30|
;;;793    	{
;;;794    		case 	USART1_BASE:
;;;795    					if(USART_GetITStatus(USART1,USART_IT_IDLE)||USART_GetFlagStatus(USART1,USART_FLAG_IDLE))
00002e  f2404124          MOV      r1,#0x424
000032  4877              LDR      r0,|L24.528|
000034  f7fffffe          BL       USART_GetITStatus
000038  b920              CBNZ     r0,|L24.68|
00003a  2110              MOVS     r1,#0x10
00003c  4874              LDR      r0,|L24.528|
00003e  f7fffffe          BL       USART_GetFlagStatus
000042  b350              CBZ      r0,|L24.154|
                  |L24.68|
;;;796    					{
;;;797    						USART_ClearITPendingBit(USART1,USART_IT_IDLE); 							//清除空闲串口标志位
000044  f2404124          MOV      r1,#0x424
000048  4871              LDR      r0,|L24.528|
00004a  f7fffffe          BL       USART_ClearITPendingBit
;;;798    						USART_ClearFlag(USART1,USART_FLAG_IDLE); 										//清除空闲串口标志位
00004e  2110              MOVS     r1,#0x10
000050  486f              LDR      r0,|L24.528|
000052  f7fffffe          BL       USART_ClearFlag
;;;799    
;;;800    						DMA1_Channel5->CCR &= (u32)0xFFFFFFFE;											//DMA_Cmd(DMA1_Channel5,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
000056  486f              LDR      r0,|L24.532|
000058  6d80              LDR      r0,[r0,#0x58]
00005a  f0200001          BIC      r0,r0,#1
00005e  496d              LDR      r1,|L24.532|
000060  6588              STR      r0,[r1,#0x58]
;;;801    						
;;;802    						//------计算接收长度及读取数据
;;;803    						USART1->DR; 																								//读出数据以完成清除标志			
000062  486b              LDR      r0,|L24.528|
000064  1d00              ADDS     r0,r0,#4
000066  8800              LDRH     r0,[r0,#0]
;;;804    						length = DMA1_Channel5->CNDTR;															//DMA_GetCurrDataCounter(DMA1_Channel5);	//得到真正接收数据个数(DMA_GetCurrDataCounter返回当前DMA通道x剩余的待传输数据数目)
000068  4608              MOV      r0,r1
00006a  6dc0              LDR      r0,[r0,#0x5c]
00006c  b284              UXTH     r4,r0
;;;805    						length=SetDmaSize.nUSART1-length;												    //设定缓冲区大小减剩余缓冲区大小得到实际接收到的数据个数
00006e  486a              LDR      r0,|L24.536|
000070  8800              LDRH     r0,[r0,#0]  ; SetDmaSize
000072  1b00              SUBS     r0,r0,r4
000074  b284              UXTH     r4,r0
;;;806    						memcpy(RevBuffer,uRx1Addr,length);													//复制指定大小的数据
000076  4622              MOV      r2,r4
000078  4968              LDR      r1,|L24.540|
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       __aeabi_memcpy
;;;807    						
;;;808    						//------重新指向接收缓冲区地址并使能DMA接收			
;;;809    						DMA1_Channel5->CMAR=(u32)uRx1Addr;							//重新设置DMA接收地址
000080  4866              LDR      r0,|L24.540|
000082  4964              LDR      r1,|L24.532|
000084  6648              STR      r0,[r1,#0x64]
;;;810    						DMA1_Channel5->CNDTR=SetDmaSize.nUSART1;			  //重新设置接收数据个数			
000086  4864              LDR      r0,|L24.536|
000088  8800              LDRH     r0,[r0,#0]  ; SetDmaSize
00008a  65c8              STR      r0,[r1,#0x5c]
;;;811    						DMA_Cmd(DMA1_Channel5,ENABLE);  								//开启接收DMA
00008c  2101              MOVS     r1,#1
00008e  4861              LDR      r0,|L24.532|
000090  3058              ADDS     r0,r0,#0x58
000092  f7fffffe          BL       DMA_Cmd
;;;812    						
;;;813    						return length;			//返回接收到的数据个数
000096  4620              MOV      r0,r4
                  |L24.152|
;;;814    					}			
;;;815    					break;
;;;816    			case 	USART2_BASE:
;;;817    					if(USART_GetITStatus(USART2,USART_IT_IDLE)||USART_GetFlagStatus(USART2,USART_FLAG_IDLE))
;;;818    					{
;;;819    						USART_ClearITPendingBit(USART2,USART_IT_IDLE); 							//清除空闲串口标志位
;;;820    						USART_ClearFlag(USART2,USART_FLAG_IDLE); 										//清除空闲串口标志位
;;;821    
;;;822    						DMA1_Channel6->CCR &= (u32)0xFFFFFFFE;											//DMA_Cmd(DMA1_Channel6,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;823    						
;;;824    						//------计算接收长度及读取数据
;;;825    						USART2->DR; 																								//读出数据以完成清除标志			
;;;826    						length = DMA1_Channel6->CNDTR;															//DMA_GetCurrDataCounter(DMA1_Channel6);	//得到真正接收数据个数(DMA_GetCurrDataCounter返回当前DMA通道x剩余的待传输数据数目)
;;;827    						length=SetDmaSize.nUSART2-length;												    //设定缓冲区大小减剩余缓冲区大小得到实际接收到的数据个数
;;;828    						memcpy(RevBuffer,uRx2Addr,length);													//复制指定大小的数据
;;;829    						
;;;830    						//------重新指向接收缓冲区地址并使能DMA接收			
;;;831    						DMA1_Channel6->CMAR=(u32)uRx2Addr;							//重新设置DMA接收地址
;;;832    						DMA1_Channel6->CNDTR=SetDmaSize.nUSART2;			  //重新设置接收数据个数
;;;833    						DMA1_Channel6->CCR |=(u32)0x00000001;						//DMA_Cmd(DMA1_Channel6,ENABLE);//DMA接收开启3						
;;;834    						return length;			//返回接收到的数据个数
;;;835    					}			
;;;836    					break;
;;;837    			case 	USART3_BASE:
;;;838    					if(USART_GetITStatus(USART3,USART_IT_IDLE)||USART_GetFlagStatus(USART3,USART_FLAG_IDLE))
;;;839    					{
;;;840    						USART_ClearITPendingBit(USART3,USART_IT_IDLE); 							//清除空闲串口标志位
;;;841    						USART_ClearFlag(USART3,USART_FLAG_IDLE); 										//清除空闲串口标志位
;;;842    
;;;843    						DMA1_Channel3->CCR &= (u32)0xFFFFFFFE;											//DMA_Cmd(DMA1_Channel3,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;844    						
;;;845    						//------计算接收长度及读取数据
;;;846    						USART3->DR; 																								//读出数据以完成清除标志			
;;;847    						length = DMA1_Channel3->CNDTR;															//DMA_GetCurrDataCounter(DMA1_Channel3);	//得到真正接收数据个数(DMA_GetCurrDataCounter返回当前DMA通道x剩余的待传输数据数目)
;;;848    						length=SetDmaSize.nUSART3-length;   												//设定缓冲区大小减剩余缓冲区大小得到实际接收到的数据个数
;;;849    						memcpy(RevBuffer,uRx3Addr,length);													//复制指定大小的数据
;;;850    						
;;;851    						//------重新指向接收缓冲区地址并使能DMA接收			
;;;852    						DMA1_Channel3->CMAR=(u32)uRx3Addr;							//重新设置DMA接收地址
;;;853    						DMA1_Channel3->CNDTR=SetDmaSize.nUSART3;			  //重新设置接收数据个数
;;;854    						DMA1_Channel3->CCR |=(u32)0x00000001;						//DMA_Cmd(DMA1_Channel3,ENABLE);//DMA接收开启3						
;;;855    						return length;			//返回接收到的数据个数
;;;856    					}			
;;;857    					break;
;;;858    			case 	UART4_BASE:
;;;859    					if(USART_GetITStatus(UART4,USART_IT_IDLE)||USART_GetFlagStatus(UART4,USART_FLAG_IDLE))
;;;860    					{
;;;861    						USART_ClearITPendingBit(UART4,USART_IT_IDLE); 							//清除空闲串口标志位
;;;862    						USART_ClearFlag(UART4,USART_FLAG_IDLE); 										//清除空闲串口标志位
;;;863    
;;;864    						DMA2_Channel3->CCR &= (u32)0xFFFFFFFE;											//DMA_Cmd(DMA2_Channel3,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;865    						
;;;866    						//------计算接收长度及读取数据
;;;867    						USART2->DR; 																								//读出数据以完成清除标志			
;;;868    						length = DMA2_Channel3->CNDTR;															//DMA_GetCurrDataCounter(DMA2_Channel3);	//得到真正接收数据个数(DMA_GetCurrDataCounter返回当前DMA通道x剩余的待传输数据数目)
;;;869    						length=SetDmaSize.nUART4-length;				    								//设定缓冲区大小减剩余缓冲区大小得到实际接收到的数据个数
;;;870    						memcpy(RevBuffer,uRx4Addr,length);													//复制指定大小的数据
;;;871    						
;;;872    						//------重新指向接收缓冲区地址并使能DMA接收			
;;;873    						DMA2_Channel3->CMAR=(u32)uRx4Addr;							//重新设置DMA接收地址
;;;874    						DMA2_Channel3->CNDTR=SetDmaSize.nUART4;		    	//重新设置接收数据个数
;;;875    						DMA2_Channel3->CCR |=(u32)0x00000001;						//DMA_Cmd(DMA2_Channel3,ENABLE);//DMA接收开启3						
;;;876    						return length;			//返回接收到的数据个数
;;;877    					}			
;;;878    					break;
;;;879    			case UART5_BASE:
;;;880    					//UART5不支持DMA
;;;881    					return 0;
;;;882    		default:break;
;;;883    	}
;;;884    	return 0;
;;;885    }
000098  bd70              POP      {r4-r6,pc}
                  |L24.154|
00009a  e0b2              B        |L24.514|
                  |L24.156|
00009c  f2404124          MOV      r1,#0x424             ;817
0000a0  485a              LDR      r0,|L24.524|
0000a2  4240              RSBS     r0,r0,#0              ;817
0000a4  f7fffffe          BL       USART_GetITStatus
0000a8  b928              CBNZ     r0,|L24.182|
0000aa  2110              MOVS     r1,#0x10              ;817
0000ac  4857              LDR      r0,|L24.524|
0000ae  4240              RSBS     r0,r0,#0              ;817
0000b0  f7fffffe          BL       USART_GetFlagStatus
0000b4  b368              CBZ      r0,|L24.274|
                  |L24.182|
0000b6  f2404124          MOV      r1,#0x424             ;819
0000ba  4854              LDR      r0,|L24.524|
0000bc  4240              RSBS     r0,r0,#0              ;819
0000be  f7fffffe          BL       USART_ClearITPendingBit
0000c2  2110              MOVS     r1,#0x10              ;820
0000c4  4851              LDR      r0,|L24.524|
0000c6  4240              RSBS     r0,r0,#0              ;820
0000c8  f7fffffe          BL       USART_ClearFlag
0000cc  4851              LDR      r0,|L24.532|
0000ce  6ec0              LDR      r0,[r0,#0x6c]         ;822
0000d0  f0200001          BIC      r0,r0,#1              ;822
0000d4  494f              LDR      r1,|L24.532|
0000d6  66c8              STR      r0,[r1,#0x6c]         ;822
0000d8  4851              LDR      r0,|L24.544|
0000da  8800              LDRH     r0,[r0,#0]            ;825
0000dc  4608              MOV      r0,r1                 ;826
0000de  6f00              LDR      r0,[r0,#0x70]         ;826
0000e0  b284              UXTH     r4,r0                 ;826
0000e2  484d              LDR      r0,|L24.536|
0000e4  8840              LDRH     r0,[r0,#2]            ;827  ; SetDmaSize
0000e6  1b00              SUBS     r0,r0,r4              ;827
0000e8  b284              UXTH     r4,r0                 ;827
0000ea  4622              MOV      r2,r4                 ;828
0000ec  494d              LDR      r1,|L24.548|
0000ee  4630              MOV      r0,r6                 ;828
0000f0  f7fffffe          BL       __aeabi_memcpy
0000f4  484b              LDR      r0,|L24.548|
0000f6  4947              LDR      r1,|L24.532|
0000f8  6788              STR      r0,[r1,#0x78]         ;831
0000fa  4847              LDR      r0,|L24.536|
0000fc  8840              LDRH     r0,[r0,#2]            ;832  ; SetDmaSize
0000fe  6708              STR      r0,[r1,#0x70]         ;832
000100  4608              MOV      r0,r1                 ;833
000102  6ec0              LDR      r0,[r0,#0x6c]         ;833
000104  f0400001          ORR      r0,r0,#1              ;833
000108  66c8              STR      r0,[r1,#0x6c]         ;833
00010a  e003              B        |L24.276|
                  |L24.268|
00010c  e03c              B        |L24.392|
                  |L24.270|
00010e  e077              B        |L24.512|
                  |L24.272|
000110  e074              B        |L24.508|
                  |L24.274|
000112  e001              B        |L24.280|
                  |L24.276|
000114  4620              MOV      r0,r4                 ;834
000116  e7bf              B        |L24.152|
                  |L24.280|
000118  e073              B        |L24.514|
                  |L24.282|
00011a  f2404124          MOV      r1,#0x424             ;838
00011e  4842              LDR      r0,|L24.552|
000120  f7fffffe          BL       USART_GetITStatus
000124  b920              CBNZ     r0,|L24.304|
000126  2110              MOVS     r1,#0x10              ;838
000128  483f              LDR      r0,|L24.552|
00012a  f7fffffe          BL       USART_GetFlagStatus
00012e  b350              CBZ      r0,|L24.390|
                  |L24.304|
000130  f2404124          MOV      r1,#0x424             ;840
000134  483c              LDR      r0,|L24.552|
000136  f7fffffe          BL       USART_ClearITPendingBit
00013a  2110              MOVS     r1,#0x10              ;841
00013c  483a              LDR      r0,|L24.552|
00013e  f7fffffe          BL       USART_ClearFlag
000142  4834              LDR      r0,|L24.532|
000144  6b00              LDR      r0,[r0,#0x30]         ;843
000146  f0200001          BIC      r0,r0,#1              ;843
00014a  4932              LDR      r1,|L24.532|
00014c  6308              STR      r0,[r1,#0x30]         ;843
00014e  4836              LDR      r0,|L24.552|
000150  1d00              ADDS     r0,r0,#4              ;846
000152  8800              LDRH     r0,[r0,#0]            ;846
000154  4608              MOV      r0,r1                 ;847
000156  6b40              LDR      r0,[r0,#0x34]         ;847
000158  b284              UXTH     r4,r0                 ;847
00015a  482f              LDR      r0,|L24.536|
00015c  8880              LDRH     r0,[r0,#4]            ;848  ; SetDmaSize
00015e  1b00              SUBS     r0,r0,r4              ;848
000160  b284              UXTH     r4,r0                 ;848
000162  4622              MOV      r2,r4                 ;849
000164  4931              LDR      r1,|L24.556|
000166  4630              MOV      r0,r6                 ;849
000168  f7fffffe          BL       __aeabi_memcpy
00016c  482f              LDR      r0,|L24.556|
00016e  4929              LDR      r1,|L24.532|
000170  63c8              STR      r0,[r1,#0x3c]         ;852
000172  4829              LDR      r0,|L24.536|
000174  8880              LDRH     r0,[r0,#4]            ;853  ; SetDmaSize
000176  6348              STR      r0,[r1,#0x34]         ;853
000178  4608              MOV      r0,r1                 ;854
00017a  6b00              LDR      r0,[r0,#0x30]         ;854
00017c  f0400001          ORR      r0,r0,#1              ;854
000180  6308              STR      r0,[r1,#0x30]         ;854
000182  4620              MOV      r0,r4                 ;855
000184  e788              B        |L24.152|
                  |L24.390|
000186  e03c              B        |L24.514|
                  |L24.392|
000188  f2404124          MOV      r1,#0x424             ;859
00018c  481e              LDR      r0,|L24.520|
00018e  f7fffffe          BL       USART_GetITStatus
000192  b920              CBNZ     r0,|L24.414|
000194  2110              MOVS     r1,#0x10              ;859
000196  481c              LDR      r0,|L24.520|
000198  f7fffffe          BL       USART_GetFlagStatus
00019c  b368              CBZ      r0,|L24.506|
                  |L24.414|
00019e  f2404124          MOV      r1,#0x424             ;861
0001a2  4819              LDR      r0,|L24.520|
0001a4  f7fffffe          BL       USART_ClearITPendingBit
0001a8  2110              MOVS     r1,#0x10              ;862
0001aa  4817              LDR      r0,|L24.520|
0001ac  f7fffffe          BL       USART_ClearFlag
0001b0  481f              LDR      r0,|L24.560|
0001b2  6800              LDR      r0,[r0,#0]            ;864
0001b4  f0200001          BIC      r0,r0,#1              ;864
0001b8  491d              LDR      r1,|L24.560|
0001ba  6008              STR      r0,[r1,#0]            ;864
0001bc  4818              LDR      r0,|L24.544|
0001be  8800              LDRH     r0,[r0,#0]            ;867
0001c0  1d08              ADDS     r0,r1,#4              ;868
0001c2  6800              LDR      r0,[r0,#0]            ;868
0001c4  b284              UXTH     r4,r0                 ;868
0001c6  4814              LDR      r0,|L24.536|
0001c8  88c0              LDRH     r0,[r0,#6]            ;869  ; SetDmaSize
0001ca  1b00              SUBS     r0,r0,r4              ;869
0001cc  b284              UXTH     r4,r0                 ;869
0001ce  4622              MOV      r2,r4                 ;870
0001d0  4918              LDR      r1,|L24.564|
0001d2  4630              MOV      r0,r6                 ;870
0001d4  f7fffffe          BL       __aeabi_memcpy
0001d8  4816              LDR      r0,|L24.564|
0001da  4915              LDR      r1,|L24.560|
0001dc  310c              ADDS     r1,r1,#0xc            ;873
0001de  6008              STR      r0,[r1,#0]            ;873
0001e0  480d              LDR      r0,|L24.536|
0001e2  88c0              LDRH     r0,[r0,#6]            ;874  ; SetDmaSize
0001e4  4912              LDR      r1,|L24.560|
0001e6  1d09              ADDS     r1,r1,#4              ;874
0001e8  6008              STR      r0,[r1,#0]            ;874
0001ea  1f08              SUBS     r0,r1,#4              ;875
0001ec  6800              LDR      r0,[r0,#0]            ;875
0001ee  f0400001          ORR      r0,r0,#1              ;875
0001f2  1f09              SUBS     r1,r1,#4              ;875
0001f4  6008              STR      r0,[r1,#0]            ;875
0001f6  4620              MOV      r0,r4                 ;876
0001f8  e74e              B        |L24.152|
                  |L24.506|
0001fa  e002              B        |L24.514|
                  |L24.508|
0001fc  2000              MOVS     r0,#0                 ;881
0001fe  e74b              B        |L24.152|
                  |L24.512|
000200  bf00              NOP                            ;882
                  |L24.514|
000202  bf00              NOP                            ;815
000204  2000              MOVS     r0,#0                 ;884
000206  e747              B        |L24.152|
;;;886    
                          ENDP

                  |L24.520|
                          DCD      0x40004c00
                  |L24.524|
                          DCD      0xbfffbc00
                  |L24.528|
                          DCD      0x40013800
                  |L24.532|
                          DCD      0x40020000
                  |L24.536|
                          DCD      SetDmaSize
                  |L24.540|
                          DCD      uRx1Addr
                  |L24.544|
                          DCD      0x40004404
                  |L24.548|
                          DCD      uRx2Addr
                  |L24.552|
                          DCD      0x40004800
                  |L24.556|
                          DCD      uRx3Addr
                  |L24.560|
                          DCD      0x40020430
                  |L24.564|
                          DCD      uRx4Addr

                          AREA ||i.USART_RxServer||, CODE, READONLY, ALIGN=1

                  USART_RxServer PROC
;;;1977   
;;;1978   void USART_RxServer(USART_TypeDef* USARTx)		//串口接收服务程序	
000000  4770              BX       lr
;;;1979   {
;;;1980   
;;;1981   }
;;;1982   /*******************************************************************************
                          ENDP


                          AREA ||i.USART_Send||, CODE, READONLY, ALIGN=1

                  USART_Send PROC
;;;1824   *******************************************************************************/
;;;1825   void	USART_Send(USART_TypeDef* USARTx,u8* TxdBuffer,u16 Lengh)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1826   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1827   	u8 Temp	=	0;
00000a  f04f0800          MOV      r8,#0
;;;1828   	u16	Len	=	0;
00000e  2600              MOVS     r6,#0
;;;1829   	while(Len<Lengh)
000010  e00f              B        |L26.50|
                  |L26.18|
;;;1830   	{
;;;1831   		while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE)!=SET)
000012  bf00              NOP      
                  |L26.20|
000014  2180              MOVS     r1,#0x80
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2801              CMP      r0,#1
00001e  d1f9              BNE      |L26.20|
;;;1832   		{			
;;;1833   		}
;;;1834   		Temp=*TxdBuffer;
000020  f8948000          LDRB     r8,[r4,#0]
;;;1835   		USART_SendData(USARTx, Temp);
000024  4641              MOV      r1,r8
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       USART_SendData
;;;1836   		TxdBuffer++;
00002c  1c64              ADDS     r4,r4,#1
;;;1837   		Len++;
00002e  1c70              ADDS     r0,r6,#1
000030  b286              UXTH     r6,r0
                  |L26.50|
000032  42ae              CMP      r6,r5                 ;1829
000034  dbed              BLT      |L26.18|
;;;1838   	}
;;;1839   }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;1840   /*******************************************************************************
                          ENDP


                          AREA ||i.USART_Status||, CODE, READONLY, ALIGN=2

                  USART_Status PROC
;;;1314   *******************************************************************************/
;;;1315   USARTStatusDef	USART_Status(USART_TypeDef* USARTx)		//串口状态检查
000000  b5f8              PUSH     {r3-r7,lr}
;;;1316   {
000002  4606              MOV      r6,r0
;;;1317     unsigned short	BufferSize	=	0;			//剩余缓存大小
000004  2400              MOVS     r4,#0
;;;1318     
;;;1319   	USARTStatusDef	Status;
;;;1320   	FlagStatus bitstatus = RESET;
000006  2500              MOVS     r5,#0
;;;1321     
;;;1322     Status.USART_IDLESTD  = 0;
000008  f89d0000          LDRB     r0,[sp,#0]
00000c  f0200001          BIC      r0,r0,#1
000010  9000              STR      r0,[sp,#0]
;;;1323   	
;;;1324   	switch(*(u32*)&USARTx)
000012  48c6              LDR      r0,|L27.812|
000014  4430              ADD      r0,r0,r6
000016  2800              CMP      r0,#0
000018  d061              BEQ      |L27.222|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d07a              BEQ      |L27.278|
000020  f5b06f00          CMP      r0,#0x800
000024  d078              BEQ      |L27.280|
000026  f5b04f74          CMP      r0,#0xf400
00002a  d176              BNE      |L27.282|
;;;1325   	{
;;;1326   		case USART1_BASE:
;;;1327   				//接收状态检查
;;;1328   				BufferSize	=	DMA1_Channel5->CNDTR;		      //获取DMA接收缓存剩余空间
00002c  48c0              LDR      r0,|L27.816|
00002e  6dc0              LDR      r0,[r0,#0x5c]
000030  b284              UXTH     r4,r0
;;;1329   				if(BufferSize<SetDmaSize.nUSART1)	          //可用缓存小于预设大小，表示已使用
000032  48c0              LDR      r0,|L27.820|
000034  8800              LDRH     r0,[r0,#0]  ; SetDmaSize
000036  42a0              CMP      r0,r4
000038  dd22              BLE      |L27.128|
;;;1330   				{
;;;1331   					if(RemaDmaSize.nUSART1	== BufferSize)    //查询可用缓存大小是否继续在变化从而判断是否还在接收中
00003a  48bf              LDR      r0,|L27.824|
00003c  8800              LDRH     r0,[r0,#0]  ; RemaDmaSize
00003e  42a0              CMP      r0,r4
000040  d110              BNE      |L27.100|
;;;1332   					{
;;;1333   						RetryCount.nUSART1++;
000042  48be              LDR      r0,|L27.828|
000044  8800              LDRH     r0,[r0,#0]  ; RetryCount
000046  1c40              ADDS     r0,r0,#1
000048  49bc              LDR      r1,|L27.828|
00004a  8008              STRH     r0,[r1,#0]
;;;1334   						if(RetryCount.nUSART1>=5)               //连续5次查询未变化表示接收完成
00004c  4608              MOV      r0,r1
00004e  8800              LDRH     r0,[r0,#0]  ; RetryCount
000050  2805              CMP      r0,#5
000052  db15              BLT      |L27.128|
;;;1335   						{
;;;1336   							RetryCount.nUSART1	  =	0;
000054  2000              MOVS     r0,#0
000056  8008              STRH     r0,[r1,#0]
;;;1337                 Status.USART_IDLESTD  = 0;            //空闲
000058  f89d0000          LDRB     r0,[sp,#0]
00005c  f0200001          BIC      r0,r0,#1
000060  9000              STR      r0,[sp,#0]
000062  e00d              B        |L27.128|
                  |L27.100|
;;;1338   						}
;;;1339   					}
;;;1340             //还在接收中
;;;1341   					else
;;;1342   					{
;;;1343   						RemaDmaSize.nUSART1		=	BufferSize;   	//更新
000064  48b4              LDR      r0,|L27.824|
000066  8004              STRH     r4,[r0,#0]
;;;1344               Status.USART_IDLESTD  = 1;             	//非空闲
000068  f89d0000          LDRB     r0,[sp,#0]
00006c  f0200001          BIC      r0,r0,#1
000070  1c40              ADDS     r0,r0,#1
000072  9000              STR      r0,[sp,#0]
;;;1345               Status.USART_ReceSTD  = 1;           		//正在接收中
000074  f89d0000          LDRB     r0,[sp,#0]
000078  f0200002          BIC      r0,r0,#2
00007c  1c80              ADDS     r0,r0,#2
00007e  9000              STR      r0,[sp,#0]
                  |L27.128|
;;;1346   					}					
;;;1347   				}
;;;1348   				//发送状态检查
;;;1349   				if((DMA1_Channel4->CNDTR!=0)&&((DMA1_Channel4->CCR&0x00000001)!=0))   //还在发送中
000080  48ab              LDR      r0,|L27.816|
000082  6c80              LDR      r0,[r0,#0x48]
000084  b188              CBZ      r0,|L27.170|
000086  48aa              LDR      r0,|L27.816|
000088  6c40              LDR      r0,[r0,#0x44]
00008a  f0000001          AND      r0,r0,#1
00008e  b160              CBZ      r0,|L27.170|
;;;1350   				{
;;;1351             Status.USART_IDLESTD  = 1;        //非空闲
000090  f89d0000          LDRB     r0,[sp,#0]
000094  f0200001          BIC      r0,r0,#1
000098  1c40              ADDS     r0,r0,#1
00009a  9000              STR      r0,[sp,#0]
;;;1352             Status.USART_SendSTD  = 1;        //正在发送中
00009c  f89d0000          LDRB     r0,[sp,#0]
0000a0  f0200004          BIC      r0,r0,#4
0000a4  1d00              ADDS     r0,r0,#4
0000a6  9000              STR      r0,[sp,#0]
0000a8  e018              B        |L27.220|
                  |L27.170|
;;;1353   				}
;;;1354   				else
;;;1355   				{
;;;1356   					bitstatus	=	USART_GetFlagStatus(USART1,USART_FLAG_TC);		//检测发送数据寄存器是否为空	RESET-非空，SET-空，
0000aa  2140              MOVS     r1,#0x40
0000ac  48a4              LDR      r0,|L27.832|
0000ae  f7fffffe          BL       USART_GetFlagStatus
0000b2  4605              MOV      r5,r0
;;;1357   					if(bitstatus	!=	SET)
0000b4  2d01              CMP      r5,#1
0000b6  d00c              BEQ      |L27.210|
;;;1358             {
;;;1359   						Status.USART_IDLESTD  = 1;        //非空闲
0000b8  f89d0000          LDRB     r0,[sp,#0]
0000bc  f0200001          BIC      r0,r0,#1
0000c0  1c40              ADDS     r0,r0,#1
0000c2  9000              STR      r0,[sp,#0]
;;;1360               Status.USART_SendSTD  = 1;        //正在发送中            
0000c4  f89d0000          LDRB     r0,[sp,#0]
0000c8  f0200004          BIC      r0,r0,#4
0000cc  1d00              ADDS     r0,r0,#4
0000ce  9000              STR      r0,[sp,#0]
0000d0  e004              B        |L27.220|
                  |L27.210|
;;;1361             }
;;;1362             else
;;;1363             {
;;;1364               Status.USART_IDLESTD  = 0;        //空闲
0000d2  f89d0000          LDRB     r0,[sp,#0]
0000d6  f0200001          BIC      r0,r0,#1
0000da  9000              STR      r0,[sp,#0]
                  |L27.220|
;;;1365             }
;;;1366   				}
;;;1367   				break;
0000dc  e120              B        |L27.800|
                  |L27.222|
;;;1368   		case USART2_BASE:
;;;1369   				//接收状态检查
;;;1370   				BufferSize	=	DMA1_Channel6->CNDTR;		//获取DMA接收缓存剩余空间
0000de  4894              LDR      r0,|L27.816|
0000e0  6f00              LDR      r0,[r0,#0x70]
0000e2  b284              UXTH     r4,r0
;;;1371   				if(BufferSize<SetDmaSize.nUSART2)	    //缓存在减小，表示在使用
0000e4  4893              LDR      r0,|L27.820|
0000e6  8840              LDRH     r0,[r0,#2]  ; SetDmaSize
0000e8  42a0              CMP      r0,r4
0000ea  dd29              BLE      |L27.320|
;;;1372   				{
;;;1373   					if(RemaDmaSize.nUSART2	== BufferSize)
0000ec  4892              LDR      r0,|L27.824|
0000ee  8840              LDRH     r0,[r0,#2]  ; RemaDmaSize
0000f0  42a0              CMP      r0,r4
0000f2  d113              BNE      |L27.284|
;;;1374   					{
;;;1375   						RetryCount.nUSART2++;
0000f4  4891              LDR      r0,|L27.828|
0000f6  8840              LDRH     r0,[r0,#2]  ; RetryCount
0000f8  1c40              ADDS     r0,r0,#1
0000fa  4990              LDR      r1,|L27.828|
0000fc  8048              STRH     r0,[r1,#2]
;;;1376   						if(RetryCount.nUSART2>=2)
0000fe  4608              MOV      r0,r1
000100  8840              LDRH     r0,[r0,#2]  ; RetryCount
000102  2802              CMP      r0,#2
000104  db1c              BLT      |L27.320|
;;;1377   						{
;;;1378   							RetryCount.nUSART2	=	0;
000106  2000              MOVS     r0,#0
000108  8048              STRH     r0,[r1,#2]
;;;1379   							Status.USART_IDLESTD  = 0;        //空闲
00010a  f89d0000          LDRB     r0,[sp,#0]
00010e  f0200001          BIC      r0,r0,#1
000112  9000              STR      r0,[sp,#0]
000114  e014              B        |L27.320|
                  |L27.278|
000116  e04a              B        |L27.430|
                  |L27.280|
000118  e0a6              B        |L27.616|
                  |L27.282|
00011a  e100              B        |L27.798|
                  |L27.284|
;;;1380   						}
;;;1381   					}
;;;1382   					else
;;;1383   					{
;;;1384   						RemaDmaSize.nUSART2	=	BufferSize;
00011c  4886              LDR      r0,|L27.824|
00011e  8044              STRH     r4,[r0,#2]
;;;1385   						Status.USART_IDLESTD  = 1;        //非空闲
000120  f89d0000          LDRB     r0,[sp,#0]
000124  f0200001          BIC      r0,r0,#1
000128  1c40              ADDS     r0,r0,#1
00012a  9000              STR      r0,[sp,#0]
;;;1386               Status.USART_ReceSTD  = 1;        //正在接收中
00012c  f89d0000          LDRB     r0,[sp,#0]
000130  f0200002          BIC      r0,r0,#2
000134  1c80              ADDS     r0,r0,#2
000136  9000              STR      r0,[sp,#0]
;;;1387   						return Status;
000138  f89d1000          LDRB     r1,[sp,#0]
00013c  4608              MOV      r0,r1
                  |L27.318|
;;;1388   					}
;;;1389   				}
;;;1390   				//发送状态检查
;;;1391   				if((DMA1_Channel7->CNDTR!=0)&&((DMA1_Channel7->CCR&0x00000001)!=0))
;;;1392   				{
;;;1393   					Status.USART_IDLESTD  = 1;        //非空闲
;;;1394             Status.USART_SendSTD  = 1;        //正在发送中
;;;1395   				}
;;;1396   				else
;;;1397   				{
;;;1398   					bitstatus	=	USART_GetFlagStatus(USART2,USART_FLAG_TC);		//检测发送数据寄存器是否为空	RESET-非空，SET-空，
;;;1399   					if(bitstatus	!=	SET)
;;;1400   					{
;;;1401   						Status.USART_IDLESTD  = 1;        //非空闲
;;;1402               Status.USART_SendSTD  = 1;        //正在发送中            
;;;1403             }
;;;1404             else
;;;1405             {
;;;1406   						Status.USART_SendSTD	=	0;
;;;1407               Status.USART_IDLESTD  =	0;        //空闲
;;;1408             }
;;;1409   				}
;;;1410   				break;
;;;1411   		case USART3_BASE:
;;;1412   				//接收状态检查
;;;1413   				BufferSize	=	DMA1_Channel3->CNDTR;		//获取DMA接收缓存剩余空间
;;;1414   				if(BufferSize<SetDmaSize.nUSART3)	    //缓存在减小，表示在使用
;;;1415   				{
;;;1416   					if(RemaDmaSize.nUSART3	== BufferSize)
;;;1417   					{
;;;1418   						RetryCount.nUSART3++;
;;;1419   						if(RetryCount.nUSART3>=5)
;;;1420   						{
;;;1421   							RetryCount.nUSART3	=	0;
;;;1422   							Status.USART_IDLESTD  = 0;        //空闲
;;;1423   						}
;;;1424   					}
;;;1425   					else
;;;1426   					{
;;;1427   						RemaDmaSize.nUSART3	=	BufferSize;
;;;1428   						Status.USART_IDLESTD  = 1;        //非空闲
;;;1429               Status.USART_ReceSTD  = 1;        //正在接收中
;;;1430   						return Status;
;;;1431   					}
;;;1432   				}
;;;1433   				//发送状态检查
;;;1434   				if((DMA1_Channel2->CNDTR!=0)&&((DMA1_Channel2->CCR&0x00000001)!=0))
;;;1435   				{
;;;1436   					Status.USART_IDLESTD  = 1;        //非空闲
;;;1437             Status.USART_SendSTD  = 1;        //正在发送中
;;;1438   				}
;;;1439   				else
;;;1440   				{
;;;1441   					bitstatus	=	USART_GetFlagStatus(USART3,USART_FLAG_TC);		//检测发送数据寄存器是否为空	RESET-非空，SET-空，
;;;1442   					if(bitstatus	!=	SET)
;;;1443   					{
;;;1444   						Status.USART_IDLESTD  = 1;        //非空闲
;;;1445               Status.USART_SendSTD  = 1;        //正在发送中            
;;;1446             }
;;;1447             else
;;;1448             {
;;;1449               Status.USART_IDLESTD  = 0;        //空闲
;;;1450             }
;;;1451   				}
;;;1452   				break;
;;;1453   		case UART4_BASE:
;;;1454   				//接收状态检查
;;;1455   				BufferSize	=	DMA2_Channel3->CNDTR;		//获取DMA接收缓存剩余空间
;;;1456   				if(BufferSize<SetDmaSize.nUART4)	    //缓存在减小，表示在使用
;;;1457   				{
;;;1458   					if(RemaDmaSize.nUART4	== BufferSize)
;;;1459   					{
;;;1460   						RetryCount.nUART4++;
;;;1461   						if(RetryCount.nUART4>=5)
;;;1462   						{
;;;1463   							RetryCount.nUART4	=	0;
;;;1464   							Status.USART_IDLESTD  = 0;        //空闲
;;;1465   						}
;;;1466   					}
;;;1467   					else
;;;1468   					{
;;;1469   						RemaDmaSize.nUART4	=	BufferSize;
;;;1470   						Status.USART_IDLESTD  = 1;        //非空闲
;;;1471               Status.USART_ReceSTD  = 1;        //正在接收中
;;;1472   					}
;;;1473   				}
;;;1474   				//发送状态检查
;;;1475   				if((DMA2_Channel5->CNDTR!=0)&&((DMA2_Channel5->CCR&0x00000001)!=0))
;;;1476   				{
;;;1477   					Status.USART_IDLESTD  = 1;        //非空闲
;;;1478             Status.USART_SendSTD  = 1;        //正在发送中
;;;1479   				}
;;;1480   				else
;;;1481   				{
;;;1482   					bitstatus	=	USART_GetFlagStatus(UART4,USART_FLAG_TC);		//检测发送数据寄存器是否为空	RESET-非空，SET-空，
;;;1483   					if(bitstatus	!=	SET)
;;;1484   					{
;;;1485   						Status.USART_IDLESTD  = 1;        //非空闲
;;;1486               Status.USART_SendSTD  = 1;        //正在发送中            
;;;1487             }
;;;1488             else
;;;1489             {
;;;1490               Status.USART_IDLESTD  = 0;        //空闲
;;;1491             }
;;;1492   				}
;;;1493   				break;
;;;1494   		default:break;
;;;1495   	}
;;;1496   	return Status;
;;;1497   }
00013e  bdf8              POP      {r3-r7,pc}
                  |L27.320|
000140  487b              LDR      r0,|L27.816|
000142  3084              ADDS     r0,r0,#0x84           ;1391
000144  6800              LDR      r0,[r0,#0]            ;1391
000146  b190              CBZ      r0,|L27.366|
000148  4879              LDR      r0,|L27.816|
00014a  3080              ADDS     r0,r0,#0x80           ;1391
00014c  6800              LDR      r0,[r0,#0]            ;1391
00014e  f0000001          AND      r0,r0,#1              ;1391
000152  b160              CBZ      r0,|L27.366|
000154  f89d0000          LDRB     r0,[sp,#0]            ;1393
000158  f0200001          BIC      r0,r0,#1              ;1393
00015c  1c40              ADDS     r0,r0,#1              ;1393
00015e  9000              STR      r0,[sp,#0]            ;1393
000160  f89d0000          LDRB     r0,[sp,#0]            ;1394
000164  f0200004          BIC      r0,r0,#4              ;1394
000168  1d00              ADDS     r0,r0,#4              ;1394
00016a  9000              STR      r0,[sp,#0]            ;1394
00016c  e01e              B        |L27.428|
                  |L27.366|
00016e  2140              MOVS     r1,#0x40              ;1398
000170  486e              LDR      r0,|L27.812|
000172  4240              RSBS     r0,r0,#0              ;1398
000174  f7fffffe          BL       USART_GetFlagStatus
000178  4605              MOV      r5,r0                 ;1398
00017a  2d01              CMP      r5,#1                 ;1399
00017c  d00c              BEQ      |L27.408|
00017e  f89d0000          LDRB     r0,[sp,#0]            ;1401
000182  f0200001          BIC      r0,r0,#1              ;1401
000186  1c40              ADDS     r0,r0,#1              ;1401
000188  9000              STR      r0,[sp,#0]            ;1401
00018a  f89d0000          LDRB     r0,[sp,#0]            ;1402
00018e  f0200004          BIC      r0,r0,#4              ;1402
000192  1d00              ADDS     r0,r0,#4              ;1402
000194  9000              STR      r0,[sp,#0]            ;1402
000196  e009              B        |L27.428|
                  |L27.408|
000198  f89d0000          LDRB     r0,[sp,#0]            ;1406
00019c  f0200004          BIC      r0,r0,#4              ;1406
0001a0  9000              STR      r0,[sp,#0]            ;1406
0001a2  f89d0000          LDRB     r0,[sp,#0]            ;1407
0001a6  f0200001          BIC      r0,r0,#1              ;1407
0001aa  9000              STR      r0,[sp,#0]            ;1407
                  |L27.428|
0001ac  e0b8              B        |L27.800|
                  |L27.430|
0001ae  4860              LDR      r0,|L27.816|
0001b0  6b40              LDR      r0,[r0,#0x34]         ;1413
0001b2  b284              UXTH     r4,r0                 ;1413
0001b4  485f              LDR      r0,|L27.820|
0001b6  8880              LDRH     r0,[r0,#4]            ;1414  ; SetDmaSize
0001b8  42a0              CMP      r0,r4                 ;1414
0001ba  dd26              BLE      |L27.522|
0001bc  485e              LDR      r0,|L27.824|
0001be  8880              LDRH     r0,[r0,#4]            ;1416  ; RemaDmaSize
0001c0  42a0              CMP      r0,r4                 ;1416
0001c2  d110              BNE      |L27.486|
0001c4  485d              LDR      r0,|L27.828|
0001c6  8880              LDRH     r0,[r0,#4]            ;1418  ; RetryCount
0001c8  1c40              ADDS     r0,r0,#1              ;1418
0001ca  495c              LDR      r1,|L27.828|
0001cc  8088              STRH     r0,[r1,#4]            ;1418
0001ce  4608              MOV      r0,r1                 ;1419
0001d0  8880              LDRH     r0,[r0,#4]            ;1419  ; RetryCount
0001d2  2805              CMP      r0,#5                 ;1419
0001d4  db19              BLT      |L27.522|
0001d6  2000              MOVS     r0,#0                 ;1421
0001d8  8088              STRH     r0,[r1,#4]            ;1421
0001da  f89d0000          LDRB     r0,[sp,#0]            ;1422
0001de  f0200001          BIC      r0,r0,#1              ;1422
0001e2  9000              STR      r0,[sp,#0]            ;1422
0001e4  e011              B        |L27.522|
                  |L27.486|
0001e6  4854              LDR      r0,|L27.824|
0001e8  8084              STRH     r4,[r0,#4]            ;1427
0001ea  f89d0000          LDRB     r0,[sp,#0]            ;1428
0001ee  f0200001          BIC      r0,r0,#1              ;1428
0001f2  1c40              ADDS     r0,r0,#1              ;1428
0001f4  9000              STR      r0,[sp,#0]            ;1428
0001f6  f89d0000          LDRB     r0,[sp,#0]            ;1429
0001fa  f0200002          BIC      r0,r0,#2              ;1429
0001fe  1c80              ADDS     r0,r0,#2              ;1429
000200  9000              STR      r0,[sp,#0]            ;1429
000202  f89d1000          LDRB     r1,[sp,#0]            ;1430
000206  4608              MOV      r0,r1                 ;1430
000208  e799              B        |L27.318|
                  |L27.522|
00020a  4849              LDR      r0,|L27.816|
00020c  6a00              LDR      r0,[r0,#0x20]         ;1434
00020e  b188              CBZ      r0,|L27.564|
000210  4847              LDR      r0,|L27.816|
000212  69c0              LDR      r0,[r0,#0x1c]         ;1434
000214  f0000001          AND      r0,r0,#1              ;1434
000218  b160              CBZ      r0,|L27.564|
00021a  f89d0000          LDRB     r0,[sp,#0]            ;1436
00021e  f0200001          BIC      r0,r0,#1              ;1436
000222  1c40              ADDS     r0,r0,#1              ;1436
000224  9000              STR      r0,[sp,#0]            ;1436
000226  f89d0000          LDRB     r0,[sp,#0]            ;1437
00022a  f0200004          BIC      r0,r0,#4              ;1437
00022e  1d00              ADDS     r0,r0,#4              ;1437
000230  9000              STR      r0,[sp,#0]            ;1437
000232  e018              B        |L27.614|
                  |L27.564|
000234  2140              MOVS     r1,#0x40              ;1441
000236  4843              LDR      r0,|L27.836|
000238  f7fffffe          BL       USART_GetFlagStatus
00023c  4605              MOV      r5,r0                 ;1441
00023e  2d01              CMP      r5,#1                 ;1442
000240  d00c              BEQ      |L27.604|
000242  f89d0000          LDRB     r0,[sp,#0]            ;1444
000246  f0200001          BIC      r0,r0,#1              ;1444
00024a  1c40              ADDS     r0,r0,#1              ;1444
00024c  9000              STR      r0,[sp,#0]            ;1444
00024e  f89d0000          LDRB     r0,[sp,#0]            ;1445
000252  f0200004          BIC      r0,r0,#4              ;1445
000256  1d00              ADDS     r0,r0,#4              ;1445
000258  9000              STR      r0,[sp,#0]            ;1445
00025a  e004              B        |L27.614|
                  |L27.604|
00025c  f89d0000          LDRB     r0,[sp,#0]            ;1449
000260  f0200001          BIC      r0,r0,#1              ;1449
000264  9000              STR      r0,[sp,#0]            ;1449
                  |L27.614|
000266  e05b              B        |L27.800|
                  |L27.616|
000268  4837              LDR      r0,|L27.840|
00026a  6800              LDR      r0,[r0,#0]            ;1455
00026c  b284              UXTH     r4,r0                 ;1455
00026e  4831              LDR      r0,|L27.820|
000270  88c0              LDRH     r0,[r0,#6]            ;1456  ; SetDmaSize
000272  42a0              CMP      r0,r4                 ;1456
000274  dd22              BLE      |L27.700|
000276  4830              LDR      r0,|L27.824|
000278  88c0              LDRH     r0,[r0,#6]            ;1458  ; RemaDmaSize
00027a  42a0              CMP      r0,r4                 ;1458
00027c  d110              BNE      |L27.672|
00027e  482f              LDR      r0,|L27.828|
000280  88c0              LDRH     r0,[r0,#6]            ;1460  ; RetryCount
000282  1c40              ADDS     r0,r0,#1              ;1460
000284  492d              LDR      r1,|L27.828|
000286  80c8              STRH     r0,[r1,#6]            ;1460
000288  4608              MOV      r0,r1                 ;1461
00028a  88c0              LDRH     r0,[r0,#6]            ;1461  ; RetryCount
00028c  2805              CMP      r0,#5                 ;1461
00028e  db15              BLT      |L27.700|
000290  2000              MOVS     r0,#0                 ;1463
000292  80c8              STRH     r0,[r1,#6]            ;1463
000294  f89d0000          LDRB     r0,[sp,#0]            ;1464
000298  f0200001          BIC      r0,r0,#1              ;1464
00029c  9000              STR      r0,[sp,#0]            ;1464
00029e  e00d              B        |L27.700|
                  |L27.672|
0002a0  4825              LDR      r0,|L27.824|
0002a2  80c4              STRH     r4,[r0,#6]            ;1469
0002a4  f89d0000          LDRB     r0,[sp,#0]            ;1470
0002a8  f0200001          BIC      r0,r0,#1              ;1470
0002ac  1c40              ADDS     r0,r0,#1              ;1470
0002ae  9000              STR      r0,[sp,#0]            ;1470
0002b0  f89d0000          LDRB     r0,[sp,#0]            ;1471
0002b4  f0200002          BIC      r0,r0,#2              ;1471
0002b8  1c80              ADDS     r0,r0,#2              ;1471
0002ba  9000              STR      r0,[sp,#0]            ;1471
                  |L27.700|
0002bc  4822              LDR      r0,|L27.840|
0002be  3028              ADDS     r0,r0,#0x28           ;1475
0002c0  6800              LDR      r0,[r0,#0]            ;1475
0002c2  b190              CBZ      r0,|L27.746|
0002c4  4820              LDR      r0,|L27.840|
0002c6  3024              ADDS     r0,r0,#0x24           ;1475
0002c8  6800              LDR      r0,[r0,#0]            ;1475
0002ca  f0000001          AND      r0,r0,#1              ;1475
0002ce  b160              CBZ      r0,|L27.746|
0002d0  f89d0000          LDRB     r0,[sp,#0]            ;1477
0002d4  f0200001          BIC      r0,r0,#1              ;1477
0002d8  1c40              ADDS     r0,r0,#1              ;1477
0002da  9000              STR      r0,[sp,#0]            ;1477
0002dc  f89d0000          LDRB     r0,[sp,#0]            ;1478
0002e0  f0200004          BIC      r0,r0,#4              ;1478
0002e4  1d00              ADDS     r0,r0,#4              ;1478
0002e6  9000              STR      r0,[sp,#0]            ;1478
0002e8  e018              B        |L27.796|
                  |L27.746|
0002ea  2140              MOVS     r1,#0x40              ;1482
0002ec  4817              LDR      r0,|L27.844|
0002ee  f7fffffe          BL       USART_GetFlagStatus
0002f2  4605              MOV      r5,r0                 ;1482
0002f4  2d01              CMP      r5,#1                 ;1483
0002f6  d00c              BEQ      |L27.786|
0002f8  f89d0000          LDRB     r0,[sp,#0]            ;1485
0002fc  f0200001          BIC      r0,r0,#1              ;1485
000300  1c40              ADDS     r0,r0,#1              ;1485
000302  9000              STR      r0,[sp,#0]            ;1485
000304  f89d0000          LDRB     r0,[sp,#0]            ;1486
000308  f0200004          BIC      r0,r0,#4              ;1486
00030c  1d00              ADDS     r0,r0,#4              ;1486
00030e  9000              STR      r0,[sp,#0]            ;1486
000310  e004              B        |L27.796|
                  |L27.786|
000312  f89d0000          LDRB     r0,[sp,#0]            ;1490
000316  f0200001          BIC      r0,r0,#1              ;1490
00031a  9000              STR      r0,[sp,#0]            ;1490
                  |L27.796|
00031c  e000              B        |L27.800|
                  |L27.798|
00031e  bf00              NOP                            ;1494
                  |L27.800|
000320  bf00              NOP                            ;1367
000322  f89d1000          LDRB     r1,[sp,#0]            ;1496
000326  4608              MOV      r0,r1                 ;1496
000328  e709              B        |L27.318|
;;;1498   //----------------------RS485---------------------------------------------------------------------------
                          ENDP

00032a  0000              DCW      0x0000
                  |L27.812|
                          DCD      0xbfffbc00
                  |L27.816|
                          DCD      0x40020000
                  |L27.820|
                          DCD      SetDmaSize
                  |L27.824|
                          DCD      RemaDmaSize
                  |L27.828|
                          DCD      RetryCount
                  |L27.832|
                          DCD      0x40013800
                  |L27.836|
                          DCD      0x40004800
                  |L27.840|
                          DCD      0x40020434
                  |L27.844|
                          DCD      0x40004c00

                          AREA ||i.USART_TxServer||, CODE, READONLY, ALIGN=2

                  USART_TxServer PROC
;;;1848   *******************************************************************************/
;;;1849   void	USART_TxServer(USART_TypeDef* USARTx)
000000  b570              PUSH     {r4-r6,lr}
;;;1850   {
000002  4604              MOV      r4,r0
;;;1851   	switch(*(u32*)&USARTx)
000004  497d              LDR      r1,|L28.508|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d07a              BEQ      |L28.258|
00000c  dc07              BGT      |L28.30|
00000e  487c              LDR      r0,|L28.512|
000010  4420              ADD      r0,r0,r4
000012  2800              CMP      r0,#0
000014  d03b              BEQ      |L28.142|
000016  f5b06f80          CMP      r0,#0x400
                  |L28.26|
00001a  d173              BNE      |L28.260|
00001c  e074              B        |L28.264|
                  |L28.30|
00001e  f5b06f80          CMP      r0,#0x400
000022  d070              BEQ      |L28.262|
000024  f5b04f6c          CMP      r0,#0xec00
000028  d1f7              BNE      |L28.26|
;;;1852   	{
;;;1853       case  USART1_BASE:
;;;1854             if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未配置
00002a  89a0              LDRH     r0,[r4,#0xc]
00002c  f4005000          AND      r0,r0,#0x2000
000030  f5b05f00          CMP      r0,#0x2000
000034  d000              BEQ      |L28.56|
                  |L28.54|
;;;1855             {
;;;1856               return;
;;;1857             }
;;;1858             if(
;;;1859   							(DMA1_Channel4->CNDTR==0)										//通道空闲--已发完数据
;;;1860   						||((DMA1_Channel4->CCR&0x00000001)==0)				//通道未开启
;;;1861   						)
;;;1862   					{
;;;1863               if(NULL !=  uTxLink1)
;;;1864               {
;;;1865                 unsigned short 	DataLen;			//存储的数据长度
;;;1866                 free(uTx1Addr);
;;;1867                 DataLen  = FIFO_OUT(&uTxLink1,(char*)uTx1Addr);
;;;1868                 if(0  ==  DataLen)
;;;1869                 {
;;;1870                   return;
;;;1871                 }
;;;1872                 DMA1_Channel4->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel7,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1873                 DMA1->IFCR = DMA1_FLAG_GL4;										//DMA_ClearFlag(DMA1_FLAG_TC7);	//清除标志						
;;;1874                 DMA1_Channel4->CNDTR 	=DataLen;	                    //设定待发送缓冲区大小
;;;1875                 DMA1_Channel4->CMAR 	=(u32)uTx1Addr;			  //发送缓冲区
;;;1876                 DMA1_Channel4->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel7,ENABLE);//DMA发送开启3
;;;1877               }
;;;1878   					}          
;;;1879             break;
;;;1880       case  USART2_BASE:
;;;1881             if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未配置
;;;1882             {
;;;1883               return;
;;;1884             }
;;;1885             if(
;;;1886   							(DMA1_Channel7->CNDTR==0)										//通道空闲--已发完数据
;;;1887   						||((DMA1_Channel7->CCR&0x00000001)==0)				//通道未开启
;;;1888   						)
;;;1889   					{
;;;1890               if(NULL !=  uTxLink2)
;;;1891               {
;;;1892                 unsigned short 	DataLen;			//存储的数据长度
;;;1893                 free(uTx2Addr);
;;;1894                 DataLen  = FIFO_OUT(&uTxLink2,(char*)uTx2Addr);
;;;1895                 if(0  ==  DataLen)
;;;1896                 {
;;;1897                   return;
;;;1898                 }
;;;1899                 DMA1_Channel7->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel7,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1900                 DMA1->IFCR = DMA1_FLAG_GL7;										//DMA_ClearFlag(DMA1_FLAG_TC7);	//清除标志						
;;;1901                 DMA1_Channel7->CNDTR 	=DataLen;	                    //设定待发送缓冲区大小
;;;1902                 DMA1_Channel7->CMAR 	=(u32)uTx2Addr;			  //发送缓冲区
;;;1903                 DMA1_Channel7->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel7,ENABLE);//DMA发送开启3
;;;1904               }
;;;1905   					}          
;;;1906             break;
;;;1907       case  USART3_BASE:
;;;1908             if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未配置
;;;1909             {
;;;1910               return;
;;;1911             }
;;;1912             if(
;;;1913                 (DMA1_Channel2->CNDTR==0)										//通道空闲--已发完数据
;;;1914               ||((DMA1_Channel2->CCR&0x00000001)==0)				//通道未开启
;;;1915               )
;;;1916             {
;;;1917               if(NULL !=  uTxLink3)
;;;1918               {
;;;1919                 unsigned short 	DataLen;			//存储的数据长度
;;;1920                 free(uTx3Addr);
;;;1921                 DataLen  = FIFO_OUT(&uTxLink3,(char*)uTx3Addr);
;;;1922                 if(0  ==  DataLen)
;;;1923                 {
;;;1924                   return;
;;;1925                 }
;;;1926                 DMA1_Channel2->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel7,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1927                 DMA1->IFCR = DMA1_FLAG_GL2;										//DMA_ClearFlag(DMA1_FLAG_TC7);	//清除标志						
;;;1928                 DMA1_Channel2->CNDTR 	=DataLen;	                    //设定待发送缓冲区大小
;;;1929                 DMA1_Channel2->CMAR 	=(u32)uTx3Addr;			  //发送缓冲区
;;;1930                 DMA1_Channel2->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel7,ENABLE);//DMA发送开启3
;;;1931               }
;;;1932             }          
;;;1933             break;
;;;1934        case  UART4_BASE:
;;;1935              if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未配置
;;;1936               {
;;;1937                 return;
;;;1938               }
;;;1939             if(
;;;1940                 (DMA2_Channel5->CNDTR==0)										//通道空闲--已发完数据
;;;1941               ||((DMA2_Channel5->CCR&0x00000001)==0)				//通道未开启
;;;1942               )
;;;1943             {
;;;1944               if(NULL !=  uTxLink4)
;;;1945               {
;;;1946                 unsigned short 	DataLen;			//存储的数据长度
;;;1947                 free(uTx4Addr);
;;;1948                 DataLen  = FIFO_OUT(&uTxLink4,(char*)uTx4Addr);
;;;1949                 if(0  ==  DataLen)
;;;1950                 {
;;;1951                   return;
;;;1952                 }
;;;1953                 DMA2_Channel5->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel7,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;1954                 DMA2->IFCR = DMA2_FLAG_GL5;										//DMA_ClearFlag(DMA1_FLAG_TC7);	//清除标志						
;;;1955                 DMA2_Channel5->CNDTR 	=DataLen;	                    //设定待发送缓冲区大小
;;;1956                 DMA2_Channel5->CMAR 	=(u32)uTx4Addr;			  //发送缓冲区
;;;1957                 DMA2_Channel5->CCR |=(u32)0x00000001;					//DMA_Cmd(DMA1_Channel7,ENABLE);//DMA发送开启3
;;;1958               }
;;;1959             }
;;;1960         case  UART5_BASE:
;;;1961              if((u16)(USARTx->CR1 &0x2000)!= 0x2000)					//串口未配置
;;;1962               {
;;;1963                 return;
;;;1964               }
;;;1965             break;
;;;1966       default:break;
;;;1967     }
;;;1968   }
000036  bd70              POP      {r4-r6,pc}
                  |L28.56|
000038  4872              LDR      r0,|L28.516|
00003a  6c80              LDR      r0,[r0,#0x48]         ;1858
00003c  b120              CBZ      r0,|L28.72|
00003e  4871              LDR      r0,|L28.516|
000040  6c40              LDR      r0,[r0,#0x44]         ;1860
000042  f0000001          AND      r0,r0,#1              ;1860
000046  bb08              CBNZ     r0,|L28.140|
                  |L28.72|
000048  486f              LDR      r0,|L28.520|
00004a  6800              LDR      r0,[r0,#0]            ;1863  ; uTxLink1
00004c  b1f0              CBZ      r0,|L28.140|
00004e  486f              LDR      r0,|L28.524|
000050  6800              LDR      r0,[r0,#0]            ;1866  ; uTx1Addr
000052  f7fffffe          BL       free
000056  486d              LDR      r0,|L28.524|
000058  6801              LDR      r1,[r0,#0]            ;1867  ; uTx1Addr
00005a  486b              LDR      r0,|L28.520|
00005c  f7fffffe          BL       FIFO_OUT
000060  4605              MOV      r5,r0                 ;1867
000062  b905              CBNZ     r5,|L28.102|
000064  e7e7              B        |L28.54|
                  |L28.102|
000066  4867              LDR      r0,|L28.516|
000068  6c40              LDR      r0,[r0,#0x44]         ;1872
00006a  f0200001          BIC      r0,r0,#1              ;1872
00006e  4965              LDR      r1,|L28.516|
000070  6448              STR      r0,[r1,#0x44]         ;1872
000072  1488              ASRS     r0,r1,#18             ;1873
000074  6048              STR      r0,[r1,#4]            ;1873
000076  4608              MOV      r0,r1                 ;1874
000078  6485              STR      r5,[r0,#0x48]         ;1874
00007a  4864              LDR      r0,|L28.524|
00007c  6800              LDR      r0,[r0,#0]            ;1875  ; uTx1Addr
00007e  6508              STR      r0,[r1,#0x50]         ;1875
000080  4608              MOV      r0,r1                 ;1876
000082  6c40              LDR      r0,[r0,#0x44]         ;1876
000084  f0400001          ORR      r0,r0,#1              ;1876
000088  6448              STR      r0,[r1,#0x44]         ;1876
00008a  bf00              NOP                            ;1877
                  |L28.140|
00008c  e0b3              B        |L28.502|
                  |L28.142|
00008e  89a0              LDRH     r0,[r4,#0xc]          ;1881
000090  f4005000          AND      r0,r0,#0x2000         ;1881
000094  f5b05f00          CMP      r0,#0x2000            ;1881
000098  d000              BEQ      |L28.156|
00009a  e7cc              B        |L28.54|
                  |L28.156|
00009c  4859              LDR      r0,|L28.516|
00009e  3084              ADDS     r0,r0,#0x84           ;1885
0000a0  6800              LDR      r0,[r0,#0]            ;1885
0000a2  b128              CBZ      r0,|L28.176|
0000a4  4857              LDR      r0,|L28.516|
0000a6  3080              ADDS     r0,r0,#0x80           ;1887
0000a8  6800              LDR      r0,[r0,#0]            ;1887
0000aa  f0000001          AND      r0,r0,#1              ;1887
0000ae  bb38              CBNZ     r0,|L28.256|
                  |L28.176|
0000b0  4857              LDR      r0,|L28.528|
0000b2  6800              LDR      r0,[r0,#0]            ;1890  ; uTxLink2
0000b4  b320              CBZ      r0,|L28.256|
0000b6  4857              LDR      r0,|L28.532|
0000b8  6800              LDR      r0,[r0,#0]            ;1893  ; uTx2Addr
0000ba  f7fffffe          BL       free
0000be  4855              LDR      r0,|L28.532|
0000c0  6801              LDR      r1,[r0,#0]            ;1894  ; uTx2Addr
0000c2  4853              LDR      r0,|L28.528|
0000c4  f7fffffe          BL       FIFO_OUT
0000c8  4605              MOV      r5,r0                 ;1894
0000ca  b905              CBNZ     r5,|L28.206|
0000cc  e7b3              B        |L28.54|
                  |L28.206|
0000ce  484d              LDR      r0,|L28.516|
0000d0  3080              ADDS     r0,r0,#0x80           ;1899
0000d2  6800              LDR      r0,[r0,#0]            ;1899
0000d4  f0200001          BIC      r0,r0,#1              ;1899
0000d8  494a              LDR      r1,|L28.516|
0000da  f8c10080          STR      r0,[r1,#0x80]         ;1899
0000de  01c8              LSLS     r0,r1,#7              ;1900
0000e0  6048              STR      r0,[r1,#4]            ;1900
0000e2  4608              MOV      r0,r1                 ;1901
0000e4  f8c05084          STR      r5,[r0,#0x84]         ;1901
0000e8  484a              LDR      r0,|L28.532|
0000ea  6800              LDR      r0,[r0,#0]            ;1902  ; uTx2Addr
0000ec  f8c1008c          STR      r0,[r1,#0x8c]         ;1902
0000f0  4608              MOV      r0,r1                 ;1903
0000f2  f8d00080          LDR      r0,[r0,#0x80]         ;1903
0000f6  f0400001          ORR      r0,r0,#1              ;1903
0000fa  f8c10080          STR      r0,[r1,#0x80]         ;1903
0000fe  bf00              NOP                            ;1904
                  |L28.256|
000100  e079              B        |L28.502|
                  |L28.258|
000102  e033              B        |L28.364|
                  |L28.260|
000104  e076              B        |L28.500|
                  |L28.262|
000106  e06d              B        |L28.484|
                  |L28.264|
000108  89a0              LDRH     r0,[r4,#0xc]          ;1908
00010a  f4005000          AND      r0,r0,#0x2000         ;1908
00010e  f5b05f00          CMP      r0,#0x2000            ;1908
000112  d000              BEQ      |L28.278|
000114  e78f              B        |L28.54|
                  |L28.278|
000116  483b              LDR      r0,|L28.516|
000118  6a00              LDR      r0,[r0,#0x20]         ;1912
00011a  b120              CBZ      r0,|L28.294|
00011c  4839              LDR      r0,|L28.516|
00011e  69c0              LDR      r0,[r0,#0x1c]         ;1914
000120  f0000001          AND      r0,r0,#1              ;1914
000124  bb08              CBNZ     r0,|L28.362|
                  |L28.294|
000126  483c              LDR      r0,|L28.536|
000128  6800              LDR      r0,[r0,#0]            ;1917  ; uTxLink3
00012a  b1f0              CBZ      r0,|L28.362|
00012c  483b              LDR      r0,|L28.540|
00012e  6800              LDR      r0,[r0,#0]            ;1920  ; uTx3Addr
000130  f7fffffe          BL       free
000134  4839              LDR      r0,|L28.540|
000136  6801              LDR      r1,[r0,#0]            ;1921  ; uTx3Addr
000138  4837              LDR      r0,|L28.536|
00013a  f7fffffe          BL       FIFO_OUT
00013e  4605              MOV      r5,r0                 ;1921
000140  b905              CBNZ     r5,|L28.324|
000142  e778              B        |L28.54|
                  |L28.324|
000144  482f              LDR      r0,|L28.516|
000146  69c0              LDR      r0,[r0,#0x1c]         ;1926
000148  f0200001          BIC      r0,r0,#1              ;1926
00014c  492d              LDR      r1,|L28.516|
00014e  61c8              STR      r0,[r1,#0x1c]         ;1926
000150  2010              MOVS     r0,#0x10              ;1927
000152  6048              STR      r0,[r1,#4]            ;1927
000154  4608              MOV      r0,r1                 ;1928
000156  6205              STR      r5,[r0,#0x20]         ;1928
000158  4830              LDR      r0,|L28.540|
00015a  6800              LDR      r0,[r0,#0]            ;1929  ; uTx3Addr
00015c  6288              STR      r0,[r1,#0x28]         ;1929
00015e  4608              MOV      r0,r1                 ;1930
000160  69c0              LDR      r0,[r0,#0x1c]         ;1930
000162  f0400001          ORR      r0,r0,#1              ;1930
000166  61c8              STR      r0,[r1,#0x1c]         ;1930
000168  bf00              NOP                            ;1931
                  |L28.362|
00016a  e044              B        |L28.502|
                  |L28.364|
00016c  89a0              LDRH     r0,[r4,#0xc]          ;1935
00016e  f4005000          AND      r0,r0,#0x2000         ;1935
000172  f5b05f00          CMP      r0,#0x2000            ;1935
000176  d000              BEQ      |L28.378|
000178  e75d              B        |L28.54|
                  |L28.378|
00017a  4829              LDR      r0,|L28.544|
00017c  6800              LDR      r0,[r0,#0]            ;1939
00017e  b128              CBZ      r0,|L28.396|
000180  4827              LDR      r0,|L28.544|
000182  1f00              SUBS     r0,r0,#4              ;1941
000184  6800              LDR      r0,[r0,#0]            ;1941
000186  f0000001          AND      r0,r0,#1              ;1941
00018a  bb50              CBNZ     r0,|L28.482|
                  |L28.396|
00018c  4825              LDR      r0,|L28.548|
00018e  6800              LDR      r0,[r0,#0]            ;1944  ; uTxLink4
000190  b338              CBZ      r0,|L28.482|
000192  4825              LDR      r0,|L28.552|
000194  6800              LDR      r0,[r0,#0]            ;1947  ; uTx4Addr
000196  f7fffffe          BL       free
00019a  4823              LDR      r0,|L28.552|
00019c  6801              LDR      r1,[r0,#0]            ;1948  ; uTx4Addr
00019e  4821              LDR      r0,|L28.548|
0001a0  f7fffffe          BL       FIFO_OUT
0001a4  4605              MOV      r5,r0                 ;1948
0001a6  b905              CBNZ     r5,|L28.426|
0001a8  e745              B        |L28.54|
                  |L28.426|
0001aa  481d              LDR      r0,|L28.544|
0001ac  1f00              SUBS     r0,r0,#4              ;1953
0001ae  6800              LDR      r0,[r0,#0]            ;1953
0001b0  f0200001          BIC      r0,r0,#1              ;1953
0001b4  491a              LDR      r1,|L28.544|
0001b6  1f09              SUBS     r1,r1,#4              ;1953
0001b8  6008              STR      r0,[r1,#0]            ;1953
0001ba  481c              LDR      r0,|L28.556|
0001bc  4918              LDR      r1,|L28.544|
0001be  3958              SUBS     r1,r1,#0x58           ;1954
0001c0  6008              STR      r0,[r1,#0]            ;1954
0001c2  4817              LDR      r0,|L28.544|
0001c4  6005              STR      r5,[r0,#0]            ;1955
0001c6  4818              LDR      r0,|L28.552|
0001c8  6800              LDR      r0,[r0,#0]            ;1956  ; uTx4Addr
0001ca  4915              LDR      r1,|L28.544|
0001cc  3108              ADDS     r1,r1,#8              ;1956
0001ce  6008              STR      r0,[r1,#0]            ;1956
0001d0  4813              LDR      r0,|L28.544|
0001d2  1f00              SUBS     r0,r0,#4              ;1957
0001d4  6800              LDR      r0,[r0,#0]            ;1957
0001d6  f0400001          ORR      r0,r0,#1              ;1957
0001da  4911              LDR      r1,|L28.544|
0001dc  1f09              SUBS     r1,r1,#4              ;1957
0001de  6008              STR      r0,[r1,#0]            ;1957
0001e0  bf00              NOP                            ;1958
                  |L28.482|
0001e2  bf00              NOP                            ;1960
                  |L28.484|
0001e4  89a0              LDRH     r0,[r4,#0xc]          ;1961
0001e6  f4005000          AND      r0,r0,#0x2000         ;1961
0001ea  f5b05f00          CMP      r0,#0x2000            ;1961
0001ee  d000              BEQ      |L28.498|
0001f0  e721              B        |L28.54|
                  |L28.498|
0001f2  e000              B        |L28.502|
                  |L28.500|
0001f4  bf00              NOP                            ;1966
                  |L28.502|
0001f6  bf00              NOP                            ;1879
0001f8  bf00              NOP      
0001fa  e71c              B        |L28.54|
;;;1969   /*******************************************************************************
                          ENDP

                  |L28.508|
                          DCD      0x40004c00
                  |L28.512|
                          DCD      0xbfffbc00
                  |L28.516|
                          DCD      0x40020000
                  |L28.520|
                          DCD      uTxLink1
                  |L28.524|
                          DCD      uTx1Addr
                  |L28.528|
                          DCD      uTxLink2
                  |L28.532|
                          DCD      uTx2Addr
                  |L28.536|
                          DCD      uTxLink3
                  |L28.540|
                          DCD      uTx3Addr
                  |L28.544|
                          DCD      0x4002045c
                  |L28.548|
                          DCD      uTxLink4
                  |L28.552|
                          DCD      uTx4Addr
                  |L28.556|
                          DCD      0x10010000

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;2007   *******************************************************************************/
;;;2008   int fputc(int ch, FILE *f)				//printf重定义
000000  b570              PUSH     {r4-r6,lr}
;;;2009   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2010   
;;;2011   	USART_SendData(USART1, (unsigned char) ch);// USART1 可以换成 USART2 等
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L29.32|
00000a  f7fffffe          BL       USART_SendData
;;;2012   
;;;2013   	while(!(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == SET));
00000e  bf00              NOP      
                  |L29.16|
000010  2180              MOVS     r1,#0x80
000012  4804              LDR      r0,|L29.36|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2801              CMP      r0,#1
00001a  d1f9              BNE      |L29.16|
;;;2014   
;;;2015   	return (ch);
00001c  4620              MOV      r0,r4
;;;2016   
;;;2017   }
00001e  bd70              POP      {r4-r6,pc}
;;;2018   
                          ENDP

                  |L29.32|
                          DCD      0x40013800
                  |L29.36|
                          DCD      0x40004400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  uRx1Addr
                          %        512
                  uRx2Addr
                          %        512
                  uRx3Addr
                          %        512
                  uRx4Addr
                          %        512

                          AREA ||.data||, DATA, ALIGN=2

                  uTx1Addr
                          DCD      0x00000000
                  uTx2Addr
                          DCD      0x00000000
                  uTx3Addr
                          DCD      0x00000000
                  uTx4Addr
                          DCD      0x00000000
                  uTxLink1
                          DCD      0x00000000
                  uTxLink2
                          DCD      0x00000000
                  uTxLink3
                          DCD      0x00000000
                  uTxLink4
                          DCD      0x00000000
                  SetDmaSize
                          %        8
                  RemaDmaSize
                          %        8
                  RetryCount
                          %        8
