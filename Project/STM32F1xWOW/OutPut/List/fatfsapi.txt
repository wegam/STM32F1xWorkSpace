; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\fatfsapi.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\fatfsapi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\fatfsapi.crf ..\..\Driver\FatFs\source\FatFsAPI.c]
                          THUMB

                          AREA ||i.ByteCmp||, CODE, READONLY, ALIGN=1

                  ByteCmp PROC
;;;93     *******************************************************************************/
;;;94     bool ByteCmp(char a,char b)
000000  4602              MOV      r2,r0
;;;95     {
;;;96       if(a==b)
000002  428a              CMP      r2,r1
000004  d101              BNE      |L1.10|
;;;97         return TRUE;
000006  2001              MOVS     r0,#1
                  |L1.8|
;;;98       if((a>='a')&&(a<='z'))
;;;99       {
;;;100        if(a-32==b)
;;;101          return TRUE;
;;;102      }
;;;103      if((b>='a')&&(b<='z'))
;;;104      {
;;;105        if(b-32==a)
;;;106          return TRUE;
;;;107      }
;;;108      return FALSE;
;;;109    }
000008  4770              BX       lr
                  |L1.10|
00000a  2a61              CMP      r2,#0x61              ;98
00000c  db07              BLT      |L1.30|
00000e  2a7a              CMP      r2,#0x7a              ;98
000010  dc05              BGT      |L1.30|
000012  f1a20020          SUB      r0,r2,#0x20           ;100
000016  4288              CMP      r0,r1                 ;100
000018  d101              BNE      |L1.30|
00001a  2001              MOVS     r0,#1                 ;101
00001c  e7f4              B        |L1.8|
                  |L1.30|
00001e  2961              CMP      r1,#0x61              ;103
000020  db07              BLT      |L1.50|
000022  297a              CMP      r1,#0x7a              ;103
000024  dc05              BGT      |L1.50|
000026  f1a10020          SUB      r0,r1,#0x20           ;105
00002a  4290              CMP      r0,r2                 ;105
00002c  d101              BNE      |L1.50|
00002e  2001              MOVS     r0,#1                 ;106
000030  e7ea              B        |L1.8|
                  |L1.50|
000032  2000              MOVS     r0,#0                 ;108
000034  e7e8              B        |L1.8|
;;;110    /*******************************************************************************
                          ENDP


                          AREA ||i.FilSearch||, CODE, READONLY, ALIGN=1

                  FilSearch PROC
;;;171    *******************************************************************************/
;;;172    bool FilSearch(FATFS *fs,DIR *dir,TCHAR *path,u8 *name,char (*p)[13])
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;173    { 
000004  b087              SUB      sp,sp,#0x1c
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  f8ddb040          LDR      r11,[sp,#0x40]
;;;174      //===========未验证
;;;175      FILINFO fno;
;;;176      FRESULT res;
;;;177      u8 i,j,k;
;;;178      j = k = 0;
000010  2000              MOVS     r0,#0
000012  4606              MOV      r6,r0
000014  4682              MOV      r10,r0
;;;179      res = f_opendir(dir,path);    //创建目录对象及获取相关参数
000016  4649              MOV      r1,r9
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       f_opendir
00001e  4607              MOV      r7,r0
;;;180      if(res != FR_OK)
000020  b11f              CBZ      r7,|L2.42|
;;;181        return FALSE;
000022  2000              MOVS     r0,#0
                  |L2.36|
;;;182      do
;;;183      {
;;;184        res = f_readdir(dir,&fno);  //按顺序读取目录条目及将文件信息
;;;185        if(res != FR_OK)
;;;186          return FALSE;
;;;187    //    if(fno.fname[0] == 0)
;;;188    //      return TRUE; 
;;;189        i = 13;   //单个文件信息存储长度
;;;190        while(--i)
;;;191        {
;;;192          if((fno.fname[i] == 0x2E) && (ByteCmp(fno.fname[i+1],name[0]) && ByteCmp(fno.fname[i+2],name[1]) && ByteCmp(fno.fname[i+3],name[2])))
;;;193            break;    
;;;194        }
;;;195        if(i) //检索到一个符合扩展名条件的文件
;;;196        {
;;;197          for(k =0;k < 13;k++) 
;;;198            *(*(p+j)+k) = fno.fname[k];
;;;199          j++; 
;;;200    //      return TRUE;
;;;201        }
;;;202    //    else
;;;203    //      return FALSE;
;;;204      }while(!res && fno.fname[0] != 0);
;;;205      return TRUE;
;;;206    }
000024  b007              ADD      sp,sp,#0x1c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.42|
00002a  bf00              NOP                            ;182
                  |L2.44|
00002c  a901              ADD      r1,sp,#4              ;184
00002e  4640              MOV      r0,r8                 ;184
000030  f7fffffe          BL       f_readdir
000034  4607              MOV      r7,r0                 ;184
000036  b10f              CBZ      r7,|L2.60|
000038  2000              MOVS     r0,#0                 ;186
00003a  e7f3              B        |L2.36|
                  |L2.60|
00003c  240d              MOVS     r4,#0xd               ;189
00003e  e01d              B        |L2.124|
                  |L2.64|
000040  f10d000d          ADD      r0,sp,#0xd            ;192
000044  5d00              LDRB     r0,[r0,r4]            ;192
000046  282e              CMP      r0,#0x2e              ;192
000048  d118              BNE      |L2.124|
00004a  7829              LDRB     r1,[r5,#0]            ;192
00004c  f10d020d          ADD      r2,sp,#0xd            ;192
000050  1c63              ADDS     r3,r4,#1              ;192
000052  5cd0              LDRB     r0,[r2,r3]            ;192
000054  f7fffffe          BL       ByteCmp
000058  b180              CBZ      r0,|L2.124|
00005a  7869              LDRB     r1,[r5,#1]            ;192
00005c  f10d020d          ADD      r2,sp,#0xd            ;192
000060  1ca3              ADDS     r3,r4,#2              ;192
000062  5cd0              LDRB     r0,[r2,r3]            ;192
000064  f7fffffe          BL       ByteCmp
000068  b140              CBZ      r0,|L2.124|
00006a  78a9              LDRB     r1,[r5,#2]            ;192
00006c  f10d020d          ADD      r2,sp,#0xd            ;192
000070  1ce3              ADDS     r3,r4,#3              ;192
000072  5cd0              LDRB     r0,[r2,r3]            ;192
000074  f7fffffe          BL       ByteCmp
000078  b100              CBZ      r0,|L2.124|
00007a  e003              B        |L2.132|
                  |L2.124|
00007c  1e60              SUBS     r0,r4,#1              ;190
00007e  b2c0              UXTB     r0,r0                 ;190
000080  1e04              SUBS     r4,r0,#0              ;190
000082  d1dd              BNE      |L2.64|
                  |L2.132|
000084  bf00              NOP                            ;193
000086  b194              CBZ      r4,|L2.174|
000088  2600              MOVS     r6,#0                 ;197
00008a  e00a              B        |L2.162|
                  |L2.140|
00008c  f10d000d          ADD      r0,sp,#0xd            ;198
000090  5d80              LDRB     r0,[r0,r6]            ;198
000092  eb0a018a          ADD      r1,r10,r10,LSL #2     ;198
000096  eb0101ca          ADD      r1,r1,r10,LSL #3      ;198
00009a  4459              ADD      r1,r1,r11             ;198
00009c  5588              STRB     r0,[r1,r6]            ;198
00009e  1c70              ADDS     r0,r6,#1              ;197
0000a0  b2c6              UXTB     r6,r0                 ;197
                  |L2.162|
0000a2  2e0d              CMP      r6,#0xd               ;197
0000a4  dbf2              BLT      |L2.140|
0000a6  f10a0001          ADD      r0,r10,#1             ;199
0000aa  f0000aff          AND      r10,r0,#0xff          ;199
                  |L2.174|
0000ae  b91f              CBNZ     r7,|L2.184|
0000b0  f89d000d          LDRB     r0,[sp,#0xd]          ;204
0000b4  2800              CMP      r0,#0                 ;204
0000b6  d1b9              BNE      |L2.44|
                  |L2.184|
0000b8  2001              MOVS     r0,#1                 ;205
0000ba  e7b3              B        |L2.36|
;;;207    ///**************************函数*************************/
                          ENDP


                          AREA ||i.SD_disk_getcapacity||, CODE, READONLY, ALIGN=1

                  SD_disk_getcapacity PROC
;;;120    *******************************************************************************/
;;;121    unsigned char SD_disk_getcapacity(unsigned char *drv,unsigned long *total,unsigned long *free)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;122    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;123    	FATFS *fs1;         //文件系统对象结构体
;;;124    	u8 res;
;;;125      u32 fre_clust=0;    /* 存储空闲簇数目变量的指针 */
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;126      u32 fre_sect=0;
00000e  4680              MOV      r8,r0
;;;127      u32 tot_sect=0;
000010  4681              MOV      r9,r0
;;;128      //========================得到磁盘信息及空闲簇数量
;;;129      res =(u32)f_getfree((const TCHAR*)drv, (DWORD*)&fre_clust, &fs1);
000012  aa01              ADD      r2,sp,#4
000014  4669              MOV      r1,sp
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       f_getfree
00001c  4606              MOV      r6,r0
;;;130      if(res==0)
00001e  b98e              CBNZ     r6,|L3.68|
;;;131    	{											   
;;;132    	    tot_sect=(fs1->n_fatent-2)*fs1->csize;	//得到总扇区数
000020  9801              LDR      r0,[sp,#4]
000022  6940              LDR      r0,[r0,#0x14]
000024  1e80              SUBS     r0,r0,#2
000026  9901              LDR      r1,[sp,#4]
000028  8949              LDRH     r1,[r1,#0xa]
00002a  fb00f901          MUL      r9,r0,r1
;;;133    	    fre_sect=fre_clust*fs1->csize;			    //得到空闲扇区数	   
00002e  9801              LDR      r0,[sp,#4]
000030  8940              LDRH     r0,[r0,#0xa]
000032  9900              LDR      r1,[sp,#0]
000034  fb00f801          MUL      r8,r0,r1
;;;134    #if FF_MAX_SS!=512				  				          //扇区大小不是512字节,则转换为512字节
;;;135    		tot_sect*=fs1->ssize/512;
;;;136    		fre_sect*=fs1->ssize/512;
;;;137    #endif	  
;;;138    		*total=tot_sect>>1;	//总容量单位为KB
000038  ea4f0059          LSR      r0,r9,#1
00003c  6020              STR      r0,[r4,#0]
;;;139    		*free=fre_sect>>1;	//剩余容量单位为KB 
00003e  ea4f0058          LSR      r0,r8,#1
000042  6028              STR      r0,[r5,#0]
                  |L3.68|
;;;140     	}
;;;141    	return res;
000044  4630              MOV      r0,r6
;;;142    }
000046  e8bd87fc          POP      {r2-r10,pc}
;;;143    /*******************************************************************************
                          ENDP


                          AREA ||i.SD_disk_initialize||, CODE, READONLY, ALIGN=2

                  SD_disk_initialize PROC
;;;26     *******************************************************************************/
;;;27     int SD_disk_initialize(void)
000000  b510              PUSH     {r4,lr}
;;;28     { 
;;;29       unsigned char result  = 0;
000002  2400              MOVS     r4,#0
;;;30       //========================硬件接口配置
;;;31       sSDFatFsPort.Port.SPIx = SPI2;
000004  4807              LDR      r0,|L4.36|
000006  4908              LDR      r1,|L4.40|
000008  6008              STR      r0,[r1,#0]  ; sSDFatFsPort
;;;32       sSDFatFsPort.Port.CS_PORT  = GPIOG;
00000a  4808              LDR      r0,|L4.44|
00000c  6048              STR      r0,[r1,#4]  ; sSDFatFsPort
;;;33       sSDFatFsPort.Port.CS_Pin   = GPIO_Pin_6;
00000e  2040              MOVS     r0,#0x40
000010  8108              STRH     r0,[r1,#8]
;;;34       sSDFatFsPort.Port.SPI_BaudRatePrescaler_x=SPI_BaudRatePrescaler_256;
000012  2038              MOVS     r0,#0x38
000014  8448              STRH     r0,[r1,#0x22]
;;;35       //========================初始化SD卡
;;;36       result  = SD_Initialize(&sSDFatFsPort);
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       SD_Initialize
00001c  4604              MOV      r4,r0
;;;37     
;;;38       return result;
00001e  4620              MOV      r0,r4
;;;39     }
000020  bd10              POP      {r4,pc}
;;;40     /*******************************************************************************
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x40003800
                  |L4.40|
                          DCD      sSDFatFsPort
                  |L4.44|
                          DCD      0x40012000

                          AREA ||i.SD_disk_read||, CODE, READONLY, ALIGN=1

                  SD_disk_read PROC
;;;62     *******************************************************************************/
;;;63     int SD_disk_read(BYTE *buff,DWORD sector,UINT count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;64     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;65       unsigned char result  = 0;
00000a  2700              MOVS     r7,#0
;;;66       result  = SD_ReadDisk(buff,sector,count);
00000c  b2e2              UXTB     r2,r4
00000e  4631              MOV      r1,r6
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       SD_ReadDisk
000016  4607              MOV      r7,r0
;;;67       return result;
000018  4638              MOV      r0,r7
;;;68     }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;69     
                          ENDP


                          AREA ||i.SD_disk_status||, CODE, READONLY, ALIGN=1

                  SD_disk_status PROC
;;;48     *******************************************************************************/
;;;49     int SD_disk_status(void)
000000  2000              MOVS     r0,#0
;;;50     {
;;;51       unsigned char result  = 0;
;;;52       return result;
;;;53     }
000002  4770              BX       lr
;;;54     /*******************************************************************************
                          ENDP


                          AREA ||i.SD_disk_write||, CODE, READONLY, ALIGN=1

                  SD_disk_write PROC
;;;78     *******************************************************************************/
;;;79     int SD_disk_write(const BYTE *buff,DWORD sector,UINT count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;80     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;81       unsigned char result  = 0;
00000a  2700              MOVS     r7,#0
;;;82       result  = SD_WriteDisk((u8*)buff,sector,count);   //往SD卡写数据
00000c  b2e2              UXTB     r2,r4
00000e  4631              MOV      r1,r6
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       SD_WriteDisk
000016  4607              MOV      r7,r0
;;;83       return result;
000018  4638              MOV      r0,r7
;;;84     }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;85     /*******************************************************************************
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sSDFatFsPort
                          %        36
