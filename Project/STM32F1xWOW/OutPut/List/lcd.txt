; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\lcd.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\lcd.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\lcd.crf ..\..\Driver\Components\SCR\LCD.c]
                          THUMB

                          AREA ||i.LCDFsmc_Initialize||, CODE, READONLY, ALIGN=2

                  LCDFsmc_Initialize PROC
;;;101    *******************************************************************************/
;;;102    void LCDFsmc_Initialize(LCDDef *pInfo)
000000  b530              PUSH     {r4,r5,lr}
;;;103    {  
000002  b097              SUB      sp,sp,#0x5c
000004  4605              MOV      r5,r0
;;;104    	static unsigned short	DeviceCode	=	0;
;;;105      GPIO_InitTypeDef                GPIO_InitStructure;
;;;106    	FSMC_NORSRAMInitTypeDef         FSMC_NORSRAMInitStructure;
;;;107      FSMC_NORSRAMTimingInitTypeDef   FSMC_NORSRAMTimingInitStructure;
;;;108      
;;;109      LCDPortDef  *Port;
;;;110    	LCDSYS	  =	pInfo;		//指针指向
000006  4852              LDR      r0,|L1.336|
000008  6005              STR      r5,[r0,#0]  ; LCDSYS
;;;111      
;;;112      Port	=	&(pInfo->Port);	
00000a  462c              MOV      r4,r5
;;;113    	
;;;114    	//==========================开时钟
;;;115      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;116      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG | RCC_APB2Periph_AFIO, ENABLE);
000014  2101              MOVS     r1,#1
000016  f24010fd          MOV      r0,#0x1fd
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;117      //==========================GPIO配置
;;;118      if(NULL!= Port->sBL_PORT)
00001e  6820              LDR      r0,[r4,#0]
000020  b118              CBZ      r0,|L1.42|
;;;119        GPIO_Configuration_OPP50	(Port->sBL_PORT,				Port->sBL_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000022  88a1              LDRH     r1,[r4,#4]
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       GPIO_Configuration_OPP50
                  |L1.42|
;;;120      if(NULL!= Port->sREST_PORT)
00002a  6920              LDR      r0,[r4,#0x10]
00002c  b118              CBZ      r0,|L1.54|
;;;121        GPIO_Configuration_OPP50	(Port->sREST_PORT,			Port->sREST_Pin);				//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00002e  8aa1              LDRH     r1,[r4,#0x14]
000030  6920              LDR      r0,[r4,#0x10]
000032  f7fffffe          BL       GPIO_Configuration_OPP50
                  |L1.54|
;;;122      if(NULL!= Port->sCS_PORT)
000036  6aa0              LDR      r0,[r4,#0x28]
000038  b118              CBZ      r0,|L1.66|
;;;123        GPIO_Configuration_OPP50	(Port->sCS_PORT,				Port->sCS_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00003a  8da1              LDRH     r1,[r4,#0x2c]
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  f7fffffe          BL       GPIO_Configuration_OPP50
                  |L1.66|
;;;124      //-----------------打开FSMC的数据端口D[15:0]
;;;125      GPIO_Configuration_APP50(GPIOD,GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 | GPIO_Pin_15);
000042  f24c7103          MOV      r1,#0xc703
000046  4843              LDR      r0,|L1.340|
000048  f7fffffe          BL       GPIO_Configuration_APP50
;;;126      GPIO_Configuration_APP50(GPIOE,GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |  GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15);
00004c  f64f7180          MOV      r1,#0xff80
000050  4841              LDR      r0,|L1.344|
000052  f7fffffe          BL       GPIO_Configuration_APP50
;;;127      //-----------------打开FSMC功能端口，PD.4=RD(nOE)；PD.5=WR(nWE)
;;;128      GPIO_Configuration_APP50(GPIOD,GPIO_Pin_4 | GPIO_Pin_5);
000056  2130              MOVS     r1,#0x30
000058  483e              LDR      r0,|L1.340|
00005a  f7fffffe          BL       GPIO_Configuration_APP50
;;;129      //-----------------打开NE4设置
;;;130      GPIO_Configuration_APP50(GPIOG,GPIO_Pin_12);
00005e  f44f5180          MOV      r1,#0x1000
000062  483e              LDR      r0,|L1.348|
000064  f7fffffe          BL       GPIO_Configuration_APP50
;;;131      //-----------------打开RS设置
;;;132      GPIO_Configuration_APP50(GPIOE,GPIO_Pin_3);
000068  2108              MOVS     r1,#8
00006a  483b              LDR      r0,|L1.344|
00006c  f7fffffe          BL       GPIO_Configuration_APP50
;;;133      
;;;134      //==========================初始化GPIO状态
;;;135      //--------------NE4=1
;;;136      GPIO_SetBits(GPIOG, GPIO_Pin_12);
000070  f44f5180          MOV      r1,#0x1000
000074  4839              LDR      r0,|L1.348|
000076  f7fffffe          BL       GPIO_SetBits
;;;137      //--------------LCD_RESET=0
;;;138      GPIO_ResetBits(GPIOE, GPIO_Pin_1);
00007a  2102              MOVS     r1,#2
00007c  4836              LDR      r0,|L1.344|
00007e  f7fffffe          BL       GPIO_ResetBits
;;;139      //--------------LCD_RD=1(nOE)
;;;140      GPIO_SetBits(GPIOD, GPIO_Pin_4);
000082  2110              MOVS     r1,#0x10
000084  4833              LDR      r0,|L1.340|
000086  f7fffffe          BL       GPIO_SetBits
;;;141      //--------------LCD_WR=1(nWE)
;;;142      GPIO_SetBits(GPIOD, GPIO_Pin_5);
00008a  2120              MOVS     r1,#0x20
00008c  4831              LDR      r0,|L1.340|
00008e  f7fffffe          BL       GPIO_SetBits
;;;143      //--------------NE4=0
;;;144      GPIO_ResetBits(GPIOG, GPIO_Pin_12);
000092  f44f5180          MOV      r1,#0x1000
000096  4831              LDR      r0,|L1.348|
000098  f7fffffe          BL       GPIO_ResetBits
;;;145      LCD_DelaymS(100); 
00009c  2064              MOVS     r0,#0x64
00009e  f7fffffe          BL       LCD_DelaymS
;;;146      
;;;147      //===========================FSMC初始化
;;;148      
;;;149      /*-- FSMC Configuration ------------------------------------------------------*/
;;;150      /*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;151      /* FSMC_Bank1_NORSRAM4 configuration */
;;;152      FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 1;
0000a2  2001              MOVS     r0,#1
0000a4  9001              STR      r0,[sp,#4]
;;;153      FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;
0000a6  2000              MOVS     r0,#0
0000a8  9002              STR      r0,[sp,#8]
;;;154      FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 2;
0000aa  2002              MOVS     r0,#2
0000ac  9003              STR      r0,[sp,#0xc]
;;;155      FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0;
0000ae  2000              MOVS     r0,#0
0000b0  9004              STR      r0,[sp,#0x10]
;;;156      FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0;
0000b2  9005              STR      r0,[sp,#0x14]
;;;157      FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0;
0000b4  9006              STR      r0,[sp,#0x18]
;;;158      FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_B;
0000b6  f04f5080          MOV      r0,#0x10000000
0000ba  9007              STR      r0,[sp,#0x1c]
;;;159    
;;;160      /* Color LCD configuration ------------------------------------
;;;161         LCD configured as follow:
;;;162            - Data/Address MUX = Disable
;;;163            - Memory Type = SRAM
;;;164            - Data Width = 16bit
;;;165            - Write Operation = Enable
;;;166            - Extended Mode = Enable
;;;167            - Asynchronous Wait = Disable */
;;;168      FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;
0000bc  2006              MOVS     r0,#6
0000be  9008              STR      r0,[sp,#0x20]
;;;169      FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
0000c0  2000              MOVS     r0,#0
0000c2  9009              STR      r0,[sp,#0x24]
;;;170      FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
0000c4  900a              STR      r0,[sp,#0x28]
;;;171      FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
0000c6  2010              MOVS     r0,#0x10
0000c8  900b              STR      r0,[sp,#0x2c]
;;;172      FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
0000ca  2000              MOVS     r0,#0
0000cc  900c              STR      r0,[sp,#0x30]
;;;173      FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
0000ce  900d              STR      r0,[sp,#0x34]
;;;174      FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
0000d0  900e              STR      r0,[sp,#0x38]
;;;175      FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
0000d2  900f              STR      r0,[sp,#0x3c]
;;;176      FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
0000d4  f44f5080          MOV      r0,#0x1000
0000d8  9010              STR      r0,[sp,#0x40]
;;;177      FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
0000da  2000              MOVS     r0,#0
0000dc  9011              STR      r0,[sp,#0x44]
;;;178      FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
0000de  9012              STR      r0,[sp,#0x48]
;;;179      FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
0000e0  9014              STR      r0,[sp,#0x50]
;;;180      FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
0000e2  a801              ADD      r0,sp,#4
0000e4  9015              STR      r0,[sp,#0x54]
;;;181      FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
0000e6  9016              STR      r0,[sp,#0x58]
;;;182    
;;;183      FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
0000e8  a808              ADD      r0,sp,#0x20
0000ea  f7fffffe          BL       FSMC_NORSRAMInit
;;;184    
;;;185      /* - BANK 3 (of NOR/SRAM Bank 0~3) is enabled */
;;;186      FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);  
0000ee  2101              MOVS     r1,#1
0000f0  2006              MOVS     r0,#6
0000f2  f7fffffe          BL       FSMC_NORSRAMCmd
;;;187      
;;;188    //	GPIO_Configuration_OPP50	(Port->sRD_PORT,				Port->sRD_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;189    //	GPIO_Configuration_OPP50	(Port->sREST_PORT,			Port->sREST_Pin);				//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;190    //	GPIO_Configuration_OPP50	(Port->sDC_PORT,				Port->sDC_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;191    //	GPIO_Configuration_OPP50	(Port->sWR_PORT,				Port->sWR_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605	
;;;192    //	GPIO_Configuration_OPP50	(Port->sTE_PORT,				Port->sTE_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;193    //	GPIO_Configuration_OPP50	(Port->sDATABUS_PORT,		Port->sDATABUS_Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;194    	
;;;195      //===========================函数地址
;;;196      LCDSYS->Display.WriteIndex    = LCDFsmc_WriteIndex;
0000f6  491a              LDR      r1,|L1.352|
0000f8  4815              LDR      r0,|L1.336|
0000fa  6800              LDR      r0,[r0,#0]  ; LCDSYS
0000fc  6641              STR      r1,[r0,#0x64]
;;;197      LCDSYS->Display.WriteData     = LCDFsmc_WriteData;
0000fe  4919              LDR      r1,|L1.356|
000100  4813              LDR      r0,|L1.336|
000102  6800              LDR      r0,[r0,#0]  ; LCDSYS
000104  6681              STR      r1,[r0,#0x68]
;;;198      LCDSYS->Display.WriteCommand  = LCD_WriteCommand;
000106  4918              LDR      r1,|L1.360|
000108  4811              LDR      r0,|L1.336|
00010a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00010c  66c1              STR      r1,[r0,#0x6c]
;;;199      //==========================驱动配置
;;;200      SSD1963_Initialize(pInfo);
00010e  4628              MOV      r0,r5
000110  f7fffffe          BL       SSD1963_Initialize
;;;201    
;;;202      //==========================检查背景色与画笔色是否相同
;;;203    	if(pInfo->Data.PColor	==	pInfo->Data.BColor)
000114  2050              MOVS     r0,#0x50
000116  5b41              LDRH     r1,[r0,r5]
000118  2052              MOVS     r0,#0x52
00011a  5b40              LDRH     r0,[r0,r5]
00011c  4281              CMP      r1,r0
00011e  d105              BNE      |L1.300|
;;;204    	{
;;;205    		pInfo->Data.PColor	=	pInfo->Data.BColor^0xFF;
000120  2052              MOVS     r0,#0x52
000122  5b40              LDRH     r0,[r0,r5]
000124  f08001ff          EOR      r1,r0,#0xff
000128  2050              MOVS     r0,#0x50
00012a  5341              STRH     r1,[r0,r5]
                  |L1.300|
;;;206    	}
;;;207    	//==========================LCD初始化及上电配置
;;;208    	LCDSYS->Display.PowerOn();						//LCD上电/初始化配置
00012c  4908              LDR      r1,|L1.336|
00012e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000130  6f88              LDR      r0,[r1,#0x78]
000132  4780              BLX      r0
;;;209    	//==========================以背景色清除屏幕
;;;210    //	LCD_Clean(pInfo->Data.BColor);				//按背景色清除屏幕函数
;;;211      LCD_Clean(LCD565_WHITE);				//按背景色清除屏幕函数
000134  f64f70ff          MOV      r0,#0xffff
000138  f7fffffe          BL       LCD_Clean
;;;212    	//==========================开背光LIGHT=1
;;;213      GPIO_SetBits(Port->sBL_PORT, Port->sBL_Pin);
00013c  88a1              LDRH     r1,[r4,#4]
00013e  6820              LDR      r0,[r4,#0]
000140  f7fffffe          BL       GPIO_SetBits
;;;214    	//==========================字库配置
;;;215    	GT32L32_Initialize(&pInfo->GT32L32.SPI);				//普通SPI通讯方式配置
000144  f10500a8          ADD      r0,r5,#0xa8
000148  f7fffffe          BL       GT32L32_Initialize
;;;216    }
00014c  b017              ADD      sp,sp,#0x5c
00014e  bd30              POP      {r4,r5,pc}
;;;217    /*******************************************************************************
                          ENDP

                  |L1.336|
                          DCD      LCDSYS
                  |L1.340|
                          DCD      0x40011400
                  |L1.344|
                          DCD      0x40011800
                  |L1.348|
                          DCD      0x40012000
                  |L1.352|
                          DCD      LCDFsmc_WriteIndex
                  |L1.356|
                          DCD      LCDFsmc_WriteData
                  |L1.360|
                          DCD      LCD_WriteCommand

                          AREA ||i.LCDFsmc_WriteData||, CODE, READONLY, ALIGN=2

                  LCDFsmc_WriteData PROC
;;;332    *******************************************************************************/
;;;333    void LCDFsmc_WriteData(unsigned short Data)
000000  4902              LDR      r1,|L2.12|
;;;334    {  
;;;335      *(volatile unsigned short*)(LCDSYS->Data.FsmcDataAddr)  = Data;
000002  6809              LDR      r1,[r1,#0]  ; LCDSYS
000004  6d49              LDR      r1,[r1,#0x54]
000006  8008              STRH     r0,[r1,#0]
;;;336    }
000008  4770              BX       lr
;;;337    /*******************************************************************************
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      LCDSYS

                          AREA ||i.LCDFsmc_WriteIndex||, CODE, READONLY, ALIGN=2

                  LCDFsmc_WriteIndex PROC
;;;319    *******************************************************************************/
;;;320    void LCDFsmc_WriteIndex(unsigned short Index)
000000  4902              LDR      r1,|L3.12|
;;;321    {  
;;;322      *(volatile unsigned short*)(LCDSYS->Data.FsmcRegAddr)  = Index;
000002  6809              LDR      r1,[r1,#0]  ; LCDSYS
000004  6d89              LDR      r1,[r1,#0x58]
000006  8008              STRH     r0,[r1,#0]
;;;323    }
000008  4770              BX       lr
;;;324    /*******************************************************************************
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      LCDSYS

                          AREA ||i.LCD_Clean||, CODE, READONLY, ALIGN=2

                  LCD_Clean PROC
;;;505    *******************************************************************************/
;;;506    void LCD_Clean(u16 Color)	//清除屏幕函数
000000  b510              PUSH     {r4,lr}
;;;507    {
000002  4604              MOV      r4,r0
;;;508    	LCDSYS->Display.Clean(Color);
000004  4803              LDR      r0,|L4.20|
000006  6800              LDR      r0,[r0,#0]  ; LCDSYS
000008  f8d01098          LDR      r1,[r0,#0x98]
00000c  4620              MOV      r0,r4
00000e  4788              BLX      r1
;;;509    }
000010  bd10              POP      {r4,pc}
;;;510    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      LCDSYS

                          AREA ||i.LCD_DelayS||, CODE, READONLY, ALIGN=1

                  LCD_DelayS PROC
;;;1185   *******************************************************************************/
;;;1186   void LCD_DelayS(u32 xS)
000000  b510              PUSH     {r4,lr}
;;;1187   {
000002  4604              MOV      r4,r0
;;;1188   	SysTick_DeleyS(xS);				//SysTick延时nmS;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SysTick_DeleyS
;;;1189   }
00000a  bd10              POP      {r4,pc}
;;;1190   //#endif//LCD_61509_EN
                          ENDP


                          AREA ||i.LCD_DelaymS||, CODE, READONLY, ALIGN=1

                  LCD_DelaymS PROC
;;;1175   *******************************************************************************/
;;;1176   void LCD_DelaymS(u32 xms)
000000  b510              PUSH     {r4,lr}
;;;1177   {
000002  4604              MOV      r4,r0
;;;1178   	SysTick_DeleymS(xms);				//SysTick延时nmS;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SysTick_DeleymS
;;;1179   }
00000a  bd10              POP      {r4,pc}
;;;1180   /*******************************************************************************
                          ENDP


                          AREA ||i.LCD_DelayuS||, CODE, READONLY, ALIGN=1

                  LCD_DelayuS PROC
;;;1165   *******************************************************************************/
;;;1166   void LCD_DelayuS(u32 xuS)
000000  b510              PUSH     {r4,lr}
;;;1167   {
000002  4604              MOV      r4,r0
;;;1168   	SysTick_DeleyuS(xuS);				//SysTick延时nmS;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SysTick_DeleyuS
;;;1169   }
00000a  bd10              POP      {r4,pc}
;;;1170   /*******************************************************************************
                          ENDP


                          AREA ||i.LCD_DisplayServer||, CODE, READONLY, ALIGN=2

                  LCD_DisplayServer PROC
;;;225    *******************************************************************************/
;;;226    void LCD_DisplayServer(void)
000000  b510              PUSH     {r4,lr}
;;;227    {
;;;228    	if(NULL	!=	ScrollBuff)
000002  4807              LDR      r0,|L8.32|
000004  6800              LDR      r0,[r0,#0]  ; ScrollBuff
000006  b148              CBZ      r0,|L8.28|
;;;229    	{
;;;230    		LCD_Clean(LCDSYS->Data.BColor);
000008  4906              LDR      r1,|L8.36|
00000a  6809              LDR      r1,[r1,#0]  ; LCDSYS
00000c  f8b10052          LDRH     r0,[r1,#0x52]
000010  f7fffffe          BL       LCD_Clean
;;;231    		LCD_ShowScroll(ScrollBuff);
000014  4802              LDR      r0,|L8.32|
000016  6800              LDR      r0,[r0,#0]  ; ScrollBuff
000018  f7fffffe          BL       LCD_ShowScroll
                  |L8.28|
;;;232    	}
;;;233    }
00001c  bd10              POP      {r4,pc}
;;;234    /*******************************************************************************
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ScrollBuff
                  |L8.36|
                          DCD      LCDSYS

                          AREA ||i.LCD_DrawCircle||, CODE, READONLY, ALIGN=2

                  LCD_DrawCircle PROC
;;;548    **************************************************************************************************/
;;;549    void LCD_DrawCircle(
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;550    												u16 x,u16 y,		//圆心坐标原点
;;;551    												u16 r,					//半径
;;;552    												u8 Filled,			//是否填充
;;;553    												u16 Color				//颜色
;;;554    												)
;;;555    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;556    	LCDSYS->Display.DrawCircle(x,y,r,Filled,Color);
000010  4806              LDR      r0,|L9.44|
000012  f8cd8000          STR      r8,[sp,#0]
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f8d0c08c          LDR      r12,[r0,#0x8c]
000022  4620              MOV      r0,r4
000024  47e0              BLX      r12
;;;557    }
000026  e8bd83f8          POP      {r3-r9,pc}
;;;558    /**************************************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      LCDSYS

                          AREA ||i.LCD_DrawDot||, CODE, READONLY, ALIGN=2

                  LCD_DrawDot PROC
;;;516    *******************************************************************************/
;;;517    void LCD_DrawDot(
000000  b570              PUSH     {r4-r6,lr}
;;;518    									unsigned short HSX,			//点X坐标*/
;;;519    									unsigned short HSY,			//点Y坐标*/
;;;520    									unsigned short Color		//点颜色*/	
;;;521    								)
;;;522    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;523    	LCDSYS->Display.DrawDot(HSX,HSY,Color);
000008  4804              LDR      r0,|L10.28|
00000a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  f8d03084          LDR      r3,[r0,#0x84]
000014  4620              MOV      r0,r4
000016  4798              BLX      r3
;;;524    }
000018  bd70              POP      {r4-r6,pc}
;;;525    /*******************************************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      LCDSYS

                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawLine PROC
;;;533    *******************************************************************************/
;;;534    void LCD_DrawLine(
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;535    									unsigned short HSX, unsigned short HSY, 	//x1,y1:起点坐标
;;;536    									unsigned short HEX, unsigned short HEY,		//x2,y2:终点坐标
;;;537    									unsigned short Color					//颜色
;;;538    )
;;;539    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;540    	LCDSYS->Display.DrawLine(HSX,HSY,HEX,HEY,Color);
000010  4806              LDR      r0,|L11.44|
000012  f8cd8000          STR      r8,[sp,#0]
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f8d0c088          LDR      r12,[r0,#0x88]
000022  4620              MOV      r0,r4
000024  47e0              BLX      r12
;;;541    }
000026  e8bd83f8          POP      {r3-r9,pc}
;;;542    /**************************************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      LCDSYS

                          AREA ||i.LCD_DrawRectangle||, CODE, READONLY, ALIGN=2

                  LCD_DrawRectangle PROC
;;;562    **************************************************************************************************/
;;;563    void LCD_DrawRectangle(u16 x1,u16 y1,u16 x2,u16 y2,u16 Color)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;564    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;565    	LCDSYS->Display.DrawRectangle(x1,y1,x2,y2,Color);
000010  4806              LDR      r0,|L12.44|
000012  f8cd8000          STR      r8,[sp,#0]
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f8d0c090          LDR      r12,[r0,#0x90]
000022  4620              MOV      r0,r4
000024  47e0              BLX      r12
;;;566    }
000026  e8bd83f8          POP      {r3-r9,pc}
;;;567    /*******************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      LCDSYS

                          AREA ||i.LCD_Fill||, CODE, READONLY, ALIGN=2

                  LCD_Fill PROC
;;;572    *******************************************************************************/
;;;573    void LCD_Fill(
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;574    							unsigned short x1, unsigned short y1, 	//x1,y1:起点坐标
;;;575    							unsigned short x2, unsigned short y2,		//x2,y2:终点坐标
;;;576    							u16 Color
;;;577    )
;;;578    { 
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;579    	LCDSYS->Display.Fill(x1,y1,x2,y2,Color);
000010  4806              LDR      r0,|L13.44|
000012  f8cd8000          STR      r8,[sp,#0]
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f8d0c094          LDR      r12,[r0,#0x94]
000022  4620              MOV      r0,r4
000024  47e0              BLX      r12
;;;580    }
000026  e8bd83f8          POP      {r3-r9,pc}
;;;581    /**************************************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      LCDSYS

                          AREA ||i.LCD_GetDispCodeBuffer||, CODE, READONLY, ALIGN=1

                  LCD_GetDispCodeBuffer PROC
;;;677    *******************************************************************************/
;;;678    unsigned short LCD_GetDispCodeBuffer(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;679    													u8 font,								//字体大小
;;;680    													u16 word,								//字符内码值
;;;681    													u8 *ReadBuffer				  //接收数据的缓存
;;;682    												)
;;;683    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;684    	unsigned short lengh=0;
00000a  2700              MOVS     r7,#0
;;;685    	lengh	=	GT32L32_GetCode(font,word,ReadBuffer);		//从字库中读数据并返回数据长度
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       GT32L32_GetCode
000016  4607              MOV      r7,r0
;;;686    	return lengh;
000018  4638              MOV      r0,r7
;;;687    }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;688    /*******************************************************************************
                          ENDP


                          AREA ||i.LCD_Initialize||, CODE, READONLY, ALIGN=2

                  LCD_Initialize PROC
;;;37     *******************************************************************************/
;;;38     unsigned short LCD_Initialize(LCDDef *pInfo)
000000  b538              PUSH     {r3-r5,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40     	static unsigned short	DeviceCode	=	0;
;;;41     	
;;;42       LCDPortDef  *Port;
;;;43     	LCDSYS	  =	pInfo;		//指针指向
000004  4837              LDR      r0,|L15.228|
000006  6004              STR      r4,[r0,#0]  ; LCDSYS
;;;44       
;;;45       Port	=	&(pInfo->Port);	
000008  4625              MOV      r5,r4
;;;46     	
;;;47     	//==========================GPIO配置
;;;48     	GPIO_Configuration_OPP50	(Port->sBL_PORT,				Port->sBL_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00000a  88a9              LDRH     r1,[r5,#4]
00000c  6828              LDR      r0,[r5,#0]
00000e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;49     	GPIO_Configuration_OPP50	(Port->sRD_PORT,				Port->sRD_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000012  89a9              LDRH     r1,[r5,#0xc]
000014  68a8              LDR      r0,[r5,#8]
000016  f7fffffe          BL       GPIO_Configuration_OPP50
;;;50     	GPIO_Configuration_OPP50	(Port->sREST_PORT,			Port->sREST_Pin);				//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00001a  8aa9              LDRH     r1,[r5,#0x14]
00001c  6928              LDR      r0,[r5,#0x10]
00001e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;51     	GPIO_Configuration_OPP50	(Port->sDC_PORT,				Port->sDC_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000022  8ba9              LDRH     r1,[r5,#0x1c]
000024  69a8              LDR      r0,[r5,#0x18]
000026  f7fffffe          BL       GPIO_Configuration_OPP50
;;;52     	GPIO_Configuration_OPP50	(Port->sWR_PORT,				Port->sWR_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00002a  8ca9              LDRH     r1,[r5,#0x24]
00002c  6a28              LDR      r0,[r5,#0x20]
00002e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;53     	GPIO_Configuration_OPP50	(Port->sCS_PORT,				Port->sCS_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000032  8da9              LDRH     r1,[r5,#0x2c]
000034  6aa8              LDR      r0,[r5,#0x28]
000036  f7fffffe          BL       GPIO_Configuration_OPP50
;;;54     	GPIO_Configuration_OPP50	(Port->sTE_PORT,				Port->sTE_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00003a  8ea9              LDRH     r1,[r5,#0x34]
00003c  6b28              LDR      r0,[r5,#0x30]
00003e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;55     	GPIO_Configuration_OPP50	(Port->sDATABUS_PORT,		Port->sDATABUS_Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000042  8fa9              LDRH     r1,[r5,#0x3c]
000044  6ba8              LDR      r0,[r5,#0x38]
000046  f7fffffe          BL       GPIO_Configuration_OPP50
;;;56     	//===========================函数地址
;;;57       LCDSYS->Display.WriteIndex    = LCD_WriteIndex;
00004a  4927              LDR      r1,|L15.232|
00004c  4825              LDR      r0,|L15.228|
00004e  6800              LDR      r0,[r0,#0]  ; LCDSYS
000050  6641              STR      r1,[r0,#0x64]
;;;58       LCDSYS->Display.WriteData     = LCD_WriteData;
000052  4926              LDR      r1,|L15.236|
000054  4823              LDR      r0,|L15.228|
000056  6800              LDR      r0,[r0,#0]  ; LCDSYS
000058  6681              STR      r1,[r0,#0x68]
;;;59       LCDSYS->Display.WriteCommand  = LCD_WriteCommand;
00005a  4925              LDR      r1,|L15.240|
00005c  4821              LDR      r0,|L15.228|
00005e  6800              LDR      r0,[r0,#0]  ; LCDSYS
000060  66c1              STR      r1,[r0,#0x6c]
;;;60     	//==========================驱动芯片检测
;;;61     	LCD_Reset();
000062  f7fffffe          BL       LCD_Reset
;;;62     //	DeviceCode	=	LCD_ReadData(0x0000);
;;;63     	
;;;64     	DeviceCode	=	ILI9326_Initialize(pInfo);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       ILI9326_Initialize
00006c  4921              LDR      r1,|L15.244|
00006e  8008              STRH     r0,[r1,#0]
;;;65     	if(ILI9326ID	==	DeviceCode)
000070  4608              MOV      r0,r1
000072  8800              LDRH     r0,[r0,#0]  ; DeviceCode
000074  f2493126          MOV      r1,#0x9326
000078  4288              CMP      r0,r1
00007a  d100              BNE      |L15.126|
;;;66     	{
;;;67     		goto	Lcd_InitContinue;
00007c  e00f              B        |L15.158|
                  |L15.126|
;;;68     	}
;;;69     		
;;;70     	DeviceCode	=	R61509V_Initialize(pInfo);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       R61509V_Initialize
000084  491b              LDR      r1,|L15.244|
000086  8008              STRH     r0,[r1,#0]
;;;71     	if(R61509ID	==	DeviceCode)
000088  4608              MOV      r0,r1
00008a  8800              LDRH     r0,[r0,#0]  ; DeviceCode
00008c  f24b5109          MOV      r1,#0xb509
000090  4288              CMP      r0,r1
000092  d100              BNE      |L15.150|
;;;72     	{
;;;73     		goto	Lcd_InitContinue;
000094  e003              B        |L15.158|
                  |L15.150|
;;;74     	}
;;;75     	
;;;76     	SSD1963_Initialize(pInfo);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       SSD1963_Initialize
;;;77     
;;;78     	Lcd_InitContinue:
00009c  bf00              NOP      
                  |L15.158|
;;;79       //==========================检查背景色与画笔色是否相同
;;;80     	if(pInfo->Data.PColor	==	pInfo->Data.BColor)
00009e  2050              MOVS     r0,#0x50
0000a0  5b01              LDRH     r1,[r0,r4]
0000a2  2052              MOVS     r0,#0x52
0000a4  5b00              LDRH     r0,[r0,r4]
0000a6  4281              CMP      r1,r0
0000a8  d105              BNE      |L15.182|
;;;81     	{
;;;82     		pInfo->Data.PColor	=	pInfo->Data.BColor^0xFF;
0000aa  2052              MOVS     r0,#0x52
0000ac  5b00              LDRH     r0,[r0,r4]
0000ae  f08001ff          EOR      r1,r0,#0xff
0000b2  2050              MOVS     r0,#0x50
0000b4  5301              STRH     r1,[r0,r4]
                  |L15.182|
;;;83     	}
;;;84       
;;;85     	//==========================LCD初始化及上电配置
;;;86     	LCDSYS->Display.PowerOn();						//LCD上电/初始化配置
0000b6  490b              LDR      r1,|L15.228|
0000b8  6809              LDR      r1,[r1,#0]  ; LCDSYS
0000ba  6f88              LDR      r0,[r1,#0x78]
0000bc  4780              BLX      r0
;;;87     	//==========================以背景色清除屏幕
;;;88     	LCD_Clean(pInfo->Data.BColor);				//按背景色清除屏幕函数
0000be  2152              MOVS     r1,#0x52
0000c0  5b08              LDRH     r0,[r1,r4]
0000c2  f7fffffe          BL       LCD_Clean
;;;89     	//==========================开背光
;;;90     	LCD_BL_ON;
0000c6  2064              MOVS     r0,#0x64
0000c8  2200              MOVS     r2,#0
0000ca  4b0b              LDR      r3,|L15.248|
0000cc  2103              MOVS     r1,#3
0000ce  9000              STR      r0,[sp,#0]
0000d0  0700              LSLS     r0,r0,#28
0000d2  f7fffffe          BL       PWM_OUT
;;;91     	//==========================字库配置
;;;92     	GT32L32_Initialize(&pInfo->GT32L32.SPI);				//普通SPI通讯方式配置
0000d6  f10400a8          ADD      r0,r4,#0xa8
0000da  f7fffffe          BL       GT32L32_Initialize
;;;93     	
;;;94     	return	0;
0000de  2000              MOVS     r0,#0
;;;95     }
0000e0  bd38              POP      {r3-r5,pc}
;;;96     /*******************************************************************************
                          ENDP

0000e2  0000              DCW      0x0000
                  |L15.228|
                          DCD      LCDSYS
                  |L15.232|
                          DCD      LCD_WriteIndex
                  |L15.236|
                          DCD      LCD_WriteData
                  |L15.240|
                          DCD      LCD_WriteCommand
                  |L15.244|
                          DCD      DeviceCode
                  |L15.248|
                          DCD      0x408f4000

                          AREA ||i.LCD_Printf||, CODE, READONLY, ALIGN=1

                  LCD_Printf PROC
;;;1005   *******************************************************************************/
;;;1006   unsigned int LCD_Printf(u16 x,u16 y,u8 font,u16 color,const char *format,...)				//后边的省略号就是可变参数
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1007   { 
000004  b0c4              SUB      sp,sp,#0x110
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  4698              MOV      r8,r3
;;;1008   		
;;;1009   //		va_list ap; 										//VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：#include <stdarg.h>,用于获取不确定个数的参数
;;;1010   //		static char string[ 256 ];			//定义数组，
;;;1011   //  	va_start( ap, format );
;;;1012   //		vsprintf( string , format, ap );    
;;;1013   //		va_end( ap );
;;;1014   	
;;;1015   	char	DataBuffer[256]={0};			//记录format内码
00000e  f44f7180          MOV      r1,#0x100
000012  a804              ADD      r0,sp,#0x10
000014  f7fffffe          BL       __aeabi_memclr4
;;;1016   	//1)**********获取数据宽度
;;;1017     u16 InputDataSize=0;		//获取数据宽度	
000018  2500              MOVS     r5,#0
;;;1018   	//3)**********args为定义的一个指向可变参数的变量，va_list以及下边要用到的va_start,va_end都是是在定义，可变参数函数中必须要用到宏， 在stdarg.h头文件中定义
;;;1019   	va_list args; 
;;;1020   	//5)**********初始化args的函数，使其指向可变参数的第一个参数，format是可变参数的前一个参数
;;;1021   	va_start(args, format);
00001a  a84b              ADD      r0,sp,#0x12c
00001c  9003              STR      r0,[sp,#0xc]
;;;1022   	//6)**********正常情况下返回生成字串的长度(除去\0),错误情况返回负值
;;;1023   	InputDataSize = vsnprintf(DataBuffer, InputDataSize,format, args);
00001e  4629              MOV      r1,r5
000020  a804              ADD      r0,sp,#0x10
000022  9b03              LDR      r3,[sp,#0xc]
000024  9a4a              LDR      r2,[sp,#0x128]
000026  f7fffffe          BL       __c89vsnprintf
00002a  b285              UXTH     r5,r0
;;;1024   
;;;1025   	//7)**********结束可变参数的获取
;;;1026   	va_end(args);                                      		
00002c  2000              MOVS     r0,#0
00002e  9003              STR      r0,[sp,#0xc]
;;;1027     if((8!=font)&&(12!=font)&&(16!=font)&&(24!=font)&&(32!=font))
000030  2c08              CMP      r4,#8
000032  d008              BEQ      |L16.70|
000034  2c0c              CMP      r4,#0xc
000036  d006              BEQ      |L16.70|
000038  2c10              CMP      r4,#0x10
00003a  d004              BEQ      |L16.70|
00003c  2c18              CMP      r4,#0x18
00003e  d002              BEQ      |L16.70|
000040  2c20              CMP      r4,#0x20
000042  d000              BEQ      |L16.70|
;;;1028     {
;;;1029       font  = 32;
000044  2420              MOVS     r4,#0x20
                  |L16.70|
;;;1030     }
;;;1031   	LCD_Show(x,y,font,color,InputDataSize,(unsigned char*)DataBuffer);
000046  a904              ADD      r1,sp,#0x10
000048  b2e8              UXTB     r0,r5
00004a  4643              MOV      r3,r8
00004c  4622              MOV      r2,r4
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
000052  4639              MOV      r1,r7
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       LCD_Show
;;;1032   	return InputDataSize;
00005a  4628              MOV      r0,r5
;;;1033   }
00005c  b044              ADD      sp,sp,#0x110
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1034   /*******************************************************************************
                          ENDP


                          AREA ||i.LCD_PrintfScroll||, CODE, READONLY, ALIGN=2

                  LCD_PrintfScroll PROC
;;;1043   *******************************************************************************/
;;;1044   unsigned int LCD_PrintfScroll(u16 x,u16 y,u8 font,u16 color,const char *format,...)				//后边的省略号就是可变参数
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1045   { 
000004  b0c1              SUB      sp,sp,#0x104
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  4698              MOV      r8,r3
;;;1046   		
;;;1047   //		va_list ap; 										//VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：#include <stdarg.h>,用于获取不确定个数的参数
;;;1048   //		static char string[ 256 ];			//定义数组，
;;;1049   //  	va_start( ap, format );
;;;1050   //		vsprintf( string , format, ap );    
;;;1051   //		va_end( ap );
;;;1052   	
;;;1053   	char	DataBuffer[256]={0};			//记录format内码
00000e  f44f7180          MOV      r1,#0x100
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       __aeabi_memclr4
;;;1054   	//1)**********获取数据宽度
;;;1055     u16 InputDataSize=0;		//获取数据宽度	
000018  2500              MOVS     r5,#0
;;;1056   	//3)**********args为定义的一个指向可变参数的变量，va_list以及下边要用到的va_start,va_end都是是在定义，可变参数函数中必须要用到宏， 在stdarg.h头文件中定义
;;;1057   	va_list args; 
;;;1058   	//5)**********初始化args的函数，使其指向可变参数的第一个参数，format是可变参数的前一个参数
;;;1059   	va_start(args, format);
00001a  a849              ADD      r0,sp,#0x124
00001c  9000              STR      r0,[sp,#0]
;;;1060   	//6)**********正常情况下返回生成字串的长度(除去\0),错误情况返回负值
;;;1061   	InputDataSize = vsnprintf(DataBuffer, InputDataSize,format, args);
00001e  4629              MOV      r1,r5
000020  a801              ADD      r0,sp,#4
000022  9b00              LDR      r3,[sp,#0]
000024  9a48              LDR      r2,[sp,#0x120]
000026  f7fffffe          BL       __c89vsnprintf
00002a  b285              UXTH     r5,r0
;;;1062   
;;;1063   	//7)**********结束可变参数的获取
;;;1064   	va_end(args);                                      		
00002c  2000              MOVS     r0,#0
00002e  9000              STR      r0,[sp,#0]
;;;1065     if((8!=font)&&(12!=font)&&(16!=font)&&(24!=font)&&(32!=font))
000030  2c08              CMP      r4,#8
000032  d008              BEQ      |L17.70|
000034  2c0c              CMP      r4,#0xc
000036  d006              BEQ      |L17.70|
000038  2c10              CMP      r4,#0x10
00003a  d004              BEQ      |L17.70|
00003c  2c18              CMP      r4,#0x18
00003e  d002              BEQ      |L17.70|
000040  2c20              CMP      r4,#0x20
000042  d000              BEQ      |L17.70|
;;;1066     {
;;;1067       font  = 24;
000044  2418              MOVS     r4,#0x18
                  |L17.70|
;;;1068     }
;;;1069   	if(NULL	==	ScrollBuff)
000046  4821              LDR      r0,|L17.204|
000048  6800              LDR      r0,[r0,#0]  ; ScrollBuff
00004a  b9b0              CBNZ     r0,|L17.122|
;;;1070   	{
;;;1071   		static stLCDScroll	NewBuff;		
;;;1072   		
;;;1073   		NewBuff.startx	=	x;
00004c  4820              LDR      r0,|L17.208|
00004e  8006              STRH     r6,[r0,#0]
;;;1074   		NewBuff.starty	=	y;
000050  8047              STRH     r7,[r0,#2]
;;;1075   		NewBuff.runxstart	=	0;
000052  2000              MOVS     r0,#0
000054  491e              LDR      r1,|L17.208|
000056  8108              STRH     r0,[r1,#8]
;;;1076   		NewBuff.color	=	color;
000058  4608              MOV      r0,r1
00005a  f8a08004          STRH     r8,[r0,#4]
;;;1077   		NewBuff.font	=	font;
00005e  7284              STRB     r4,[r0,#0xa]
;;;1078   		NewBuff.length	=	InputDataSize;
000060  80c5              STRH     r5,[r0,#6]
;;;1079   		memcpy(NewBuff.buffer,DataBuffer,InputDataSize);
000062  462a              MOV      r2,r5
000064  a901              ADD      r1,sp,#4
000066  300b              ADDS     r0,r0,#0xb
000068  f7fffffe          BL       __aeabi_memcpy
;;;1080   		
;;;1081   		ScrollBuff	=	&NewBuff;
00006c  4818              LDR      r0,|L17.208|
00006e  4917              LDR      r1,|L17.204|
000070  6008              STR      r0,[r1,#0]  ; ScrollBuff
;;;1082   		ScrollBuff->nextlist	=	NULL;
000072  2000              MOVS     r0,#0
000074  6809              LDR      r1,[r1,#0]  ; ScrollBuff
000076  6708              STR      r0,[r1,#0x70]
000078  e023              B        |L17.194|
                  |L17.122|
;;;1083   	}
;;;1084   	else
;;;1085   	{
;;;1086   		static stLCDScroll		NewBuff;
;;;1087   		stLCDScroll*	TempBuff;
;;;1088   		TempBuff	=	(stLCDScroll*)ScrollBuff->nextlist;
00007a  4814              LDR      r0,|L17.204|
00007c  6800              LDR      r0,[r0,#0]  ; ScrollBuff
00007e  f8d09070          LDR      r9,[r0,#0x70]
;;;1089   		while(NULL	!=	TempBuff->nextlist)
000082  e003              B        |L17.140|
                  |L17.132|
;;;1090   		{
;;;1091   			TempBuff	=	(stLCDScroll*)ScrollBuff->nextlist;
000084  4811              LDR      r0,|L17.204|
000086  6800              LDR      r0,[r0,#0]  ; ScrollBuff
000088  f8d09070          LDR      r9,[r0,#0x70]
                  |L17.140|
00008c  f8d90070          LDR      r0,[r9,#0x70]         ;1089
000090  2800              CMP      r0,#0                 ;1089
000092  d1f7              BNE      |L17.132|
;;;1092   		}
;;;1093   		NewBuff.startx	=	x;
000094  480f              LDR      r0,|L17.212|
000096  8006              STRH     r6,[r0,#0]
;;;1094   		NewBuff.starty	=	y;
000098  8047              STRH     r7,[r0,#2]
;;;1095   		NewBuff.runxstart	=	0;
00009a  2000              MOVS     r0,#0
00009c  490d              LDR      r1,|L17.212|
00009e  8108              STRH     r0,[r1,#8]
;;;1096   		NewBuff.color	=	color;
0000a0  4608              MOV      r0,r1
0000a2  f8a08004          STRH     r8,[r0,#4]
;;;1097   		NewBuff.font	=	font;
0000a6  7284              STRB     r4,[r0,#0xa]
;;;1098   		NewBuff.length	=	InputDataSize;
0000a8  80c5              STRH     r5,[r0,#6]
;;;1099   		memcpy(NewBuff.buffer,DataBuffer,InputDataSize);
0000aa  462a              MOV      r2,r5
0000ac  a901              ADD      r1,sp,#4
0000ae  300b              ADDS     r0,r0,#0xb
0000b0  f7fffffe          BL       __aeabi_memcpy
;;;1100   		
;;;1101   		NewBuff.nextlist	=	NULL;
0000b4  2000              MOVS     r0,#0
0000b6  4907              LDR      r1,|L17.212|
0000b8  6708              STR      r0,[r1,#0x70]  ; NewBuff
;;;1102   		TempBuff->nextlist	=	(unsigned long*)&NewBuff;
0000ba  4608              MOV      r0,r1
0000bc  f8c90070          STR      r0,[r9,#0x70]
;;;1103   	}
0000c0  bf00              NOP      
                  |L17.194|
;;;1104   //	LCD_ShowScroll(x,y,font,color,InputDataSize,(unsigned char*)DataBuffer);
;;;1105   	return InputDataSize;
0000c2  4628              MOV      r0,r5
;;;1106   }
0000c4  b041              ADD      sp,sp,#0x104
0000c6  e8bd83f0          POP      {r4-r9,pc}
;;;1107   /*******************************************************************************
                          ENDP

0000ca  0000              DCW      0x0000
                  |L17.204|
                          DCD      ScrollBuff
                  |L17.208|
                          DCD      NewBuff
                  |L17.212|
                          DCD      |symbol_number.100|

                          AREA ||i.LCD_ReadData||, CODE, READONLY, ALIGN=2

                  LCD_ReadData PROC
;;;356    **************************************************************************************************/
;;;357    u16 LCD_ReadData( unsigned short Index )
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359    	u16 Data;
;;;360    	
;;;361    	GPIO_Configuration_OPP50	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000004  4a30              LDR      r2,|L18.200|
000006  6812              LDR      r2,[r2,#0]  ; LCDSYS
000008  8f91              LDRH     r1,[r2,#0x3c]
00000a  4a2f              LDR      r2,|L18.200|
00000c  6812              LDR      r2,[r2,#0]  ; LCDSYS
00000e  6b90              LDR      r0,[r2,#0x38]
000010  f7fffffe          BL       GPIO_Configuration_OPP50
;;;362    	
;;;363    	//==================写地址
;;;364    	LCD_RD_HIGH;
000014  482c              LDR      r0,|L18.200|
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  8980              LDRH     r0,[r0,#0xc]
00001a  492b              LDR      r1,|L18.200|
00001c  6809              LDR      r1,[r1,#0]  ; LCDSYS
00001e  6889              LDR      r1,[r1,#8]
000020  6108              STR      r0,[r1,#0x10]
;;;365    	LCD_CS_LOW;
000022  4829              LDR      r0,|L18.200|
000024  6800              LDR      r0,[r0,#0]  ; LCDSYS
000026  8d80              LDRH     r0,[r0,#0x2c]
000028  4927              LDR      r1,|L18.200|
00002a  6809              LDR      r1,[r1,#0]  ; LCDSYS
00002c  6a89              LDR      r1,[r1,#0x28]
00002e  6148              STR      r0,[r1,#0x14]
;;;366    	LCD_RS_LOW;
000030  4825              LDR      r0,|L18.200|
000032  6800              LDR      r0,[r0,#0]  ; LCDSYS
000034  8b80              LDRH     r0,[r0,#0x1c]
000036  4924              LDR      r1,|L18.200|
000038  6809              LDR      r1,[r1,#0]  ; LCDSYS
00003a  6989              LDR      r1,[r1,#0x18]
00003c  6148              STR      r0,[r1,#0x14]
;;;367    
;;;368    	LCD_DATABUS_PORT->ODR = Index;
00003e  4822              LDR      r0,|L18.200|
000040  6800              LDR      r0,[r0,#0]  ; LCDSYS
000042  6b80              LDR      r0,[r0,#0x38]
000044  60c4              STR      r4,[r0,#0xc]
;;;369    	LCD_WR_LOW;
000046  4820              LDR      r0,|L18.200|
000048  6800              LDR      r0,[r0,#0]  ; LCDSYS
00004a  8c80              LDRH     r0,[r0,#0x24]
00004c  491e              LDR      r1,|L18.200|
00004e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000050  6a09              LDR      r1,[r1,#0x20]
000052  6148              STR      r0,[r1,#0x14]
;;;370    	LCD_WR_HIGH;
000054  481c              LDR      r0,|L18.200|
000056  6800              LDR      r0,[r0,#0]  ; LCDSYS
000058  8c80              LDRH     r0,[r0,#0x24]
00005a  491b              LDR      r1,|L18.200|
00005c  6809              LDR      r1,[r1,#0]  ; LCDSYS
00005e  6a09              LDR      r1,[r1,#0x20]
000060  6108              STR      r0,[r1,#0x10]
;;;371    	LCD_RS_HIGH;
000062  4819              LDR      r0,|L18.200|
000064  6800              LDR      r0,[r0,#0]  ; LCDSYS
000066  8b80              LDRH     r0,[r0,#0x1c]
000068  4917              LDR      r1,|L18.200|
00006a  6809              LDR      r1,[r1,#0]  ; LCDSYS
00006c  6989              LDR      r1,[r1,#0x18]
00006e  6108              STR      r0,[r1,#0x10]
;;;372    
;;;373    	GPIO_Configuration_IPU	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
000070  4a15              LDR      r2,|L18.200|
000072  6812              LDR      r2,[r2,#0]  ; LCDSYS
000074  8f91              LDRH     r1,[r2,#0x3c]
000076  4a14              LDR      r2,|L18.200|
000078  6812              LDR      r2,[r2,#0]  ; LCDSYS
00007a  6b90              LDR      r0,[r2,#0x38]
00007c  f7fffffe          BL       GPIO_Configuration_IPU
;;;374      
;;;375    	LCD_RD_LOW;
000080  4811              LDR      r0,|L18.200|
000082  6800              LDR      r0,[r0,#0]  ; LCDSYS
000084  8980              LDRH     r0,[r0,#0xc]
000086  4910              LDR      r1,|L18.200|
000088  6809              LDR      r1,[r1,#0]  ; LCDSYS
00008a  6889              LDR      r1,[r1,#8]
00008c  6148              STR      r0,[r1,#0x14]
;;;376    
;;;377    	Data = LCD_DATABUS_PORT->IDR;
00008e  480e              LDR      r0,|L18.200|
000090  6800              LDR      r0,[r0,#0]  ; LCDSYS
000092  6b80              LDR      r0,[r0,#0x38]
000094  6880              LDR      r0,[r0,#8]
000096  b285              UXTH     r5,r0
;;;378    	LCD_RD_HIGH;
000098  480b              LDR      r0,|L18.200|
00009a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00009c  8980              LDRH     r0,[r0,#0xc]
00009e  490a              LDR      r1,|L18.200|
0000a0  6809              LDR      r1,[r1,#0]  ; LCDSYS
0000a2  6889              LDR      r1,[r1,#8]
0000a4  6108              STR      r0,[r1,#0x10]
;;;379    	LCD_CS_HIGH;
0000a6  4808              LDR      r0,|L18.200|
0000a8  6800              LDR      r0,[r0,#0]  ; LCDSYS
0000aa  8d80              LDRH     r0,[r0,#0x2c]
0000ac  4906              LDR      r1,|L18.200|
0000ae  6809              LDR      r1,[r1,#0]  ; LCDSYS
0000b0  6a89              LDR      r1,[r1,#0x28]
0000b2  6108              STR      r0,[r1,#0x10]
;;;380    	
;;;381    	GPIO_Configuration_OPP50	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
0000b4  4a04              LDR      r2,|L18.200|
0000b6  6812              LDR      r2,[r2,#0]  ; LCDSYS
0000b8  8f91              LDRH     r1,[r2,#0x3c]
0000ba  4a03              LDR      r2,|L18.200|
0000bc  6812              LDR      r2,[r2,#0]  ; LCDSYS
0000be  6b90              LDR      r0,[r2,#0x38]
0000c0  f7fffffe          BL       GPIO_Configuration_OPP50
;;;382    	return Data;	
0000c4  4628              MOV      r0,r5
;;;383    }
0000c6  bd70              POP      {r4-r6,pc}
;;;384    /*******************************************************************************
                          ENDP

                  |L18.200|
                          DCD      LCDSYS

                          AREA ||i.LCD_ReadRegister||, CODE, READONLY, ALIGN=2

                  LCD_ReadRegister PROC
;;;446    *******************************************************************************/
;;;447    unsigned short LCD_ReadRegister(unsigned	short	Index)
000000  b570              PUSH     {r4-r6,lr}
;;;448    {
000002  4604              MOV      r4,r0
;;;449    	unsigned short Data	=	0;
000004  2500              MOVS     r5,#0
;;;450    #ifdef	Bus16Bit
;;;451    	//---------------------Write Index
;;;452    	LCD_RD_HIGH;
000006  482d              LDR      r0,|L19.188|
000008  6800              LDR      r0,[r0,#0]  ; LCDSYS
00000a  8980              LDRH     r0,[r0,#0xc]
00000c  492b              LDR      r1,|L19.188|
00000e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000010  6889              LDR      r1,[r1,#8]
000012  6108              STR      r0,[r1,#0x10]
;;;453    	LCD_CS_LOW;
000014  4829              LDR      r0,|L19.188|
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  8d80              LDRH     r0,[r0,#0x2c]
00001a  4928              LDR      r1,|L19.188|
00001c  6809              LDR      r1,[r1,#0]  ; LCDSYS
00001e  6a89              LDR      r1,[r1,#0x28]
000020  6148              STR      r0,[r1,#0x14]
;;;454    	
;;;455    	LCD_DC_LOW;		//RS
000022  4826              LDR      r0,|L19.188|
000024  6800              LDR      r0,[r0,#0]  ; LCDSYS
000026  8b80              LDRH     r0,[r0,#0x1c]
000028  4924              LDR      r1,|L19.188|
00002a  6809              LDR      r1,[r1,#0]  ; LCDSYS
00002c  6989              LDR      r1,[r1,#0x18]
00002e  6148              STR      r0,[r1,#0x14]
;;;456    	LCD_WR_LOW;
000030  4822              LDR      r0,|L19.188|
000032  6800              LDR      r0,[r0,#0]  ; LCDSYS
000034  8c80              LDRH     r0,[r0,#0x24]
000036  4921              LDR      r1,|L19.188|
000038  6809              LDR      r1,[r1,#0]  ; LCDSYS
00003a  6a09              LDR      r1,[r1,#0x20]
00003c  6148              STR      r0,[r1,#0x14]
;;;457    	LCD_DATABUS_PORT->ODR = Index;
00003e  481f              LDR      r0,|L19.188|
000040  6800              LDR      r0,[r0,#0]  ; LCDSYS
000042  6b80              LDR      r0,[r0,#0x38]
000044  60c4              STR      r4,[r0,#0xc]
;;;458    	LCD_WR_HIGH;
000046  481d              LDR      r0,|L19.188|
000048  6800              LDR      r0,[r0,#0]  ; LCDSYS
00004a  8c80              LDRH     r0,[r0,#0x24]
00004c  491b              LDR      r1,|L19.188|
00004e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000050  6a09              LDR      r1,[r1,#0x20]
000052  6108              STR      r0,[r1,#0x10]
;;;459    	LCD_DC_HIGH;	//RS
000054  4819              LDR      r0,|L19.188|
000056  6800              LDR      r0,[r0,#0]  ; LCDSYS
000058  8b80              LDRH     r0,[r0,#0x1c]
00005a  4918              LDR      r1,|L19.188|
00005c  6809              LDR      r1,[r1,#0]  ; LCDSYS
00005e  6989              LDR      r1,[r1,#0x18]
000060  6108              STR      r0,[r1,#0x10]
;;;460    	//---------------------Write Data
;;;461    	GPIO_Configuration_IPU	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
000062  4a16              LDR      r2,|L19.188|
000064  6812              LDR      r2,[r2,#0]  ; LCDSYS
000066  8f91              LDRH     r1,[r2,#0x3c]
000068  4a14              LDR      r2,|L19.188|
00006a  6812              LDR      r2,[r2,#0]  ; LCDSYS
00006c  6b90              LDR      r0,[r2,#0x38]
00006e  f7fffffe          BL       GPIO_Configuration_IPU
;;;462    	LCD_RD_LOW;
000072  4812              LDR      r0,|L19.188|
000074  6800              LDR      r0,[r0,#0]  ; LCDSYS
000076  8980              LDRH     r0,[r0,#0xc]
000078  4910              LDR      r1,|L19.188|
00007a  6809              LDR      r1,[r1,#0]  ; LCDSYS
00007c  6889              LDR      r1,[r1,#8]
00007e  6148              STR      r0,[r1,#0x14]
;;;463    	Data	=	LCD_DATABUS_PORT->IDR;
000080  480e              LDR      r0,|L19.188|
000082  6800              LDR      r0,[r0,#0]  ; LCDSYS
000084  6b80              LDR      r0,[r0,#0x38]
000086  6880              LDR      r0,[r0,#8]
000088  b285              UXTH     r5,r0
;;;464    	LCD_RD_HIGH;
00008a  480c              LDR      r0,|L19.188|
00008c  6800              LDR      r0,[r0,#0]  ; LCDSYS
00008e  8980              LDRH     r0,[r0,#0xc]
000090  490a              LDR      r1,|L19.188|
000092  6809              LDR      r1,[r1,#0]  ; LCDSYS
000094  6889              LDR      r1,[r1,#8]
000096  6108              STR      r0,[r1,#0x10]
;;;465    	LCD_CS_HIGH;
000098  4808              LDR      r0,|L19.188|
00009a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00009c  8d80              LDRH     r0,[r0,#0x2c]
00009e  4907              LDR      r1,|L19.188|
0000a0  6809              LDR      r1,[r1,#0]  ; LCDSYS
0000a2  6a89              LDR      r1,[r1,#0x28]
0000a4  6108              STR      r0,[r1,#0x10]
;;;466    	GPIO_Configuration_OPP50	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
0000a6  4a05              LDR      r2,|L19.188|
0000a8  6812              LDR      r2,[r2,#0]  ; LCDSYS
0000aa  8f91              LDRH     r1,[r2,#0x3c]
0000ac  4a03              LDR      r2,|L19.188|
0000ae  6812              LDR      r2,[r2,#0]  ; LCDSYS
0000b0  6b90              LDR      r0,[r2,#0x38]
0000b2  f7fffffe          BL       GPIO_Configuration_OPP50
;;;467    #else
;;;468    	//---------------------Write Index
;;;469    	LCD_RD_HIGH;
;;;470    	LCD_CS_LOW;
;;;471    	
;;;472    	LCD_DC_LOW;		//RS
;;;473    	
;;;474    	LCD_WR_LOW;
;;;475    	LCD_DATABUS_PORT->ODR = Index>>8;
;;;476    	LCD_WR_HIGH;
;;;477    	
;;;478    	LCD_WR_LOW;
;;;479    	LCD_DATABUS_PORT->ODR = Index;
;;;480    	LCD_WR_HIGH;
;;;481    	
;;;482    	LCD_DC_HIGH;	//RS
;;;483    	//---------------------Write Data
;;;484    	GPIO_Configuration_IPU	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
;;;485    	LCD_RD_LOW;
;;;486    	Data	=	LCD_DATABUS_PORT->IDR;
;;;487    	LCD_RD_HIGH;
;;;488    	
;;;489    	Data	<<=8;
;;;490    	
;;;491    	LCD_RD_LOW;
;;;492    	Data	|=	LCD_DATABUS_PORT->IDR;
;;;493    	LCD_RD_HIGH;	
;;;494    	LCD_CS_HIGH;
;;;495    	GPIO_Configuration_OPP50	(LCD_DATABUS_PORT,LCD_DATABUS_Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;496    #endif
;;;497    	return Data;
0000b6  4628              MOV      r0,r5
;;;498    }
0000b8  bd70              POP      {r4-r6,pc}
;;;499    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L19.188|
                          DCD      LCDSYS

                          AREA ||i.LCD_Reset||, CODE, READONLY, ALIGN=2

                  LCD_Reset PROC
;;;242    *******************************************************************************/
;;;243    void LCD_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;244    {
;;;245    	LCD_RST_HIGH;
000002  480f              LDR      r0,|L20.64|
000004  6800              LDR      r0,[r0,#0]  ; LCDSYS
000006  8a80              LDRH     r0,[r0,#0x14]
000008  490d              LDR      r1,|L20.64|
00000a  6809              LDR      r1,[r1,#0]  ; LCDSYS
00000c  6909              LDR      r1,[r1,#0x10]
00000e  6108              STR      r0,[r1,#0x10]
;;;246    	LCD_DelaymS(5);				//SysTick延时nmS
000010  2005              MOVS     r0,#5
000012  f7fffffe          BL       LCD_DelaymS
;;;247    	LCD_RST_LOW;
000016  480a              LDR      r0,|L20.64|
000018  6800              LDR      r0,[r0,#0]  ; LCDSYS
00001a  8a80              LDRH     r0,[r0,#0x14]
00001c  4908              LDR      r1,|L20.64|
00001e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000020  6909              LDR      r1,[r1,#0x10]
000022  6148              STR      r0,[r1,#0x14]
;;;248    	LCD_DelaymS(5);				//SysTick延时nmS
000024  2005              MOVS     r0,#5
000026  f7fffffe          BL       LCD_DelaymS
;;;249    	LCD_RST_HIGH;
00002a  4805              LDR      r0,|L20.64|
00002c  6800              LDR      r0,[r0,#0]  ; LCDSYS
00002e  8a80              LDRH     r0,[r0,#0x14]
000030  4903              LDR      r1,|L20.64|
000032  6809              LDR      r1,[r1,#0]  ; LCDSYS
000034  6909              LDR      r1,[r1,#0x10]
000036  6108              STR      r0,[r1,#0x10]
;;;250    	LCD_DelaymS(10);				//SysTick延时nmS
000038  200a              MOVS     r0,#0xa
00003a  f7fffffe          BL       LCD_DelaymS
;;;251    }
00003e  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  |L20.64|
                          DCD      LCDSYS

                          AREA ||i.LCD_SetBackground||, CODE, READONLY, ALIGN=2

                  LCD_SetBackground PROC
;;;584    **************************************************************************************************/
;;;585    void LCD_SetBackground(  u16 BackColor )
000000  b510              PUSH     {r4,lr}
;;;586    {
000002  4604              MOV      r4,r0
;;;587      LCDSYS->Data.BColor = BackColor;
000004  4803              LDR      r0,|L21.20|
000006  6800              LDR      r0,[r0,#0]  ; LCDSYS
000008  f8a04052          STRH     r4,[r0,#0x52]
;;;588    	LCD_Clean(BackColor);	//清除屏幕函数
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       LCD_Clean
;;;589    }
000012  bd10              POP      {r4,pc}
;;;590    /*******************************************************************************
                          ENDP

                  |L21.20|
                          DCD      LCDSYS

                          AREA ||i.LCD_Show||, CODE, READONLY, ALIGN=2

                  LCD_Show PROC
;;;693    *******************************************************************************/
;;;694    void LCD_Show(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;695    							u16 x,			//x				:起点x坐标
;;;696    							u16 y,			//y				:起点y坐标
;;;697    							u8 font,		//font		:字体大小
;;;698    							u16 PenColor,//字体颜色
;;;699    							u8 num,			//num			:字节数
;;;700    							u8 *Buffer	//Buffer	:显示的内容缓存
;;;701    )		//高通字库测试程序
;;;702    {
000004  b0a5              SUB      sp,sp,#0x94
000006  4682              MOV      r10,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  f8ddb0cc          LDR      r11,[sp,#0xcc]
;;;703    	unsigned short	MaxV,MaxH;	//边界值
;;;704    	unsigned char i=0;
000010  2500              MOVS     r5,#0
;;;705    	unsigned char CodeBuffer[130]={0};
000012  2184              MOVS     r1,#0x84
000014  a804              ADD      r0,sp,#0x10
000016  f7fffffe          BL       __aeabi_memclr4
;;;706    	switch(LCDSYS->Flag.Rotate)
00001a  4860              LDR      r0,|L22.412|
00001c  6800              LDR      r0,[r0,#0]  ; LCDSYS
00001e  f890005c          LDRB     r0,[r0,#0x5c]
000022  2801              CMP      r0,#1
000024  d004              BEQ      |L22.48|
000026  2802              CMP      r0,#2
000028  d00b              BEQ      |L22.66|
00002a  2803              CMP      r0,#3
00002c  d11b              BNE      |L22.102|
00002e  e011              B        |L22.84|
                  |L22.48|
;;;707    	{
;;;708    		case Draw_Rotate_90D:
;;;709    			MaxV	=	LCDSYS->Data.MaxH;
000030  485a              LDR      r0,|L22.412|
000032  6800              LDR      r0,[r0,#0]  ; LCDSYS
000034  f8b08040          LDRH     r8,[r0,#0x40]
;;;710    			MaxH	=	LCDSYS->Data.MaxV;
000038  4858              LDR      r0,|L22.412|
00003a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00003c  f8b09042          LDRH     r9,[r0,#0x42]
;;;711    			break;
000040  e01a              B        |L22.120|
                  |L22.66|
;;;712    		case Draw_Rotate_180D:
;;;713    			MaxV	=	LCDSYS->Data.MaxV;
000042  4856              LDR      r0,|L22.412|
000044  6800              LDR      r0,[r0,#0]  ; LCDSYS
000046  f8b08042          LDRH     r8,[r0,#0x42]
;;;714    			MaxH	=	LCDSYS->Data.MaxH;
00004a  4854              LDR      r0,|L22.412|
00004c  6800              LDR      r0,[r0,#0]  ; LCDSYS
00004e  f8b09040          LDRH     r9,[r0,#0x40]
;;;715    			break;
000052  e011              B        |L22.120|
                  |L22.84|
;;;716    		case Draw_Rotate_270D:
;;;717    			MaxV	=	LCDSYS->Data.MaxH;
000054  4851              LDR      r0,|L22.412|
000056  6800              LDR      r0,[r0,#0]  ; LCDSYS
000058  f8b08040          LDRH     r8,[r0,#0x40]
;;;718    			MaxH	=	LCDSYS->Data.MaxV;
00005c  484f              LDR      r0,|L22.412|
00005e  6800              LDR      r0,[r0,#0]  ; LCDSYS
000060  f8b09042          LDRH     r9,[r0,#0x42]
;;;719    			break;
000064  e008              B        |L22.120|
                  |L22.102|
;;;720    		default:
;;;721    			MaxV	=	LCDSYS->Data.MaxV;
000066  484d              LDR      r0,|L22.412|
000068  6800              LDR      r0,[r0,#0]  ; LCDSYS
00006a  f8b08042          LDRH     r8,[r0,#0x42]
;;;722    			MaxH	=	LCDSYS->Data.MaxH;
00006e  484b              LDR      r0,|L22.412|
000070  6800              LDR      r0,[r0,#0]  ; LCDSYS
000072  f8b09040          LDRH     r9,[r0,#0x40]
;;;723    			break;
000076  bf00              NOP      
                  |L22.120|
000078  bf00              NOP                            ;711
;;;724    	}
;;;725    	for(i=0;i<num;i++)
00007a  2500              MOVS     r5,#0
00007c  e086              B        |L22.396|
                  |L22.126|
;;;726    	{
;;;727    		unsigned char GetBufferLength	=	0;
00007e  2000              MOVS     r0,#0
000080  9003              STR      r0,[sp,#0xc]
;;;728    		unsigned char dst=Buffer[i];
000082  f81b6005          LDRB     r6,[r11,r5]
;;;729    		
;;;730    		//A=====================双字节--汉字
;;;731    		if(dst>0x80)
000086  2e80              CMP      r6,#0x80
000088  dd2e              BLE      |L22.232|
;;;732    		{
;;;733    			u16 word=dst<<8;
00008a  0230              LSLS     r0,r6,#8
00008c  9002              STR      r0,[sp,#8]
;;;734          
;;;735    			dst=Buffer[i+1];
00008e  1c68              ADDS     r0,r5,#1
000090  f81b6000          LDRB     r6,[r11,r0]
;;;736    			word=word|dst;			
000094  9802              LDR      r0,[sp,#8]
000096  4330              ORRS     r0,r0,r6
000098  9002              STR      r0,[sp,#8]
;;;737    			//A1=====================显示超限换行
;;;738          if(x>MaxH-font)
00009a  eba90004          SUB      r0,r9,r4
00009e  4550              CMP      r0,r10
0000a0  da03              BGE      |L22.170|
;;;739          {
;;;740            x=0;
0000a2  f04f0a00          MOV      r10,#0
;;;741            y+=font;
0000a6  1938              ADDS     r0,r7,r4
0000a8  b287              UXTH     r7,r0
                  |L22.170|
;;;742          }
;;;743          //A2=====================显示到屏尾，从原点开始
;;;744          if(y>MaxV-font)
0000aa  eba80004          SUB      r0,r8,r4
0000ae  42b8              CMP      r0,r7
0000b0  da02              BGE      |L22.184|
;;;745          {
;;;746            y=x=0;
0000b2  2000              MOVS     r0,#0
0000b4  4682              MOV      r10,r0
0000b6  4607              MOV      r7,r0
                  |L22.184|
;;;747          }
;;;748          //A3=====================读取点阵数据
;;;749    			GetBufferLength	=	LCD_GetDispCodeBuffer(font,word,CodeBuffer);		//从字库中读数据并返回数据长度
0000b8  aa04              ADD      r2,sp,#0x10
0000ba  4620              MOV      r0,r4
0000bc  9902              LDR      r1,[sp,#8]
0000be  f7fffffe          BL       LCD_GetDispCodeBuffer
0000c2  b2c0              UXTB     r0,r0
0000c4  9003              STR      r0,[sp,#0xc]
;;;750    			//A4=====================写入屏幕
;;;751    			LCD_ShowWord(x,y,font,PenColor,GetBufferLength,CodeBuffer);
0000c6  a904              ADD      r1,sp,#0x10
0000c8  9803              LDR      r0,[sp,#0xc]
0000ca  e9cd0100          STRD     r0,r1,[sp,#0]
0000ce  4622              MOV      r2,r4
0000d0  4639              MOV      r1,r7
0000d2  4650              MOV      r0,r10
0000d4  9b28              LDR      r3,[sp,#0xa0]
0000d6  f7fffffe          BL       LCD_ShowWord
;;;752    			//A5=====================水平显示地址增加
;;;753          x+=font;
0000da  eb0a0004          ADD      r0,r10,r4
0000de  fa1ffa80          UXTH     r10,r0
;;;754    			i++;		//双字节，减两次			
0000e2  1c68              ADDS     r0,r5,#1
0000e4  b2c5              UXTB     r5,r0
;;;755    		}
0000e6  e04d              B        |L22.388|
                  |L22.232|
;;;756    		else if(('\r'==dst)||('\n'==dst))
0000e8  2e0d              CMP      r6,#0xd
0000ea  d001              BEQ      |L22.240|
0000ec  2e0a              CMP      r6,#0xa
0000ee  d118              BNE      |L22.290|
                  |L22.240|
;;;757    		{
;;;758    			if(('\n'==Buffer[i+1])||('\r'==Buffer[i+1]))
0000f0  1c68              ADDS     r0,r5,#1
0000f2  f81b0000          LDRB     r0,[r11,r0]
0000f6  280a              CMP      r0,#0xa
0000f8  d004              BEQ      |L22.260|
0000fa  1c68              ADDS     r0,r5,#1
0000fc  f81b0000          LDRB     r0,[r11,r0]
000100  280d              CMP      r0,#0xd
000102  d101              BNE      |L22.264|
                  |L22.260|
;;;759    			{
;;;760    				i++;	//去掉回车符长度
000104  1c68              ADDS     r0,r5,#1
000106  b2c5              UXTB     r5,r0
                  |L22.264|
;;;761    			}
;;;762    			if(y>MaxV-font)
000108  eba80004          SUB      r0,r8,r4
00010c  42b8              CMP      r0,r7
00010e  da03              BGE      |L22.280|
;;;763          {
;;;764            y=x=0;
000110  2000              MOVS     r0,#0
000112  4682              MOV      r10,r0
000114  4607              MOV      r7,r0
000116  e003              B        |L22.288|
                  |L22.280|
;;;765          }
;;;766    			else
;;;767    			{
;;;768    				x=0;
000118  f04f0a00          MOV      r10,#0
;;;769    				y+=font;
00011c  1938              ADDS     r0,r7,r4
00011e  b287              UXTH     r7,r0
                  |L22.288|
;;;770    			}
;;;771    			goto LCD_ShowJump;
000120  e031              B        |L22.390|
                  |L22.290|
;;;772    		}
;;;773    		//B=====================单字节--ASCII字符集
;;;774    		else
;;;775    		{			
;;;776    			//B1=====================显示超限换行
;;;777          if(x>MaxH-font/2)
000122  eb0471d4          ADD      r1,r4,r4,LSR #31
000126  eba90161          SUB      r1,r9,r1,ASR #1
00012a  4551              CMP      r1,r10
00012c  da03              BGE      |L22.310|
;;;778          {
;;;779            x=0;
00012e  f04f0a00          MOV      r10,#0
;;;780            y+=font;
000132  1938              ADDS     r0,r7,r4
000134  b287              UXTH     r7,r0
                  |L22.310|
;;;781          }
;;;782          //B2=====================显示到屏尾，从原点开始
;;;783          if(y>MaxV-font)
000136  eba80004          SUB      r0,r8,r4
00013a  42b8              CMP      r0,r7
00013c  da02              BGE      |L22.324|
;;;784          {
;;;785            y=x=0;
00013e  2000              MOVS     r0,#0
000140  4682              MOV      r10,r0
000142  4607              MOV      r7,r0
                  |L22.324|
;;;786          }
;;;787          //B3=====================读取点阵数据
;;;788    			GetBufferLength	=	LCD_GetDispCodeBuffer(font,(u16)dst,CodeBuffer);		//从字库中读数据并返回数据长度
000144  aa04              ADD      r2,sp,#0x10
000146  4631              MOV      r1,r6
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       LCD_GetDispCodeBuffer
00014e  b2c0              UXTB     r0,r0
000150  9003              STR      r0,[sp,#0xc]
;;;789    			//=======================水平制表符按空格显示(部分字库会当0xFF输出)
;;;790    			if(	('	'	==	(char)dst)		//水平制表符
000152  2e09              CMP      r6,#9
000154  d001              BEQ      |L22.346|
;;;791    				||(' '	==	(char)dst))		//空格
000156  2e20              CMP      r6,#0x20
000158  d103              BNE      |L22.354|
                  |L22.346|
;;;792    			{
;;;793    				memset(CodeBuffer,0x00,GetBufferLength);
00015a  a804              ADD      r0,sp,#0x10
00015c  9903              LDR      r1,[sp,#0xc]
00015e  f7fffffe          BL       __aeabi_memclr4
                  |L22.354|
;;;794    			}
;;;795    			//B4=====================写入屏幕
;;;796    			LCD_ShowChar(x,y,font,PenColor,GetBufferLength,CodeBuffer);
000162  a904              ADD      r1,sp,#0x10
000164  9803              LDR      r0,[sp,#0xc]
000166  e9cd0100          STRD     r0,r1,[sp,#0]
00016a  4622              MOV      r2,r4
00016c  4639              MOV      r1,r7
00016e  4650              MOV      r0,r10
000170  9b28              LDR      r3,[sp,#0xa0]
000172  f7fffffe          BL       LCD_ShowChar
;;;797    			//B5=====================水平显示地址增加
;;;798          x+=font/2;						
000176  4620              MOV      r0,r4
000178  eb0471d0          ADD      r1,r4,r0,LSR #31
00017c  eb0a0161          ADD      r1,r10,r1,ASR #1
000180  fa1ffa81          UXTH     r10,r1
                  |L22.388|
;;;799    		}
;;;800    		LCD_ShowJump:
000184  bf00              NOP      
                  |L22.390|
;;;801    			__nop();
000186  bf00              NOP      
000188  1c68              ADDS     r0,r5,#1              ;725
00018a  b2c5              UXTB     r5,r0                 ;725
                  |L22.396|
00018c  9832              LDR      r0,[sp,#0xc8]         ;725
00018e  4285              CMP      r5,r0                 ;725
000190  f6ffaf75          BLT      |L22.126|
;;;802    	}
;;;803    }
000194  b029              ADD      sp,sp,#0xa4
000196  e8bd8ff0          POP      {r4-r11,pc}
;;;804    /*******************************************************************************
                          ENDP

00019a  0000              DCW      0x0000
                  |L22.412|
                          DCD      LCDSYS

                          AREA ||i.LCD_ShowAntenna||, CODE, READONLY, ALIGN=1

                  LCD_ShowAntenna PROC
;;;595    *******************************************************************************/
;;;596    void LCD_ShowAntenna(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;597                        u16 x,			//x				:起点x坐标
;;;598    										u16 y,			//y				:起点y坐标
;;;599                        u8 Num,
;;;600    										u16 PenColor)
;;;601    {	
000004  b08a              SUB      sp,sp,#0x28
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  461f              MOV      r7,r3
;;;602      unsigned char GetBufferLength	=	0;
00000e  f04f0800          MOV      r8,#0
;;;603      unsigned char CodeBuffer[32]={0};
000012  2120              MOVS     r1,#0x20
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       __aeabi_memclr4
;;;604      if(Num>4)
00001a  2c04              CMP      r4,#4
00001c  dd00              BLE      |L23.32|
;;;605      {
;;;606        Num=4;
00001e  2404              MOVS     r4,#4
                  |L23.32|
;;;607      }
;;;608      GetBufferLength = GT32L32_GetAntennaCode(Num,CodeBuffer);
000020  a902              ADD      r1,sp,#8
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GT32L32_GetAntennaCode
000028  f00008ff          AND      r8,r0,#0xff
;;;609    //	LCD_Show(x,y,12,GetBufferLength,CodeBuffer);
;;;610    	LCD_ShowWord(x,y,12,PenColor,GetBufferLength,CodeBuffer);
00002c  a802              ADD      r0,sp,#8
00002e  463b              MOV      r3,r7
000030  220c              MOVS     r2,#0xc
000032  4631              MOV      r1,r6
000034  e9cd8000          STRD     r8,r0,[sp,#0]
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       LCD_ShowWord
;;;611    }
00003e  b00a              ADD      sp,sp,#0x28
000040  e8bd81f0          POP      {r4-r8,pc}
;;;612    /*******************************************************************************
                          ENDP


                          AREA ||i.LCD_ShowBMP||, CODE, READONLY, ALIGN=2

                  LCD_ShowBMP PROC
;;;1112   *******************************************************************************/
;;;1113   void LCD_ShowBMP(
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1114   							unsigned short x1, unsigned short y1, 	//x1,y1:起点坐标
;;;1115   							unsigned short x2, unsigned short y2,		//x2,y2:终点坐标
;;;1116   							u16 Length,   
;;;1117                 u8 *RGBBuffer     //RGB888数据地址，传入顺序为BGR，就是第一字节为B
;;;1118   )		//高通字库测试程序
;;;1119   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;1120   	unsigned short i = 0;
000010  2400              MOVS     r4,#0
;;;1121     unsigned short j = 0;
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
;;;1122     unsigned short  RGB565;
;;;1123     eRotate Rotate = LCDSYS->Flag.Rotate;
000016  4814              LDR      r0,|L24.104|
000018  6800              LDR      r0,[r0,#0]  ; LCDSYS
00001a  f890b05c          LDRB     r11,[r0,#0x5c]
;;;1124     LCDSYS->Flag.Rotate  = Draw_Rotate_0D;			//使用旋转角度
00001e  2000              MOVS     r0,#0
000020  4911              LDR      r1,|L24.104|
000022  6809              LDR      r1,[r1,#0]  ; LCDSYS
000024  f881005c          STRB     r0,[r1,#0x5c]
;;;1125     LCDSYS->Display.WriteAddress(x1,y1,x2,y2);	//设置显示区域
000028  480f              LDR      r0,|L24.104|
00002a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00002c  4643              MOV      r3,r8
00002e  463a              MOV      r2,r7
000030  4631              MOV      r1,r6
000032  f8d0c060          LDR      r12,[r0,#0x60]
000036  4628              MOV      r0,r5
000038  47e0              BLX      r12
;;;1126   //  LCD_WriteDataStart();
;;;1127   	for(i=0;i<Length;)
00003a  bf00              NOP      
00003c  e00b              B        |L24.86|
                  |L24.62|
;;;1128   	{
;;;1129       RGB565  = RGB888toRGB565(&RGBBuffer[i]);
00003e  eb0a0004          ADD      r0,r10,r4
000042  f7fffffe          BL       RGB888toRGB565
000046  9000              STR      r0,[sp,#0]
;;;1130       LCDSYS->Display.WriteData(RGB565);
000048  4807              LDR      r0,|L24.104|
00004a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00004c  6e81              LDR      r1,[r0,#0x68]
00004e  9800              LDR      r0,[sp,#0]
000050  4788              BLX      r1
;;;1131       i+=3;
000052  1ce0              ADDS     r0,r4,#3
000054  b284              UXTH     r4,r0
                  |L24.86|
000056  454c              CMP      r4,r9                 ;1127
000058  dbf1              BLT      |L24.62|
;;;1132   	}
;;;1133   //  LCD_WriteDataEnd();
;;;1134     LCDSYS->Flag.Rotate  =  Rotate;
00005a  4803              LDR      r0,|L24.104|
00005c  6800              LDR      r0,[r0,#0]  ; LCDSYS
00005e  f880b05c          STRB     r11,[r0,#0x5c]
;;;1135   }
000062  e8bd9ffc          POP      {r2-r12,pc}
;;;1136   /*******************************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L24.104|
                          DCD      LCDSYS

                          AREA ||i.LCD_ShowBattery||, CODE, READONLY, ALIGN=1

                  LCD_ShowBattery PROC
;;;617    *******************************************************************************/
;;;618    void LCD_ShowBattery(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;619                        u16 x,			//x				:起点x坐标
;;;620    										u16 y,			//y				:起点y坐标
;;;621                        u8 Num,
;;;622    										u16 PenColor)
;;;623    {
000004  b092              SUB      sp,sp,#0x48
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  461f              MOV      r7,r3
;;;624      unsigned char GetBufferLength	=	0;
00000e  f04f0800          MOV      r8,#0
;;;625      unsigned char CodeBuffer[64]={0};
000012  2140              MOVS     r1,#0x40
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       __aeabi_memclr4
;;;626      if(Num>3)
00001a  2c03              CMP      r4,#3
00001c  dd00              BLE      |L25.32|
;;;627      {
;;;628        Num=3;
00001e  2403              MOVS     r4,#3
                  |L25.32|
;;;629      }
;;;630      GetBufferLength = GT32L32_GetBatteryCode(Num,CodeBuffer);
000020  a902              ADD      r1,sp,#8
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GT32L32_GetBatteryCode
000028  f00008ff          AND      r8,r0,#0xff
;;;631    	LCD_ShowWord(x,y,12,PenColor,GetBufferLength,CodeBuffer);
00002c  a802              ADD      r0,sp,#8
00002e  463b              MOV      r3,r7
000030  220c              MOVS     r2,#0xc
000032  4631              MOV      r1,r6
000034  e9cd8000          STRD     r8,r0,[sp,#0]
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       LCD_ShowWord
;;;632    }
00003e  b012              ADD      sp,sp,#0x48
000040  e8bd81f0          POP      {r4-r8,pc}
;;;633    /*******************************************************************************
                          ENDP


                          AREA ||i.LCD_ShowChar||, CODE, READONLY, ALIGN=2

                  LCD_ShowChar PROC
;;;638    *******************************************************************************/
;;;639    void LCD_ShowChar(
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;640    										u16 x,			//x				:起点x坐标
;;;641    										u16 y,			//y				:起点y坐标
;;;642    										u8 font,		//font		:字体大小
;;;643    										u16 color,	//字体颜色
;;;644    										u8 num,			//num			:字节数
;;;645    										u8 *Buffer	//Buffer	:显示的内容缓存
;;;646    										
;;;647    )		//高通字库测试程序
;;;648    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;649    	LCDSYS->Display.ShowChar(x,y,font,color,num,Buffer);
000010  4806              LDR      r0,|L26.44|
000012  e9cd8900          STRD     r8,r9,[sp,#0]
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f8d0c0a0          LDR      r12,[r0,#0xa0]
000022  4620              MOV      r0,r4
000024  47e0              BLX      r12
;;;650    }
000026  e8bd87fc          POP      {r2-r10,pc}
;;;651    /*******************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L26.44|
                          DCD      LCDSYS

                          AREA ||i.LCD_ShowHex||, CODE, READONLY, ALIGN=2

                  LCD_ShowHex PROC
;;;917    *******************************************************************************/
;;;918    void LCD_ShowHex(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;919    							u16 x,			//x				:起点x坐标
;;;920    							u16 y,			//y				:起点y坐标
;;;921    							u8 font,		//font		:字体大小
;;;922    							u16 color,	///字体颜色
;;;923    							u8 num,			//num			:数据个数
;;;924                  u8 bitnum,  //num			:位数
;;;925    							u8 *Buffer	//Buffer	:显示的内容缓存
;;;926    )		//高通字库测试程序
;;;927    {
000004  b0a5              SUB      sp,sp,#0x94
000006  4607              MOV      r7,r0
000008  4689              MOV      r9,r1
00000a  4614              MOV      r4,r2
00000c  f8dda0cc          LDR      r10,[sp,#0xcc]
;;;928    	unsigned short	MaxV,MaxH;	//边界值
;;;929    	unsigned char i=0;
000010  f04f0b00          MOV      r11,#0
;;;930      unsigned char Cril  = 0;
000014  2000              MOVS     r0,#0
000016  9024              STR      r0,[sp,#0x90]
;;;931    	unsigned char CodeBuffer[130]={0};
000018  2184              MOVS     r1,#0x84
00001a  a803              ADD      r0,sp,#0xc
00001c  f7fffffe          BL       __aeabi_memclr4
;;;932    
;;;933      
;;;934    	switch(LCDSYS->Flag.Rotate)
000020  484d              LDR      r0,|L27.344|
000022  6800              LDR      r0,[r0,#0]  ; LCDSYS
000024  f890005c          LDRB     r0,[r0,#0x5c]
000028  2801              CMP      r0,#1
00002a  d004              BEQ      |L27.54|
00002c  2802              CMP      r0,#2
00002e  d00b              BEQ      |L27.72|
000030  2803              CMP      r0,#3
000032  d11b              BNE      |L27.108|
000034  e011              B        |L27.90|
                  |L27.54|
;;;935    	{
;;;936    		case Draw_Rotate_90D:
;;;937    			MaxV	=	LCDSYS->Data.MaxH;
000036  4848              LDR      r0,|L27.344|
000038  6800              LDR      r0,[r0,#0]  ; LCDSYS
00003a  f8b08040          LDRH     r8,[r0,#0x40]
;;;938    			MaxH	=	LCDSYS->Data.MaxV;
00003e  4846              LDR      r0,|L27.344|
000040  6800              LDR      r0,[r0,#0]  ; LCDSYS
000042  f8b05042          LDRH     r5,[r0,#0x42]
;;;939    			break;
000046  e01a              B        |L27.126|
                  |L27.72|
;;;940    		case Draw_Rotate_180D:
;;;941    			MaxV	=	LCDSYS->Data.MaxV;
000048  4843              LDR      r0,|L27.344|
00004a  6800              LDR      r0,[r0,#0]  ; LCDSYS
00004c  f8b08042          LDRH     r8,[r0,#0x42]
;;;942    			MaxH	=	LCDSYS->Data.MaxH;
000050  4841              LDR      r0,|L27.344|
000052  6800              LDR      r0,[r0,#0]  ; LCDSYS
000054  f8b05040          LDRH     r5,[r0,#0x40]
;;;943    			break;
000058  e011              B        |L27.126|
                  |L27.90|
;;;944    		case Draw_Rotate_270D:
;;;945    			MaxV	=	LCDSYS->Data.MaxH;
00005a  483f              LDR      r0,|L27.344|
00005c  6800              LDR      r0,[r0,#0]  ; LCDSYS
00005e  f8b08040          LDRH     r8,[r0,#0x40]
;;;946    			MaxH	=	LCDSYS->Data.MaxV;
000062  483d              LDR      r0,|L27.344|
000064  6800              LDR      r0,[r0,#0]  ; LCDSYS
000066  f8b05042          LDRH     r5,[r0,#0x42]
;;;947    			break;
00006a  e008              B        |L27.126|
                  |L27.108|
;;;948    		default:
;;;949    			MaxV	=	LCDSYS->Data.MaxV;
00006c  483a              LDR      r0,|L27.344|
00006e  6800              LDR      r0,[r0,#0]  ; LCDSYS
000070  f8b08042          LDRH     r8,[r0,#0x42]
;;;950    			MaxH	=	LCDSYS->Data.MaxH;
000074  4838              LDR      r0,|L27.344|
000076  6800              LDR      r0,[r0,#0]  ; LCDSYS
000078  f8b05040          LDRH     r5,[r0,#0x40]
;;;951    			break;
00007c  bf00              NOP      
                  |L27.126|
00007e  bf00              NOP                            ;939
;;;952    	}
;;;953    	for(i=0;i<num;i++)
000080  f04f0b00          MOV      r11,#0
000084  e062              B        |L27.332|
                  |L27.134|
;;;954    	{
;;;955        unsigned char GetBufferLength	=	0;
000086  2000              MOVS     r0,#0
000088  9002              STR      r0,[sp,#8]
;;;956        for(Cril=bitnum/4;Cril>0;Cril--)
00008a  4650              MOV      r0,r10
00008c  ea4f71ea          ASR      r1,r10,#31
000090  eb0a7191          ADD      r1,r10,r1,LSR #30
000094  f3c10187          UBFX     r1,r1,#2,#8
000098  9124              STR      r1,[sp,#0x90]
00009a  e042              B        |L27.290|
                  |L27.156|
;;;957        {
;;;958          //=============================8位显示方式      
;;;959          unsigned char dst=(((u32)Buffer[i]>>(Cril-1)*4)&0x0F);
00009c  9834              LDR      r0,[sp,#0xd0]
00009e  f810100b          LDRB     r1,[r0,r11]
0000a2  9824              LDR      r0,[sp,#0x90]
0000a4  1e40              SUBS     r0,r0,#1
0000a6  0080              LSLS     r0,r0,#2
0000a8  40c1              LSRS     r1,r1,r0
0000aa  f001060f          AND      r6,r1,#0xf
;;;960          //1=====================转换为ASSIC码
;;;961          if(dst<=9)
0000ae  2e09              CMP      r6,#9
0000b0  dc03              BGT      |L27.186|
;;;962          {
;;;963            dst+=0x30;
0000b2  f1060030          ADD      r0,r6,#0x30
0000b6  b2c6              UXTB     r6,r0
0000b8  e006              B        |L27.200|
                  |L27.186|
;;;964          }
;;;965          else if((10<=dst)&&(15>=dst))
0000ba  2e0a              CMP      r6,#0xa
0000bc  db04              BLT      |L27.200|
0000be  2e0f              CMP      r6,#0xf
0000c0  dc02              BGT      |L27.200|
;;;966          {
;;;967            dst+=0x37;
0000c2  f1060037          ADD      r0,r6,#0x37
0000c6  b2c6              UXTB     r6,r0
                  |L27.200|
;;;968          }
;;;969          //1=====================显示超限换行
;;;970          if(x>MaxH-font/2)
0000c8  eb0471d4          ADD      r1,r4,r4,LSR #31
0000cc  eba50161          SUB      r1,r5,r1,ASR #1
0000d0  42b9              CMP      r1,r7
0000d2  da04              BGE      |L27.222|
;;;971          {
;;;972            x=0;
0000d4  2700              MOVS     r7,#0
;;;973            y+=font;
0000d6  eb090004          ADD      r0,r9,r4
0000da  fa1ff980          UXTH     r9,r0
                  |L27.222|
;;;974          }
;;;975          //2=====================显示到屏尾，从原点开始
;;;976          if(y>MaxV-font)
0000de  eba80004          SUB      r0,r8,r4
0000e2  4548              CMP      r0,r9
0000e4  da02              BGE      |L27.236|
;;;977          {
;;;978            y=x=0;
0000e6  2000              MOVS     r0,#0
0000e8  4607              MOV      r7,r0
0000ea  4681              MOV      r9,r0
                  |L27.236|
;;;979          }
;;;980          //3=====================读取点阵数据
;;;981          GetBufferLength	=	LCD_GetDispCodeBuffer(font,dst,CodeBuffer);		//从字库中读数据并返回数据长度
0000ec  aa03              ADD      r2,sp,#0xc
0000ee  4631              MOV      r1,r6
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       LCD_GetDispCodeBuffer
0000f6  b2c0              UXTB     r0,r0
0000f8  9002              STR      r0,[sp,#8]
;;;982          //4=====================写入屏幕
;;;983          LCD_ShowChar(x,y,font,color,GetBufferLength,CodeBuffer);
0000fa  a903              ADD      r1,sp,#0xc
0000fc  9802              LDR      r0,[sp,#8]
0000fe  e9cd0100          STRD     r0,r1,[sp,#0]
000102  4622              MOV      r2,r4
000104  4649              MOV      r1,r9
000106  4638              MOV      r0,r7
000108  9b28              LDR      r3,[sp,#0xa0]
00010a  f7fffffe          BL       LCD_ShowChar
;;;984          //5=====================显示地址增加
;;;985          x+=font/2;
00010e  4620              MOV      r0,r4
000110  eb0471d0          ADD      r1,r4,r0,LSR #31
000114  eb070161          ADD      r1,r7,r1,ASR #1
000118  b28f              UXTH     r7,r1
00011a  9824              LDR      r0,[sp,#0x90]         ;956
00011c  1e40              SUBS     r0,r0,#1              ;956
00011e  b2c0              UXTB     r0,r0                 ;956
000120  9024              STR      r0,[sp,#0x90]         ;956
                  |L27.290|
000122  9824              LDR      r0,[sp,#0x90]         ;956
000124  2800              CMP      r0,#0                 ;956
000126  dcb9              BGT      |L27.156|
;;;986        }
;;;987        //5=====================显示地址增加(增加空格位)
;;;988        x+=font/2;
000128  4620              MOV      r0,r4
00012a  eb0471d0          ADD      r1,r4,r0,LSR #31
00012e  eb070161          ADD      r1,r7,r1,ASR #1
000132  b28f              UXTH     r7,r1
;;;989    		if(x>MaxH-font)
000134  1b28              SUBS     r0,r5,r4
000136  42b8              CMP      r0,r7
000138  da04              BGE      |L27.324|
;;;990    		{
;;;991    			y+=font;
00013a  eb090004          ADD      r0,r9,r4
00013e  fa1ff980          UXTH     r9,r0
;;;992    			x=0;
000142  2700              MOVS     r7,#0
                  |L27.324|
000144  f10b0001          ADD      r0,r11,#1             ;953
000148  f0000bff          AND      r11,r0,#0xff          ;953
                  |L27.332|
00014c  9832              LDR      r0,[sp,#0xc8]         ;953
00014e  4583              CMP      r11,r0                ;953
000150  db99              BLT      |L27.134|
;;;993    		}
;;;994    	}
;;;995    }
000152  b029              ADD      sp,sp,#0xa4
000154  e8bd8ff0          POP      {r4-r11,pc}
;;;996    /*******************************************************************************
                          ENDP

                  |L27.344|
                          DCD      LCDSYS

                          AREA ||i.LCD_ShowScroll||, CODE, READONLY, ALIGN=2

                  LCD_ShowScroll PROC
;;;809    *******************************************************************************/
;;;810    void LCD_ShowScroll(stLCDScroll	*ScrollBuff)		//高通字库测试程序
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;811    {
000004  b0a8              SUB      sp,sp,#0xa0
;;;812    	unsigned short	MaxV,MaxH;	//边界值
;;;813    	unsigned char i=0;
000006  f04f0800          MOV      r8,#0
;;;814    	unsigned char CodeBuffer[130]={0};
00000a  2184              MOVS     r1,#0x84
00000c  a807              ADD      r0,sp,#0x1c
00000e  f7fffffe          BL       __aeabi_memclr4
;;;815    	unsigned char	num		=	ScrollBuff->length;
000012  9828              LDR      r0,[sp,#0xa0]
000014  7980              LDRB     r0,[r0,#6]
000016  9006              STR      r0,[sp,#0x18]
;;;816    	unsigned char	font	=	0;
000018  2400              MOVS     r4,#0
;;;817    	unsigned char* Buffer	=NULL;
00001a  2000              MOVS     r0,#0
00001c  9005              STR      r0,[sp,#0x14]
;;;818    	unsigned	short x,y;
;;;819    	stLCDScroll*	TempBuff;
;;;820    	if(NULL==	ScrollBuff)
00001e  9828              LDR      r0,[sp,#0xa0]
000020  b910              CBNZ     r0,|L28.40|
                  |L28.34|
;;;821    	{
;;;822    		return;
;;;823    	}
;;;824    	TempBuff	=	ScrollBuff;
;;;825    	
;;;826    //	LCD_Show(TempBuff->startx,TempBuff->starty,TempBuff->font,TempBuff->color,TempBuff->length,TempBuff->buffer);
;;;827    	switch(LCDSYS->Flag.Rotate)
;;;828    	{
;;;829    		case Draw_Rotate_90D:
;;;830    			MaxV	=	LCDSYS->Data.MaxH;
;;;831    			MaxH	=	LCDSYS->Data.MaxV;
;;;832    			break;
;;;833    		case Draw_Rotate_180D:
;;;834    			MaxV	=	LCDSYS->Data.MaxV;
;;;835    			MaxH	=	LCDSYS->Data.MaxH;
;;;836    			break;
;;;837    		case Draw_Rotate_270D:
;;;838    			MaxV	=	LCDSYS->Data.MaxH;
;;;839    			MaxH	=	LCDSYS->Data.MaxV;
;;;840    			break;
;;;841    		default:
;;;842    			MaxV	=	LCDSYS->Data.MaxV;
;;;843    			MaxH	=	LCDSYS->Data.MaxH;
;;;844    			break;
;;;845    	}
;;;846    	LCD_ShowCoutinue:
;;;847    	Buffer	=	&TempBuff->buffer[TempBuff->starty];
;;;848    	for(i=0;i<num;i++)
;;;849    	{
;;;850    		unsigned char GetBufferLength	=	0;
;;;851    		unsigned char dst=Buffer[i];
;;;852    		
;;;853    		//A=====================双字节--汉字
;;;854    		if(dst>0x80)
;;;855    		{
;;;856    			
;;;857    			u16 word=dst<<8;
;;;858          
;;;859    			TempBuff->starty+=2;
;;;860    			dst=Buffer[i+1];
;;;861    			word=word|dst;			
;;;862    			//A1=====================显示超限换行
;;;863          if(x>MaxH-font)
;;;864          {
;;;865            x=0;
;;;866            y+=font;
;;;867          }
;;;868          //A2=====================显示到屏尾，从原点开始
;;;869          if(y>MaxV-font)
;;;870          {
;;;871            y=x=0;
;;;872          }
;;;873          //A3=====================读取点阵数据
;;;874    			GetBufferLength	=	LCD_GetDispCodeBuffer(font,word,CodeBuffer);		//从字库中读数据并返回数据长度
;;;875    			//A4=====================写入屏幕
;;;876    			LCD_ShowWord(x,y,font,PenColor,GetBufferLength,CodeBuffer);
;;;877    			//A5=====================水平显示地址增加
;;;878          x+=font;
;;;879    			i++;		//双字节，减两次			
;;;880    		}
;;;881    		//B=====================单字节--ASCII字符集
;;;882    		else
;;;883    		{			
;;;884    			//B1=====================显示超限换行
;;;885          if(x>MaxH-font/2)
;;;886          {
;;;887            x=0;
;;;888            y+=font;
;;;889          }
;;;890          //B2=====================显示到屏尾，从原点开始
;;;891          if(y>MaxV-font)
;;;892          {
;;;893            y=x=0;
;;;894          }
;;;895          //B3=====================读取点阵数据
;;;896    			GetBufferLength	=	LCD_GetDispCodeBuffer(font,(u16)dst,CodeBuffer);		//从字库中读数据并返回数据长度
;;;897    			//=======================水平制表符按空格显示(部分字库会当0xFF输出)
;;;898    			if(	('	'	==	(char)dst)		//水平制表符
;;;899    				||(' '	==	(char)dst))		//空格
;;;900    			{
;;;901    				memset(CodeBuffer,0x00,GetBufferLength);
;;;902    			}
;;;903    			//B4=====================写入屏幕
;;;904    			LCD_ShowChar(x,y,font,PenColor,GetBufferLength,CodeBuffer);
;;;905    			//B5=====================水平显示地址增加
;;;906          x+=font/2;						
;;;907    		}
;;;908    		LCD_ShowJump:
;;;909    			__nop();
;;;910    	}
;;;911    }
000022  b029              ADD      sp,sp,#0xa4
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L28.40|
000028  f8ddb0a0          LDR      r11,[sp,#0xa0]        ;824
00002c  485a              LDR      r0,|L28.408|
00002e  6800              LDR      r0,[r0,#0]            ;827  ; LCDSYS
000030  f890005c          LDRB     r0,[r0,#0x5c]         ;827
000034  2801              CMP      r0,#1                 ;827
000036  d004              BEQ      |L28.66|
000038  2802              CMP      r0,#2                 ;827
00003a  d00b              BEQ      |L28.84|
00003c  2803              CMP      r0,#3                 ;827
00003e  d11b              BNE      |L28.120|
000040  e011              B        |L28.102|
                  |L28.66|
000042  4855              LDR      r0,|L28.408|
000044  6800              LDR      r0,[r0,#0]            ;830  ; LCDSYS
000046  f8b05040          LDRH     r5,[r0,#0x40]         ;830
00004a  4853              LDR      r0,|L28.408|
00004c  6800              LDR      r0,[r0,#0]            ;831  ; LCDSYS
00004e  f8b06042          LDRH     r6,[r0,#0x42]         ;831
000052  e01a              B        |L28.138|
                  |L28.84|
000054  4850              LDR      r0,|L28.408|
000056  6800              LDR      r0,[r0,#0]            ;834  ; LCDSYS
000058  f8b05042          LDRH     r5,[r0,#0x42]         ;834
00005c  484e              LDR      r0,|L28.408|
00005e  6800              LDR      r0,[r0,#0]            ;835  ; LCDSYS
000060  f8b06040          LDRH     r6,[r0,#0x40]         ;835
000064  e011              B        |L28.138|
                  |L28.102|
000066  484c              LDR      r0,|L28.408|
000068  6800              LDR      r0,[r0,#0]            ;838  ; LCDSYS
00006a  f8b05040          LDRH     r5,[r0,#0x40]         ;838
00006e  484a              LDR      r0,|L28.408|
000070  6800              LDR      r0,[r0,#0]            ;839  ; LCDSYS
000072  f8b06042          LDRH     r6,[r0,#0x42]         ;839
000076  e008              B        |L28.138|
                  |L28.120|
000078  4847              LDR      r0,|L28.408|
00007a  6800              LDR      r0,[r0,#0]            ;842  ; LCDSYS
00007c  f8b05042          LDRH     r5,[r0,#0x42]         ;842
000080  4845              LDR      r0,|L28.408|
000082  6800              LDR      r0,[r0,#0]            ;843  ; LCDSYS
000084  f8b06040          LDRH     r6,[r0,#0x40]         ;843
000088  bf00              NOP                            ;844
                  |L28.138|
00008a  bf00              NOP                            ;832
00008c  f8bb1002          LDRH     r1,[r11,#2]           ;847
000090  f10b000b          ADD      r0,r11,#0xb           ;847
000094  4408              ADD      r0,r0,r1              ;847
000096  9005              STR      r0,[sp,#0x14]         ;847
000098  f04f0800          MOV      r8,#0                 ;848
00009c  e076              B        |L28.396|
                  |L28.158|
00009e  2000              MOVS     r0,#0                 ;850
0000a0  9004              STR      r0,[sp,#0x10]         ;850
0000a2  9805              LDR      r0,[sp,#0x14]         ;851
0000a4  f8107008          LDRB     r7,[r0,r8]            ;851
0000a8  2f80              CMP      r7,#0x80              ;854
0000aa  dd37              BLE      |L28.284|
0000ac  0238              LSLS     r0,r7,#8              ;857
0000ae  9003              STR      r0,[sp,#0xc]          ;857
0000b0  f8bb0002          LDRH     r0,[r11,#2]           ;859
0000b4  1c80              ADDS     r0,r0,#2              ;859
0000b6  f8ab0002          STRH     r0,[r11,#2]           ;859
0000ba  f1080101          ADD      r1,r8,#1              ;860
0000be  9805              LDR      r0,[sp,#0x14]         ;860
0000c0  5c47              LDRB     r7,[r0,r1]            ;860
0000c2  9803              LDR      r0,[sp,#0xc]          ;861
0000c4  4338              ORRS     r0,r0,r7              ;861
0000c6  9003              STR      r0,[sp,#0xc]          ;861
0000c8  1b30              SUBS     r0,r6,r4              ;863
0000ca  4548              CMP      r0,r9                 ;863
0000cc  da05              BGE      |L28.218|
0000ce  f04f0900          MOV      r9,#0                 ;865
0000d2  eb0a0004          ADD      r0,r10,r4             ;866
0000d6  fa1ffa80          UXTH     r10,r0                ;866
                  |L28.218|
0000da  1b28              SUBS     r0,r5,r4              ;869
0000dc  4550              CMP      r0,r10                ;869
0000de  da02              BGE      |L28.230|
0000e0  2000              MOVS     r0,#0                 ;871
0000e2  4681              MOV      r9,r0                 ;871
0000e4  4682              MOV      r10,r0                ;871
                  |L28.230|
0000e6  aa07              ADD      r2,sp,#0x1c           ;874
0000e8  4620              MOV      r0,r4                 ;874
0000ea  9903              LDR      r1,[sp,#0xc]          ;874
0000ec  f7fffffe          BL       LCD_GetDispCodeBuffer
0000f0  b2c0              UXTB     r0,r0                 ;874
0000f2  9004              STR      r0,[sp,#0x10]         ;874
0000f4  a907              ADD      r1,sp,#0x1c           ;876
0000f6  9804              LDR      r0,[sp,#0x10]         ;876
0000f8  e9cd0100          STRD     r0,r1,[sp,#0]         ;876
0000fc  4827              LDR      r0,|L28.412|
0000fe  8803              LDRH     r3,[r0,#0]            ;876  ; PenColor
000100  4622              MOV      r2,r4                 ;876
000102  4651              MOV      r1,r10                ;876
000104  4648              MOV      r0,r9                 ;876
000106  f7fffffe          BL       LCD_ShowWord
00010a  eb090004          ADD      r0,r9,r4              ;878
00010e  fa1ff980          UXTH     r9,r0                 ;878
000112  f1080001          ADD      r0,r8,#1              ;879
000116  f00008ff          AND      r8,r0,#0xff           ;879
00011a  e032              B        |L28.386|
                  |L28.284|
00011c  eb0471d4          ADD      r1,r4,r4,LSR #31      ;885
000120  eba60161          SUB      r1,r6,r1,ASR #1       ;885
000124  4549              CMP      r1,r9                 ;885
000126  da05              BGE      |L28.308|
000128  f04f0900          MOV      r9,#0                 ;887
00012c  eb0a0004          ADD      r0,r10,r4             ;888
000130  fa1ffa80          UXTH     r10,r0                ;888
                  |L28.308|
000134  1b28              SUBS     r0,r5,r4              ;891
000136  4550              CMP      r0,r10                ;891
000138  da02              BGE      |L28.320|
00013a  2000              MOVS     r0,#0                 ;893
00013c  4681              MOV      r9,r0                 ;893
00013e  4682              MOV      r10,r0                ;893
                  |L28.320|
000140  aa07              ADD      r2,sp,#0x1c           ;896
000142  4639              MOV      r1,r7                 ;896
000144  4620              MOV      r0,r4                 ;896
000146  f7fffffe          BL       LCD_GetDispCodeBuffer
00014a  b2c0              UXTB     r0,r0                 ;896
00014c  9004              STR      r0,[sp,#0x10]         ;896
00014e  2f09              CMP      r7,#9                 ;898
000150  d001              BEQ      |L28.342|
000152  2f20              CMP      r7,#0x20              ;899
000154  d103              BNE      |L28.350|
                  |L28.342|
000156  a807              ADD      r0,sp,#0x1c           ;901
000158  9904              LDR      r1,[sp,#0x10]         ;901
00015a  f7fffffe          BL       __aeabi_memclr4
                  |L28.350|
00015e  a907              ADD      r1,sp,#0x1c           ;904
000160  9804              LDR      r0,[sp,#0x10]         ;904
000162  e9cd0100          STRD     r0,r1,[sp,#0]         ;904
000166  480d              LDR      r0,|L28.412|
000168  8803              LDRH     r3,[r0,#0]            ;904  ; PenColor
00016a  4622              MOV      r2,r4                 ;904
00016c  4651              MOV      r1,r10                ;904
00016e  4648              MOV      r0,r9                 ;904
000170  f7fffffe          BL       LCD_ShowChar
000174  4620              MOV      r0,r4                 ;906
000176  eb0471d0          ADD      r1,r4,r0,LSR #31      ;906
00017a  eb090161          ADD      r1,r9,r1,ASR #1       ;906
00017e  fa1ff981          UXTH     r9,r1                 ;906
                  |L28.386|
000182  bf00              NOP                            ;909
000184  f1080001          ADD      r0,r8,#1              ;848
000188  f00008ff          AND      r8,r0,#0xff           ;848
                  |L28.396|
00018c  9806              LDR      r0,[sp,#0x18]         ;848
00018e  4580              CMP      r8,r0                 ;848
000190  db85              BLT      |L28.158|
000192  bf00              NOP      
000194  e745              B        |L28.34|
;;;912    /*******************************************************************************
                          ENDP

000196  0000              DCW      0x0000
                  |L28.408|
                          DCD      LCDSYS
                  |L28.412|
                          DCD      PenColor

                          AREA ||i.LCD_ShowWord||, CODE, READONLY, ALIGN=2

                  LCD_ShowWord PROC
;;;656    *******************************************************************************/
;;;657    void LCD_ShowWord(
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;658    										u16 x,			//x				:起点x坐标
;;;659    										u16 y,			//y				:起点y坐标
;;;660    										u8 font,		//font		:字体大小
;;;661    										u16 color,	//字体颜色
;;;662    										u8 num,			//num			:字节数
;;;663    										u8 *Buffer	//Buffer	:显示的内容缓存
;;;664    										
;;;665    )		//高通字库测试程序
;;;666    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;667    	LCDSYS->Display.ShowWord(x,y,font,color,num,Buffer);
000010  4806              LDR      r0,|L29.44|
000012  e9cd8900          STRD     r8,r9,[sp,#0]
000016  6800              LDR      r0,[r0,#0]  ; LCDSYS
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f8d0c0a4          LDR      r12,[r0,#0xa4]
000022  4620              MOV      r0,r4
000024  47e0              BLX      r12
;;;668    }
000026  e8bd87fc          POP      {r2-r10,pc}
;;;669    /*******************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L29.44|
                          DCD      LCDSYS

                          AREA ||i.LCD_WriteCommand||, CODE, READONLY, ALIGN=2

                  LCD_WriteCommand PROC
;;;342    *******************************************************************************/
;;;343    void LCD_WriteCommand(												  //写完整控制命令
000000  b570              PUSH     {r4-r6,lr}
;;;344    											unsigned short Index,			//寄存器索引
;;;345    											unsigned short Command		//命令
;;;346    											)	//写完整控制命令
;;;347    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;348    	//==================写地址
;;;349      LCDSYS->Display.WriteIndex(Index);	
000006  4805              LDR      r0,|L30.28|
000008  6800              LDR      r0,[r0,#0]  ; LCDSYS
00000a  6e41              LDR      r1,[r0,#0x64]
00000c  4628              MOV      r0,r5
00000e  4788              BLX      r1
;;;350    	//==================写数据
;;;351      LCDSYS->Display.WriteData(Command);
000010  4802              LDR      r0,|L30.28|
000012  6800              LDR      r0,[r0,#0]  ; LCDSYS
000014  6e81              LDR      r1,[r0,#0x68]
000016  4620              MOV      r0,r4
000018  4788              BLX      r1
;;;352    }
00001a  bd70              POP      {r4-r6,pc}
;;;353    /**************************************************************************************************
                          ENDP

                  |L30.28|
                          DCD      LCDSYS

                          AREA ||i.LCD_WriteData||, CODE, READONLY, ALIGN=2

                  LCD_WriteData PROC
;;;280    *******************************************************************************/
;;;281    void LCD_WriteData(u16 Data)
000000  4917              LDR      r1,|L31.96|
;;;282    {
;;;283    #if 1	//16位数据接口
;;;284    //	LCD_WR_LOW;
;;;285    //	LCD_DATABUS_PORT->ODR = Data;		
;;;286    //	LCD_WR_HIGH;
;;;287    	
;;;288    	LCD_CS_LOW;
000002  6809              LDR      r1,[r1,#0]  ; LCDSYS
000004  8d89              LDRH     r1,[r1,#0x2c]
000006  4a16              LDR      r2,|L31.96|
000008  6812              LDR      r2,[r2,#0]  ; LCDSYS
00000a  6a92              LDR      r2,[r2,#0x28]
00000c  6151              STR      r1,[r2,#0x14]
;;;289    	LCD_RD_HIGH;
00000e  4914              LDR      r1,|L31.96|
000010  6809              LDR      r1,[r1,#0]  ; LCDSYS
000012  8989              LDRH     r1,[r1,#0xc]
000014  4a12              LDR      r2,|L31.96|
000016  6812              LDR      r2,[r2,#0]  ; LCDSYS
000018  6892              LDR      r2,[r2,#8]
00001a  6111              STR      r1,[r2,#0x10]
;;;290    	LCD_RS_HIGH;
00001c  4910              LDR      r1,|L31.96|
00001e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000020  8b89              LDRH     r1,[r1,#0x1c]
000022  4a0f              LDR      r2,|L31.96|
000024  6812              LDR      r2,[r2,#0]  ; LCDSYS
000026  6992              LDR      r2,[r2,#0x18]
000028  6111              STR      r1,[r2,#0x10]
;;;291    	LCD_DATABUS_PORT->ODR = Data;
00002a  490d              LDR      r1,|L31.96|
00002c  6809              LDR      r1,[r1,#0]  ; LCDSYS
00002e  6b89              LDR      r1,[r1,#0x38]
000030  60c8              STR      r0,[r1,#0xc]
;;;292    	LCD_WR_LOW;
000032  490b              LDR      r1,|L31.96|
000034  6809              LDR      r1,[r1,#0]  ; LCDSYS
000036  8c89              LDRH     r1,[r1,#0x24]
000038  4a09              LDR      r2,|L31.96|
00003a  6812              LDR      r2,[r2,#0]  ; LCDSYS
00003c  6a12              LDR      r2,[r2,#0x20]
00003e  6151              STR      r1,[r2,#0x14]
;;;293    	LCD_WR_HIGH;
000040  4907              LDR      r1,|L31.96|
000042  6809              LDR      r1,[r1,#0]  ; LCDSYS
000044  8c89              LDRH     r1,[r1,#0x24]
000046  4a06              LDR      r2,|L31.96|
000048  6812              LDR      r2,[r2,#0]  ; LCDSYS
00004a  6a12              LDR      r2,[r2,#0x20]
00004c  6111              STR      r1,[r2,#0x10]
;;;294    	LCD_CS_HIGH;
00004e  4904              LDR      r1,|L31.96|
000050  6809              LDR      r1,[r1,#0]  ; LCDSYS
000052  8d89              LDRH     r1,[r1,#0x2c]
000054  4a02              LDR      r2,|L31.96|
000056  6812              LDR      r2,[r2,#0]  ; LCDSYS
000058  6a92              LDR      r2,[r2,#0x28]
00005a  6111              STR      r1,[r2,#0x10]
;;;295    #else	//8位数据接口
;;;296    	LCD_CS_LOW;
;;;297    	LCD_RD_HIGH;
;;;298    	LCD_RS_HIGH;
;;;299    	//----------高8位
;;;300    	LCD_WR_LOW;
;;;301    	LCD_DATABUS_PORT->ODR = Data>>8;		
;;;302    	LCD_WR_HIGH;
;;;303    	//----------低8位
;;;304    	LCD_WR_LOW;
;;;305    	LCD_DATABUS_PORT->ODR = Data;		
;;;306    	LCD_WR_HIGH;
;;;307    	
;;;308    	LCD_CS_HIGH;
;;;309    #endif
;;;310    }
00005c  4770              BX       lr
;;;311    /*******************************************************************************
                          ENDP

00005e  0000              DCW      0x0000
                  |L31.96|
                          DCD      LCDSYS

                          AREA ||i.LCD_WriteIndex||, CODE, READONLY, ALIGN=2

                  LCD_WriteIndex PROC
;;;256    **************************************************************************************************/
;;;257    void LCD_WriteIndex( unsigned short Index )
000000  4917              LDR      r1,|L32.96|
;;;258    {
;;;259    //	LCD_CS_LOW; 	//片选信号 0:片选;1:失能;
;;;260    //	LCD_DC_LOW; 	//命令/数据：0：命令;1-数据
;;;261    //	LCD_WriteData(Index);
;;;262    //	LCD_DC_HIGH; 	//命令/数据：0：命令;1-数据
;;;263    	
;;;264    	LCD_CS_LOW;
000002  6809              LDR      r1,[r1,#0]  ; LCDSYS
000004  8d89              LDRH     r1,[r1,#0x2c]
000006  4a16              LDR      r2,|L32.96|
000008  6812              LDR      r2,[r2,#0]  ; LCDSYS
00000a  6a92              LDR      r2,[r2,#0x28]
00000c  6151              STR      r1,[r2,#0x14]
;;;265    	LCD_RD_HIGH;
00000e  4914              LDR      r1,|L32.96|
000010  6809              LDR      r1,[r1,#0]  ; LCDSYS
000012  8989              LDRH     r1,[r1,#0xc]
000014  4a12              LDR      r2,|L32.96|
000016  6812              LDR      r2,[r2,#0]  ; LCDSYS
000018  6892              LDR      r2,[r2,#8]
00001a  6111              STR      r1,[r2,#0x10]
;;;266    	LCD_RS_LOW;
00001c  4910              LDR      r1,|L32.96|
00001e  6809              LDR      r1,[r1,#0]  ; LCDSYS
000020  8b89              LDRH     r1,[r1,#0x1c]
000022  4a0f              LDR      r2,|L32.96|
000024  6812              LDR      r2,[r2,#0]  ; LCDSYS
000026  6992              LDR      r2,[r2,#0x18]
000028  6151              STR      r1,[r2,#0x14]
;;;267    	LCD_DATABUS_PORT->ODR = Index;
00002a  490d              LDR      r1,|L32.96|
00002c  6809              LDR      r1,[r1,#0]  ; LCDSYS
00002e  6b89              LDR      r1,[r1,#0x38]
000030  60c8              STR      r0,[r1,#0xc]
;;;268    	LCD_WR_LOW;
000032  490b              LDR      r1,|L32.96|
000034  6809              LDR      r1,[r1,#0]  ; LCDSYS
000036  8c89              LDRH     r1,[r1,#0x24]
000038  4a09              LDR      r2,|L32.96|
00003a  6812              LDR      r2,[r2,#0]  ; LCDSYS
00003c  6a12              LDR      r2,[r2,#0x20]
00003e  6151              STR      r1,[r2,#0x14]
;;;269    	LCD_WR_HIGH;
000040  4907              LDR      r1,|L32.96|
000042  6809              LDR      r1,[r1,#0]  ; LCDSYS
000044  8c89              LDRH     r1,[r1,#0x24]
000046  4a06              LDR      r2,|L32.96|
000048  6812              LDR      r2,[r2,#0]  ; LCDSYS
00004a  6a12              LDR      r2,[r2,#0x20]
00004c  6111              STR      r1,[r2,#0x10]
;;;270    	LCD_CS_HIGH;
00004e  4904              LDR      r1,|L32.96|
000050  6809              LDR      r1,[r1,#0]  ; LCDSYS
000052  8d89              LDRH     r1,[r1,#0x2c]
000054  4a02              LDR      r2,|L32.96|
000056  6812              LDR      r2,[r2,#0]  ; LCDSYS
000058  6a92              LDR      r2,[r2,#0x28]
00005a  6111              STR      r1,[r2,#0x10]
;;;271    }
00005c  4770              BX       lr
;;;272    /*******************************************************************************
                          ENDP

00005e  0000              DCW      0x0000
                  |L32.96|
                          DCD      LCDSYS

                          AREA ||i.LCD_WriteRegister||, CODE, READONLY, ALIGN=2

                  LCD_WriteRegister PROC
;;;392    *******************************************************************************/
;;;393    void LCD_WriteRegister(unsigned	short	Index,unsigned short Data)
000000  4a23              LDR      r2,|L33.144|
;;;394    {
;;;395    #ifdef	Bus16Bit
;;;396    	//---------------------Write Index
;;;397    	LCD_RD_HIGH;
000002  6812              LDR      r2,[r2,#0]  ; LCDSYS
000004  8992              LDRH     r2,[r2,#0xc]
000006  4b22              LDR      r3,|L33.144|
000008  681b              LDR      r3,[r3,#0]  ; LCDSYS
00000a  689b              LDR      r3,[r3,#8]
00000c  611a              STR      r2,[r3,#0x10]
;;;398    	LCD_CS_LOW;
00000e  4a20              LDR      r2,|L33.144|
000010  6812              LDR      r2,[r2,#0]  ; LCDSYS
000012  8d92              LDRH     r2,[r2,#0x2c]
000014  4b1e              LDR      r3,|L33.144|
000016  681b              LDR      r3,[r3,#0]  ; LCDSYS
000018  6a9b              LDR      r3,[r3,#0x28]
00001a  615a              STR      r2,[r3,#0x14]
;;;399    	
;;;400    	LCD_DC_LOW;		//RS
00001c  4a1c              LDR      r2,|L33.144|
00001e  6812              LDR      r2,[r2,#0]  ; LCDSYS
000020  8b92              LDRH     r2,[r2,#0x1c]
000022  4b1b              LDR      r3,|L33.144|
000024  681b              LDR      r3,[r3,#0]  ; LCDSYS
000026  699b              LDR      r3,[r3,#0x18]
000028  615a              STR      r2,[r3,#0x14]
;;;401    	LCD_WR_LOW;
00002a  4a19              LDR      r2,|L33.144|
00002c  6812              LDR      r2,[r2,#0]  ; LCDSYS
00002e  8c92              LDRH     r2,[r2,#0x24]
000030  4b17              LDR      r3,|L33.144|
000032  681b              LDR      r3,[r3,#0]  ; LCDSYS
000034  6a1b              LDR      r3,[r3,#0x20]
000036  615a              STR      r2,[r3,#0x14]
;;;402    	LCD_DATABUS_PORT->ODR = Index;
000038  4a15              LDR      r2,|L33.144|
00003a  6812              LDR      r2,[r2,#0]  ; LCDSYS
00003c  6b92              LDR      r2,[r2,#0x38]
00003e  60d0              STR      r0,[r2,#0xc]
;;;403    	LCD_WR_HIGH;
000040  4a13              LDR      r2,|L33.144|
000042  6812              LDR      r2,[r2,#0]  ; LCDSYS
000044  8c92              LDRH     r2,[r2,#0x24]
000046  4b12              LDR      r3,|L33.144|
000048  681b              LDR      r3,[r3,#0]  ; LCDSYS
00004a  6a1b              LDR      r3,[r3,#0x20]
00004c  611a              STR      r2,[r3,#0x10]
;;;404    	LCD_DC_HIGH;	//RS
00004e  4a10              LDR      r2,|L33.144|
000050  6812              LDR      r2,[r2,#0]  ; LCDSYS
000052  8b92              LDRH     r2,[r2,#0x1c]
000054  4b0e              LDR      r3,|L33.144|
000056  681b              LDR      r3,[r3,#0]  ; LCDSYS
000058  699b              LDR      r3,[r3,#0x18]
00005a  611a              STR      r2,[r3,#0x10]
;;;405    	//---------------------Write Data
;;;406    	LCD_WR_LOW;
00005c  4a0c              LDR      r2,|L33.144|
00005e  6812              LDR      r2,[r2,#0]  ; LCDSYS
000060  8c92              LDRH     r2,[r2,#0x24]
000062  4b0b              LDR      r3,|L33.144|
000064  681b              LDR      r3,[r3,#0]  ; LCDSYS
000066  6a1b              LDR      r3,[r3,#0x20]
000068  615a              STR      r2,[r3,#0x14]
;;;407    	LCD_DATABUS_PORT->ODR = Data;
00006a  4a09              LDR      r2,|L33.144|
00006c  6812              LDR      r2,[r2,#0]  ; LCDSYS
00006e  6b92              LDR      r2,[r2,#0x38]
000070  60d1              STR      r1,[r2,#0xc]
;;;408    	LCD_WR_HIGH;
000072  4a07              LDR      r2,|L33.144|
000074  6812              LDR      r2,[r2,#0]  ; LCDSYS
000076  8c92              LDRH     r2,[r2,#0x24]
000078  4b05              LDR      r3,|L33.144|
00007a  681b              LDR      r3,[r3,#0]  ; LCDSYS
00007c  6a1b              LDR      r3,[r3,#0x20]
00007e  611a              STR      r2,[r3,#0x10]
;;;409    	LCD_CS_HIGH;	
000080  4a03              LDR      r2,|L33.144|
000082  6812              LDR      r2,[r2,#0]  ; LCDSYS
000084  8d92              LDRH     r2,[r2,#0x2c]
000086  4b02              LDR      r3,|L33.144|
000088  681b              LDR      r3,[r3,#0]  ; LCDSYS
00008a  6a9b              LDR      r3,[r3,#0x28]
00008c  611a              STR      r2,[r3,#0x10]
;;;410    #else
;;;411    	//---------------------Write Index
;;;412    	LCD_RD_HIGH;
;;;413    	LCD_CS_LOW;
;;;414    	
;;;415    	LCD_DC_LOW;		//RS
;;;416    	
;;;417    	LCD_WR_LOW;
;;;418    	LCD_DATABUS_PORT->ODR = Index>>8;
;;;419    	LCD_WR_HIGH;
;;;420    	
;;;421    	LCD_WR_LOW;
;;;422    	LCD_DATABUS_PORT->ODR = Index;
;;;423    	LCD_WR_HIGH;
;;;424    	
;;;425    	LCD_DC_HIGH;	//RS
;;;426    	//---------------------Write Data
;;;427    	LCD_WR_LOW;
;;;428    	LCD_DATABUS_PORT->ODR = Data>>8;
;;;429    	LCD_WR_HIGH;
;;;430    	
;;;431    	LCD_WR_LOW;
;;;432    	LCD_DATABUS_PORT->ODR = Data;
;;;433    	LCD_WR_HIGH;
;;;434    	
;;;435    	LCD_CS_HIGH;		
;;;436    #endif
;;;437    }
00008e  4770              BX       lr
;;;438    /*******************************************************************************
                          ENDP

                  |L33.144|
                          DCD      LCDSYS

                          AREA ||i.RGB888toRGB565||, CODE, READONLY, ALIGN=1

                  RGB888toRGB565 PROC
;;;1144   *******************************************************************************/
;;;1145   unsigned  short RGB888toRGB565(u8 *RGB888)
000000  4601              MOV      r1,r0
;;;1146   {
;;;1147     unsigned  short RGB565  = 0;
000002  2000              MOVS     r0,#0
;;;1148     //-----------------Red:取5位
;;;1149     RGB565  = RGB888[2]>>3;
000004  788a              LDRB     r2,[r1,#2]
000006  10d0              ASRS     r0,r2,#3
;;;1150     RGB565<<=5;
000008  f64f72ff          MOV      r2,#0xffff
00000c  ea021040          AND      r0,r2,r0,LSL #5
;;;1151     //-----------------Green：取5位
;;;1152     RGB565  |= RGB888[1]>>3;
000010  784a              LDRB     r2,[r1,#1]
000012  ea4000e2          ORR      r0,r0,r2,ASR #3
;;;1153     RGB565<<=6;
000016  f64f72ff          MOV      r2,#0xffff
00001a  ea021080          AND      r0,r2,r0,LSL #6
;;;1154     //-----------------Blue：取5位
;;;1155     RGB565  |= RGB888[0]>>3;
00001e  780a              LDRB     r2,[r1,#0]
000020  ea4000e2          ORR      r0,r0,r2,ASR #3
;;;1156     return  RGB565;
;;;1157   }
000024  4770              BX       lr
;;;1158   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  NewBuff
                          %        116
                  |symbol_number.100|
                          %        116

                          AREA ||.data||, DATA, ALIGN=2

                  LCDSYS
                          DCD      0x00000000
                  ScrollBuff
                          DCD      0x00000000
                  PenColor
000008  0000              DCW      0x0000
                  BackColor
00000a  0000              DCW      0x0000
                  VAsize
00000c  0000              DCW      0x0000
                  DeviceCode
00000e  0000              DCW      0x0000
                  |symbol_number.102|
000010  0000              DCW      0x0000
