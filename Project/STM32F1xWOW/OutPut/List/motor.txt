; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\motor.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\motor.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\motor.crf ..\..\Driver\Components\SCR\MOTOR.C]
                          THUMB

                          AREA ||i.StepMotoConf||, CODE, READONLY, ALIGN=2

                  StepMotoConf PROC
;;;18     ******************************************************************/
;;;19     void StepMotoConf(STEP_MOTO_CONF *STEP_MOTOx)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;20     {
000004  4604              MOV      r4,r0
;;;21     	//____________PUL转速控制
;;;22     	GPIO_Configuration_OPP50	(STEP_MOTOx->PUL_PORT,	STEP_MOTOx->PUL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000006  88a1              LDRH     r1,[r4,#4]
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;23     	//____________DIR方向控制
;;;24     	GPIO_Configuration_OPP50	(STEP_MOTOx->DIR_PORT,	STEP_MOTOx->DIR_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00000e  89a1              LDRH     r1,[r4,#0xc]
000010  68a0              LDR      r0,[r4,#8]
000012  f7fffffe          BL       GPIO_Configuration_OPP50
;;;25     	//____________EN使能
;;;26     	GPIO_Configuration_OPP50	(STEP_MOTOx->EN_PORT,		STEP_MOTOx->EN_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000016  8aa1              LDRH     r1,[r4,#0x14]
000018  6920              LDR      r0,[r4,#0x10]
00001a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;27     	//____________Brake刹车控制
;;;28     	GPIO_Configuration_OPP50	(STEP_MOTOx->Brake_PORT,	STEP_MOTOx->Brake_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00001e  8ba1              LDRH     r1,[r4,#0x1c]
000020  69a0              LDR      r0,[r4,#0x18]
000022  f7fffffe          BL       GPIO_Configuration_OPP50
;;;29     	
;;;30     	//------
;;;31     	STEP_MOTOx->TIME_RUN.StepCycle=1000000/(STEP_MOTOx->TIME_CONF.BaseTime)/(STEP_MOTOx->TIME_CONF.StepFreq);				//正常运行周期=1S/时基/频率
000026  4920              LDR      r1,|L1.168|
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  fbb1f1f0          UDIV     r1,r1,r0
00002e  6a60              LDR      r0,[r4,#0x24]
000030  fbb1f1f0          UDIV     r1,r1,r0
000034  6361              STR      r1,[r4,#0x34]
;;;32     	if(STEP_MOTOx->TIME_RUN.StepCycle<2)
000036  6b60              LDR      r0,[r4,#0x34]
000038  2802              CMP      r0,#2
00003a  d202              BCS      |L1.66|
;;;33     	{
;;;34     		STEP_MOTOx->TIME_RUN.StepCycle=2;
00003c  2102              MOVS     r1,#2
00003e  6361              STR      r1,[r4,#0x34]
000040  e007              B        |L1.82|
                  |L1.66|
;;;35     	}
;;;36     	else if((STEP_MOTOx->TIME_RUN.StepCycle%2)!=0)
000042  2034              MOVS     r0,#0x34
000044  5d00              LDRB     r0,[r0,r4]
000046  f0000001          AND      r0,r0,#1
00004a  b110              CBZ      r0,|L1.82|
;;;37     	{
;;;38     		STEP_MOTOx->TIME_RUN.StepCycle-=1;
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  1e40              SUBS     r0,r0,#1
000050  6360              STR      r0,[r4,#0x34]
                  |L1.82|
;;;39     	}
;;;40     	STEP_MOTOx->TIME_RUN.StartCycle=1000000/(STEP_MOTOx->TIME_CONF.BaseTime)/(STEP_MOTOx->TIME_CONF.StartFreq);			//起始运行周期=1S/时基/起始频率
000052  4915              LDR      r1,|L1.168|
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  fbb1f1f0          UDIV     r1,r1,r0
00005a  6aa0              LDR      r0,[r4,#0x28]
00005c  fbb1f1f0          UDIV     r1,r1,r0
000060  63a1              STR      r1,[r4,#0x38]
;;;41     	STEP_MOTOx->TIME_RUN.StartSteps=(STEP_MOTOx->TIME_RUN.StartCycle-STEP_MOTOx->TIME_RUN.StepCycle)/500+0.5;				//分500步加速
000062  e9d4010d          LDRD     r0,r1,[r4,#0x34]
000066  1a08              SUBS     r0,r1,r0
000068  f44f71fa          MOV      r1,#0x1f4
00006c  fbb0f9f1          UDIV     r9,r0,r1
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       __aeabi_ui2d
000076  4607              MOV      r7,r0
000078  2200              MOVS     r2,#0
00007a  4b0c              LDR      r3,|L1.172|
00007c  f7fffffe          BL       __aeabi_dadd
000080  4605              MOV      r5,r0
000082  f7fffffe          BL       __aeabi_d2uiz
000086  63e0              STR      r0,[r4,#0x3c]
;;;42     	STEP_MOTOx->TIME_RUN.RunCycle=STEP_MOTOx->TIME_RUN.StartCycle;		//恢复起始时间
000088  6ba1              LDR      r1,[r4,#0x38]
00008a  6421              STR      r1,[r4,#0x40]
;;;43     	STEP_MOTOx->TIME_RUN.HalfCycle=STEP_MOTOx->TIME_RUN.RunCycle/2;		//半周期时间
00008c  6c20              LDR      r0,[r4,#0x40]
00008e  0841              LSRS     r1,r0,#1
000090  6461              STR      r1,[r4,#0x44]
;;;44     	if(STEP_MOTOx->TIME_RUN.StartSteps<2)
000092  6be0              LDR      r0,[r4,#0x3c]
000094  2802              CMP      r0,#2
000096  d201              BCS      |L1.156|
;;;45     	{
;;;46     		STEP_MOTOx->TIME_RUN.StartSteps=2;
000098  2102              MOVS     r1,#2
00009a  63e1              STR      r1,[r4,#0x3c]
                  |L1.156|
;;;47     	}
;;;48     	
;;;49     	STEP_MOTOx->MOTO_COMMAND		=	MOTO_COMMAND_STOP;		//
00009c  2002              MOVS     r0,#2
00009e  f884004c          STRB     r0,[r4,#0x4c]
;;;50     }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;51     /****************************************************************
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
                          DCD      0x000f4240
                  |L1.172|
                          DCD      0x3fe00000

                          AREA ||i.StepMotoContrl||, CODE, READONLY, ALIGN=1

                  StepMotoContrl PROC
;;;55     ******************************************************************/
;;;56     void StepMotoContrl(STEP_MOTO_CONF *STEP_MOTOx)
000000  4770              BX       lr
;;;57     {
;;;58     
;;;59     }
;;;60     /****************************************************************
                          ENDP


                          AREA ||i.StepMotoPause||, CODE, READONLY, ALIGN=1

                  StepMotoPause PROC
;;;135    ******************************************************************/
;;;136    void StepMotoPause(STEP_MOTO_CONF *STEP_MOTOx)
000000  b510              PUSH     {r4,lr}
;;;137    {
000002  4604              MOV      r4,r0
;;;138    	STEP_MOTOx->TIME_RUN.StepTimeCount=0;														//运行计时清零
000004  2000              MOVS     r0,#0
000006  6320              STR      r0,[r4,#0x30]
;;;139    	STEP_MOTOx->TIME_RUN.ToggleTime=0;															//翻转时间清零
000008  2100              MOVS     r1,#0
00000a  64a1              STR      r1,[r4,#0x48]
;;;140    	STEP_MOTOx->TIME_RUN.RunCycle=STEP_MOTOx->TIME_RUN.StartCycle;	//恢复起始时间
00000c  6ba1              LDR      r1,[r4,#0x38]
00000e  6421              STR      r1,[r4,#0x40]
;;;141    	
;;;142    	GPIO_ResetBits(STEP_MOTOx->DIR_PORT,STEP_MOTOx->DIR_Pin);
000010  89a1              LDRH     r1,[r4,#0xc]
000012  68a0              LDR      r0,[r4,#8]
000014  f7fffffe          BL       GPIO_ResetBits
;;;143    	GPIO_ResetBits(STEP_MOTOx->PUL_PORT,STEP_MOTOx->PUL_Pin);				//停止
000018  88a1              LDRH     r1,[r4,#4]
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       GPIO_ResetBits
;;;144    	
;;;145    //	STEP_MOTOx->MOTO_STATUS=MOTOR_STATUS_STOP;											//状态为停止状态
;;;146    //	STEP_MOTOx->MOTO_CTLSTATUS=MOTOR_WAIT_START;
;;;147    }
000020  bd10              POP      {r4,pc}
;;;148    /****************************************************************
                          ENDP


                          AREA ||i.StepMotoRun||, CODE, READONLY, ALIGN=1

                  StepMotoRun PROC
;;;64     ******************************************************************/
;;;65     void StepMotoRun(STEP_MOTO_CONF *STEP_MOTOx)
000000  b510              PUSH     {r4,lr}
;;;66     {
000002  4604              MOV      r4,r0
;;;67     	STEP_MOTOx->TIME_RUN.StepTimeCount++;
000004  6b20              LDR      r0,[r4,#0x30]
000006  1c40              ADDS     r0,r0,#1
000008  6320              STR      r0,[r4,#0x30]
;;;68     	if(STEP_MOTOx->TIME_RUN.StepTimeCount	<=	2)								//开启DIR时间
00000a  6b20              LDR      r0,[r4,#0x30]
00000c  2802              CMP      r0,#2
00000e  d803              BHI      |L4.24|
;;;69     	{
;;;70     		GPIO_SetBits(STEP_MOTOx->DIR_PORT,STEP_MOTOx->DIR_Pin);
000010  89a1              LDRH     r1,[r4,#0xc]
000012  68a0              LDR      r0,[r4,#8]
000014  f7fffffe          BL       GPIO_SetBits
                  |L4.24|
;;;71     	}
;;;72     	if(STEP_MOTOx->TIME_RUN.StepTimeCount	<	STEP_MOTOx->TIME_CONF.StepTimeOut)				//未超时
000018  6a21              LDR      r1,[r4,#0x20]
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  4288              CMP      r0,r1
00001e  d236              BCS      |L4.142|
;;;73     	{
;;;74     		//1------------加速阶段:当前运行周期比预定周期长表示还在加速阶段
;;;75     		//-------------加速时间最高为500ms,每1ms增加一个频率段,直到加速到预定速度,相关参数:StartSteps
;;;76     		//-------------频率增加后检查是否加速完成,可以节省加速完成后的时间
;;;77     		if(STEP_MOTOx->TIME_RUN.RunCycle	>	STEP_MOTOx->TIME_RUN.StepCycle)
000020  6c21              LDR      r1,[r4,#0x40]
000022  6b60              LDR      r0,[r4,#0x34]
000024  4281              CMP      r1,r0
000026  d918              BLS      |L4.90|
;;;78     		{
;;;79     			if((STEP_MOTOx->TIME_RUN.StepTimeCount*STEP_MOTOx->TIME_CONF.BaseTime)%1000==0)		//1ms加速计时
000028  e9d4100b          LDRD     r1,r0,[r4,#0x2c]
00002c  4348              MULS     r0,r1,r0
00002e  f44f717a          MOV      r1,#0x3e8
000032  fbb0f2f1          UDIV     r2,r0,r1
000036  fb010012          MLS      r0,r1,r2,r0
00003a  b928              CBNZ     r0,|L4.72|
;;;80     			{
;;;81     				STEP_MOTOx->TIME_RUN.RunCycle		-=	2;
00003c  6c20              LDR      r0,[r4,#0x40]
00003e  1e80              SUBS     r0,r0,#2
000040  6420              STR      r0,[r4,#0x40]
;;;82     				STEP_MOTOx->TIME_RUN.HalfCycle	=		(STEP_MOTOx->TIME_RUN.RunCycle/2);		//半周期时间
000042  6c20              LDR      r0,[r4,#0x40]
000044  0841              LSRS     r1,r0,#1
000046  6461              STR      r1,[r4,#0x44]
                  |L4.72|
;;;83     			}
;;;84     			//检查是否加速完成:如果加速完成,后期正常运行不再进入此步骤以达到节省运算时间的目的
;;;85     			if(STEP_MOTOx->TIME_RUN.RunCycle	<=	STEP_MOTOx->TIME_RUN.StepCycle)			//加速过程完成
000048  6c21              LDR      r1,[r4,#0x40]
00004a  6b60              LDR      r0,[r4,#0x34]
00004c  4281              CMP      r1,r0
00004e  d804              BHI      |L4.90|
;;;86     			{
;;;87     				STEP_MOTOx->TIME_RUN.RunCycle		=		STEP_MOTOx->TIME_RUN.StepCycle;				//按正常运行周期运行
000050  6b61              LDR      r1,[r4,#0x34]
000052  6421              STR      r1,[r4,#0x40]
;;;88     				STEP_MOTOx->TIME_RUN.HalfCycle	=		(STEP_MOTOx->TIME_RUN.RunCycle/2);		//半周期时间
000054  6c20              LDR      r0,[r4,#0x40]
000056  0841              LSRS     r1,r0,#1
000058  6461              STR      r1,[r4,#0x44]
                  |L4.90|
;;;89     			}
;;;90     		}
;;;91     		//1============================PWM脉冲输出控制
;;;92     		//1.1-----------计算输出翻转时间
;;;93     		if(STEP_MOTOx->TIME_RUN.ToggleTime++	>=	STEP_MOTOx->TIME_RUN.RunCycle-1)	//翻转计时:前半周期->后半周期状态切换,如果到达一个预定周期,清零重新计时
00005a  6ca2              LDR      r2,[r4,#0x48]
00005c  1c50              ADDS     r0,r2,#1
00005e  64a0              STR      r0,[r4,#0x48]
000060  6c20              LDR      r0,[r4,#0x40]
000062  1e40              SUBS     r0,r0,#1
000064  4282              CMP      r2,r0
000066  d304              BCC      |L4.114|
;;;94     		{
;;;95     			STEP_MOTOx->TIME_RUN.HalfCycle	=	(STEP_MOTOx->TIME_RUN.RunCycle/2);			//半周期时间
000068  6c20              LDR      r0,[r4,#0x40]
00006a  0841              LSRS     r1,r0,#1
00006c  6461              STR      r1,[r4,#0x44]
;;;96     			STEP_MOTOx->TIME_RUN.ToggleTime	=	0;			//清零
00006e  2100              MOVS     r1,#0
000070  64a1              STR      r1,[r4,#0x48]
                  |L4.114|
;;;97     		}
;;;98     		//1.2-----------输出翻转控制(模拟PWM)		
;;;99     		if(STEP_MOTOx->TIME_RUN.ToggleTime	<	STEP_MOTOx->TIME_RUN.HalfCycle)			//翻转时的前半周期输出电平
000072  e9d40111          LDRD     r0,r1,[r4,#0x44]
000076  4281              CMP      r1,r0
000078  d204              BCS      |L4.132|
;;;100    		{
;;;101    			GPIO_SetBits(STEP_MOTOx->PUL_PORT,STEP_MOTOx->PUL_Pin);
00007a  88a1              LDRH     r1,[r4,#4]
00007c  6820              LDR      r0,[r4,#0]
00007e  f7fffffe          BL       GPIO_SetBits
000082  e007              B        |L4.148|
                  |L4.132|
;;;102    		}
;;;103    		else					//翻转时的后半周期输出电平
;;;104    		{
;;;105    			GPIO_ResetBits(STEP_MOTOx->PUL_PORT,STEP_MOTOx->PUL_Pin);
000084  88a1              LDRH     r1,[r4,#4]
000086  6820              LDR      r0,[r4,#0]
000088  f7fffffe          BL       GPIO_ResetBits
00008c  e002              B        |L4.148|
                  |L4.142|
;;;106    		}
;;;107    //		STEP_MOTOx->MOTO_STATUS	=	MOTOR_STATUS_RUN;										//超时标志
;;;108    	}
;;;109    	else		//超时
;;;110    	{
;;;111    		StepMotoStop(STEP_MOTOx);																		//停止电机
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       StepMotoStop
                  |L4.148|
;;;112    	}
;;;113    }
000094  bd10              POP      {r4,pc}
;;;114    /****************************************************************
                          ENDP


                          AREA ||i.StepMotoSever||, CODE, READONLY, ALIGN=1

                  StepMotoSever PROC
;;;152    ******************************************************************/
;;;153    void StepMotoSever(STEP_MOTO_CONF *STEP_MOTOx)
000000  b510              PUSH     {r4,lr}
;;;154    {
000002  4604              MOV      r4,r0
;;;155    	if(STEP_MOTOx->MOTO_COMMAND==MOTO_COMMAND_RUN)
000004  f894004c          LDRB     r0,[r4,#0x4c]
000008  b918              CBNZ     r0,|L5.18|
;;;156    	{
;;;157    		StepMotoRun(STEP_MOTOx);			//		
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       StepMotoRun
000010  e006              B        |L5.32|
                  |L5.18|
;;;158    	}
;;;159    	else if(STEP_MOTOx->MOTO_COMMAND==MOTO_COMMAND_STOP)
000012  f894004c          LDRB     r0,[r4,#0x4c]
000016  2802              CMP      r0,#2
000018  d102              BNE      |L5.32|
;;;160    	{
;;;161    		StepMotoStop(STEP_MOTOx);			//
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       StepMotoStop
                  |L5.32|
;;;162    		
;;;163    	}
;;;164    }
000020  bd10              POP      {r4,pc}
;;;165    
                          ENDP


                          AREA ||i.StepMotoStop||, CODE, READONLY, ALIGN=1

                  StepMotoStop PROC
;;;118    ******************************************************************/
;;;119    void StepMotoStop(STEP_MOTO_CONF *STEP_MOTOx)
000000  b510              PUSH     {r4,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121    	STEP_MOTOx->TIME_RUN.StepTimeCount=0;														//运行计时清零
000004  2000              MOVS     r0,#0
000006  6320              STR      r0,[r4,#0x30]
;;;122    	STEP_MOTOx->TIME_RUN.ToggleTime=0;															//翻转时间清零
000008  2100              MOVS     r1,#0
00000a  64a1              STR      r1,[r4,#0x48]
;;;123    	STEP_MOTOx->TIME_RUN.RunCycle=STEP_MOTOx->TIME_RUN.StartCycle;	//恢复起始时间
00000c  6ba1              LDR      r1,[r4,#0x38]
00000e  6421              STR      r1,[r4,#0x40]
;;;124    	
;;;125    	GPIO_ResetBits(STEP_MOTOx->DIR_PORT,STEP_MOTOx->DIR_Pin);
000010  89a1              LDRH     r1,[r4,#0xc]
000012  68a0              LDR      r0,[r4,#8]
000014  f7fffffe          BL       GPIO_ResetBits
;;;126    	GPIO_ResetBits(STEP_MOTOx->PUL_PORT,STEP_MOTOx->PUL_Pin);				//停止
000018  88a1              LDRH     r1,[r4,#4]
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       GPIO_ResetBits
;;;127    	
;;;128    //	STEP_MOTOx->MOTO_STATUS=MOTOR_STATUS_STOP;											//状态为停止状态
;;;129    //	STEP_MOTOx->MOTO_CTLSTATUS=MOTOR_WAIT_START;
;;;130    }
000020  bd10              POP      {r4,pc}
;;;131    /****************************************************************
                          ENDP

