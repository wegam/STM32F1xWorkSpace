; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\mmc_sd.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\mmc_sd.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\mmc_sd.crf ..\..\Driver\Components\SCR\MMC_SD.C]
                          THUMB

                          AREA ||i.SD_DisSelect||, CODE, READONLY, ALIGN=2

                  SD_DisSelect PROC
;;;28     //取消选择,释放SPI总线
;;;29     void SD_DisSelect(void)
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	SD_CS=1;
000002  2001              MOVS     r0,#1
000004  4902              LDR      r1,|L1.16|
000006  6008              STR      r0,[r1,#0]
;;;32      	SD_SPI_ReadWriteByte(0xff);//提供额外的8个时钟
000008  20ff              MOVS     r0,#0xff
00000a  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;33     }
00000e  bd10              POP      {r4,pc}
;;;34     //选择sd卡,并且等待卡准备OK
                          ENDP

                  |L1.16|
                          DCD      0x42220198

                          AREA ||i.SD_GetCID||, CODE, READONLY, ALIGN=1

                  SD_GetCID PROC
;;;190    *******************************************************************************/
;;;191    unsigned char SD_GetCID(u8 *cid_data)
000000  b570              PUSH     {r4-r6,lr}
;;;192    {
000002  4605              MOV      r5,r0
;;;193        u8 r1;	   
;;;194        //发CMD10命令，读CID
;;;195        r1=SD_SendCmd(CMD10,0,0x01);
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       SD_SendCmd
00000e  4604              MOV      r4,r0
;;;196      if(r1==0x00)
000010  b924              CBNZ     r4,|L2.28|
;;;197    	{
;;;198    		r1=SD_RecvData(cid_data,16);//接收16个字节的数据	 
000012  2110              MOVS     r1,#0x10
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SD_RecvData
00001a  4604              MOV      r4,r0
                  |L2.28|
;;;199      }
;;;200    	SD_DisSelect();//取消片选
00001c  f7fffffe          BL       SD_DisSelect
;;;201    	if(r1)
000020  b10c              CBZ      r4,|L2.38|
;;;202        return 1;
000022  2001              MOVS     r0,#1
                  |L2.36|
;;;203    	else
;;;204        return 0;
;;;205    }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  2000              MOVS     r0,#0                 ;204
000028  e7fc              B        |L2.36|
;;;206    /*******************************************************************************
                          ENDP


                          AREA ||i.SD_GetCSD||, CODE, READONLY, ALIGN=1

                  SD_GetCSD PROC
;;;215    *******************************************************************************/
;;;216    unsigned char SD_GetCSD(u8 *csd_data)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
000002  4605              MOV      r5,r0
;;;218        u8 r1;	 
;;;219        r1=SD_SendCmd(CMD9,0,0x01);//发CMD9命令，读CSD
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  2009              MOVS     r0,#9
00000a  f7fffffe          BL       SD_SendCmd
00000e  4604              MOV      r4,r0
;;;220        if(r1==0)
000010  b924              CBNZ     r4,|L3.28|
;;;221    	{
;;;222        	r1=SD_RecvData(csd_data, 16);//接收16个字节的数据 
000012  2110              MOVS     r1,#0x10
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SD_RecvData
00001a  4604              MOV      r4,r0
                  |L3.28|
;;;223        }
;;;224    	SD_DisSelect();//取消片选
00001c  f7fffffe          BL       SD_DisSelect
;;;225    	if(r1)
000020  b10c              CBZ      r4,|L3.38|
;;;226        return 1;
000022  2001              MOVS     r0,#1
                  |L3.36|
;;;227    	else
;;;228        return 0;
;;;229    }
000024  bd70              POP      {r4-r6,pc}
                  |L3.38|
000026  2000              MOVS     r0,#0                 ;228
000028  e7fc              B        |L3.36|
;;;230    /*******************************************************************************
                          ENDP


                          AREA ||i.SD_GetResponse||, CODE, READONLY, ALIGN=1

                  SD_GetResponse PROC
;;;76     *******************************************************************************/
;;;77     unsigned char SD_GetResponse(u8 Response)
000000  b570              PUSH     {r4-r6,lr}
;;;78     {
000002  4605              MOV      r5,r0
;;;79     	u16 Count=0xFFFF;//等待次数	   						  
000004  f64f74ff          MOV      r4,#0xffff
;;;80     	while ((SD_SPI_ReadWriteByte(0XFF)!=Response)&&Count)Count--;//等待得到准确的回应  	  
000008  e001              B        |L4.14|
                  |L4.10|
00000a  1e60              SUBS     r0,r4,#1
00000c  b284              UXTH     r4,r0
                  |L4.14|
00000e  20ff              MOVS     r0,#0xff
000010  f7fffffe          BL       SD_SPI_ReadWriteByte
000014  42a8              CMP      r0,r5
000016  d001              BEQ      |L4.28|
000018  2c00              CMP      r4,#0
00001a  d1f6              BNE      |L4.10|
                  |L4.28|
;;;81     	if (Count==0)return MSD_RESPONSE_FAILURE;//得到回应失败   
00001c  b90c              CBNZ     r4,|L4.34|
00001e  20ff              MOVS     r0,#0xff
                  |L4.32|
;;;82     	else return MSD_RESPONSE_NO_ERROR;//正确回应
;;;83     }
000020  bd70              POP      {r4-r6,pc}
                  |L4.34|
000022  2000              MOVS     r0,#0                 ;82
000024  e7fc              B        |L4.32|
;;;84     /*******************************************************************************
                          ENDP


                          AREA ||i.SD_GetSectorCount||, CODE, READONLY, ALIGN=1

                  SD_GetSectorCount PROC
;;;239    *******************************************************************************/
;;;240    u32 SD_GetSectorCount(void)
000000  b57f              PUSH     {r0-r6,lr}
;;;241    {
;;;242      u8 csd[16];
;;;243      u32 Capacity;  
;;;244      u8 n;
;;;245    	u16 csize;  					    
;;;246    	//取CSD信息，如果期间出错，返回0
;;;247      if(SD_GetCSD(csd)!=0)
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       SD_GetCSD
000008  b110              CBZ      r0,|L5.16|
;;;248        return 0;	    
00000a  2000              MOVS     r0,#0
                  |L5.12|
;;;249      //如果为SDHC卡，按照下面方式计算
;;;250      if((csd[0]&0xC0)==0x40)	 //V2.00的卡
;;;251      {	
;;;252        csize = csd[9] + ((u16)csd[8] << 8) + 1;
;;;253        Capacity = (u32)csize << 9;//得到扇区数	 		   
;;;254      }
;;;255      else//V1.XX的卡
;;;256      {	
;;;257        n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
;;;258        csize = (csd[8] >> 6) + ((u16)csd[7] << 2) + ((u16)(csd[6] & 3) << 10) + 1;
;;;259        Capacity= (u32)csize << (n - 9);//得到扇区数   
;;;260      }
;;;261      return Capacity;
;;;262    }
00000c  b004              ADD      sp,sp,#0x10
00000e  bd70              POP      {r4-r6,pc}
                  |L5.16|
000010  f89d0000          LDRB     r0,[sp,#0]            ;250
000014  f00000c0          AND      r0,r0,#0xc0           ;250
000018  2840              CMP      r0,#0x40              ;250
00001a  d109              BNE      |L5.48|
00001c  f89d0009          LDRB     r0,[sp,#9]            ;252
000020  f89d1008          LDRB     r1,[sp,#8]            ;252
000024  eb002001          ADD      r0,r0,r1,LSL #8       ;252
000028  1c40              ADDS     r0,r0,#1              ;252
00002a  b284              UXTH     r4,r0                 ;252
00002c  0265              LSLS     r5,r4,#9              ;253
00002e  e020              B        |L5.114|
                  |L5.48|
000030  f89d0005          LDRB     r0,[sp,#5]            ;257
000034  f000000f          AND      r0,r0,#0xf            ;257
000038  f89d100a          LDRB     r1,[sp,#0xa]          ;257
00003c  eb0010d1          ADD      r0,r0,r1,LSR #7       ;257
000040  f89d1009          LDRB     r1,[sp,#9]            ;257
000044  f0010103          AND      r1,r1,#3              ;257
000048  eb000041          ADD      r0,r0,r1,LSL #1       ;257
00004c  1c86              ADDS     r6,r0,#2              ;257
00004e  f89d0008          LDRB     r0,[sp,#8]            ;258
000052  1180              ASRS     r0,r0,#6              ;258
000054  f89d1007          LDRB     r1,[sp,#7]            ;258
000058  eb000081          ADD      r0,r0,r1,LSL #2       ;258
00005c  f89d1006          LDRB     r1,[sp,#6]            ;258
000060  f0010103          AND      r1,r1,#3              ;258
000064  eb002081          ADD      r0,r0,r1,LSL #10      ;258
000068  1c44              ADDS     r4,r0,#1              ;258
00006a  f1a60009          SUB      r0,r6,#9              ;259
00006e  fa04f500          LSL      r5,r4,r0              ;259
                  |L5.114|
000072  4628              MOV      r0,r5                 ;261
000074  e7ca              B        |L5.12|
;;;263    //初始化SD卡
                          ENDP


                          AREA ||i.SD_Initialize||, CODE, READONLY, ALIGN=2

                  SD_Initialize PROC
;;;263    //初始化SD卡
;;;264    u8 SD_Initialize(SPIDef *SpiPort)
000000  b5f8              PUSH     {r3-r7,lr}
;;;265    {
000002  4607              MOV      r7,r0
;;;266      u8 r1;      // 存放SD卡的返回值
;;;267      u16 retry;  // 用来进行超时计数
;;;268      u8 buf[4];  
;;;269      u16 i;
;;;270      pSDSPI  = SpiPort;
000004  4861              LDR      r0,|L6.396|
000006  6007              STR      r7,[r0,#0]  ; pSDSPI
;;;271      //========================硬件初始化
;;;272      SPI_Initialize(pSDSPI);   //初始化GPIO
000008  6800              LDR      r0,[r0,#0]  ; pSDSPI
00000a  f7fffffe          BL       SPI_Initialize
;;;273     	SD_SPI_SpeedLow();	      //设置到低速模式
00000e  f7fffffe          BL       SD_SPI_SpeedLow
;;;274      //========================发送大于74个时钟等待SD卡上电稳定  
;;;275     	for(i=0;i<10;i++)
000012  2500              MOVS     r5,#0
000014  e004              B        |L6.32|
                  |L6.22|
;;;276        SD_SPI_ReadWriteByte(0XFF);//发送最少74个脉冲
000016  20ff              MOVS     r0,#0xff
000018  f7fffffe          BL       SD_SPI_ReadWriteByte
00001c  1c68              ADDS     r0,r5,#1              ;275
00001e  b285              UXTH     r5,r0                 ;275
                  |L6.32|
000020  2d0a              CMP      r5,#0xa               ;275
000022  dbf8              BLT      |L6.22|
;;;277      //========================发送复位命令进入IDLE状态
;;;278    	retry=20;
000024  2614              MOVS     r6,#0x14
;;;279    	do
000026  bf00              NOP      
                  |L6.40|
;;;280    	{
;;;281    		r1=SD_SendCmd(CMD0,0,0x95); //进入IDLE状态
000028  2295              MOVS     r2,#0x95
00002a  2100              MOVS     r1,#0
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       SD_SendCmd
000032  4604              MOV      r4,r0
;;;282    	}while((r1!=0X01) && retry--);
000034  2c01              CMP      r4,#1
000036  d004              BEQ      |L6.66|
000038  1e30              SUBS     r0,r6,#0
00003a  f1a60101          SUB      r1,r6,#1
00003e  b28e              UXTH     r6,r1
000040  d1f2              BNE      |L6.40|
                  |L6.66|
;;;283     	SD_Type=0;//默认无卡
000042  2000              MOVS     r0,#0
000044  4952              LDR      r1,|L6.400|
000046  7008              STRB     r0,[r1,#0]
;;;284    	if(r1==0X01)
000048  2c01              CMP      r4,#1
00004a  d14a              BNE      |L6.226|
;;;285    	{
;;;286        //========================检查SD类型及版本
;;;287        //------------------------检查是否为SD V2.0
;;;288    		if(SD_SendCmd(CMD8,0x1AA,0x87)==1)  //SD V2.0
00004c  2287              MOVS     r2,#0x87
00004e  f44f71d5          MOV      r1,#0x1aa
000052  2008              MOVS     r0,#8
000054  f7fffffe          BL       SD_SendCmd
000058  2801              CMP      r0,#1
00005a  d147              BNE      |L6.236|
;;;289    		{
;;;290    			for(i=0;i<4;i++)
00005c  2500              MOVS     r5,#0
00005e  e006              B        |L6.110|
                  |L6.96|
;;;291            buf[i]=SD_SPI_ReadWriteByte(0XFF);	//Get trailing return value of R7 resp
000060  20ff              MOVS     r0,#0xff
000062  f7fffffe          BL       SD_SPI_ReadWriteByte
000066  f80d0005          STRB     r0,[sp,r5]
00006a  1c68              ADDS     r0,r5,#1              ;290
00006c  b285              UXTH     r5,r0                 ;290
                  |L6.110|
00006e  2d04              CMP      r5,#4                 ;290
000070  dbf6              BLT      |L6.96|
;;;292    			if(buf[2]==0X01&&buf[3]==0XAA)    //卡是否支持2.7~3.6V
000072  f89d0002          LDRB     r0,[sp,#2]
000076  2801              CMP      r0,#1
000078  d179              BNE      |L6.366|
00007a  f89d0003          LDRB     r0,[sp,#3]
00007e  28aa              CMP      r0,#0xaa
000080  d175              BNE      |L6.366|
;;;293    			{
;;;294    				retry=0XFFFE;
000082  f64f76fe          MOV      r6,#0xfffe
;;;295            //------------------------循环发送CMD55和CMD41直到返回0x00，使SD卡进入Ready状态
;;;296    				do
000086  bf00              NOP      
                  |L6.136|
;;;297    				{          
;;;298    					SD_SendCmd(CMD55,0,0X01);	            //发送CMD55
000088  2201              MOVS     r2,#1
00008a  2100              MOVS     r1,#0
00008c  2037              MOVS     r0,#0x37
00008e  f7fffffe          BL       SD_SendCmd
;;;299    					r1=SD_SendCmd(CMD41,0x40000000,0X01); //发送CMD41
000092  2201              MOVS     r2,#1
000094  0791              LSLS     r1,r2,#30
000096  2029              MOVS     r0,#0x29
000098  f7fffffe          BL       SD_SendCmd
00009c  4604              MOV      r4,r0
;;;300    				}while(r1&&retry--);
00009e  b124              CBZ      r4,|L6.170|
0000a0  1e30              SUBS     r0,r6,#0
0000a2  f1a60101          SUB      r1,r6,#1
0000a6  b28e              UXTH     r6,r1
0000a8  d1ee              BNE      |L6.136|
                  |L6.170|
;;;301            //========================鉴别SD2.0卡版本开始
;;;302            //------------------------发送CMD58获取OCR信息
;;;303    				if(retry&&SD_SendCmd(CMD58,0,0X01)==0)    //鉴别SD2.0卡版本开始
0000aa  2e00              CMP      r6,#0
0000ac  d05f              BEQ      |L6.366|
0000ae  2201              MOVS     r2,#1
0000b0  2100              MOVS     r1,#0
0000b2  203a              MOVS     r0,#0x3a
0000b4  f7fffffe          BL       SD_SendCmd
0000b8  2800              CMP      r0,#0
0000ba  d158              BNE      |L6.366|
;;;304    				{
;;;305    					for(i=0;i<4;i++)
0000bc  2500              MOVS     r5,#0
0000be  e006              B        |L6.206|
                  |L6.192|
;;;306                buf[i]=SD_SPI_ReadWriteByte(0XFF);    //得到OCR值
0000c0  20ff              MOVS     r0,#0xff
0000c2  f7fffffe          BL       SD_SPI_ReadWriteByte
0000c6  f80d0005          STRB     r0,[sp,r5]
0000ca  1c68              ADDS     r0,r5,#1              ;305
0000cc  b285              UXTH     r5,r0                 ;305
                  |L6.206|
0000ce  2d04              CMP      r5,#4                 ;305
0000d0  dbf6              BLT      |L6.192|
;;;307    					if(buf[0]&0x40)
0000d2  f89d0000          LDRB     r0,[sp,#0]
0000d6  f0000040          AND      r0,r0,#0x40
0000da  b118              CBZ      r0,|L6.228|
;;;308                SD_Type=SD_TYPE_V2HC;     //大容量V2.0SD卡 
0000dc  2006              MOVS     r0,#6
0000de  492c              LDR      r1,|L6.400|
0000e0  7008              STRB     r0,[r1,#0]
                  |L6.226|
0000e2  e044              B        |L6.366|
                  |L6.228|
;;;309    					else
;;;310                SD_Type=SD_TYPE_V2MC;     //小容量V2.0SD卡 
0000e4  2004              MOVS     r0,#4
0000e6  492a              LDR      r1,|L6.400|
0000e8  7008              STRB     r0,[r1,#0]
0000ea  e040              B        |L6.366|
                  |L6.236|
;;;311    				}
;;;312    			}
;;;313    		}
;;;314        else//SD V1.x/ MMC	V3
;;;315    		{
;;;316    			SD_SendCmd(CMD55,0,0X01);		  //发送CMD55
0000ec  2201              MOVS     r2,#1
0000ee  2100              MOVS     r1,#0
0000f0  2037              MOVS     r0,#0x37
0000f2  f7fffffe          BL       SD_SendCmd
;;;317    			r1=SD_SendCmd(CMD41,0,0X01);	//发送CMD41
0000f6  2201              MOVS     r2,#1
0000f8  2100              MOVS     r1,#0
0000fa  2029              MOVS     r0,#0x29
0000fc  f7fffffe          BL       SD_SendCmd
000100  4604              MOV      r4,r0
;;;318    			if(r1<=1)
000102  2c01              CMP      r4,#1
000104  dc17              BGT      |L6.310|
;;;319    			{		
;;;320    				SD_Type=SD_TYPE_V1;
000106  2002              MOVS     r0,#2
000108  4921              LDR      r1,|L6.400|
00010a  7008              STRB     r0,[r1,#0]
;;;321    				retry=0XFFFE;
00010c  f64f76fe          MOV      r6,#0xfffe
;;;322    				do //等待退出IDLE模式
000110  bf00              NOP      
                  |L6.274|
;;;323    				{
;;;324    					SD_SendCmd(CMD55,0,0X01);	    //发送CMD55
000112  2201              MOVS     r2,#1
000114  2100              MOVS     r1,#0
000116  2037              MOVS     r0,#0x37
000118  f7fffffe          BL       SD_SendCmd
;;;325    					r1=SD_SendCmd(CMD41,0,0X01);  //发送CMD41
00011c  2201              MOVS     r2,#1
00011e  2100              MOVS     r1,#0
000120  2029              MOVS     r0,#0x29
000122  f7fffffe          BL       SD_SendCmd
000126  4604              MOV      r4,r0
;;;326    				}while(r1&&retry--);
000128  b1bc              CBZ      r4,|L6.346|
00012a  1e30              SUBS     r0,r6,#0
00012c  f1a60101          SUB      r1,r6,#1
000130  b28e              UXTH     r6,r1
000132  d1ee              BNE      |L6.274|
000134  e011              B        |L6.346|
                  |L6.310|
;;;327    			}
;;;328          else//MMC卡不支持CMD55+CMD41识别
;;;329    			{
;;;330    				SD_Type=SD_TYPE_MMC;//MMC V3
000136  2001              MOVS     r0,#1
000138  4915              LDR      r1,|L6.400|
00013a  7008              STRB     r0,[r1,#0]
;;;331    				retry=0XFFFE;
00013c  f64f76fe          MOV      r6,#0xfffe
;;;332    				do //等待退出IDLE模式
000140  bf00              NOP      
                  |L6.322|
;;;333    				{											    
;;;334    					r1=SD_SendCmd(CMD1,0,0X01);//发送CMD1
000142  2201              MOVS     r2,#1
000144  2100              MOVS     r1,#0
000146  4610              MOV      r0,r2
000148  f7fffffe          BL       SD_SendCmd
00014c  4604              MOV      r4,r0
;;;335    				}while(r1&&retry--);  
00014e  b124              CBZ      r4,|L6.346|
000150  1e30              SUBS     r0,r6,#0
000152  f1a60101          SUB      r1,r6,#1
000156  b28e              UXTH     r6,r1
000158  d1f3              BNE      |L6.322|
                  |L6.346|
;;;336    			}
;;;337    			if(retry==0||SD_SendCmd(CMD16,512,0X01)!=0)
00015a  b12e              CBZ      r6,|L6.360|
00015c  2201              MOVS     r2,#1
00015e  0251              LSLS     r1,r2,#9
000160  2010              MOVS     r0,#0x10
000162  f7fffffe          BL       SD_SendCmd
000166  b110              CBZ      r0,|L6.366|
                  |L6.360|
;;;338            SD_Type=SD_TYPE_ERR;//错误的卡
000168  2000              MOVS     r0,#0
00016a  4909              LDR      r1,|L6.400|
00016c  7008              STRB     r0,[r1,#0]
                  |L6.366|
;;;339    		}
;;;340    	}
;;;341    	SD_DisSelect();//取消片选
00016e  f7fffffe          BL       SD_DisSelect
;;;342    	SD_SPI_SpeedHigh();//高速
000172  f7fffffe          BL       SD_SPI_SpeedHigh
;;;343    	if(SD_Type)
000176  4806              LDR      r0,|L6.400|
000178  7800              LDRB     r0,[r0,#0]  ; SD_Type
00017a  b108              CBZ      r0,|L6.384|
;;;344        return 0;
00017c  2000              MOVS     r0,#0
                  |L6.382|
;;;345    	else if(r1)
;;;346        return r1; 	   
;;;347    	return 0xaa;//其他错误
;;;348    }
00017e  bdf8              POP      {r3-r7,pc}
                  |L6.384|
000180  b10c              CBZ      r4,|L6.390|
000182  4620              MOV      r0,r4                 ;346
000184  e7fb              B        |L6.382|
                  |L6.390|
000186  20aa              MOVS     r0,#0xaa              ;347
000188  e7f9              B        |L6.382|
;;;349    /*******************************************************************************
                          ENDP

00018a  0000              DCW      0x0000
                  |L6.396|
                          DCD      pSDSPI
                  |L6.400|
                          DCD      SD_Type

                          AREA ||i.SD_ReadDisk||, CODE, READONLY, ALIGN=2

                  SD_ReadDisk PROC
;;;359    *******************************************************************************/
;;;360    unsigned char SD_ReadDisk(u8*buf,u32 sector,u8 cnt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;361    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;362    	u8 r1;
;;;363    	if(SD_Type!=SD_TYPE_V2HC)
00000a  4819              LDR      r0,|L7.112|
00000c  7800              LDRB     r0,[r0,#0]  ; SD_Type
00000e  2806              CMP      r0,#6
000010  d000              BEQ      |L7.20|
;;;364        sector <<= 9;//转换为字节地址
000012  027f              LSLS     r7,r7,#9
                  |L7.20|
;;;365    	if(cnt==1)
000014  2d01              CMP      r5,#1
000016  d10c              BNE      |L7.50|
;;;366    	{
;;;367    		r1=SD_SendCmd(CMD17,sector,0X01);//读命令
000018  2201              MOVS     r2,#1
00001a  4639              MOV      r1,r7
00001c  2011              MOVS     r0,#0x11
00001e  f7fffffe          BL       SD_SendCmd
000022  4604              MOV      r4,r0
;;;368    		if(r1==0)//指令发送成功
000024  b9fc              CBNZ     r4,|L7.102|
;;;369    		{
;;;370    			r1=SD_RecvData(buf,512);//接收512个字节	   
000026  0269              LSLS     r1,r5,#9
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       SD_RecvData
00002e  4604              MOV      r4,r0
000030  e019              B        |L7.102|
                  |L7.50|
;;;371    		}
;;;372    	}
;;;373      else
;;;374    	{
;;;375    		r1=SD_SendCmd(CMD18,sector,0X01);//连续读命令
000032  2201              MOVS     r2,#1
000034  4639              MOV      r1,r7
000036  2012              MOVS     r0,#0x12
000038  f7fffffe          BL       SD_SendCmd
00003c  4604              MOV      r4,r0
;;;376    		do
00003e  bf00              NOP      
                  |L7.64|
;;;377    		{
;;;378    			r1=SD_RecvData(buf,512);//接收512个字节	 
000040  f44f7100          MOV      r1,#0x200
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       SD_RecvData
00004a  4604              MOV      r4,r0
;;;379    			buf+=512;  
00004c  f5067600          ADD      r6,r6,#0x200
;;;380    		}while(--cnt && r1==0); 	
000050  1e68              SUBS     r0,r5,#1
000052  b2c0              UXTB     r0,r0
000054  1e05              SUBS     r5,r0,#0
000056  d001              BEQ      |L7.92|
000058  2c00              CMP      r4,#0
00005a  d0f1              BEQ      |L7.64|
                  |L7.92|
;;;381    		SD_SendCmd(CMD12,0,0X01);	//发送停止命令
00005c  2201              MOVS     r2,#1
00005e  2100              MOVS     r1,#0
000060  200c              MOVS     r0,#0xc
000062  f7fffffe          BL       SD_SendCmd
                  |L7.102|
;;;382    	}   
;;;383    	SD_DisSelect();//取消片选
000066  f7fffffe          BL       SD_DisSelect
;;;384    	return r1;//
00006a  4620              MOV      r0,r4
;;;385    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;386    /*******************************************************************************
                          ENDP

                  |L7.112|
                          DCD      SD_Type

                          AREA ||i.SD_RecvData||, CODE, READONLY, ALIGN=1

                  SD_RecvData PROC
;;;93     *******************************************************************************/
;;;94     unsigned char SD_RecvData(u8*buf,u16 len)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {			  	  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;96     	if(SD_GetResponse(0xFE))
000006  20fe              MOVS     r0,#0xfe
000008  f7fffffe          BL       SD_GetResponse
00000c  b108              CBZ      r0,|L8.18|
;;;97         return 1;//等待SD卡发回数据起始令牌0xFE
00000e  2001              MOVS     r0,#1
                  |L8.16|
;;;98         while(len--)//开始接收数据
;;;99         {
;;;100            *buf=SPI1_ReadWriteByte(0xFF);
;;;101            buf++;
;;;102        }
;;;103        //下面是2个伪CRC（dummy CRC）
;;;104        SD_SPI_ReadWriteByte(0xFF);
;;;105        SD_SPI_ReadWriteByte(0xFF);									  					    
;;;106        return 0;//读取成功
;;;107    }
000010  bd70              POP      {r4-r6,pc}
                  |L8.18|
000012  e004              B        |L8.30|
                  |L8.20|
000014  20ff              MOVS     r0,#0xff              ;100
000016  f7fffffe          BL       SPI1_ReadWriteByte
00001a  7020              STRB     r0,[r4,#0]            ;100
00001c  1c64              ADDS     r4,r4,#1              ;101
                  |L8.30|
00001e  1e28              SUBS     r0,r5,#0              ;98
000020  f1a50101          SUB      r1,r5,#1              ;98
000024  b28d              UXTH     r5,r1                 ;98
000026  d1f5              BNE      |L8.20|
000028  20ff              MOVS     r0,#0xff              ;104
00002a  f7fffffe          BL       SD_SPI_ReadWriteByte
00002e  20ff              MOVS     r0,#0xff              ;105
000030  f7fffffe          BL       SD_SPI_ReadWriteByte
000034  2000              MOVS     r0,#0                 ;106
000036  e7eb              B        |L8.16|
;;;108    /*******************************************************************************
                          ENDP


                          AREA ||i.SD_SPI_ReadWriteByte||, CODE, READONLY, ALIGN=1

                  SD_SPI_ReadWriteByte PROC
;;;441    //返回值:读到的数据
;;;442    unsigned char SD_SPI_ReadWriteByte(u8 data)
000000  b510              PUSH     {r4,lr}
;;;443    {
000002  4604              MOV      r4,r0
;;;444    //  return SPI_ReadWriteByteSPI(pSPI,data);
;;;445    	return SPI1_ReadWriteByte(data);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI1_ReadWriteByte
;;;446    }	  
00000a  bd10              POP      {r4,pc}
;;;447    //SD卡初始化的时候,需要低速
                          ENDP


                          AREA ||i.SD_SPI_SpeedHigh||, CODE, READONLY, ALIGN=2

                  SD_SPI_SpeedHigh PROC
;;;454    //SD卡正常工作的时候,可以高速了
;;;455    void SD_SPI_SpeedHigh(void)
000000  4809              LDR      r0,|L10.40|
;;;456    {
;;;457      pSDSPI->Port.SPIx->CR1 &= 0xFFC7;
000002  6800              LDR      r0,[r0,#0]  ; pSDSPI
000004  6800              LDR      r0,[r0,#0]
000006  8800              LDRH     r0,[r0,#0]
000008  f64f71c7          MOV      r1,#0xffc7
00000c  4008              ANDS     r0,r0,r1
00000e  4906              LDR      r1,|L10.40|
000010  6809              LDR      r1,[r1,#0]  ; pSDSPI
000012  6809              LDR      r1,[r1,#0]
000014  8008              STRH     r0,[r1,#0]
;;;458      pSDSPI->Port.SPIx->CR1 |= SPI_BaudRatePrescaler_2;
000016  4804              LDR      r0,|L10.40|
000018  6800              LDR      r0,[r0,#0]  ; pSDSPI
00001a  6800              LDR      r0,[r0,#0]
00001c  8800              LDRH     r0,[r0,#0]
00001e  4902              LDR      r1,|L10.40|
000020  6809              LDR      r1,[r1,#0]  ; pSDSPI
000022  6809              LDR      r1,[r1,#0]
000024  8008              STRH     r0,[r1,#0]
;;;459    // 	SPI1_SetSpeed(SPI_BaudRatePrescaler_2);//设置到高速模式	
;;;460    }
000026  4770              BX       lr
;;;461    
                          ENDP

                  |L10.40|
                          DCD      pSDSPI

                          AREA ||i.SD_SPI_SpeedLow||, CODE, READONLY, ALIGN=2

                  SD_SPI_SpeedLow PROC
;;;447    //SD卡初始化的时候,需要低速
;;;448    void SD_SPI_SpeedLow(void)
000000  480a              LDR      r0,|L11.44|
;;;449    {
;;;450      pSDSPI->Port.SPIx->CR1 &= 0xFFC7;
000002  6800              LDR      r0,[r0,#0]  ; pSDSPI
000004  6800              LDR      r0,[r0,#0]
000006  8800              LDRH     r0,[r0,#0]
000008  f64f71c7          MOV      r1,#0xffc7
00000c  4008              ANDS     r0,r0,r1
00000e  4907              LDR      r1,|L11.44|
000010  6809              LDR      r1,[r1,#0]  ; pSDSPI
000012  6809              LDR      r1,[r1,#0]
000014  8008              STRH     r0,[r1,#0]
;;;451      pSDSPI->Port.SPIx->CR1 |= SPI_BaudRatePrescaler_256;
000016  4805              LDR      r0,|L11.44|
000018  6800              LDR      r0,[r0,#0]  ; pSDSPI
00001a  6800              LDR      r0,[r0,#0]
00001c  8800              LDRH     r0,[r0,#0]
00001e  f0400038          ORR      r0,r0,#0x38
000022  4902              LDR      r1,|L11.44|
000024  6809              LDR      r1,[r1,#0]  ; pSDSPI
000026  6809              LDR      r1,[r1,#0]
000028  8008              STRH     r0,[r1,#0]
;;;452    // 	SPI1_SetSpeed(SPI_BaudRatePrescaler_256);//设置到低速模式	
;;;453    }
00002a  4770              BX       lr
;;;454    //SD卡正常工作的时候,可以高速了
                          ENDP

                  |L11.44|
                          DCD      pSDSPI

                          AREA ||i.SD_Select||, CODE, READONLY, ALIGN=2

                  SD_Select PROC
;;;35     //返回值:0,成功;1,失败;
;;;36     unsigned char SD_Select(void)
000000  2000              MOVS     r0,#0
;;;37     {
;;;38     	SD_CS=0;
000002  4902              LDR      r1,|L12.12|
000004  6008              STR      r0,[r1,#0]
;;;39     //	if(SD_WaitReady()==0)
;;;40     //    return 0;//等待成功
;;;41     //	SD_DisSelect();
;;;42     	return 1;//等待失败
000006  2001              MOVS     r0,#1
;;;43     }
000008  4770              BX       lr
;;;44     /*******************************************************************************
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x42220198

                          AREA ||i.SD_SendBlock||, CODE, READONLY, ALIGN=1

                  SD_SendBlock PROC
;;;117    *******************************************************************************/
;;;118    unsigned char SD_SendBlock(u8*buf,u8 cmd)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {	
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;120    	u16 t;		  	  
;;;121    	if(SD_WaitReady())return 1;//等待准备失效
000006  f7fffffe          BL       SD_WaitReady
00000a  b108              CBZ      r0,|L13.16|
00000c  2001              MOVS     r0,#1
                  |L13.14|
;;;122    	SD_SPI_ReadWriteByte(cmd);
;;;123    	if(cmd!=0XFD)//不是结束指令
;;;124    	{
;;;125    		for(t=0;t<512;t++)SPI1_ReadWriteByte(buf[t]);//提高速度,减少函数传参时间
;;;126    	    SD_SPI_ReadWriteByte(0xFF);//忽略crc
;;;127    	    SD_SPI_ReadWriteByte(0xFF);
;;;128    		t=SD_SPI_ReadWriteByte(0xFF);//接收响应
;;;129    		if((t&0x1F)!=0x05)return 2;//响应错误									  					    
;;;130    	}						 									  					    
;;;131        return 0;//写入成功
;;;132    }
00000e  bd70              POP      {r4-r6,pc}
                  |L13.16|
000010  4628              MOV      r0,r5                 ;122
000012  f7fffffe          BL       SD_SPI_ReadWriteByte
000016  2dfd              CMP      r5,#0xfd              ;123
000018  d019              BEQ      |L13.78|
00001a  2400              MOVS     r4,#0                 ;125
00001c  e004              B        |L13.40|
                  |L13.30|
00001e  5d30              LDRB     r0,[r6,r4]            ;125
000020  f7fffffe          BL       SPI1_ReadWriteByte
000024  1c60              ADDS     r0,r4,#1              ;125
000026  b284              UXTH     r4,r0                 ;125
                  |L13.40|
000028  f5b47f00          CMP      r4,#0x200             ;125
00002c  dbf7              BLT      |L13.30|
00002e  20ff              MOVS     r0,#0xff              ;126
000030  f7fffffe          BL       SD_SPI_ReadWriteByte
000034  20ff              MOVS     r0,#0xff              ;127
000036  f7fffffe          BL       SD_SPI_ReadWriteByte
00003a  20ff              MOVS     r0,#0xff              ;128
00003c  f7fffffe          BL       SD_SPI_ReadWriteByte
000040  4604              MOV      r4,r0                 ;128
000042  f004001f          AND      r0,r4,#0x1f           ;129
000046  2805              CMP      r0,#5                 ;129
000048  d001              BEQ      |L13.78|
00004a  2002              MOVS     r0,#2                 ;129
00004c  e7df              B        |L13.14|
                  |L13.78|
00004e  2000              MOVS     r0,#0                 ;131
000050  e7dd              B        |L13.14|
;;;133    /*******************************************************************************
                          ENDP


                          AREA ||i.SD_SendCmd||, CODE, READONLY, ALIGN=1

                  SD_SendCmd PROC
;;;143    *******************************************************************************/
;;;144    unsigned char SD_SendCmd(u8 cmd, u32 arg, u8 crc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;145    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;146      u8 r1 = 0;	
00000a  2600              MOVS     r6,#0
;;;147    	u8 Retry=0;
00000c  2700              MOVS     r7,#0
;;;148      //=========================片选
;;;149    	SD_DisSelect();     //取消上次片选
00000e  f7fffffe          BL       SD_DisSelect
;;;150      SD_Select();        //片选使能
000012  f7fffffe          BL       SD_Select
;;;151    	//=========================发送命令
;;;152      SD_SPI_ReadWriteByte(cmd | 0x40);//分别写入命令
000016  f0450040          ORR      r0,r5,#0x40
00001a  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;153      SD_SPI_ReadWriteByte(arg >> 24);
00001e  0e20              LSRS     r0,r4,#24
000020  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;154      SD_SPI_ReadWriteByte(arg >> 16);
000024  f3c44007          UBFX     r0,r4,#16,#8
000028  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;155      SD_SPI_ReadWriteByte(arg >> 8);
00002c  f3c42007          UBFX     r0,r4,#8,#8
000030  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;156      SD_SPI_ReadWriteByte(arg);	  
000034  b2e0              UXTB     r0,r4
000036  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;157      SD_SPI_ReadWriteByte(crc); 
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       SD_SPI_ReadWriteByte
;;;158      //=========================根据发送的命令返回的响应参数判断结果
;;;159      //-------------------------复位命令：返回0x01表示响应成功
;;;160      if(CMD0 ==  cmd)
000040  b975              CBNZ     r5,|L14.96|
;;;161      {
;;;162        for(Retry=0;Retry<0xFF;Retry++)
000042  bf00              NOP      
000044  e00a              B        |L14.92|
                  |L14.70|
;;;163        {
;;;164          r1=SD_SPI_ReadWriteByte(0xFF);
000046  20ff              MOVS     r0,#0xff
000048  f7fffffe          BL       SD_SPI_ReadWriteByte
00004c  4606              MOV      r6,r0
;;;165          if(0x01 ==  r1)   //响应0x01表示复位响应成功
00004e  2e01              CMP      r6,#1
000050  d102              BNE      |L14.88|
;;;166            return r1;
000052  4630              MOV      r0,r6
                  |L14.84|
;;;167        }
;;;168      }
;;;169      //-------------------------停止数据传输
;;;170    	if(cmd==CMD12)
;;;171        SD_SPI_ReadWriteByte(0xff);//Skip a stuff byte when stop reading
;;;172        //等待响应，或超时退出
;;;173    	Retry=0XFF;
;;;174    	do
;;;175    	{
;;;176    		r1=SD_SPI_ReadWriteByte(0xFF);
;;;177    	}while((r1&0X80) && Retry--);	 
;;;178    	//返回状态值
;;;179      return r1;
;;;180    }
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L14.88|
000058  1c78              ADDS     r0,r7,#1              ;162
00005a  b2c7              UXTB     r7,r0                 ;162
                  |L14.92|
00005c  2fff              CMP      r7,#0xff              ;162
00005e  dbf2              BLT      |L14.70|
                  |L14.96|
000060  2d0c              CMP      r5,#0xc               ;170
000062  d102              BNE      |L14.106|
000064  20ff              MOVS     r0,#0xff              ;171
000066  f7fffffe          BL       SD_SPI_ReadWriteByte
                  |L14.106|
00006a  27ff              MOVS     r7,#0xff              ;173
00006c  bf00              NOP                            ;174
                  |L14.110|
00006e  20ff              MOVS     r0,#0xff              ;176
000070  f7fffffe          BL       SD_SPI_ReadWriteByte
000074  4606              MOV      r6,r0                 ;176
000076  f0060080          AND      r0,r6,#0x80           ;177
00007a  b120              CBZ      r0,|L14.134|
00007c  1e38              SUBS     r0,r7,#0              ;177
00007e  f1a70101          SUB      r1,r7,#1              ;177
000082  b2cf              UXTB     r7,r1                 ;177
000084  d1f3              BNE      |L14.110|
                  |L14.134|
000086  4630              MOV      r0,r6                 ;179
000088  e7e4              B        |L14.84|
;;;181    /*******************************************************************************
                          ENDP


                          AREA ||i.SD_WaitReady||, CODE, READONLY, ALIGN=1

                  SD_WaitReady PROC
;;;56     //返回值:0,准备好了;其他,错误代码
;;;57     unsigned char SD_WaitReady(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59     	u32 t=0;
000002  2400              MOVS     r4,#0
;;;60     	do
000004  bf00              NOP      
                  |L15.6|
;;;61     	{
;;;62     		if(SD_SPI_ReadWriteByte(0XFF)==0XFF)
000006  20ff              MOVS     r0,#0xff
000008  f7fffffe          BL       SD_SPI_ReadWriteByte
00000c  28ff              CMP      r0,#0xff
00000e  d101              BNE      |L15.20|
;;;63           return 0;//OK
000010  2000              MOVS     r0,#0
                  |L15.18|
;;;64     		t++;		  	
;;;65     	}while(t<0XFFFFFF);//等待 
;;;66     	return 1;
;;;67     }
000012  bd10              POP      {r4,pc}
                  |L15.20|
000014  1c64              ADDS     r4,r4,#1              ;64
000016  f06f407f          MVN      r0,#0xff000000        ;65
00001a  4284              CMP      r4,r0                 ;65
00001c  d3f3              BCC      |L15.6|
00001e  2001              MOVS     r0,#1                 ;66
000020  e7f7              B        |L15.18|
;;;68     /*******************************************************************************
                          ENDP


                          AREA ||i.SD_WriteDisk||, CODE, READONLY, ALIGN=2

                  SD_WriteDisk PROC
;;;396    *******************************************************************************/
;;;397    unsigned char SD_WriteDisk(u8*buf,u32 sector,u8 cnt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;398    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;399    	u8 r1;
;;;400    	if(SD_Type!=SD_TYPE_V2HC)sector *= 512;//转换为字节地址
00000a  4820              LDR      r0,|L16.140|
00000c  7800              LDRB     r0,[r0,#0]  ; SD_Type
00000e  2806              CMP      r0,#6
000010  d000              BEQ      |L16.20|
000012  027f              LSLS     r7,r7,#9
                  |L16.20|
;;;401    	if(cnt==1)
000014  2d01              CMP      r5,#1
000016  d10c              BNE      |L16.50|
;;;402    	{
;;;403    		r1=SD_SendCmd(CMD24,sector,0X01);//读命令
000018  2201              MOVS     r2,#1
00001a  4639              MOV      r1,r7
00001c  2018              MOVS     r0,#0x18
00001e  f7fffffe          BL       SD_SendCmd
000022  4604              MOV      r4,r0
;;;404    		if(r1==0)//指令发送成功
000024  bb6c              CBNZ     r4,|L16.130|
;;;405    		{
;;;406    			r1=SD_SendBlock(buf,0xFE);//写512个字节	   
000026  21fe              MOVS     r1,#0xfe
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       SD_SendBlock
00002e  4604              MOV      r4,r0
000030  e027              B        |L16.130|
                  |L16.50|
;;;407    		}
;;;408    	}else
;;;409    	{
;;;410    		if(SD_Type!=SD_TYPE_MMC)
000032  4816              LDR      r0,|L16.140|
000034  7800              LDRB     r0,[r0,#0]  ; SD_Type
000036  2801              CMP      r0,#1
000038  d009              BEQ      |L16.78|
;;;411    		{
;;;412    			SD_SendCmd(CMD55,0,0X01);	
00003a  2201              MOVS     r2,#1
00003c  2100              MOVS     r1,#0
00003e  2037              MOVS     r0,#0x37
000040  f7fffffe          BL       SD_SendCmd
;;;413    			SD_SendCmd(CMD23,cnt,0X01);//发送指令	
000044  2201              MOVS     r2,#1
000046  4629              MOV      r1,r5
000048  2017              MOVS     r0,#0x17
00004a  f7fffffe          BL       SD_SendCmd
                  |L16.78|
;;;414    		}
;;;415     		r1=SD_SendCmd(CMD25,sector,0X01);//连续读命令
00004e  2201              MOVS     r2,#1
000050  4639              MOV      r1,r7
000052  2019              MOVS     r0,#0x19
000054  f7fffffe          BL       SD_SendCmd
000058  4604              MOV      r4,r0
;;;416    		if(r1==0)
00005a  b994              CBNZ     r4,|L16.130|
;;;417    		{
;;;418    			do
00005c  bf00              NOP      
                  |L16.94|
;;;419    			{
;;;420    				r1=SD_SendBlock(buf,0xFC);//接收512个字节	 
00005e  21fc              MOVS     r1,#0xfc
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       SD_SendBlock
000066  4604              MOV      r4,r0
;;;421    				buf+=512;  
000068  f5067600          ADD      r6,r6,#0x200
;;;422    			}while(--cnt && r1==0);
00006c  1e68              SUBS     r0,r5,#1
00006e  b2c0              UXTB     r0,r0
000070  1e05              SUBS     r5,r0,#0
000072  d001              BEQ      |L16.120|
000074  2c00              CMP      r4,#0
000076  d0f2              BEQ      |L16.94|
                  |L16.120|
;;;423    			r1=SD_SendBlock(0,0xFD);//接收512个字节 
000078  21fd              MOVS     r1,#0xfd
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       SD_SendBlock
000080  4604              MOV      r4,r0
                  |L16.130|
;;;424    		}
;;;425    	}   
;;;426    	SD_DisSelect();//取消片选
000082  f7fffffe          BL       SD_DisSelect
;;;427    	return r1;//
000086  4620              MOV      r0,r4
;;;428    }	
000088  e8bd81f0          POP      {r4-r8,pc}
;;;429    
                          ENDP

                  |L16.140|
                          DCD      SD_Type

                          AREA ||i.SPI1_ReadWriteByte||, CODE, READONLY, ALIGN=2

                  SPI1_ReadWriteByte PROC
;;;434    //返回值:读取到的字节
;;;435    unsigned char SPI1_ReadWriteByte(u8 TxData)
000000  b510              PUSH     {r4,lr}
;;;436    {		
000002  4604              MOV      r4,r0
;;;437    	return SPI_ReadWriteByteSPI(pSDSPI,TxData);			    
000004  4621              MOV      r1,r4
000006  4802              LDR      r0,|L17.16|
000008  6800              LDR      r0,[r0,#0]  ; pSDSPI
00000a  f7fffffe          BL       SPI_ReadWriteByteSPI
;;;438    }
00000e  bd10              POP      {r4,pc}
;;;439    //移植时候的接口
                          ENDP

                  |L17.16|
                          DCD      pSDSPI

                          AREA ||.data||, DATA, ALIGN=2

                  SD_Type
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  pSDSPI
                          DCD      0x00000000
