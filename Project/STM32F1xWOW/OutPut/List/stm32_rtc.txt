; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_rtc.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_rtc.crf ..\..\Driver\WOW\SCR\STM32_RTC.C]
                          THUMB

                          AREA ||i.Is_Leap_Year||, CODE, READONLY, ALIGN=1

                  Is_Leap_Year PROC
;;;107    }
;;;108    u8 Is_Leap_Year(u16 pyear)
000000  4601              MOV      r1,r0
;;;109    {
;;;110      if(pyear%4==0)//首先需能被4整除
000002  17ca              ASRS     r2,r1,#31
000004  eb017292          ADD      r2,r1,r2,LSR #30
000008  1092              ASRS     r2,r2,#2
00000a  eba10282          SUB      r2,r1,r2,LSL #2
00000e  b992              CBNZ     r2,|L1.54|
;;;111      {
;;;112        if(pyear%100==0)
000010  2064              MOVS     r0,#0x64
000012  fb91f2f0          SDIV     r2,r1,r0
000016  fb001012          MLS      r0,r0,r2,r1
00001a  b950              CBNZ     r0,|L1.50|
;;;113        {
;;;114            if(pyear%400==0)    return 1;//如果以00结尾，还要能被400整除
00001c  f44f70c8          MOV      r0,#0x190
000020  fb91f2f0          SDIV     r2,r1,r0
000024  fb001012          MLS      r0,r0,r2,r1
000028  b908              CBNZ     r0,|L1.46|
00002a  2001              MOVS     r0,#1
                  |L1.44|
;;;115            else    return 0;
;;;116        }
;;;117        else
;;;118            return 1;
;;;119      }
;;;120      else
;;;121        return 0;
;;;122    }
00002c  4770              BX       lr
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;115
000030  e7fc              B        |L1.44|
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;118
000034  e7fa              B        |L1.44|
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;121
000038  e7f8              B        |L1.44|
;;;123    /*
                          ENDP


                          AREA ||i.NVIC_ConfigurationRTC||, CODE, READONLY, ALIGN=1

                  NVIC_ConfigurationRTC PROC
;;;31     /*rtc中断向量配置*/
;;;32     void NVIC_ConfigurationRTC(void)
000000  b508              PUSH     {r3,lr}
;;;33     {
;;;34         NVIC_InitTypeDef NVIC_InitStructure;
;;;35         NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); 
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;36         NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
00000a  2003              MOVS     r0,#3
00000c  f88d0000          STRB     r0,[sp,#0]
;;;37         NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;38         NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
000016  f88d0002          STRB     r0,[sp,#2]
;;;39         NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2001              MOVS     r0,#1
00001c  f88d0003          STRB     r0,[sp,#3]
;;;40         NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;41     }
000026  bd08              POP      {r3,pc}
;;;42     
                          ENDP


                          AREA ||i.RTC_Configuration||, CODE, READONLY, ALIGN=1

                  RTC_Configuration PROC
;;;42     
;;;43     void RTC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45       /* 使能PWR和BKP时钟 */
;;;46       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP,ENABLE);
000002  2101              MOVS     r1,#1
000004  f04f50c0          MOV      r0,#0x18000000
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;47       /* 使能对后备寄存器的访问 */ 
;;;48       PWR_BackupAccessCmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;49       /* 复位BKP寄存器 */ 
;;;50       BKP_DeInit();
000012  f7fffffe          BL       BKP_DeInit
;;;51       /* 使能LSE */ 
;;;52       RCC_LSEConfig(RCC_LSE_ON);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       RCC_LSEConfig
;;;53       /*等待启动完成 */
;;;54       while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) {}
00001c  bf00              NOP      
                  |L3.30|
00001e  2041              MOVS     r0,#0x41
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0fa              BEQ      |L3.30|
;;;55       /* 将 RTC时钟设置为LSE这个32.768KHZ的晶振*/ 
;;;56       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000028  f44f7080          MOV      r0,#0x100
00002c  f7fffffe          BL       RCC_RTCCLKConfig
;;;57       /* 使能RTC Clock */ 
;;;58       RCC_RTCCLKCmd(ENABLE);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       RCC_RTCCLKCmd
;;;59       /* 等待同步 */ 
;;;60       RTC_WaitForSynchro();
000036  f7fffffe          BL       RTC_WaitForSynchro
;;;61       /* 等待对RTC寄存器最后的写操作完成*/             
;;;62       RTC_WaitForLastTask();
00003a  f7fffffe          BL       RTC_WaitForLastTask
;;;63       /* 配置了预分频值: 设置RTC时钟周期为1s */
;;;64       //RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1)*/   //24小时会快9秒
;;;65       RTC_SetPrescaler(32771); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1)*/
00003e  f2480003          MOV      r0,#0x8003
000042  f7fffffe          BL       RTC_SetPrescaler
;;;66       /* 等待对RTC寄存器最后的写操作完成 */
;;;67       RTC_WaitForLastTask();
000046  f7fffffe          BL       RTC_WaitForLastTask
;;;68       /* 使能RTC秒中断 */ 
;;;69       RTC_ITConfig(RTC_IT_SEC, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       RTC_ITConfig
;;;70       /* 等待对RTC寄存器最后的写操作完成 */         
;;;71       RTC_WaitForLastTask();
000052  f7fffffe          BL       RTC_WaitForLastTask
;;;72           
;;;73           
;;;74       RTC_WaitForSynchro();//等待RTC寄存器同步完成
000056  f7fffffe          BL       RTC_WaitForSynchro
;;;75       RTC_ITConfig(RTC_IT_SEC, ENABLE);//使能RTC秒中断
00005a  2101              MOVS     r1,#1
00005c  4608              MOV      r0,r1
00005e  f7fffffe          BL       RTC_ITConfig
;;;76       RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
000062  f7fffffe          BL       RTC_WaitForLastTask
;;;77     //  GPIO_SetBits(GPIOG, GPIO_Pin_14);//点亮D2
;;;78       
;;;79       NVIC_ConfigurationRTC();
000066  f7fffffe          BL       NVIC_ConfigurationRTC
;;;80       RTC_Get();//更新时间
00006a  f7fffffe          BL       RTC_Get
;;;81     }
00006e  bd10              POP      {r4,pc}
;;;82     void RTC_Init(void)
                          ENDP


                          AREA ||i.RTC_Get||, CODE, READONLY, ALIGN=2

                  RTC_Get PROC
;;;166    */
;;;167    u8 RTC_Get(void)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
;;;169      static u16 dayCount=0;
;;;170      u32 secCount=0;
000002  2600              MOVS     r6,#0
;;;171      u32 tmp=0;
000004  2400              MOVS     r4,#0
;;;172      u16 tmp1=0;
000006  2500              MOVS     r5,#0
;;;173      secCount=RTC_GetCounter();
000008  f7fffffe          BL       RTC_GetCounter
00000c  4606              MOV      r6,r0
;;;174      tmp=secCount/86400;//得到天数
00000e  4833              LDR      r0,|L4.220|
000010  fbb6f4f0          UDIV     r4,r6,r0
;;;175      if(dayCount!=tmp)//超过一天
000014  4832              LDR      r0,|L4.224|
000016  8800              LDRH     r0,[r0,#0]  ; dayCount
000018  42a0              CMP      r0,r4
00001a  d03a              BEQ      |L4.146|
;;;176      {
;;;177        dayCount=tmp;
00001c  4930              LDR      r1,|L4.224|
00001e  800c              STRH     r4,[r1,#0]
;;;178        tmp1=1970;//从1970年开始
000020  f24075b2          MOV      r5,#0x7b2
;;;179        while(tmp>=365)
000024  e00e              B        |L4.68|
                  |L4.38|
;;;180        {
;;;181          if(Is_Leap_Year(tmp1))//是闰年
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       Is_Leap_Year
00002c  b130              CBZ      r0,|L4.60|
;;;182          {
;;;183              if(tmp>=366)    
00002e  f5b47fb7          CMP      r4,#0x16e
000032  d302              BCC      |L4.58|
;;;184                  tmp-=366;//减掉闰年的天数
000034  f5a474b7          SUB      r4,r4,#0x16e
000038  e002              B        |L4.64|
                  |L4.58|
;;;185              else
;;;186              {
;;;187              //    tmp1++;
;;;188                  break;
00003a  e006              B        |L4.74|
                  |L4.60|
;;;189              }
;;;190          }
;;;191          else
;;;192              tmp-=365;//平年
00003c  f2a4146d          SUB      r4,r4,#0x16d
                  |L4.64|
;;;193          tmp1++;
000040  1c68              ADDS     r0,r5,#1
000042  b285              UXTH     r5,r0
                  |L4.68|
000044  f5b47fb6          CMP      r4,#0x16c             ;179
000048  d8ed              BHI      |L4.38|
                  |L4.74|
00004a  bf00              NOP                            ;188
;;;194        }
;;;195        calendar.w_year=tmp1;//得到年份
00004c  4825              LDR      r0,|L4.228|
00004e  8085              STRH     r5,[r0,#4]
;;;196        tmp1=0;
000050  2500              MOVS     r5,#0
;;;197        while(tmp>=28)//超过一个月
000052  e016              B        |L4.130|
                  |L4.84|
;;;198        {
;;;199          if(Is_Leap_Year(calendar.w_year)&&tmp1==1)  //当年是闰年且轮循到2月
000054  4923              LDR      r1,|L4.228|
000056  8888              LDRH     r0,[r1,#4]  ; calendar
000058  f7fffffe          BL       Is_Leap_Year
00005c  b130              CBZ      r0,|L4.108|
00005e  2d01              CMP      r5,#1
000060  d104              BNE      |L4.108|
;;;200          {
;;;201              if(tmp>=29)    
000062  2c1d              CMP      r4,#0x1d
000064  d301              BCC      |L4.106|
;;;202                  tmp-=29;
000066  3c1d              SUBS     r4,r4,#0x1d
000068  e009              B        |L4.126|
                  |L4.106|
;;;203              else
;;;204                  break;
00006a  e00c              B        |L4.134|
                  |L4.108|
;;;205          }
;;;206          else
;;;207          {
;;;208              if(tmp>=mon_table[tmp1])//平年
00006c  481e              LDR      r0,|L4.232|
00006e  5d40              LDRB     r0,[r0,r5]
000070  42a0              CMP      r0,r4
000072  d803              BHI      |L4.124|
;;;209                  tmp-=mon_table[tmp1];
000074  481c              LDR      r0,|L4.232|
000076  5d40              LDRB     r0,[r0,r5]
000078  1a24              SUBS     r4,r4,r0
00007a  e000              B        |L4.126|
                  |L4.124|
;;;210              else
;;;211                  break;
00007c  e003              B        |L4.134|
                  |L4.126|
;;;212          }
;;;213          tmp1++;
00007e  1c68              ADDS     r0,r5,#1
000080  b285              UXTH     r5,r0
                  |L4.130|
000082  2c1c              CMP      r4,#0x1c              ;197
000084  d2e6              BCS      |L4.84|
                  |L4.134|
000086  bf00              NOP                            ;204
;;;214        }
;;;215        calendar.w_month=tmp1+1;//得到月份，tmp1=0表示1月，所以要加1
000088  1c68              ADDS     r0,r5,#1
00008a  4916              LDR      r1,|L4.228|
00008c  7188              STRB     r0,[r1,#6]
;;;216        calendar.w_date=tmp+1;    //得到日期，因为这一天还没过完，所以tmp只到其前一天，但是显示的时候要显示正常日期
00008e  1c60              ADDS     r0,r4,#1
000090  71c8              STRB     r0,[r1,#7]
                  |L4.146|
;;;217      }
;;;218      tmp=secCount%86400;//得到秒钟数
000092  4812              LDR      r0,|L4.220|
000094  fbb6f1f0          UDIV     r1,r6,r0
000098  fb006411          MLS      r4,r0,r1,r6
;;;219      calendar.hour=tmp/3600;//小时
00009c  f44f6061          MOV      r0,#0xe10
0000a0  fbb4f0f0          UDIV     r0,r4,r0
0000a4  490f              LDR      r1,|L4.228|
0000a6  7008              STRB     r0,[r1,#0]
;;;220      calendar.min=(tmp%3600)/60;//分钟
0000a8  f44f6061          MOV      r0,#0xe10
0000ac  fbb4f1f0          UDIV     r1,r4,r0
0000b0  fb004011          MLS      r0,r0,r1,r4
0000b4  213c              MOVS     r1,#0x3c
0000b6  fbb0f0f1          UDIV     r0,r0,r1
0000ba  490a              LDR      r1,|L4.228|
0000bc  7048              STRB     r0,[r1,#1]
;;;221      calendar.sec=(tmp%3600)%60;//秒
0000be  f44f6061          MOV      r0,#0xe10
0000c2  fbb4f1f0          UDIV     r1,r4,r0
0000c6  fb004011          MLS      r0,r0,r1,r4
0000ca  213c              MOVS     r1,#0x3c
0000cc  fbb0f2f1          UDIV     r2,r0,r1
0000d0  fb010012          MLS      r0,r1,r2,r0
0000d4  4903              LDR      r1,|L4.228|
0000d6  7088              STRB     r0,[r1,#2]
;;;222      return 0;
0000d8  2000              MOVS     r0,#0
;;;223    }
0000da  bd70              POP      {r4-r6,pc}
;;;224    /*
                          ENDP

                  |L4.220|
                          DCD      0x00015180
                  |L4.224|
                          DCD      dayCount
                  |L4.228|
                          DCD      calendar
                  |L4.232|
                          DCD      mon_table

                          AREA ||i.RTC_IRQHandler||, CODE, READONLY, ALIGN=1

                  RTC_IRQHandler PROC
;;;227    */
;;;228    void RTC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;229    {         
;;;230        if (RTC_GetITStatus(RTC_IT_SEC) != RESET)//秒钟中断
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RTC_GetITStatus
000008  b108              CBZ      r0,|L5.14|
;;;231        {                            
;;;232            RTC_Get();//更新时间
00000a  f7fffffe          BL       RTC_Get
                  |L5.14|
;;;233          
;;;234         }
;;;235        if(RTC_GetITStatus(RTC_IT_ALR)!= RESET)//闹钟中断
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       RTC_GetITStatus
000014  b110              CBZ      r0,|L5.28|
;;;236        {
;;;237            RTC_ClearITPendingBit(RTC_IT_ALR);//清闹钟中断        
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       RTC_ClearITPendingBit
                  |L5.28|
;;;238      }                                                    
;;;239        RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW);//清闹钟中断
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       RTC_ClearITPendingBit
;;;240        RTC_WaitForLastTask();                                                   
000022  f7fffffe          BL       RTC_WaitForLastTask
;;;241    }
000026  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=1

                  RTC_Init PROC
;;;81     }
;;;82     void RTC_Init(void)
000000  b510              PUSH     {r4,lr}
;;;83     {
;;;84     //  /*如果是第一次配置时钟，则执行RCC_Configuration()进行配置*/
;;;85     //  if(BKP_ReadBackupRegister(BKP_DR1)!=0x1016)
;;;86     //  {
;;;87     //    RCC_Configuration();
;;;88     //    RTC_Set(2016,5,11,9,7,55);
;;;89     //    GPIO_SetBits(GPIOD, GPIO_Pin_13);//点亮D1
;;;90     //    BKP_WriteBackupRegister(BKP_DR1, 0x1016);//向执行的后备寄存器中写入用户程序数据
;;;91     //  }
;;;92     //  else
;;;93     //  {
;;;94     //    RTC_WaitForSynchro();//等待RTC寄存器同步完成
;;;95     //    RTC_ITConfig(RTC_IT_SEC, ENABLE);//使能RTC秒中断
;;;96     //    RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
;;;97     //    GPIO_SetBits(GPIOG, GPIO_Pin_14);//点亮D2
;;;98     //  }
;;;99       
;;;100      RTC_WaitForSynchro();//等待RTC寄存器同步完成
000002  f7fffffe          BL       RTC_WaitForSynchro
;;;101      RTC_ITConfig(RTC_IT_SEC, ENABLE);//使能RTC秒中断
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RTC_ITConfig
;;;102      RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
00000e  f7fffffe          BL       RTC_WaitForLastTask
;;;103    //  GPIO_SetBits(GPIOG, GPIO_Pin_14);//点亮D2
;;;104      
;;;105      NVIC_ConfigurationRTC();
000012  f7fffffe          BL       NVIC_ConfigurationRTC
;;;106      RTC_Get();//更新时间
000016  f7fffffe          BL       RTC_Get
;;;107    }
00001a  bd10              POP      {r4,pc}
;;;108    u8 Is_Leap_Year(u16 pyear)
                          ENDP


                          AREA ||i.RTC_Set||, CODE, READONLY, ALIGN=2

                  RTC_Set PROC
;;;129    */
;;;130    u8 RTC_Set(u16 year,u8 mon,u8 day,u8 hour,u8 min,u8 sec)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;131    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;132        u16 t;
;;;133        u32 secCount=0;
000010  2400              MOVS     r4,#0
;;;134        if(year<1970||year>2099)
000012  f24070b2          MOV      r0,#0x7b2
000016  4286              CMP      r6,r0
000018  db03              BLT      |L7.34|
00001a  f6400033          MOV      r0,#0x833
00001e  4286              CMP      r6,r0
000020  dd02              BLE      |L7.40|
                  |L7.34|
;;;135            return 1;//3?′í
000022  2001              MOVS     r0,#1
                  |L7.36|
;;;136        for(t=1970;t<year;t++)    //把所有年份的秒钟相加
;;;137        {
;;;138            if(Is_Leap_Year(t))//闰年
;;;139                secCount+=31622400;//闰年的秒钟数
;;;140            else
;;;141                secCount+=31536000;    
;;;142        }
;;;143        mon-=1;//先减掉一个月再算秒数（如现在是5月10日，则只需要算前4个月的天数，再加上10天，然后计算秒数）
;;;144        for(t=0;t<mon;t++)
;;;145        {
;;;146            secCount+=(u32)mon_table[t]*86400;//月份秒钟数相加
;;;147            if(Is_Leap_Year(year)&&t==1)
;;;148                secCount+=86400;//闰年，2月份增加一天的秒钟数
;;;149        }
;;;150        
;;;151        secCount+=(u32)(day-1)*86400;//把前面日期的秒钟数相加（这一天还没过完，所以-1）
;;;152        secCount+=(u32)hour*3600;//小时秒钟数
;;;153        secCount+=(u32)min*60;//分钟秒钟数
;;;154        secCount+=sec;
;;;155    //    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR    | RCC_APB1Periph_BKP,ENABLE);
;;;156    //    PWR_BackupAccessCmd(ENABLE);
;;;157        RTC_SetCounter(secCount);//设置RTC计数器的值
;;;158        RTC_WaitForLastTask();    //等待最近一次对RTC寄存器的写操作完成
;;;159        RTC_Get();//更新时间
;;;160        return 0;
;;;161    }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.40|
000028  f24075b2          MOV      r5,#0x7b2             ;136
00002c  e00a              B        |L7.68|
                  |L7.46|
00002e  4628              MOV      r0,r5                 ;138
000030  f7fffffe          BL       Is_Leap_Year
000034  b110              CBZ      r0,|L7.60|
000036  481d              LDR      r0,|L7.172|
000038  4404              ADD      r4,r4,r0              ;139
00003a  e001              B        |L7.64|
                  |L7.60|
00003c  481c              LDR      r0,|L7.176|
00003e  4404              ADD      r4,r4,r0              ;141
                  |L7.64|
000040  1c68              ADDS     r0,r5,#1              ;136
000042  b285              UXTH     r5,r0                 ;136
                  |L7.68|
000044  42b5              CMP      r5,r6                 ;136
000046  dbf2              BLT      |L7.46|
000048  1e78              SUBS     r0,r7,#1              ;143
00004a  b2c7              UXTB     r7,r0                 ;143
00004c  2500              MOVS     r5,#0                 ;144
00004e  e010              B        |L7.114|
                  |L7.80|
000050  4818              LDR      r0,|L7.180|
000052  5d40              LDRB     r0,[r0,r5]            ;146
000054  f24021a3          MOV      r1,#0x2a3             ;146
000058  4348              MULS     r0,r1,r0              ;146
00005a  eb0414c0          ADD      r4,r4,r0,LSL #7       ;146
00005e  4630              MOV      r0,r6                 ;147
000060  f7fffffe          BL       Is_Leap_Year
000064  b118              CBZ      r0,|L7.110|
000066  2d01              CMP      r5,#1                 ;147
000068  d101              BNE      |L7.110|
00006a  4813              LDR      r0,|L7.184|
00006c  4404              ADD      r4,r4,r0              ;148
                  |L7.110|
00006e  1c68              ADDS     r0,r5,#1              ;144
000070  b285              UXTH     r5,r0                 ;144
                  |L7.114|
000072  42bd              CMP      r5,r7                 ;144
000074  dbec              BLT      |L7.80|
000076  f1a80001          SUB      r0,r8,#1              ;151
00007a  f24021a3          MOV      r1,#0x2a3             ;151
00007e  4348              MULS     r0,r1,r0              ;151
000080  eb0414c0          ADD      r4,r4,r0,LSL #7       ;151
000084  ebc91049          RSB      r0,r9,r9,LSL #5       ;152
000088  ebc02009          RSB      r0,r0,r9,LSL #8       ;152
00008c  eb041400          ADD      r4,r4,r0,LSL #4       ;152
000090  ebca100a          RSB      r0,r10,r10,LSL #4     ;153
000094  eb040480          ADD      r4,r4,r0,LSL #2       ;153
000098  445c              ADD      r4,r4,r11             ;154
00009a  4620              MOV      r0,r4                 ;157
00009c  f7fffffe          BL       RTC_SetCounter
0000a0  f7fffffe          BL       RTC_WaitForLastTask
0000a4  f7fffffe          BL       RTC_Get
0000a8  2000              MOVS     r0,#0                 ;160
0000aa  e7bb              B        |L7.36|
;;;162    
                          ENDP

                  |L7.172|
                          DCD      0x01e28500
                  |L7.176|
                          DCD      0x01e13380
                  |L7.180|
                          DCD      mon_table
                  |L7.184|
                          DCD      0x00015180

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  calendar
                          %        10

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  mon_table
000000  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000004  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000008  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=1

                  dayCount
000000  0000              DCW      0x0000
