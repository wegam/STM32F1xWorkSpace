; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\usart_isp.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\usart_isp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\usart_isp.crf ..\..\Driver\Protocol\USART_ISP.C]
                          THUMB

                          AREA ||i.BSP_Configuration||, CODE, READONLY, ALIGN=1

                  BSP_Configuration PROC
;;;1139   *******************************************************************************/
;;;1140   void BSP_Configuration(BSP_Conf_TypeDef *BSP_Conf)		//配置函数
000000  b510              PUSH     {r4,lr}
;;;1141   {
000002  4604              MOV      r4,r0
;;;1142   	USART_DMA_ConfigurationEV	(BSP_Conf->BSP_Port.USARTx,115200,ISP_BufferSize);	//USART_DMA配置--查询方式，不开中断
000004  f44f7296          MOV      r2,#0x12c
000008  f44f31e1          MOV      r1,#0x1c200
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       USART_DMA_ConfigurationEV
;;;1143   	GPIO_Configuration_OPP50	(BSP_Conf->BSP_Port.RESET_CTL_PORT,BSP_Conf->BSP_Port.RESET_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000012  8921              LDRH     r1,[r4,#8]
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1144   	GPIO_Configuration_OPP50	(BSP_Conf->BSP_Port.BOOT0_CTL_PORT,BSP_Conf->BSP_Port.BOOT0_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00001a  8a21              LDRH     r1,[r4,#0x10]
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;1145   	BSP_Reset(BSP_Conf);																																								//重置编程器---恢复所有参数为默认值
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       BSP_Reset
;;;1146   //	USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ResetDevice);		//更新状态---BSP主机准备连接----复位后检测从机----测试
;;;1147   //	ISP_Conf->ISP_FUN=ISP_SLAVE;			//测试---将模块设置为从机
;;;1148   }
000028  bd10              POP      {r4,pc}
;;;1149   /*******************************************************************************
                          ENDP


                          AREA ||i.BSP_Process||, CODE, READONLY, ALIGN=1

                  BSP_Process PROC
;;;1154   *******************************************************************************/
;;;1155   void BSP_Process(BSP_Conf_TypeDef *BSP_Conf)			//事件处理函数
000000  b510              PUSH     {r4,lr}
;;;1156   {
000002  4604              MOV      r4,r0
;;;1157   	USM_BSP_PROCESS(BSP_Conf);					//主机事件处理函数
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_PROCESS
;;;1158   	USS_BSP_PROCESS(BSP_Conf);					//从机事件处理函数
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USS_BSP_PROCESS
;;;1159   	
;;;1160   }
000010  bd10              POP      {r4,pc}
;;;1161   void BSP_SendBuffer(BSP_Conf_TypeDef *BSP_Conf)						//通过串口发送数据，当检测到USARTSendLen不为0时自动发送
                          ENDP


                          AREA ||i.BSP_Reset||, CODE, READONLY, ALIGN=1

                  BSP_Reset PROC
;;;1176   *******************************************************************************/
;;;1177   void BSP_Reset(BSP_Conf_TypeDef *BSP_Conf)	//重置编程器---恢复所有参数为默认值
000000  b510              PUSH     {r4,lr}
;;;1178   {	
000002  4604              MOV      r4,r0
;;;1179   	//----------BSPM_Info_TypeDef		BSPM_Info
;;;1180   	BSP_Conf->BSPM_Info.BSP_MASTER_STATUS	=	BSP_MSTATUS_IDLE;		//BSP主机空闲状态----开始写前或者写完成后状态
000004  205e              MOVS     r0,#0x5e
000006  7520              STRB     r0,[r4,#0x14]
;;;1181   	BSP_Conf->BSPM_Info.MasterLastStatus	=	BSP_MSTATUS_IDLE;		//BSP主机空闲状态----开始写前或者写完成后状态
000008  215e              MOVS     r1,#0x5e
00000a  7561              STRB     r1,[r4,#0x15]
;;;1182   	BSP_Conf->BSPM_Info.ACK								=	BSP_NACK;						//默认无应答状态
00000c  211f              MOVS     r1,#0x1f
00000e  2023              MOVS     r0,#0x23
000010  5501              STRB     r1,[r0,r4]
;;;1183   	BSP_Conf->BSPM_Info.ACK2							=	BSP_NACK;						//默认无应答状态
000012  2024              MOVS     r0,#0x24
000014  5501              STRB     r1,[r0,r4]
;;;1184   	//----------BSPM_Info_TypeDef		BSPM_Info
;;;1185   	BSP_Conf->BSPS_Info.BSP_SLAVE_STATUS	=	BSP_STATUS_IDLE;		//ISP空闲状态，可以读写
000016  203e              MOVS     r0,#0x3e
000018  f8840025          STRB     r0,[r4,#0x25]
;;;1186   	BSP_Conf->BSPS_Info.SlaveLastStatus		=	BSP_STATUS_IDLE;		//ISP空闲状态，可以读写
00001c  213e              MOVS     r1,#0x3e
00001e  2026              MOVS     r0,#0x26
000020  5501              STRB     r1,[r0,r4]
;;;1187   	//----------BSPM_Info_TypeDef		BSPM_Info
;;;1188   	BSP_Conf->BSP_DATA.OverRunTime=0;			//超时时间
000022  2000              MOVS     r0,#0
000024  62a0              STR      r0,[r4,#0x28]
;;;1189   	BSP_Conf->BSP_DATA.TimeCount=0;				//计时时间
000026  2100              MOVS     r1,#0
000028  62e1              STR      r1,[r4,#0x2c]
;;;1190   	BSP_Conf->BSP_DATA.Connected=0;				//连接状态--从机更新固件时使用，如果Connected==0，表示未连接，需要格式化，如果Connected==1，表示已经连接
00002a  2034              MOVS     r0,#0x34
00002c  5501              STRB     r1,[r0,r4]
;;;1191   	BSP_Conf->BSP_DATA.OffsetAddr=0;			//写从机时的地址偏移
00002e  63a1              STR      r1,[r4,#0x38]
;;;1192   	BSP_Conf->BSP_DATA.StartAddr=0;				//起始地址
000030  63e1              STR      r1,[r4,#0x3c]
;;;1193   	BSP_Conf->BSP_DATA.StepLen	=256;			//每次写入的字节长，备地址自增用
000032  f44f7180          MOV      r1,#0x100
000036  6421              STR      r1,[r4,#0x40]
;;;1194   	BSP_Conf->BSP_DATA.GoAddr=0;					//复位运行起始地址
000038  2100              MOVS     r1,#0
00003a  6461              STR      r1,[r4,#0x44]
;;;1195   	BSP_Conf->BSP_DATA.FirmwareLen=0;			//固件长度---需要ISP下载的总数据
00003c  64a1              STR      r1,[r4,#0x48]
;;;1196   	BSP_Conf->BSP_DATA.FLASHNumToSave=0;	//需要往FLASH里保存的数据个数---当此不为0时SPI-FLASH自动存储数据
00003e  64e1              STR      r1,[r4,#0x4c]
;;;1197   	BSP_Conf->BSP_DATA.FLASHNumToRead=0;	//需要从FLASH里读取的数据个数---当此不为0时，SPI-FLASH自动通过WriteAddr地址从SPI-FLASH读取数据
000040  6521              STR      r1,[r4,#0x50]
;;;1198   	BSP_Conf->BSP_DATA.ReadAddr=0;				//读数据起始地址
000042  6561              STR      r1,[r4,#0x54]
;;;1199   	BSP_Conf->BSP_DATA.ReadLen=0;					//需要读取的长度
000044  65a1              STR      r1,[r4,#0x58]
;;;1200   	BSP_Conf->BSP_DATA.WriteAddr=0;				//要写入Flash的数据起始地址--ISP接口
000046  65e1              STR      r1,[r4,#0x5c]
;;;1201   	BSP_Conf->BSP_DATA.WriteLen=0;				//要写入Flash的数据长度（字节数)--ISP接口
000048  6621              STR      r1,[r4,#0x60]
;;;1202   	BSP_Conf->BSP_DATA.ReceivedLen=0;			//串口接收的数据个数
00004a  6661              STR      r1,[r4,#0x64]
;;;1203   	BSP_Conf->BSP_DATA.USARTSendLen=0;		//需要往串口发送的数据个数---//当检测到SendLen不为0时自动发送数据
00004c  66a1              STR      r1,[r4,#0x68]
;;;1204   	BSP_Conf->BSP_DATA.SumHaveReceived=0;	//作为从机时总共接收到的数据个数
00004e  66e1              STR      r1,[r4,#0x6c]
;;;1205   	BSP_Conf->BSP_DATA.SumHaveWritten=0;	//主机总共往从机写入的数据个数
000050  6721              STR      r1,[r4,#0x70]
;;;1206   	BSP_Conf->BSP_DATA.Command[0]=0;			//自举程序命令及异或校验码
000052  f8841074          STRB     r1,[r4,#0x74]
;;;1207   	BSP_Conf->BSP_DATA.Command[1]=0;
000056  f8841075          STRB     r1,[r4,#0x75]
;;;1208   	
;;;1209   
;;;1210   	memset(BSP_Conf->BSP_DATA.BSP_RxBuffer,0xFF, BSP_BufferSize);	//接收缓冲区
00005a  22ff              MOVS     r2,#0xff
00005c  f44f7196          MOV      r1,#0x12c
000060  f1040076          ADD      r0,r4,#0x76
000064  f7fffffe          BL       __aeabi_memset
;;;1211   	memset(BSP_Conf->BSP_DATA.BSP_RvBuffer,0xFF, BSP_BufferSize);	//接收缓冲区--备份区
000068  22ff              MOVS     r2,#0xff
00006a  f44f7196          MOV      r1,#0x12c
00006e  f50470d1          ADD      r0,r4,#0x1a2
000072  f7fffffe          BL       __aeabi_memset
;;;1212   	memset(BSP_Conf->BSP_DATA.BSP_TxBuffer,0xFF, BSP_BufferSize);	//发送缓冲区
000076  22ff              MOVS     r2,#0xff
000078  f44f7196          MOV      r1,#0x12c
00007c  f20420ce          ADD      r0,r4,#0x2ce
000080  f7fffffe          BL       __aeabi_memset
;;;1213   	memset(BSP_Conf->BSP_DATA.BSP_TvBuffer,0xFF, BSP_BufferSize);	//发送缓冲区--备份区
000084  22ff              MOVS     r2,#0xff
000086  f44f7196          MOV      r1,#0x12c
00008a  f20430fa          ADD      r0,r4,#0x3fa
00008e  f7fffffe          BL       __aeabi_memset
;;;1214   	
;;;1215   }
000092  bd10              POP      {r4,pc}
;;;1216   
                          ENDP


                          AREA ||i.BSP_SendBuffer||, CODE, READONLY, ALIGN=1

                  BSP_SendBuffer PROC
;;;1160   }
;;;1161   void BSP_SendBuffer(BSP_Conf_TypeDef *BSP_Conf)						//通过串口发送数据，当检测到USARTSendLen不为0时自动发送
000000  b510              PUSH     {r4,lr}
;;;1162   {
000002  4604              MOV      r4,r0
;;;1163   	if(BSP_Conf->BSP_DATA.USARTSendLen!=0)
000004  6ea0              LDR      r0,[r4,#0x68]
000006  b1b0              CBZ      r0,|L4.54|
;;;1164   	{
;;;1165   		memcpy(BSP_Conf->BSP_DATA.BSP_TxBuffer,BSP_Conf->BSP_DATA.BSP_TvBuffer,BSP_Conf->BSP_DATA.USARTSendLen);					//从TvBuffer拷贝数据到TxBuffer		
000008  f20431fa          ADD      r1,r4,#0x3fa
00000c  f20420ce          ADD      r0,r4,#0x2ce
000010  6ea2              LDR      r2,[r4,#0x68]
000012  f7fffffe          BL       __aeabi_memcpy
;;;1166   		USART_DMASend(BSP_Conf->BSP_Port.USARTx,(u8*)BSP_Conf->BSP_DATA.BSP_TxBuffer,BSP_Conf->BSP_DATA.USARTSendLen);		//串口DMA发送程序
000016  f8b41068          LDRH     r1,[r4,#0x68]
00001a  b28a              UXTH     r2,r1
00001c  f20421ce          ADD      r1,r4,#0x2ce
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       USART_DMASend
;;;1167   		memset(BSP_Conf->BSP_DATA.BSP_TvBuffer,0xFF, BSP_Conf->BSP_DATA.USARTSendLen);																		//清空发送备份区
000026  22ff              MOVS     r2,#0xff
000028  f20430fa          ADD      r0,r4,#0x3fa
00002c  6ea1              LDR      r1,[r4,#0x68]
00002e  f7fffffe          BL       __aeabi_memset
;;;1168   		BSP_Conf->BSP_DATA.USARTSendLen=0;			//清空发送区
000032  2100              MOVS     r1,#0
000034  66a1              STR      r1,[r4,#0x68]
                  |L4.54|
;;;1169   	}
;;;1170   }
000036  bd10              POP      {r4,pc}
;;;1171   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_Connect||, CODE, READONLY, ALIGN=1

                  USM_BSP_Connect PROC
;;;1356   *******************************************************************************/
;;;1357   void USM_BSP_Connect(BSP_Conf_TypeDef *BSP_Conf)		//连接从机---间隔5ms连接发送0x7F，让从机识别波特率
000000  b500              PUSH     {lr}
;;;1358   {
000002  4602              MOV      r2,r0
;;;1359   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteConnect)
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2860              CMP      r0,#0x60
00000c  d103              BNE      |L5.22|
;;;1360   	{
;;;1361   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ad0              LDR      r0,[r2,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62d0              STR      r0,[r2,#0x2c]
000014  e000              B        |L5.24|
                  |L5.22|
;;;1362   	}
;;;1363   	else
;;;1364   	{
;;;1365   		return;
;;;1366   	}
;;;1367   	
;;;1368   	if(BSP_Conf->BSP_DATA.TimeCount==100)				//前1ms发送0x7F，后9ms检测应答，让从机识别波特率
;;;1369   	{
;;;1370   		BSP_Conf->BSP_DATA.BSP_TvBuffer[0]=0x7F;
;;;1371   		BSP_Conf->BSP_DATA.USARTSendLen=1;				//发送一个字节
;;;1372   	}
;;;1373   	else if(BSP_Conf->BSP_DATA.TimeCount>1000)	//剩下5ms检测应答
;;;1374   	{
;;;1375   		BSP_Conf->BSP_DATA.RetryTimes++;	//重试次数不超过50次，否则判定为失败
;;;1376   		if(BSP_Conf->BSP_DATA.RetryTimes>50)//重试次数不超过50次，否则判定为失败
;;;1377   		{
;;;1378   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---等待释放从机
;;;1379   		}
;;;1380   		BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数		
;;;1381   	}
;;;1382   	else
;;;1383   	{
;;;1384   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)
;;;1385   		{
;;;1386   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteGet);		//更新状态---等待释放从机
;;;1387   			BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1388   			BSP_Conf->BSP_DATA.RetryTimes=0;	//重试计数清零
;;;1389   			BSP_Conf->BSPM_Info.ACK=BSP_NACK;	//清除应答标志
;;;1390   		}		
;;;1391   	}
;;;1392   }
000016  bd00              POP      {pc}
                  |L5.24|
000018  6ad0              LDR      r0,[r2,#0x2c]         ;1368
00001a  2864              CMP      r0,#0x64              ;1368
00001c  d105              BNE      |L5.42|
00001e  217f              MOVS     r1,#0x7f              ;1370
000020  f88213fa          STRB     r1,[r2,#0x3fa]        ;1370
000024  2101              MOVS     r1,#1                 ;1371
000026  6691              STR      r1,[r2,#0x68]         ;1371
000028  e01e              B        |L5.104|
                  |L5.42|
00002a  6ad0              LDR      r0,[r2,#0x2c]         ;1373
00002c  f5b07f7a          CMP      r0,#0x3e8             ;1373
000030  d90c              BLS      |L5.76|
000032  6b10              LDR      r0,[r2,#0x30]         ;1375
000034  1c40              ADDS     r0,r0,#1              ;1375
000036  6310              STR      r0,[r2,#0x30]         ;1375
000038  6b10              LDR      r0,[r2,#0x30]         ;1376
00003a  2832              CMP      r0,#0x32              ;1376
00003c  d903              BLS      |L5.70|
00003e  217a              MOVS     r1,#0x7a              ;1378
000040  4610              MOV      r0,r2                 ;1378
000042  f7fffffe          BL       USM_BSP_SetStatus
                  |L5.70|
000046  2100              MOVS     r1,#0                 ;1380
000048  62d1              STR      r1,[r2,#0x2c]         ;1380
00004a  e00d              B        |L5.104|
                  |L5.76|
00004c  2023              MOVS     r0,#0x23              ;1384
00004e  5c80              LDRB     r0,[r0,r2]            ;1384
000050  2879              CMP      r0,#0x79              ;1384
000052  d109              BNE      |L5.104|
000054  2161              MOVS     r1,#0x61              ;1386
000056  4610              MOV      r0,r2                 ;1386
000058  f7fffffe          BL       USM_BSP_SetStatus
00005c  2100              MOVS     r1,#0                 ;1387
00005e  62d1              STR      r1,[r2,#0x2c]         ;1387
000060  6311              STR      r1,[r2,#0x30]         ;1388
000062  211f              MOVS     r1,#0x1f              ;1389
000064  2023              MOVS     r0,#0x23              ;1389
000066  5481              STRB     r1,[r0,r2]            ;1389
                  |L5.104|
000068  bf00              NOP      
00006a  e7d4              B        |L5.22|
;;;1393   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_EEraseMemory||, CODE, READONLY, ALIGN=1

                  USM_BSP_EEraseMemory PROC
;;;1764   *******************************************************************************/
;;;1765   void USM_BSP_EEraseMemory(BSP_Conf_TypeDef *BSP_Conf)		//使用双字节寻址模式擦除一个到全部 Flash 页面（仅用于v3.0 usart 自举程序版本及以上版本）
000000  4770              BX       lr
;;;1766   {
;;;1767   
;;;1768   }
;;;1769   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_EraseMemory||, CODE, READONLY, ALIGN=1

                  USM_BSP_EraseMemory PROC
;;;1704   *******************************************************************************/
;;;1705   void USM_BSP_EraseMemory(BSP_Conf_TypeDef *BSP_Conf)		//擦除一个到全部 Flash 页面（擦除FLASH后开始写入地址）
000000  b510              PUSH     {r4,lr}
;;;1706   {
000002  4604              MOV      r4,r0
;;;1707   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteErase)
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2865              CMP      r0,#0x65
00000c  d103              BNE      |L7.22|
;;;1708   	{
;;;1709   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62e0              STR      r0,[r4,#0x2c]
000014  e000              B        |L7.24|
                  |L7.22|
;;;1710   	}
;;;1711   	else
;;;1712   	{
;;;1713   		return;
;;;1714   	}
;;;1715   	if(BSP_Conf->BSP_DATA.TimeCount==100)				//前1ms发送0x7F，后9ms检测应答，让从机识别波特率
;;;1716   	{
;;;1717   		if(BSP_Conf->BSPM_Info.ACK2!=BSP_ACK)
;;;1718   		{
;;;1719   			USM_BSP_SendCommand(BSP_Conf,BSP_COMMAND_Erase);	//串口编程发送命令程序---擦除命令
;;;1720   		}
;;;1721   		else
;;;1722   		{
;;;1723   			BSP_Conf->BSP_DATA.BSP_TvBuffer[0]=0xFF;
;;;1724   			BSP_Conf->BSP_DATA.BSP_TvBuffer[1]=0x00;
;;;1725   			BSP_Conf->BSP_DATA.USARTSendLen=2;				//发送一个字节
;;;1726   		}
;;;1727   	}
;;;1728   	else if(BSP_Conf->BSP_DATA.TimeCount>1000)	//剩下5ms检测应答
;;;1729   	{
;;;1730   		BSP_Conf->BSP_DATA.RetryTimes++;			//重试次数不超过50次，否则判定为失败
;;;1731   		if(BSP_Conf->BSP_DATA.RetryTimes>50)	//重试次数不超过50次，否则判定为失败
;;;1732   		{
;;;1733   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---错误
;;;1734   		}	
;;;1735   		BSP_Conf->BSP_DATA.TimeCount=0;				//清除计数--重新开时进入擦除操作		
;;;1736   	}
;;;1737   	else	//以下过程为不断检测应答标志---USM_BSP_GetAck(BSP_Conf);	//获取从机应答
;;;1738   	{
;;;1739   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)		//检测到应答
;;;1740   		{	
;;;1741   			if(BSP_Conf->BSPM_Info.ACK2!=BSP_ACK)	//第二次未设置应答标志，表示为第一次应答
;;;1742   			{
;;;1743   				BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1744   				BSP_Conf->BSP_DATA.RetryTimes=0;	//重试计数清零
;;;1745   				BSP_Conf->BSPM_Info.ACK=BSP_NACK;	//清除应答标志--应答检测标志
;;;1746   				BSP_Conf->BSPM_Info.ACK2=BSP_ACK;	//存储上次应答标志
;;;1747   			}
;;;1748   			else		//检测到第二次成功应答，表示此项成功完成
;;;1749   			{
;;;1750   				USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteWM);		//更新状态---BSP主机发送写命令，Write Memory:从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash---需要应答
;;;1751   				BSP_Conf->BSP_DATA.TimeCount=0;			//清除计数
;;;1752   				BSP_Conf->BSP_DATA.RetryTimes=0;		//重试计数清零
;;;1753   				BSP_Conf->BSPM_Info.ACK=BSP_NACK;		//清除应答标志
;;;1754   				BSP_Conf->BSPM_Info.ACK2=BSP_NACK;	//清除应答标志
;;;1755   			}			
;;;1756   		}		
;;;1757   	}
;;;1758   }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  6ae0              LDR      r0,[r4,#0x2c]         ;1715
00001a  2864              CMP      r0,#0x64              ;1715
00001c  d111              BNE      |L7.66|
00001e  2024              MOVS     r0,#0x24              ;1717
000020  5d00              LDRB     r0,[r0,r4]            ;1717
000022  2879              CMP      r0,#0x79              ;1717
000024  d004              BEQ      |L7.48|
000026  2143              MOVS     r1,#0x43              ;1719
000028  4620              MOV      r0,r4                 ;1719
00002a  f7fffffe          BL       USM_BSP_SendCommand
00002e  e037              B        |L7.160|
                  |L7.48|
000030  21ff              MOVS     r1,#0xff              ;1723
000032  f88413fa          STRB     r1,[r4,#0x3fa]        ;1723
000036  2100              MOVS     r1,#0                 ;1724
000038  f88413fb          STRB     r1,[r4,#0x3fb]        ;1724
00003c  2102              MOVS     r1,#2                 ;1725
00003e  66a1              STR      r1,[r4,#0x68]         ;1725
000040  e02e              B        |L7.160|
                  |L7.66|
000042  6ae0              LDR      r0,[r4,#0x2c]         ;1728
000044  f5b07f7a          CMP      r0,#0x3e8             ;1728
000048  d90c              BLS      |L7.100|
00004a  6b20              LDR      r0,[r4,#0x30]         ;1730
00004c  1c40              ADDS     r0,r0,#1              ;1730
00004e  6320              STR      r0,[r4,#0x30]         ;1730
000050  6b20              LDR      r0,[r4,#0x30]         ;1731
000052  2832              CMP      r0,#0x32              ;1731
000054  d903              BLS      |L7.94|
000056  217a              MOVS     r1,#0x7a              ;1733
000058  4620              MOV      r0,r4                 ;1733
00005a  f7fffffe          BL       USM_BSP_SetStatus
                  |L7.94|
00005e  2100              MOVS     r1,#0                 ;1735
000060  62e1              STR      r1,[r4,#0x2c]         ;1735
000062  e01d              B        |L7.160|
                  |L7.100|
000064  2023              MOVS     r0,#0x23              ;1739
000066  5d00              LDRB     r0,[r0,r4]            ;1739
000068  2879              CMP      r0,#0x79              ;1739
00006a  d119              BNE      |L7.160|
00006c  2024              MOVS     r0,#0x24              ;1741
00006e  5d00              LDRB     r0,[r0,r4]            ;1741
000070  2879              CMP      r0,#0x79              ;1741
000072  d009              BEQ      |L7.136|
000074  2100              MOVS     r1,#0                 ;1743
000076  62e1              STR      r1,[r4,#0x2c]         ;1743
000078  6321              STR      r1,[r4,#0x30]         ;1744
00007a  211f              MOVS     r1,#0x1f              ;1745
00007c  2023              MOVS     r0,#0x23              ;1745
00007e  5501              STRB     r1,[r0,r4]            ;1745
000080  2179              MOVS     r1,#0x79              ;1746
000082  2024              MOVS     r0,#0x24              ;1746
000084  5501              STRB     r1,[r0,r4]            ;1746
000086  e00b              B        |L7.160|
                  |L7.136|
000088  2166              MOVS     r1,#0x66              ;1750
00008a  4620              MOV      r0,r4                 ;1750
00008c  f7fffffe          BL       USM_BSP_SetStatus
000090  2100              MOVS     r1,#0                 ;1751
000092  62e1              STR      r1,[r4,#0x2c]         ;1751
000094  6321              STR      r1,[r4,#0x30]         ;1752
000096  211f              MOVS     r1,#0x1f              ;1753
000098  2023              MOVS     r0,#0x23              ;1753
00009a  5501              STRB     r1,[r0,r4]            ;1753
00009c  2024              MOVS     r0,#0x24              ;1754
00009e  5501              STRB     r1,[r0,r4]            ;1754
                  |L7.160|
0000a0  bf00              NOP      
0000a2  e7b8              B        |L7.22|
;;;1759   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_Get||, CODE, READONLY, ALIGN=1

                  USM_BSP_Get PROC
;;;1398   *******************************************************************************/
;;;1399   void USM_BSP_Get(BSP_Conf_TypeDef *BSP_Conf)		//获取当前自举程序版本及允许使用的命令
000000  b510              PUSH     {r4,lr}
;;;1400   {
000002  4604              MOV      r4,r0
;;;1401   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteGet)
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2861              CMP      r0,#0x61
00000c  d103              BNE      |L8.22|
;;;1402   	{
;;;1403   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62e0              STR      r0,[r4,#0x2c]
000014  e000              B        |L8.24|
                  |L8.22|
;;;1404   	}
;;;1405   	else
;;;1406   	{
;;;1407   		return;
;;;1408   	}
;;;1409   	if(BSP_Conf->BSP_DATA.TimeCount==100)				//前1ms发送0x7F，后9ms检测应答，让从机识别波特率
;;;1410   	{
;;;1411   		USM_BSP_SendCommand(BSP_Conf,BSP_COMMAND_Get);	//串口编程发送命令程序
;;;1412   	}
;;;1413   	else if(BSP_Conf->BSP_DATA.TimeCount>1000)	//剩下5ms检测应答
;;;1414   	{
;;;1415   		BSP_Conf->BSP_DATA.RetryTimes++;	//重试次数不超过50次，否则判定为失败
;;;1416   		if(BSP_Conf->BSP_DATA.RetryTimes>50)//重试次数不超过50次，否则判定为失败
;;;1417   		{
;;;1418   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---等待释放从机
;;;1419   		}
;;;1420   		BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数		
;;;1421   	}
;;;1422   	else
;;;1423   	{
;;;1424   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)
;;;1425   		{
;;;1426   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS					=	BSP_Conf->BSP_DATA.BSP_RvBuffer[2];		//自举程序版本（0 < 版本 < 255），示例：0x10 = 版本 1.0
;;;1427   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_Get			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[3];		//Get:获取当前自举程序版本及允许使用的命令
;;;1428   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_GetVS		=	BSP_Conf->BSP_DATA.BSP_RvBuffer[4];		//Get Version & Read Protection Status:获取自举程序版本及 Flash 的读保护状态
;;;1429   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_GetID		=	BSP_Conf->BSP_DATA.BSP_RvBuffer[5];		//Get ID:获取芯片 ID
;;;1430   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_RM			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[6];		//Read Memory:从应用程序指定的地址开始读取最多 256 个字节的存储器空间
;;;1431   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_Go			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[7];		//Go:跳转到内部 Flash 或 SRAM 内的应用程序代码
;;;1432   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_WM			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[8];		//Write Memory:从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash
;;;1433   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_Erase		=	BSP_Conf->BSP_DATA.BSP_RvBuffer[9];		//Erase:擦除一个到全部 Flash 页面
;;;1434   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_WP			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[10];	//Write Protect:使能某些扇区的写保护
;;;1435   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_WU			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[11];	//Write Unprotect:禁止所有 Flash 扇区的写保护
;;;1436   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_RP			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[12];	//Readout Protect:使能读保护
;;;1437   			BSP_Conf->BSPM_Info.SlaveVersion.BSP_VS_RU			=	BSP_Conf->BSP_DATA.BSP_RvBuffer[13];	//Readout Unprotect:禁止读保护
;;;1438   			
;;;1439   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteGetVR);		//更新状态---等待释放从机
;;;1440   			BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1441   			BSP_Conf->BSP_DATA.RetryTimes=0;	//重试计数清零
;;;1442   			BSP_Conf->BSPM_Info.ACK=BSP_NACK;	//清除应答标志
;;;1443   		}		
;;;1444   	}
;;;1445   }
000016  bd10              POP      {r4,pc}
                  |L8.24|
000018  6ae0              LDR      r0,[r4,#0x2c]         ;1409
00001a  2864              CMP      r0,#0x64              ;1409
00001c  d104              BNE      |L8.40|
00001e  2100              MOVS     r1,#0                 ;1411
000020  4620              MOV      r0,r4                 ;1411
000022  f7fffffe          BL       USM_BSP_SendCommand
000026  e044              B        |L8.178|
                  |L8.40|
000028  6ae0              LDR      r0,[r4,#0x2c]         ;1413
00002a  f5b07f7a          CMP      r0,#0x3e8             ;1413
00002e  d90c              BLS      |L8.74|
000030  6b20              LDR      r0,[r4,#0x30]         ;1415
000032  1c40              ADDS     r0,r0,#1              ;1415
000034  6320              STR      r0,[r4,#0x30]         ;1415
000036  6b20              LDR      r0,[r4,#0x30]         ;1416
000038  2832              CMP      r0,#0x32              ;1416
00003a  d903              BLS      |L8.68|
00003c  217a              MOVS     r1,#0x7a              ;1418
00003e  4620              MOV      r0,r4                 ;1418
000040  f7fffffe          BL       USM_BSP_SetStatus
                  |L8.68|
000044  2100              MOVS     r1,#0                 ;1420
000046  62e1              STR      r1,[r4,#0x2c]         ;1420
000048  e033              B        |L8.178|
                  |L8.74|
00004a  2023              MOVS     r0,#0x23              ;1424
00004c  5d00              LDRB     r0,[r0,r4]            ;1424
00004e  2879              CMP      r0,#0x79              ;1424
000050  d12f              BNE      |L8.178|
000052  f89411a4          LDRB     r1,[r4,#0x1a4]        ;1426
000056  75a1              STRB     r1,[r4,#0x16]         ;1426
000058  f89411a5          LDRB     r1,[r4,#0x1a5]        ;1427
00005c  75e1              STRB     r1,[r4,#0x17]         ;1427
00005e  f89411a6          LDRB     r1,[r4,#0x1a6]        ;1428
000062  7621              STRB     r1,[r4,#0x18]         ;1428
000064  f89411a7          LDRB     r1,[r4,#0x1a7]        ;1429
000068  7661              STRB     r1,[r4,#0x19]         ;1429
00006a  f89411a8          LDRB     r1,[r4,#0x1a8]        ;1430
00006e  76a1              STRB     r1,[r4,#0x1a]         ;1430
000070  f89411a9          LDRB     r1,[r4,#0x1a9]        ;1431
000074  76e1              STRB     r1,[r4,#0x1b]         ;1431
000076  f89411aa          LDRB     r1,[r4,#0x1aa]        ;1432
00007a  7721              STRB     r1,[r4,#0x1c]         ;1432
00007c  f89411ab          LDRB     r1,[r4,#0x1ab]        ;1433
000080  7761              STRB     r1,[r4,#0x1d]         ;1433
000082  f89411ac          LDRB     r1,[r4,#0x1ac]        ;1434
000086  77a1              STRB     r1,[r4,#0x1e]         ;1434
000088  f89411ad          LDRB     r1,[r4,#0x1ad]        ;1435
00008c  77e1              STRB     r1,[r4,#0x1f]         ;1435
00008e  f89411ae          LDRB     r1,[r4,#0x1ae]        ;1436
000092  f8841020          STRB     r1,[r4,#0x20]         ;1436
000096  f89411af          LDRB     r1,[r4,#0x1af]        ;1437
00009a  f8841021          STRB     r1,[r4,#0x21]         ;1437
00009e  2162              MOVS     r1,#0x62              ;1439
0000a0  4620              MOV      r0,r4                 ;1439
0000a2  f7fffffe          BL       USM_BSP_SetStatus
0000a6  2100              MOVS     r1,#0                 ;1440
0000a8  62e1              STR      r1,[r4,#0x2c]         ;1440
0000aa  6321              STR      r1,[r4,#0x30]         ;1441
0000ac  211f              MOVS     r1,#0x1f              ;1442
0000ae  2023              MOVS     r0,#0x23              ;1442
0000b0  5501              STRB     r1,[r0,r4]            ;1442
                  |L8.178|
0000b2  bf00              NOP      
0000b4  e7af              B        |L8.22|
;;;1446   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_GetAck||, CODE, READONLY, ALIGN=1

                  USM_BSP_GetAck PROC
;;;1814   *******************************************************************************/
;;;1815   void USM_BSP_GetAck(BSP_Conf_TypeDef *BSP_Conf)		//获取从机应答
000000  b570              PUSH     {r4-r6,lr}
;;;1816   {
000002  4604              MOV      r4,r0
;;;1817   	unsigned char RxNum=0;
000004  2500              MOVS     r5,#0
;;;1818   	RxNum=USART_ReadBufferIDLE(BSP_Conf->BSP_Port.USARTx,(u8*)BSP_Conf->BSP_DATA.BSP_RvBuffer);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的
000006  f50471d1          ADD      r1,r4,#0x1a2
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       USART_ReadBufferIDLE
000010  b2c5              UXTB     r5,r0
;;;1819   	if((RxNum!=0)&&(BSP_Conf->BSP_DATA.BSP_RvBuffer[0]==BSP_ACK))
000012  b14d              CBZ      r5,|L9.40|
000014  f89401a2          LDRB     r0,[r4,#0x1a2]
000018  2879              CMP      r0,#0x79
00001a  d105              BNE      |L9.40|
;;;1820   	{
;;;1821   		BSP_Conf->BSP_DATA.BSP_RvBuffer[0]=0xFF;		//清除应答标识
00001c  21ff              MOVS     r1,#0xff
00001e  f88411a2          STRB     r1,[r4,#0x1a2]
;;;1822   		BSP_Conf->BSPM_Info.ACK=BSP_ACK;		//应答
000022  2179              MOVS     r1,#0x79
000024  2023              MOVS     r0,#0x23
000026  5501              STRB     r1,[r0,r4]
                  |L9.40|
;;;1823   	}
;;;1824   }
000028  bd70              POP      {r4-r6,pc}
;;;1825   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_GetId||, CODE, READONLY, ALIGN=1

                  USM_BSP_GetId PROC
;;;1492   *******************************************************************************/
;;;1493   void USM_BSP_GetId(BSP_Conf_TypeDef *BSP_Conf)			//获取芯片 ID
000000  b510              PUSH     {r4,lr}
;;;1494   {
000002  4604              MOV      r4,r0
;;;1495   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteGetID)
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2863              CMP      r0,#0x63
00000c  d103              BNE      |L10.22|
;;;1496   	{
;;;1497   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62e0              STR      r0,[r4,#0x2c]
000014  e000              B        |L10.24|
                  |L10.22|
;;;1498   	}
;;;1499   	else
;;;1500   	{
;;;1501   		return;
;;;1502   	}
;;;1503   	if(BSP_Conf->BSP_DATA.TimeCount==100)				//前1ms发送0x7F，后9ms检测应答，让从机识别波特率
;;;1504   	{
;;;1505   		USM_BSP_SendCommand(BSP_Conf,BSP_COMMAND_GetID);	//串口编程发送命令程序
;;;1506   	}
;;;1507   	else if(BSP_Conf->BSP_DATA.TimeCount>1000)	//剩下5ms检测应答
;;;1508   	{
;;;1509   		BSP_Conf->BSP_DATA.RetryTimes++;	//重试次数不超过50次，否则判定为失败
;;;1510   		if(BSP_Conf->BSP_DATA.RetryTimes>50)//重试次数不超过50次，否则判定为失败
;;;1511   		{
;;;1512   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---等待释放从机
;;;1513   		}	
;;;1514   		BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数		
;;;1515   	}
;;;1516   	else
;;;1517   	{
;;;1518   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)
;;;1519   		{
;;;1520   			
;;;1521   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteErase);		//更新状态---等待释放从机
;;;1522   			BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1523   			BSP_Conf->BSP_DATA.RetryTimes=0;	//重试计数清零
;;;1524   			BSP_Conf->BSPM_Info.ACK=BSP_NACK;	//清除应答标志
;;;1525   		}		
;;;1526   	}
;;;1527   }
000016  bd10              POP      {r4,pc}
                  |L10.24|
000018  6ae0              LDR      r0,[r4,#0x2c]         ;1503
00001a  2864              CMP      r0,#0x64              ;1503
00001c  d104              BNE      |L10.40|
00001e  2102              MOVS     r1,#2                 ;1505
000020  4620              MOV      r0,r4                 ;1505
000022  f7fffffe          BL       USM_BSP_SendCommand
000026  e01e              B        |L10.102|
                  |L10.40|
000028  6ae0              LDR      r0,[r4,#0x2c]         ;1507
00002a  f5b07f7a          CMP      r0,#0x3e8             ;1507
00002e  d90c              BLS      |L10.74|
000030  6b20              LDR      r0,[r4,#0x30]         ;1509
000032  1c40              ADDS     r0,r0,#1              ;1509
000034  6320              STR      r0,[r4,#0x30]         ;1509
000036  6b20              LDR      r0,[r4,#0x30]         ;1510
000038  2832              CMP      r0,#0x32              ;1510
00003a  d903              BLS      |L10.68|
00003c  217a              MOVS     r1,#0x7a              ;1512
00003e  4620              MOV      r0,r4                 ;1512
000040  f7fffffe          BL       USM_BSP_SetStatus
                  |L10.68|
000044  2100              MOVS     r1,#0                 ;1514
000046  62e1              STR      r1,[r4,#0x2c]         ;1514
000048  e00d              B        |L10.102|
                  |L10.74|
00004a  2023              MOVS     r0,#0x23              ;1518
00004c  5d00              LDRB     r0,[r0,r4]            ;1518
00004e  2879              CMP      r0,#0x79              ;1518
000050  d109              BNE      |L10.102|
000052  2165              MOVS     r1,#0x65              ;1521
000054  4620              MOV      r0,r4                 ;1521
000056  f7fffffe          BL       USM_BSP_SetStatus
00005a  2100              MOVS     r1,#0                 ;1522
00005c  62e1              STR      r1,[r4,#0x2c]         ;1522
00005e  6321              STR      r1,[r4,#0x30]         ;1523
000060  211f              MOVS     r1,#0x1f              ;1524
000062  2023              MOVS     r0,#0x23              ;1524
000064  5501              STRB     r1,[r0,r4]            ;1524
                  |L10.102|
000066  bf00              NOP      
000068  e7d5              B        |L10.22|
;;;1528   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_GetStatus||, CODE, READONLY, ALIGN=1

                  USM_BSP_GetStatus PROC
;;;1346   *******************************************************************************/
;;;1347   BSPM_STATUS_TypeDef USM_BSP_GetStatus(BSP_Conf_TypeDef *BSP_Conf)		//获取主机状态
000000  4601              MOV      r1,r0
;;;1348   {
;;;1349   	return BSP_Conf->BSPM_Info.BSP_MASTER_STATUS;				//主机状态值
000002  7d08              LDRB     r0,[r1,#0x14]
;;;1350   }
000004  4770              BX       lr
;;;1351   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_GetVR||, CODE, READONLY, ALIGN=1

                  USM_BSP_GetVR PROC
;;;1451   *******************************************************************************/
;;;1452   void USM_BSP_GetVR(BSP_Conf_TypeDef *BSP_Conf)		//获取自举程序版本及 Flash 的读保护状态
000000  b510              PUSH     {r4,lr}
;;;1453   {
000002  4604              MOV      r4,r0
;;;1454   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteGetVR)
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2862              CMP      r0,#0x62
00000c  d103              BNE      |L12.22|
;;;1455   	{
;;;1456   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62e0              STR      r0,[r4,#0x2c]
000014  e000              B        |L12.24|
                  |L12.22|
;;;1457   	}
;;;1458   	else
;;;1459   	{
;;;1460   		return;
;;;1461   	}
;;;1462   	if(BSP_Conf->BSP_DATA.TimeCount==100)				//前1ms发送0x7F，后9ms检测应答，让从机识别波特率
;;;1463   	{
;;;1464   		USM_BSP_SendCommand(BSP_Conf,BSP_COMMAND_GetVR);	//串口编程发送命令程序
;;;1465   	}
;;;1466   	else if(BSP_Conf->BSP_DATA.TimeCount>1000)	//剩下5ms检测应答
;;;1467   	{
;;;1468   		BSP_Conf->BSP_DATA.RetryTimes++;	//重试次数不超过50次，否则判定为失败
;;;1469   		if(BSP_Conf->BSP_DATA.RetryTimes>50)//重试次数不超过50次，否则判定为失败
;;;1470   		{
;;;1471   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---等待释放从机
;;;1472   		}	
;;;1473   		BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数		
;;;1474   	}
;;;1475   	else
;;;1476   	{
;;;1477   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)
;;;1478   		{
;;;1479   			
;;;1480   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteGetID);		//更新状态---等待释放从机
;;;1481   			BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1482   			BSP_Conf->BSP_DATA.RetryTimes=0;	//重试计数清零
;;;1483   			BSP_Conf->BSPM_Info.ACK=BSP_NACK;	//清除应答标志
;;;1484   		}		
;;;1485   	}
;;;1486   }
000016  bd10              POP      {r4,pc}
                  |L12.24|
000018  6ae0              LDR      r0,[r4,#0x2c]         ;1462
00001a  2864              CMP      r0,#0x64              ;1462
00001c  d104              BNE      |L12.40|
00001e  2101              MOVS     r1,#1                 ;1464
000020  4620              MOV      r0,r4                 ;1464
000022  f7fffffe          BL       USM_BSP_SendCommand
000026  e01e              B        |L12.102|
                  |L12.40|
000028  6ae0              LDR      r0,[r4,#0x2c]         ;1466
00002a  f5b07f7a          CMP      r0,#0x3e8             ;1466
00002e  d90c              BLS      |L12.74|
000030  6b20              LDR      r0,[r4,#0x30]         ;1468
000032  1c40              ADDS     r0,r0,#1              ;1468
000034  6320              STR      r0,[r4,#0x30]         ;1468
000036  6b20              LDR      r0,[r4,#0x30]         ;1469
000038  2832              CMP      r0,#0x32              ;1469
00003a  d903              BLS      |L12.68|
00003c  217a              MOVS     r1,#0x7a              ;1471
00003e  4620              MOV      r0,r4                 ;1471
000040  f7fffffe          BL       USM_BSP_SetStatus
                  |L12.68|
000044  2100              MOVS     r1,#0                 ;1473
000046  62e1              STR      r1,[r4,#0x2c]         ;1473
000048  e00d              B        |L12.102|
                  |L12.74|
00004a  2023              MOVS     r0,#0x23              ;1477
00004c  5d00              LDRB     r0,[r0,r4]            ;1477
00004e  2879              CMP      r0,#0x79              ;1477
000050  d109              BNE      |L12.102|
000052  2163              MOVS     r1,#0x63              ;1480
000054  4620              MOV      r0,r4                 ;1480
000056  f7fffffe          BL       USM_BSP_SetStatus
00005a  2100              MOVS     r1,#0                 ;1481
00005c  62e1              STR      r1,[r4,#0x2c]         ;1481
00005e  6321              STR      r1,[r4,#0x30]         ;1482
000060  211f              MOVS     r1,#0x1f              ;1483
000062  2023              MOVS     r0,#0x23              ;1483
000064  5501              STRB     r1,[r0,r4]            ;1483
                  |L12.102|
000066  bf00              NOP      
000068  e7d5              B        |L12.22|
;;;1487   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_Go||, CODE, READONLY, ALIGN=1

                  USM_BSP_Go PROC
;;;1543   *******************************************************************************/
;;;1544   void USM_BSP_Go(BSP_Conf_TypeDef *BSP_Conf)		//跳转到内部 Flash 或 SRAM 内的应用程序代码
000000  4770              BX       lr
;;;1545   {
;;;1546   
;;;1547   }
;;;1548   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_PROCESS||, CODE, READONLY, ALIGN=1

                  USM_BSP_PROCESS PROC
;;;1229   *******************************************************************************/
;;;1230   void USM_BSP_PROCESS(BSP_Conf_TypeDef *BSP_Conf)
000000  b510              PUSH     {r4,lr}
;;;1231   {
000002  4604              MOV      r4,r0
;;;1232   	if(BSP_Conf->BSPM_Info.BSP_MASTER_STATUS==BSP_MSTATUS_IDLE)
000004  7d20              LDRB     r0,[r4,#0x14]
000006  285e              CMP      r0,#0x5e
000008  d101              BNE      |L14.14|
;;;1233   	{
;;;1234   		BSP_Conf->BSPM_Info.BSP_MASTER_STATUS=BSP_MSTATUS_ResetDevice;
00000a  205f              MOVS     r0,#0x5f
00000c  7520              STRB     r0,[r4,#0x14]
                  |L14.14|
;;;1235   	}
;;;1236   
;;;1237   	USM_BSP_GetAck(BSP_Conf);					//获取从机应答	
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USM_BSP_GetAck
;;;1238   	
;;;1239   	USM_BSP_RESET(BSP_Conf);					//复位从机
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USM_BSP_RESET
;;;1240   	USM_BSP_Connect(BSP_Conf);				//连接从机---间隔5ms连接发送0x7F，让从机识别波特率
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       USM_BSP_Connect
;;;1241   //	
;;;1242   	USM_BSP_Get(BSP_Conf);						//获取当前自举程序版本及允许使用的命令
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USM_BSP_Get
;;;1243   	USM_BSP_GetVR(BSP_Conf);					//获取自举程序版本及 Flash 的读保护状态
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       USM_BSP_GetVR
;;;1244   	USM_BSP_GetId(BSP_Conf);					//获取芯片 ID
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       USM_BSP_GetId
;;;1245   	USM_BSP_EraseMemory(BSP_Conf);		//擦除一个到全部 Flash 页面（擦除FLASH后开始写入地址）
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USM_BSP_EraseMemory
;;;1246   	USM_BSP_EEraseMemory(BSP_Conf);		//使用双字节寻址模式擦除一个到全部 Flash 页面（仅用于v3.0 usart 自举程序版本及以上版本）	
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USM_BSP_EEraseMemory
;;;1247   	USM_BSP_WriteMemory(BSP_Conf);		//从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       USM_BSP_WriteMemory
;;;1248   	USM_BSP_WriteAddr(BSP_Conf);			//写地址----包含地址自动增加及完成判断
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       USM_BSP_WriteAddr
;;;1249   //	USM_BSP_WriteData(BSP_Conf);			//写数据----向从机写入FLASH数据
;;;1250   	
;;;1251   	BSP_SendBuffer(BSP_Conf);					//通过串口发送数据，当检测到USARTSendLen不为0时自动发送
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       BSP_SendBuffer
;;;1252   }
000050  bd10              POP      {r4,pc}
;;;1253   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_RESET||, CODE, READONLY, ALIGN=1

                  USM_BSP_RESET PROC
;;;1260   *******************************************************************************/
;;;1261   void USM_BSP_RESET(BSP_Conf_TypeDef *BSP_Conf)		//复位从机
000000  b510              PUSH     {r4,lr}
;;;1262   {
000002  4604              MOV      r4,r0
;;;1263   	USM_BSP_ResetToBSP(BSP_Conf);			//复位从机设备--使从机进行ISP模式		
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_ResetToBSP
;;;1264   
;;;1265   	USM_BSP_ResetToRUN(BSP_Conf);			//启动从机接收BOOT0使从机正常运行
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USM_BSP_ResetToRUN
;;;1266   }
000010  bd10              POP      {r4,pc}
;;;1267   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_ReadMemory||, CODE, READONLY, ALIGN=1

                  USM_BSP_ReadMemory PROC
;;;1533   *******************************************************************************/
;;;1534   void USM_BSP_ReadMemory(BSP_Conf_TypeDef *BSP_Conf)		//从应用程序指定的地址开始读取最多 256 个字节的存储器空间
000000  4770              BX       lr
;;;1535   {
;;;1536   
;;;1537   }
;;;1538   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_ReadProtect||, CODE, READONLY, ALIGN=1

                  USM_BSP_ReadProtect PROC
;;;1794   *******************************************************************************/
;;;1795   void USM_BSP_ReadProtect(BSP_Conf_TypeDef *BSP_Conf)		//使能读保护
000000  4770              BX       lr
;;;1796   {
;;;1797   
;;;1798   }
;;;1799   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_ReadUnProtect||, CODE, READONLY, ALIGN=1

                  USM_BSP_ReadUnProtect PROC
;;;1804   *******************************************************************************/
;;;1805   void USM_BSP_ReadUnProtect(BSP_Conf_TypeDef *BSP_Conf)		//禁止读保护
000000  4770              BX       lr
;;;1806   {
;;;1807   
;;;1808   }
;;;1809   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_ResetToBSP||, CODE, READONLY, ALIGN=1

                  USM_BSP_ResetToBSP PROC
;;;1272   *******************************************************************************/
;;;1273   void USM_BSP_ResetToBSP(BSP_Conf_TypeDef *BSP_Conf)			//复位从机设备--使从机进行ISP模式
000000  b510              PUSH     {r4,lr}
;;;1274   {
000002  4604              MOV      r4,r0
;;;1275   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_ResetDevice)		//BSP主机准备连接----复位从机
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  285f              CMP      r0,#0x5f
00000c  d103              BNE      |L19.22|
;;;1276   	{
;;;1277   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62e0              STR      r0,[r4,#0x2c]
000014  e000              B        |L19.24|
                  |L19.22|
;;;1278   	}
;;;1279   	else
;;;1280   	{
;;;1281   		return;
;;;1282   	}
;;;1283   	if(BSP_Conf->BSP_DATA.TimeCount<=100)	//拉高约1ms
;;;1284   	{	
;;;1285   		GPIO_SetBits	(BSP_Conf->BSP_Port.BOOT0_CTL_PORT,BSP_Conf->BSP_Port.BOOT0_CTL_Pin);		//BOOT0脚拉高
;;;1286   		GPIO_SetBits	(BSP_Conf->BSP_Port.RESET_CTL_PORT,BSP_Conf->BSP_Port.RESET_CTL_Pin);		//RESET脚拉低				
;;;1287   	}
;;;1288   	else if(BSP_Conf->BSP_DATA.TimeCount>100&&BSP_Conf->BSP_DATA.TimeCount<=10000)	//拉高约50ms		//进入BSP模式			//进入BSP模式
;;;1289   	{
;;;1290   		GPIO_SetBits	(BSP_Conf->BSP_Port.BOOT0_CTL_PORT,BSP_Conf->BSP_Port.BOOT0_CTL_Pin);		//BOOT0脚拉高
;;;1291   		GPIO_ResetBits	(BSP_Conf->BSP_Port.RESET_CTL_PORT,BSP_Conf->BSP_Port.RESET_CTL_Pin);		//RESET脚拉高，进入BSP模式		
;;;1292   	}
;;;1293   	else
;;;1294   	{
;;;1295   		GPIO_SetBits	(BSP_Conf->BSP_Port.RESET_CTL_PORT,BSP_Conf->BSP_Port.RESET_CTL_Pin);		//RESET脚拉高，进入BSP模式
;;;1296   		USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteConnect);		//更新状态---BSP主机准备连接----复位后检测从机
;;;1297   		BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1298   	}
;;;1299   }
000016  bd10              POP      {r4,pc}
                  |L19.24|
000018  6ae0              LDR      r0,[r4,#0x2c]         ;1283
00001a  2864              CMP      r0,#0x64              ;1283
00001c  d808              BHI      |L19.48|
00001e  8a21              LDRH     r1,[r4,#0x10]         ;1285
000020  68e0              LDR      r0,[r4,#0xc]          ;1285
000022  f7fffffe          BL       GPIO_SetBits
000026  8921              LDRH     r1,[r4,#8]            ;1286
000028  6860              LDR      r0,[r4,#4]            ;1286
00002a  f7fffffe          BL       GPIO_SetBits
00002e  e01a              B        |L19.102|
                  |L19.48|
000030  6ae0              LDR      r0,[r4,#0x2c]         ;1288
000032  2864              CMP      r0,#0x64              ;1288
000034  d90d              BLS      |L19.82|
000036  f2427110          MOV      r1,#0x2710            ;1288
00003a  6ae0              LDR      r0,[r4,#0x2c]         ;1288
00003c  4288              CMP      r0,r1                 ;1288
00003e  d808              BHI      |L19.82|
000040  8a21              LDRH     r1,[r4,#0x10]         ;1290
000042  68e0              LDR      r0,[r4,#0xc]          ;1290
000044  f7fffffe          BL       GPIO_SetBits
000048  8921              LDRH     r1,[r4,#8]            ;1291
00004a  6860              LDR      r0,[r4,#4]            ;1291
00004c  f7fffffe          BL       GPIO_ResetBits
000050  e009              B        |L19.102|
                  |L19.82|
000052  8921              LDRH     r1,[r4,#8]            ;1295
000054  6860              LDR      r0,[r4,#4]            ;1295
000056  f7fffffe          BL       GPIO_SetBits
00005a  2160              MOVS     r1,#0x60              ;1296
00005c  4620              MOV      r0,r4                 ;1296
00005e  f7fffffe          BL       USM_BSP_SetStatus
000062  2100              MOVS     r1,#0                 ;1297
000064  62e1              STR      r1,[r4,#0x2c]         ;1297
                  |L19.102|
000066  bf00              NOP      
000068  e7d5              B        |L19.22|
;;;1300   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_ResetToRUN||, CODE, READONLY, ALIGN=1

                  USM_BSP_ResetToRUN PROC
;;;1305   *******************************************************************************/
;;;1306   void USM_BSP_ResetToRUN(BSP_Conf_TypeDef *BSP_Conf)			//启动从机接收BOOT0使从机进行下载状态
000000  b510              PUSH     {r4,lr}
;;;1307   {
000002  4604              MOV      r4,r0
;;;1308   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_StartDevice)
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2879              CMP      r0,#0x79
00000c  d103              BNE      |L20.22|
;;;1309   	{
;;;1310   		BSP_Conf->BSP_DATA.TimeCount++;
00000e  6ae0              LDR      r0,[r4,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62e0              STR      r0,[r4,#0x2c]
000014  e000              B        |L20.24|
                  |L20.22|
;;;1311   	}
;;;1312   	else
;;;1313   	{
;;;1314   		return;
;;;1315   	}
;;;1316   	if(BSP_Conf->BSP_DATA.TimeCount<=5000)	//拉底约50ms
;;;1317   	{
;;;1318   		GPIO_ResetBits(BSP_Conf->BSP_Port.BOOT0_CTL_PORT,BSP_Conf->BSP_Port.BOOT0_CTL_Pin);		//BOOT0脚拉低
;;;1319   		GPIO_ResetBits(BSP_Conf->BSP_Port.RESET_CTL_PORT,BSP_Conf->BSP_Port.RESET_CTL_Pin);		//RESET脚拉低
;;;1320   	}
;;;1321   	else if(BSP_Conf->BSP_DATA.TimeCount>5000&&BSP_Conf->BSP_DATA.TimeCount<10000)	//拉高约50ms		//进入BSP模式
;;;1322   	{
;;;1323   		GPIO_SetBits	(BSP_Conf->BSP_Port.RESET_CTL_PORT,BSP_Conf->BSP_Port.RESET_CTL_Pin);		//RESET脚拉高，进入BSP模式		
;;;1324   	}
;;;1325   	else
;;;1326   	{
;;;1327   		USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteConnect);		//更新状态---等待释放从机
;;;1328   		BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
;;;1329   	}
;;;1330   }
000016  bd10              POP      {r4,pc}
                  |L20.24|
000018  f2413188          MOV      r1,#0x1388            ;1316
00001c  6ae0              LDR      r0,[r4,#0x2c]         ;1316
00001e  4288              CMP      r0,r1                 ;1316
000020  d808              BHI      |L20.52|
000022  8a21              LDRH     r1,[r4,#0x10]         ;1318
000024  68e0              LDR      r0,[r4,#0xc]          ;1318
000026  f7fffffe          BL       GPIO_ResetBits
00002a  8921              LDRH     r1,[r4,#8]            ;1319
00002c  6860              LDR      r0,[r4,#4]            ;1319
00002e  f7fffffe          BL       GPIO_ResetBits
000032  e013              B        |L20.92|
                  |L20.52|
000034  f2413188          MOV      r1,#0x1388            ;1321
000038  6ae0              LDR      r0,[r4,#0x2c]         ;1321
00003a  4288              CMP      r0,r1                 ;1321
00003c  d908              BLS      |L20.80|
00003e  0049              LSLS     r1,r1,#1              ;1321
000040  6ae0              LDR      r0,[r4,#0x2c]         ;1321
000042  4288              CMP      r0,r1                 ;1321
000044  d204              BCS      |L20.80|
000046  8921              LDRH     r1,[r4,#8]            ;1323
000048  6860              LDR      r0,[r4,#4]            ;1323
00004a  f7fffffe          BL       GPIO_SetBits
00004e  e005              B        |L20.92|
                  |L20.80|
000050  2160              MOVS     r1,#0x60              ;1327
000052  4620              MOV      r0,r4                 ;1327
000054  f7fffffe          BL       USM_BSP_SetStatus
000058  2100              MOVS     r1,#0                 ;1328
00005a  62e1              STR      r1,[r4,#0x2c]         ;1328
                  |L20.92|
00005c  bf00              NOP      
00005e  e7da              B        |L20.22|
;;;1331   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_SendBuffer||, CODE, READONLY, ALIGN=1

                  USM_BSP_SendBuffer PROC
;;;1842   *******************************************************************************/
;;;1843   void USM_BSP_SendBuffer(BSP_Conf_TypeDef *BSP_Conf)						//发送函数包括从机发送应答、发送地址、发送命令、发送数据
000000  b510              PUSH     {r4,lr}
;;;1844   {
000002  4604              MOV      r4,r0
;;;1845   	if(BSP_Conf->BSP_DATA.USARTSendLen)
000004  6ea0              LDR      r0,[r4,#0x68]
000006  b1b8              CBZ      r0,|L21.56|
;;;1846   	{
;;;1847   		memcpy(BSP_Conf->BSP_DATA.BSP_TxBuffer, BSP_Conf->BSP_DATA.BSP_TvBuffer,BSP_Conf->BSP_DATA.USARTSendLen);				//复制数据
000008  f20431fa          ADD      r1,r4,#0x3fa
00000c  f20420ce          ADD      r0,r4,#0x2ce
000010  6ea2              LDR      r2,[r4,#0x68]
000012  f7fffffe          BL       __aeabi_memcpy
;;;1848   		memset(BSP_Conf->BSP_DATA.BSP_TvBuffer,0xFF, BSP_BufferSize);				//接收缓冲区
000016  22ff              MOVS     r2,#0xff
000018  f44f7196          MOV      r1,#0x12c
00001c  f20430fa          ADD      r0,r4,#0x3fa
000020  f7fffffe          BL       __aeabi_memset
;;;1849   		USART_DMASend(BSP_Conf->BSP_Port.USARTx,(u8*)BSP_Conf->BSP_DATA.BSP_TxBuffer,BSP_Conf->BSP_DATA.USARTSendLen);	//串口DMA发送程序
000024  f8b41068          LDRH     r1,[r4,#0x68]
000028  b28a              UXTH     r2,r1
00002a  f20421ce          ADD      r1,r4,#0x2ce
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       USART_DMASend
;;;1850   		BSP_Conf->BSP_DATA.USARTSendLen=0;
000034  2100              MOVS     r1,#0
000036  66a1              STR      r1,[r4,#0x68]
                  |L21.56|
;;;1851   	}
;;;1852   }
000038  bd10              POP      {r4,pc}
;;;1853   
                          ENDP


                          AREA ||i.USM_BSP_SendCommand||, CODE, READONLY, ALIGN=1

                  USM_BSP_SendCommand PROC
;;;1830   *******************************************************************************/
;;;1831   void USM_BSP_SendCommand(BSP_Conf_TypeDef *BSP_Conf,BSP_COMMAND_TypeDef Command)	//串口编程发送命令程序
000000  b570              PUSH     {r4-r6,lr}
;;;1832   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1833   	BSP_Conf->BSP_DATA.Command[0]=Command;
000006  f8845074          STRB     r5,[r4,#0x74]
;;;1834   	BSP_Conf->BSP_DATA.Command[1]=Command^0XFF;
00000a  f08501ff          EOR      r1,r5,#0xff
00000e  f8841075          STRB     r1,[r4,#0x75]
;;;1835   	USART_DMASend(BSP_Conf->BSP_Port.USARTx,(u8*)BSP_Conf->BSP_DATA.Command,2);	//串口DMA发送程序
000012  2202              MOVS     r2,#2
000014  f1040174          ADD      r1,r4,#0x74
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       USART_DMASend
;;;1836   }
00001e  bd70              POP      {r4-r6,pc}
;;;1837   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_SetStatus||, CODE, READONLY, ALIGN=1

                  USM_BSP_SetStatus PROC
;;;1336   *******************************************************************************/
;;;1337   void USM_BSP_SetStatus(BSP_Conf_TypeDef *BSP_Conf,BSPM_STATUS_TypeDef BSPM_STATUS)		//更新/设置主机状态
000000  7501              STRB     r1,[r0,#0x14]
;;;1338   {
;;;1339   	BSP_Conf->BSPM_Info.BSP_MASTER_STATUS	=	BSPM_STATUS;				//新状态值
;;;1340   }
000002  4770              BX       lr
;;;1341   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_WriteAddr||, CODE, READONLY, ALIGN=1

                  USM_BSP_WriteAddr PROC
;;;1594   *******************************************************************************/
;;;1595   void USM_BSP_WriteAddr(BSP_Conf_TypeDef *BSP_Conf)		//写地址----包含地址自动增加及完成判断
000000  b510              PUSH     {r4,lr}
;;;1596   {
000002  4604              MOV      r4,r0
;;;1597   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteAddr&&BSP_Conf->BSP_DATA.USARTSendLen==0)	//BSP主机发送要写入数据的起始地址并且串口无数据等待发送---需要应答
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2867              CMP      r0,#0x67
00000c  d105              BNE      |L24.26|
00000e  6ea0              LDR      r0,[r4,#0x68]
000010  b918              CBNZ     r0,|L24.26|
;;;1598   	{
;;;1599   		BSP_Conf->BSP_DATA.TimeCount++;												//计时周期10uS	
000012  6ae0              LDR      r0,[r4,#0x2c]
000014  1c40              ADDS     r0,r0,#1
000016  62e0              STR      r0,[r4,#0x2c]
000018  e000              B        |L24.28|
                  |L24.26|
;;;1600   	}
;;;1601   	else		//跳过
;;;1602   	{
;;;1603   		return;
;;;1604   	}
;;;1605   	if(BSP_Conf->BSP_DATA.TimeCount==5)		//发送数据
;;;1606   	{	
;;;1607   		BSP_Conf->BSP_DATA.BSP_TvBuffer[0]=BSP_Conf->BSP_DATA.WriteAddr>>24;
;;;1608   		BSP_Conf->BSP_DATA.BSP_TvBuffer[1]=BSP_Conf->BSP_DATA.WriteAddr>>16;
;;;1609   		BSP_Conf->BSP_DATA.BSP_TvBuffer[2]=BSP_Conf->BSP_DATA.WriteAddr>>8;
;;;1610   		BSP_Conf->BSP_DATA.BSP_TvBuffer[3]=BSP_Conf->BSP_DATA.WriteAddr>>0;
;;;1611   		BSP_Conf->BSP_DATA.BSP_TvBuffer[4]=BCC8(BSP_Conf->BSP_DATA.BSP_TvBuffer,4);		//异或校验;
;;;1612   		BSP_Conf->BSP_DATA.USARTSendLen=5;
;;;1613   	}
;;;1614   	else if(BSP_Conf->BSP_DATA.TimeCount>200)		//2ms未检测到应答重试一次
;;;1615   	{
;;;1616   		BSP_Conf->BSP_DATA.RetryTimes++;			//重试次数不超过10次，否则判定为失败
;;;1617   		if(BSP_Conf->BSP_DATA.RetryTimes>10)	//重试次数不超过10次，否则判定为失败
;;;1618   		{
;;;1619   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---等待释放从机
;;;1620   		}	
;;;1621   		BSP_Conf->BSP_DATA.TimeCount=0;				//清除计数--重新开时进入擦除操作
;;;1622   	}
;;;1623   	else if(BSP_Conf->BSP_DATA.TimeCount>5)		//等待应答
;;;1624   	{
;;;1625   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)		//检测到应答
;;;1626   		{	
;;;1627   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteData);		//更新状态---BSP主机写数据，最多 256 个字节
;;;1628   			BSP_Conf->BSP_DATA.TimeCount=0;			//清除计数
;;;1629   			BSP_Conf->BSP_DATA.RetryTimes=0;		//重试计数清零
;;;1630   			BSP_Conf->BSPM_Info.ACK=BSP_NACK;		//清除应答标志
;;;1631   			BSP_Conf->BSP_DATA.WriteAddr+=BSP_Conf->BSP_DATA.StepLen;		//根据每次写入的字节长度增加地址，备下一个地址写入
;;;1632   			return;		//退出
;;;1633   		}
;;;1634   		else		//跳过
;;;1635   		{
;;;1636   			return;
;;;1637   		}
;;;1638   	}
;;;1639   	else		//跳过
;;;1640   	{
;;;1641   		return;
;;;1642   	}
;;;1643   }
00001a  bd10              POP      {r4,pc}
                  |L24.28|
00001c  6ae0              LDR      r0,[r4,#0x2c]         ;1605
00001e  2805              CMP      r0,#5                 ;1605
000020  d11a              BNE      |L24.88|
000022  6de0              LDR      r0,[r4,#0x5c]         ;1607
000024  0e01              LSRS     r1,r0,#24             ;1607
000026  f88413fa          STRB     r1,[r4,#0x3fa]        ;1607
00002a  6de0              LDR      r0,[r4,#0x5c]         ;1608
00002c  0c01              LSRS     r1,r0,#16             ;1608
00002e  f88413fb          STRB     r1,[r4,#0x3fb]        ;1608
000032  205c              MOVS     r0,#0x5c              ;1609
000034  5b00              LDRH     r0,[r0,r4]            ;1609
000036  0a01              LSRS     r1,r0,#8              ;1609
000038  f88413fc          STRB     r1,[r4,#0x3fc]        ;1609
00003c  f894105c          LDRB     r1,[r4,#0x5c]         ;1610
000040  f88413fd          STRB     r1,[r4,#0x3fd]        ;1610
000044  2104              MOVS     r1,#4                 ;1611
000046  f20430fa          ADD      r0,r4,#0x3fa          ;1611
00004a  f7fffffe          BL       BCC8
00004e  f88403fe          STRB     r0,[r4,#0x3fe]        ;1611
000052  2105              MOVS     r1,#5                 ;1612
000054  66a1              STR      r1,[r4,#0x68]         ;1612
000056  e027              B        |L24.168|
                  |L24.88|
000058  6ae0              LDR      r0,[r4,#0x2c]         ;1614
00005a  28c8              CMP      r0,#0xc8              ;1614
00005c  d90c              BLS      |L24.120|
00005e  6b20              LDR      r0,[r4,#0x30]         ;1616
000060  1c40              ADDS     r0,r0,#1              ;1616
000062  6320              STR      r0,[r4,#0x30]         ;1616
000064  6b20              LDR      r0,[r4,#0x30]         ;1617
000066  280a              CMP      r0,#0xa               ;1617
000068  d903              BLS      |L24.114|
00006a  217a              MOVS     r1,#0x7a              ;1619
00006c  4620              MOV      r0,r4                 ;1619
00006e  f7fffffe          BL       USM_BSP_SetStatus
                  |L24.114|
000072  2100              MOVS     r1,#0                 ;1621
000074  62e1              STR      r1,[r4,#0x2c]         ;1621
000076  e017              B        |L24.168|
                  |L24.120|
000078  6ae0              LDR      r0,[r4,#0x2c]         ;1623
00007a  2805              CMP      r0,#5                 ;1623
00007c  d913              BLS      |L24.166|
00007e  2023              MOVS     r0,#0x23              ;1625
000080  5d00              LDRB     r0,[r0,r4]            ;1625
000082  2879              CMP      r0,#0x79              ;1625
000084  d10e              BNE      |L24.164|
000086  2168              MOVS     r1,#0x68              ;1627
000088  4620              MOV      r0,r4                 ;1627
00008a  f7fffffe          BL       USM_BSP_SetStatus
00008e  2100              MOVS     r1,#0                 ;1628
000090  62e1              STR      r1,[r4,#0x2c]         ;1628
000092  6321              STR      r1,[r4,#0x30]         ;1629
000094  211f              MOVS     r1,#0x1f              ;1630
000096  2023              MOVS     r0,#0x23              ;1630
000098  5501              STRB     r1,[r0,r4]            ;1630
00009a  6de1              LDR      r1,[r4,#0x5c]         ;1631
00009c  6c20              LDR      r0,[r4,#0x40]         ;1631
00009e  4401              ADD      r1,r1,r0              ;1631
0000a0  65e1              STR      r1,[r4,#0x5c]         ;1631
0000a2  e7ba              B        |L24.26|
                  |L24.164|
0000a4  e7b9              B        |L24.26|
                  |L24.166|
0000a6  e7b8              B        |L24.26|
                  |L24.168|
0000a8  bf00              NOP      
0000aa  e7b6              B        |L24.26|
;;;1644   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_WriteData||, CODE, READONLY, ALIGN=1

                  USM_BSP_WriteData PROC
;;;1649   *******************************************************************************/
;;;1650   void USM_BSP_WriteData(BSP_Conf_TypeDef *BSP_Conf)		//写数据----向从机写入FLASH数据
000000  b510              PUSH     {r4,lr}
;;;1651   {
000002  4604              MOV      r4,r0
;;;1652   	if(
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2868              CMP      r0,#0x68
00000c  d107              BNE      |L25.30|
;;;1653   		USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteData&&	//BSP主机发送数据，---需要应答
;;;1654   		BSP_Conf->BSP_DATA.USARTSendLen==0&&		//串口无待发送数据
00000e  6ea0              LDR      r0,[r4,#0x68]
000010  b928              CBNZ     r0,|L25.30|
;;;1655   		BSP_Conf->BSP_DATA.WriteLen							//FLASH已经准备好数据，可以通过串口发往从机
000012  6e20              LDR      r0,[r4,#0x60]
000014  b118              CBZ      r0,|L25.30|
;;;1656   	)	//BSP主机发送数据，---需要应答
;;;1657   	{
;;;1658   		BSP_Conf->BSP_DATA.TimeCount++;												//计时周期10uS	
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  62e0              STR      r0,[r4,#0x2c]
00001c  e00a              B        |L25.52|
                  |L25.30|
;;;1659   	}
;;;1660   	else if(BSP_Conf->BSP_DATA.TimeCount>5000)			//50ms超时
00001e  f2413188          MOV      r1,#0x1388
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  4288              CMP      r0,r1
000026  d904              BLS      |L25.50|
;;;1661   	{
;;;1662   		USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---错误
000028  217a              MOVS     r1,#0x7a
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       USM_BSP_SetStatus
000030  e000              B        |L25.52|
                  |L25.50|
;;;1663   	}
;;;1664   	else	//跳过
;;;1665   	{
;;;1666   		return;
;;;1667   	}
;;;1668   	if(BSP_Conf->BSP_DATA.TimeCount==1)
;;;1669   	{
;;;1670   		BSP_Conf->BSP_DATA.USARTSendLen=BSP_Conf->BSP_DATA.WriteLen;				//待写入的数据长度
;;;1671   		BSP_Conf->BSP_DATA.SumHaveWritten+=BSP_Conf->BSP_DATA.USARTSendLen;	//主机总共往从机写入的数据个数---计数
;;;1672   		memcpy(BSP_Conf->BSP_DATA.BSP_TxBuffer, BSP_Conf->BSP_DATA.BSP_FlashBuffer,BSP_Conf->BSP_DATA.USARTSendLen);	//复制数据---将读取的FLASH数据复制到串口发送缓冲区
;;;1673   	}
;;;1674   	else	//检测应答
;;;1675   	{
;;;1676   		if(BSP_Conf->BSPM_Info.ACK==BSP_ACK)	//检测到应答
;;;1677   		{
;;;1678   			if(BSP_Conf->BSP_DATA.SumHaveWritten<BSP_Conf->BSP_DATA.FirmwareLen)	//还有待写入数据
;;;1679   			{
;;;1680   				USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteAddr);		//更新状态---BSP主机发送要写入数据的起始地址---需要应答
;;;1681   				BSP_Conf->BSP_DATA.TimeCount=0;			//清除计数
;;;1682   				BSP_Conf->BSPM_Info.ACK=BSP_NACK;		//清除应答标志
;;;1683   				BSP_Conf->BSP_DATA.WriteLen=0;			//待写入的数据长度---清零，以备FLAHS准备下一组数据
;;;1684   			}
;;;1685   			else	//全部数据写入完成---后续为重启从机，从GoAddr开始运行从机
;;;1686   			{
;;;1687   				USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteGo);		//更新状态---BSP主机发送Go命令---执行完Go全部命令后重启从机运行
;;;1688   				BSP_Conf->BSP_DATA.TimeCount=0;			//清除计数
;;;1689   				BSP_Conf->BSPM_Info.ACK=BSP_NACK;		//清除应答标志
;;;1690   				BSP_Conf->BSP_DATA.WriteLen=0;			//待写入的数据长度---清零，以备FLAHS准备下一组数据
;;;1691   			}			
;;;1692   		}
;;;1693   		else
;;;1694   		{
;;;1695   			return;
;;;1696   		}
;;;1697   	}
;;;1698   }
000032  bd10              POP      {r4,pc}
                  |L25.52|
000034  6ae0              LDR      r0,[r4,#0x2c]         ;1668
000036  2801              CMP      r0,#1                 ;1668
000038  d10d              BNE      |L25.86|
00003a  6e21              LDR      r1,[r4,#0x60]         ;1670
00003c  66a1              STR      r1,[r4,#0x68]         ;1670
00003e  6f21              LDR      r1,[r4,#0x70]         ;1671
000040  6ea0              LDR      r0,[r4,#0x68]         ;1671
000042  4401              ADD      r1,r1,r0              ;1671
000044  6721              STR      r1,[r4,#0x70]         ;1671
000046  f2045126          ADD      r1,r4,#0x526          ;1672
00004a  f20420ce          ADD      r0,r4,#0x2ce          ;1672
00004e  6ea2              LDR      r2,[r4,#0x68]         ;1672
000050  f7fffffe          BL       __aeabi_memcpy
000054  e020              B        |L25.152|
                  |L25.86|
000056  2023              MOVS     r0,#0x23              ;1676
000058  5d00              LDRB     r0,[r0,r4]            ;1676
00005a  2879              CMP      r0,#0x79              ;1676
00005c  d11b              BNE      |L25.150|
00005e  6f21              LDR      r1,[r4,#0x70]         ;1678
000060  6ca0              LDR      r0,[r4,#0x48]         ;1678
000062  4281              CMP      r1,r0                 ;1678
000064  d20b              BCS      |L25.126|
000066  2167              MOVS     r1,#0x67              ;1680
000068  4620              MOV      r0,r4                 ;1680
00006a  f7fffffe          BL       USM_BSP_SetStatus
00006e  2100              MOVS     r1,#0                 ;1681
000070  62e1              STR      r1,[r4,#0x2c]         ;1681
000072  211f              MOVS     r1,#0x1f              ;1682
000074  2023              MOVS     r0,#0x23              ;1682
000076  5501              STRB     r1,[r0,r4]            ;1682
000078  2100              MOVS     r1,#0                 ;1683
00007a  6621              STR      r1,[r4,#0x60]         ;1683
00007c  e00c              B        |L25.152|
                  |L25.126|
00007e  2169              MOVS     r1,#0x69              ;1687
000080  4620              MOV      r0,r4                 ;1687
000082  f7fffffe          BL       USM_BSP_SetStatus
000086  2100              MOVS     r1,#0                 ;1688
000088  62e1              STR      r1,[r4,#0x2c]         ;1688
00008a  211f              MOVS     r1,#0x1f              ;1689
00008c  2023              MOVS     r0,#0x23              ;1689
00008e  5501              STRB     r1,[r0,r4]            ;1689
000090  2100              MOVS     r1,#0                 ;1690
000092  6621              STR      r1,[r4,#0x60]         ;1690
000094  e000              B        |L25.152|
                  |L25.150|
000096  e7cc              B        |L25.50|
                  |L25.152|
000098  bf00              NOP      
00009a  e7ca              B        |L25.50|
;;;1699   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_WriteMemory||, CODE, READONLY, ALIGN=1

                  USM_BSP_WriteMemory PROC
;;;1555   *******************************************************************************/
;;;1556   void USM_BSP_WriteMemory(BSP_Conf_TypeDef *BSP_Conf)		//从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash
000000  b500              PUSH     {lr}
;;;1557   {
000002  4602              MOV      r2,r0
;;;1558   	if(USM_BSP_GetStatus(BSP_Conf)==BSP_MSTATUS_WriteWM)	//BSP主机发送写命令，Write Memory:从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash---需要应答
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       USM_BSP_GetStatus
00000a  2866              CMP      r0,#0x66
00000c  d11a              BNE      |L26.68|
;;;1559   	{
;;;1560   		BSP_Conf->BSP_DATA.TimeCount++;						//计时周期10uS
00000e  6ad0              LDR      r0,[r2,#0x2c]
000010  1c40              ADDS     r0,r0,#1
000012  62d0              STR      r0,[r2,#0x2c]
;;;1561   		if(BSP_Conf->BSP_DATA.TimeCount<=5000)		//超时时间50mS
000014  f2413188          MOV      r1,#0x1388
000018  6ad0              LDR      r0,[r2,#0x2c]
00001a  4288              CMP      r0,r1
00001c  d80d              BHI      |L26.58|
;;;1562   		{
;;;1563   			if(BSP_Conf->BSP_DATA.StartAddr!=0)			//接收到起始地址--设定写地址状态
00001e  6bd0              LDR      r0,[r2,#0x3c]
000020  b150              CBZ      r0,|L26.56|
;;;1564   			{
;;;1565   				BSP_Conf->BSP_DATA.TimeCount=0;		//清除计数
000022  2100              MOVS     r1,#0
000024  62d1              STR      r1,[r2,#0x2c]
;;;1566   				BSP_Conf->BSP_DATA.WriteAddr=BSP_Conf->BSP_DATA.StartAddr;		//WriteAddr	//要写入Flash的数据起始地址--ISP接口
000026  6bd1              LDR      r1,[r2,#0x3c]
000028  65d1              STR      r1,[r2,#0x5c]
;;;1567   				BSP_Conf->BSP_DATA.SumHaveWritten=0;	//主机总共往从机写入的数据个数---清零
00002a  2100              MOVS     r1,#0
00002c  6711              STR      r1,[r2,#0x70]
;;;1568   				USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_WriteAddr);		//更新状态---BSP主机发送要写入数据的起始地址---需要应答
00002e  2167              MOVS     r1,#0x67
000030  4610              MOV      r0,r2
000032  f7fffffe          BL       USM_BSP_SetStatus
000036  e006              B        |L26.70|
                  |L26.56|
;;;1569   			}
;;;1570   			else
;;;1571   			{
;;;1572   				return;			//未检测到起始地址，退出，继续等待
;;;1573   			}
;;;1574   		}
;;;1575   		else		//超时---状态更新为错误状态
;;;1576   		{
;;;1577   			USM_BSP_SetStatus(BSP_Conf,BSP_MSTATUS_ERROR);		//更新状态---错误
;;;1578   			return;
;;;1579   		}
;;;1580   	}
;;;1581   	else
;;;1582   	{
;;;1583   		return;
;;;1584   	}
;;;1585   }
000038  bd00              POP      {pc}
                  |L26.58|
00003a  217a              MOVS     r1,#0x7a              ;1577
00003c  4610              MOV      r0,r2                 ;1577
00003e  f7fffffe          BL       USM_BSP_SetStatus
000042  e7f9              B        |L26.56|
                  |L26.68|
000044  e7f8              B        |L26.56|
                  |L26.70|
000046  bf00              NOP      
000048  e7f6              B        |L26.56|
;;;1586   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_WriteProtect||, CODE, READONLY, ALIGN=1

                  USM_BSP_WriteProtect PROC
;;;1774   *******************************************************************************/
;;;1775   void USM_BSP_WriteProtect(BSP_Conf_TypeDef *BSP_Conf)		//使能某些扇区的写保护
000000  4770              BX       lr
;;;1776   {
;;;1777   
;;;1778   }
;;;1779   /*******************************************************************************
                          ENDP


                          AREA ||i.USM_BSP_WriteUnProtect||, CODE, READONLY, ALIGN=1

                  USM_BSP_WriteUnProtect PROC
;;;1784   *******************************************************************************/
;;;1785   void USM_BSP_WriteUnProtect(BSP_Conf_TypeDef *BSP_Conf)		//禁止所有 Flash 扇区的写保护
000000  4770              BX       lr
;;;1786   {
;;;1787   
;;;1788   }
;;;1789   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_ACK||, CODE, READONLY, ALIGN=1

                  USS_BSP_ACK PROC
;;;2015   *******************************************************************************/
;;;2016   void USS_BSP_ACK(BSP_Conf_TypeDef *BSP_Conf)		//向主机发送应答(0x79)
000000  4770              BX       lr
;;;2017   {
;;;2018   
;;;2019   }
;;;2020   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_EEraseMemory||, CODE, READONLY, ALIGN=1

                  USS_BSP_EEraseMemory PROC
;;;1965   *******************************************************************************/
;;;1966   void USS_BSP_EEraseMemory(BSP_Conf_TypeDef *BSP_Conf)		//使用双字节寻址模式擦除一个到全部 Flash 页面（仅用于v3.0 usart 自举程序版本及以上版本）
000000  4770              BX       lr
;;;1967   {
;;;1968   
;;;1969   }
;;;1970   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_EraseMemory||, CODE, READONLY, ALIGN=1

                  USS_BSP_EraseMemory PROC
;;;1955   *******************************************************************************/
;;;1956   void USS_BSP_EraseMemory(BSP_Conf_TypeDef *BSP_Conf)		//擦除一个到全部 Flash 页面
000000  4770              BX       lr
;;;1957   {
;;;1958   
;;;1959   }
;;;1960   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_Get||, CODE, READONLY, ALIGN=1

                  USS_BSP_Get PROC
;;;1895   *******************************************************************************/
;;;1896   void USS_BSP_Get(BSP_Conf_TypeDef *BSP_Conf)		//获取当前自举程序版本及允许使用的命令
000000  4770              BX       lr
;;;1897   {
;;;1898   
;;;1899   }
;;;1900   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_GetId||, CODE, READONLY, ALIGN=1

                  USS_BSP_GetId PROC
;;;1915   *******************************************************************************/
;;;1916   void USS_BSP_GetId(BSP_Conf_TypeDef *BSP_Conf)			//获取芯片 ID
000000  4770              BX       lr
;;;1917   {
;;;1918   
;;;1919   }
;;;1920   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_GetVR||, CODE, READONLY, ALIGN=1

                  USS_BSP_GetVR PROC
;;;1905   *******************************************************************************/
;;;1906   void USS_BSP_GetVR(BSP_Conf_TypeDef *BSP_Conf)		//获取自举程序版本及 Flash 的读保护状态
000000  4770              BX       lr
;;;1907   {
;;;1908   
;;;1909   }
;;;1910   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_Go||, CODE, READONLY, ALIGN=1

                  USS_BSP_Go PROC
;;;1935   *******************************************************************************/
;;;1936   void USS_BSP_Go(BSP_Conf_TypeDef *BSP_Conf)		//跳转到内部 Flash 或 SRAM 内的应用程序代码
000000  4770              BX       lr
;;;1937   {
;;;1938   
;;;1939   }
;;;1940   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_NACK||, CODE, READONLY, ALIGN=1

                  USS_BSP_NACK PROC
;;;2025   *******************************************************************************/
;;;2026   void USS_BSP_NACK(BSP_Conf_TypeDef *BSP_Conf)		//向主机发送非应答(0x1F)
000000  4770              BX       lr
;;;2027   {
;;;2028   
;;;2029   }
;;;2030   
                          ENDP


                          AREA ||i.USS_BSP_PROCESS||, CODE, READONLY, ALIGN=1

                  USS_BSP_PROCESS PROC
;;;1875   *******************************************************************************/
;;;1876   void USS_BSP_PROCESS(BSP_Conf_TypeDef *BSP_Conf)
000000  4770              BX       lr
;;;1877   {
;;;1878   
;;;1879   }
;;;1880   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_RESET||, CODE, READONLY, ALIGN=1

                  USS_BSP_RESET PROC
;;;1885   *******************************************************************************/
;;;1886   void USS_BSP_RESET(BSP_Conf_TypeDef *BSP_Conf)
000000  4770              BX       lr
;;;1887   {
;;;1888   
;;;1889   }
;;;1890   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_ReadMemory||, CODE, READONLY, ALIGN=1

                  USS_BSP_ReadMemory PROC
;;;1925   *******************************************************************************/
;;;1926   void USS_BSP_ReadMemory(BSP_Conf_TypeDef *BSP_Conf)		//从应用程序指定的地址开始读取最多 256 个字节的存储器空间
000000  4770              BX       lr
;;;1927   {
;;;1928   
;;;1929   }
;;;1930   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_ReadProtect||, CODE, READONLY, ALIGN=1

                  USS_BSP_ReadProtect PROC
;;;1995   *******************************************************************************/
;;;1996   void USS_BSP_ReadProtect(BSP_Conf_TypeDef *BSP_Conf)		//使能读保护
000000  4770              BX       lr
;;;1997   {
;;;1998   
;;;1999   }
;;;2000   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_ReadUnProtect||, CODE, READONLY, ALIGN=1

                  USS_BSP_ReadUnProtect PROC
;;;2005   *******************************************************************************/
;;;2006   void USS_BSP_ReadUnProtect(BSP_Conf_TypeDef *BSP_Conf)		//禁止读保护
000000  4770              BX       lr
;;;2007   {
;;;2008   
;;;2009   }
;;;2010   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_WriteMemory||, CODE, READONLY, ALIGN=1

                  USS_BSP_WriteMemory PROC
;;;1945   *******************************************************************************/
;;;1946   void USS_BSP_WriteMemory(BSP_Conf_TypeDef *BSP_Conf)		//从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash
000000  4770              BX       lr
;;;1947   {
;;;1948   
;;;1949   }
;;;1950   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_WriteProtect||, CODE, READONLY, ALIGN=1

                  USS_BSP_WriteProtect PROC
;;;1975   *******************************************************************************/
;;;1976   void USS_BSP_WriteProtect(BSP_Conf_TypeDef *BSP_Conf)		//使能某些扇区的写保护
000000  4770              BX       lr
;;;1977   {
;;;1978   
;;;1979   }
;;;1980   /*******************************************************************************
                          ENDP


                          AREA ||i.USS_BSP_WriteUnProtect||, CODE, READONLY, ALIGN=1

                  USS_BSP_WriteUnProtect PROC
;;;1985   *******************************************************************************/
;;;1986   void USS_BSP_WriteUnProtect(BSP_Conf_TypeDef *BSP_Conf)		//禁止所有 Flash 扇区的写保护
000000  4770              BX       lr
;;;1987   {
;;;1988   
;;;1989   }
;;;1990   /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_ACK||, CODE, READONLY, ALIGN=1

                  Usart_ISP_ACK PROC
;;;249    *******************************************************************************/
;;;250    void Usart_ISP_ACK(ISP_Conf_TypeDef *ISP_Conf)	//ISP应答
000000  b510              PUSH     {r4,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252    	ISP_Conf->ISP_DATA.Command[0]=ISP_ANSWER_ACK;
000004  2179              MOVS     r1,#0x79
000006  f884105c          STRB     r1,[r4,#0x5c]
;;;253    	USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.Command,1);	//串口DMA发送程序
00000a  2201              MOVS     r2,#1
00000c  f104015c          ADD      r1,r4,#0x5c
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_DMASend
;;;254    }
000016  bd10              POP      {r4,pc}
;;;255    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_CheckFun||, CODE, READONLY, ALIGN=1

                  Usart_ISP_CheckFun PROC
;;;184    *******************************************************************************/
;;;185    void Usart_ISP_CheckFun(ISP_Conf_TypeDef *ISP_Conf)				//检测ISP模块工作模式---空闲时检测
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
000002  4604              MOV      r4,r0
;;;187    	u32 delaytime=0x00;
000004  2500              MOVS     r5,#0
;;;188    //	GPIO_Configuration_OPP50	(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
;;;189    //	GPIO_Configuration_OPP50	(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
;;;190    //	GPIO_Configuration_INA		(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
;;;191    //	GPIO_Configuration_INA		(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
;;;192    //	GPIO_ReadInputDataBit(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);
;;;193    //	GPIO_ReadInputDataBit(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);
;;;194    //	GPIO_Configuration_IPD(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为下拉输入模式----V20170605
;;;195    //	GPIO_Configuration_IPD(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//将GPIO相应管脚配置为下拉输入模式----V20170605
;;;196    //	GPIO_Configuration_IPU(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
;;;197    //	GPIO_Configuration_IPU(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
;;;198    	//判断主机还是从机
;;;199    	//---------------------判断是否为从机：编程器将RESET脚拉低，将BOOT0脚拉高
;;;200    //	GPIO_Configuration_IPU(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
;;;201    	
;;;202    	
;;;203    	if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitReset)	//作为从机时程序下载完后从机需要重置
000006  7ca0              LDRB     r0,[r4,#0x12]
000008  2813              CMP      r0,#0x13
00000a  d10e              BNE      |L46.42|
;;;204    	{
;;;205    		GPIO_Configuration_IPD(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);				//将GPIO相应管脚配置为下拉输入模式----V20170605
00000c  8a21              LDRH     r1,[r4,#0x10]
00000e  68e0              LDR      r0,[r4,#0xc]
000010  f7fffffe          BL       GPIO_Configuration_IPD
;;;206    		while((GPIO_ReadInputDataBit(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin)==Bit_SET));
000014  bf00              NOP      
                  |L46.22|
000016  8a21              LDRH     r1,[r4,#0x10]
000018  68e0              LDR      r0,[r4,#0xc]
00001a  f7fffffe          BL       GPIO_ReadInputDataBit
00001e  2801              CMP      r0,#1
000020  d0f9              BEQ      |L46.22|
;;;207    		Usart_ISP_Reset(ISP_Conf);						//重置编程器---恢复所有参数为默认值
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       Usart_ISP_Reset
000028  e042              B        |L46.176|
                  |L46.42|
;;;208    	}
;;;209    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WaitDeliver)	//作为主机时烧录完成后等待从机离开
00002a  7d20              LDRB     r0,[r4,#0x14]
00002c  2839              CMP      r0,#0x39
00002e  d11a              BNE      |L46.102|
;;;210    	{
;;;211    		GPIO_Configuration_IPD(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为下拉输入模式----V20170605
000030  8921              LDRH     r1,[r4,#8]
000032  6860              LDR      r0,[r4,#4]
000034  f7fffffe          BL       GPIO_Configuration_IPD
;;;212    		if(GPIO_ReadInputDataBit(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin)==Bit_SET)
000038  8921              LDRH     r1,[r4,#8]
00003a  6860              LDR      r0,[r4,#4]
00003c  f7fffffe          BL       GPIO_ReadInputDataBit
000040  2801              CMP      r0,#1
000042  d103              BNE      |L46.76|
;;;213    		{
;;;214    //			Usart_ISP_Reset(ISP_Conf);						//重置编程器---恢复所有参数为默认值
;;;215    			ISP_Conf->TimeCount=0;
000044  2000              MOVS     r0,#0
000046  f8c40a04          STR      r0,[r4,#0xa04]
00004a  e031              B        |L46.176|
                  |L46.76|
;;;216    		}
;;;217    		else
;;;218    		{
;;;219    			if(ISP_Conf->TimeCount++>20000)
00004c  f8d41a04          LDR      r1,[r4,#0xa04]
000050  1c48              ADDS     r0,r1,#1
000052  f8c40a04          STR      r0,[r4,#0xa04]
000056  f6446020          MOV      r0,#0x4e20
00005a  4281              CMP      r1,r0
00005c  d928              BLS      |L46.176|
;;;220    				Usart_ISP_Reset(ISP_Conf);						//重置编程器---恢复所有参数为默认值
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       Usart_ISP_Reset
000064  e024              B        |L46.176|
                  |L46.102|
;;;221    		}
;;;222    	}
;;;223    	else
;;;224    	{	
;;;225    		GPIO_Configuration_IPD(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);				//将GPIO相应管脚配置为下拉输入模式----V20170605		
000066  8a21              LDRH     r1,[r4,#0x10]
000068  68e0              LDR      r0,[r4,#0xc]
00006a  f7fffffe          BL       GPIO_Configuration_IPD
;;;226    		while(delaytime++<0xFFFF)
00006e  e009              B        |L46.132|
                  |L46.112|
;;;227    		{
;;;228    			if((GPIO_ReadInputDataBit(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin)==Bit_SET))
000070  8a21              LDRH     r1,[r4,#0x10]
000072  68e0              LDR      r0,[r4,#0xc]
000074  f7fffffe          BL       GPIO_ReadInputDataBit
000078  2801              CMP      r0,#1
00007a  d103              BNE      |L46.132|
;;;229    			{
;;;230    				ISP_Conf->ISP_FUN=ISP_SLAVE;		//ISP作为从机
00007c  20a1              MOVS     r0,#0xa1
00007e  f88409fc          STRB     r0,[r4,#0x9fc]
                  |L46.130|
;;;231    				return;
;;;232    			}
;;;233    		}
;;;234    		//---------------------判断是否为主机(不为从机时则认为是从机）：从机正常工作时，RESET脚带上拉，BOOT0脚为低
;;;235    		{
;;;236    			Usart_ISP_Reset(ISP_Conf);			//重置编程器---恢复所有参数为默认值
;;;237    			ISP_Conf->ISP_FUN=ISP_MASTER;		//ISP作为主机--更新自身程序
;;;238    			ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_IDLE;
;;;239    			GPIO_Configuration_OPP50	(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
;;;240    			GPIO_Configuration_OPP50	(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605		
;;;241    		}
;;;242    	}		
;;;243    }
000082  bd70              POP      {r4-r6,pc}
                  |L46.132|
000084  4628              MOV      r0,r5                 ;226
000086  1c6d              ADDS     r5,r5,#1              ;226
000088  f64f71ff          MOV      r1,#0xffff            ;226
00008c  4288              CMP      r0,r1                 ;226
00008e  d3ef              BCC      |L46.112|
000090  4620              MOV      r0,r4                 ;236
000092  f7fffffe          BL       Usart_ISP_Reset
000096  20a2              MOVS     r0,#0xa2              ;237
000098  f88409fc          STRB     r0,[r4,#0x9fc]        ;237
00009c  201e              MOVS     r0,#0x1e              ;238
00009e  7520              STRB     r0,[r4,#0x14]         ;238
0000a0  8921              LDRH     r1,[r4,#8]            ;239
0000a2  6860              LDR      r0,[r4,#4]            ;239
0000a4  f7fffffe          BL       GPIO_Configuration_OPP50
0000a8  8a21              LDRH     r1,[r4,#0x10]         ;240
0000aa  68e0              LDR      r0,[r4,#0xc]          ;240
0000ac  f7fffffe          BL       GPIO_Configuration_OPP50
                  |L46.176|
0000b0  bf00              NOP      
0000b2  e7e6              B        |L46.130|
;;;244    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_Cof||, CODE, READONLY, ALIGN=1

                  Usart_ISP_Cof PROC
;;;55     *******************************************************************************/
;;;56     void Usart_ISP_Cof(ISP_Conf_TypeDef *ISP_Conf)
000000  b510              PUSH     {r4,lr}
;;;57     {
000002  4604              MOV      r4,r0
;;;58     	USART_DMA_ConfigurationEV	(ISP_Conf->USARTx,115200,ISP_BufferSize);	//USART_DMA配置--查询方式，不开中断
000004  f44f7296          MOV      r2,#0x12c
000008  f44f31e1          MOV      r1,#0x1c200
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       USART_DMA_ConfigurationEV
;;;59     	GPIO_Configuration_OPP50	(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000012  8921              LDRH     r1,[r4,#8]
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       GPIO_Configuration_OPP50
;;;60     	GPIO_Configuration_OPP50	(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00001a  8a21              LDRH     r1,[r4,#0x10]
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;61     	Usart_ISP_Reset(ISP_Conf);																																								//重置编程器---恢复所有参数为默认值
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       Usart_ISP_Reset
;;;62     //	ISP_Conf->ISP_FUN=ISP_SLAVE;			//测试---将模块设置为从机
;;;63     }
000028  bd10              POP      {r4,pc}
;;;64     /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_CommandRead||, CODE, READONLY, ALIGN=1

                  Usart_ISP_CommandRead PROC
;;;272    *******************************************************************************/
;;;273    void Usart_ISP_CommandRead(ISP_Conf_TypeDef *ISP_Conf)			//串口接收命令（主机->从机)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
000002  4604              MOV      r4,r0
;;;275    //	unsigned short rxNum=0;
;;;276    	unsigned char C0=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];
000004  f894518a          LDRB     r5,[r4,#0x18a]
;;;277    	unsigned char C1=ISP_Conf->ISP_DATA.ISP_RvBuffer[1];
000008  f894618b          LDRB     r6,[r4,#0x18b]
;;;278    	C1=C1^0XFF;
00000c  f08606ff          EOR      r6,r6,#0xff
;;;279    	if(C0!=C1)
000010  42b5              CMP      r5,r6
000012  d000              BEQ      |L48.22|
                  |L48.20|
;;;280    	{
;;;281    		return;
;;;282    	}
;;;283    	if(C0==ISP_COMMAND_Get)			//获取当前自举程序版本及允许使用的命令
;;;284    	{
;;;285    		ISP_Conf->ISP_DATA.ISP_TvBuffer[0]=ISP_ANSWER_ACK;			//应答
;;;286    		ISP_Conf->ISP_DATA.ISP_TvBuffer[1]=0x0B;								//长度
;;;287    		ISP_Conf->ISP_DATA.ISP_TvBuffer[2]=0x22;								//版本
;;;288    		ISP_Conf->ISP_DATA.ISP_TvBuffer[3]=ISP_COMMAND_Get;		//Get 命令
;;;289    		ISP_Conf->ISP_DATA.ISP_TvBuffer[4]=ISP_COMMAND_GetVS;	//Get Version and Read Protection Status
;;;290    		ISP_Conf->ISP_DATA.ISP_TvBuffer[5]=ISP_COMMAND_GetID;	//Get ID
;;;291    		ISP_Conf->ISP_DATA.ISP_TvBuffer[6]=ISP_COMMAND_RM;			//Read Memory 命令
;;;292    		ISP_Conf->ISP_DATA.ISP_TvBuffer[7]=ISP_COMMAND_Go;			//Go 命令
;;;293    		ISP_Conf->ISP_DATA.ISP_TvBuffer[8]=ISP_COMMAND_WM;			//Write Memory 命令
;;;294    		ISP_Conf->ISP_DATA.ISP_TvBuffer[9]=ISP_COMMAND_Erase;	//Erase 命令
;;;295    		ISP_Conf->ISP_DATA.ISP_TvBuffer[10]=ISP_COMMAND_WP;		//Write Protect 命令
;;;296    		ISP_Conf->ISP_DATA.ISP_TvBuffer[11]=ISP_COMMAND_WU;		//Write Unprotect 命令
;;;297    		ISP_Conf->ISP_DATA.ISP_TvBuffer[12]=ISP_COMMAND_RP;		//Readout Protect 命令
;;;298    		ISP_Conf->ISP_DATA.ISP_TvBuffer[13]=ISP_COMMAND_RU;		//Readout Unprotect 命令
;;;299    		ISP_Conf->ISP_DATA.ISP_TvBuffer[14]=ISP_ANSWER_ACK;		//应答
;;;300    		
;;;301    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);		//ISP等待命令（作为从机)--处理完Get命令后等待下一下命令
;;;302    		ISP_Conf->ISP_DATA.USARTSendLen=15;												//串口需要发送的数据长度
;;;303    		
;;;304    		memcpy(ISP_Conf->ISP_DATA.ISP_TxBuffer, ISP_Conf->ISP_DATA.ISP_TvBuffer, ISP_Conf->ISP_DATA.USARTSendLen);
;;;305    		USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_TxBuffer,ISP_Conf->ISP_DATA.USARTSendLen);	//串口DMA发送程序	
;;;306    			
;;;307    	}
;;;308    	else if(C0==ISP_COMMAND_GetVS)	//获取自举程序版本及 Flash 的读保护状态
;;;309    	{
;;;310    		ISP_Conf->ISP_DATA.ISP_TvBuffer[0]=ISP_ANSWER_ACK;		//应答
;;;311    		ISP_Conf->ISP_DATA.ISP_TvBuffer[1]=0x22;							//自举程序版本（0 < 版本 ≤ 255），示例：0x10 = 版本 1.0
;;;312    		ISP_Conf->ISP_DATA.ISP_TvBuffer[2]=0x00;							//选项字节 1：0x00，保持与通用自举程序协议的兼容性
;;;313    		ISP_Conf->ISP_DATA.ISP_TvBuffer[3]=0x00;							//选项字节 2：0x00，保持与通用自举程序协议的兼容性
;;;314    		ISP_Conf->ISP_DATA.ISP_TvBuffer[4]=ISP_ANSWER_ACK;		//应答
;;;315    		
;;;316    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);		//ISP等待命令（作为从机)--处理完GetVS命令后等待下一下命令
;;;317    		ISP_Conf->ISP_DATA.USARTSendLen=5;												//串口需要发送的数据长度
;;;318    		
;;;319    		memcpy(ISP_Conf->ISP_DATA.ISP_TxBuffer, ISP_Conf->ISP_DATA.ISP_TvBuffer, ISP_Conf->ISP_DATA.USARTSendLen);
;;;320    		USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_TxBuffer,ISP_Conf->ISP_DATA.USARTSendLen);	//串口DMA发送程序	
;;;321    	}
;;;322    	else if(C0==ISP_COMMAND_GetID)	//获取芯片 ID
;;;323    	{
;;;324    		ISP_Conf->ISP_DATA.ISP_TvBuffer[0]=ISP_ANSWER_ACK;		//应答
;;;325    		ISP_Conf->ISP_DATA.ISP_TvBuffer[1]=0x01;							//N = 字节数 C 1（对 STM32 N = 1），除当前字节和 ACK 之外。
;;;326    		ISP_Conf->ISP_DATA.ISP_TvBuffer[2]=0x04;							//PID(1) 字节 3 = 0x04，字节 4 = 0xXX
;;;327    		ISP_Conf->ISP_DATA.ISP_TvBuffer[3]=0x10;							//PID(1) 字节 3 = 0x04，字节 4 = 0xXX
;;;328    		ISP_Conf->ISP_DATA.ISP_TvBuffer[4]=ISP_ANSWER_ACK;		//应答
;;;329    		
;;;330    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);		//ISP等待命令（作为从机)--处理完GetID命令后等待下一下命令
;;;331    		ISP_Conf->ISP_DATA.USARTSendLen=5;												//串口需要发送的数据长度
;;;332    		
;;;333    		memcpy(ISP_Conf->ISP_DATA.ISP_TxBuffer, ISP_Conf->ISP_DATA.ISP_TvBuffer, ISP_Conf->ISP_DATA.USARTSendLen);
;;;334    		USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_TxBuffer,ISP_Conf->ISP_DATA.USARTSendLen);	//串口DMA发送程序	
;;;335    	}
;;;336    	else if(C0==ISP_COMMAND_RM)			//从应用程序指定的地址开始读取最多 256 个字节的存储器空间：读数据分五步：1-读数据命令，2-读数据起始地址，3-需要读取的长度，4-读数据过程，5-上报数据
;;;337    	{
;;;338    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitReadAddr);			//ISP等待待读取地址---从机接收到读数据命令后应答，然后等待待读取数据地址
;;;339    		Usart_ISP_ACK(ISP_Conf);															//ISP应答
;;;340    		return;
;;;341    	}
;;;342    	else if(C0==ISP_COMMAND_Go)			//等待待跳转到内部 Flash 或 SRAM 内的应用程序代码地址//Go 命令用于从应用程序指定的地址开始执行已下载的代码或其它任何代码
;;;343    	{
;;;344    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitGoAddr);			//接收到Go命令后，应答，然后等待开始执行起始地址
;;;345    		Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;346    	}
;;;347    	else if(C0==ISP_COMMAND_WM)			//Write Memory:从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash
;;;348    	{
;;;349    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitWAddr);			//ISP等待待写入地址---接收到写命令后，应答，然后等待写入起始地址
;;;350    		Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;351    	}
;;;352    	else if(C0==ISP_COMMAND_Erase)	//擦除一个到全部 Flash 页面
;;;353    	{
;;;354    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitEraseAddr);	//ISP等待待擦除地址，接收到擦除命令后，应答，等待输入待擦除地址（全部擦除或者页擦除）
;;;355    		Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;356    	}
;;;357    	else if(C0==ISP_COMMAND_EE)			//使用双字节寻址模式擦除一个到全部 Flash 页面（仅用于v3.0 usart 自举程序版本及以上版本）。
;;;358    	{
;;;359    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitEraseAddr);	//ISP等待待擦除地址，接收到擦除命令后，应答，等待输入待擦除地址（全部擦除或者页擦除）
;;;360    		Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;361    	}
;;;362    	else if(C0==ISP_COMMAND_WP)			//使能某些扇区的写保护
;;;363    	{
;;;364    		/*Write Protect 命令用于为一部分或所有 Flash 扇区使能写保护。自举程序接收到 Write Protect 命令后，
;;;365    			会将 ACK 字节发送到主机。发送 ACK 字节后，自举程序将等待要接收的 字节数（受保护的扇区），之后从应用程序接收 Flash 扇区代码。
;;;366    			在 Write Protect 命令结束时，自举程序会发送 ACK 字节并启动系统复位，以实施新的选项 字节配置。
;;;367    		*/
;;;368    		return;			//暂不处理
;;;369    	}
;;;370    	else if(C0==ISP_COMMAND_WU)			//关闭所有 Flash 扇区的写保护
;;;371    	{
;;;372    		/*Write Unprotect 命令用于禁止所有 Flash 扇区的写保护。自举程序接收到 Write Unprotect 命令后，
;;;373    		会将 ACK 字节发送到主机。发送 ACK 字节后，自举程序会禁止所有 Flash 扇区的 写保护。执行禁止保护操作后，自举程序发送 ACK 字节。
;;;374    		在 Write Unprotect 命令结束时，自举程序会发送 ACK 字节并启动系统复位，以实施新的选项 字节配置。
;;;375    		*/
;;;376    		return;			//暂不处理
;;;377    	}
;;;378    	else if(C0==ISP_COMMAND_RP)			//使能读保护
;;;379    	{
;;;380    		/*Readout Protect 命令用于使能 Flash 读保护。自举程序接收到 Readout Protect 命令后，
;;;381    			会将 ACK 字节发送到主机。发送 ACK 字节后，自举程序将使能 Flash 的读保护。
;;;382    			在 Readout Protect 命令结束时，自举程序会发送 ACK 字节并启动系统复位，以实施新的选 项字节配置。
;;;383    		*/
;;;384    		return;			//暂不处理
;;;385    	}
;;;386    	else if(C0==ISP_COMMAND_RU)			//关闭读保护
;;;387    	{
;;;388    		/*Readout Unprotect 命令用于禁止 Flash 读保护。自举程序接收到 Readout Unprotect 命令 后，会将 ACK 字节发送到主机。
;;;389    			发送了 ACK 字节后，自举程序将擦除所有 Flash 扇区并禁 止整个 Flash 的读保护。如果擦除操作成功完成，自举程序将停用 RDP。
;;;390    			如果擦除操作失败，自举程序会发送一个 NACK 且读保护仍然有效。
;;;391    			在 Readout Unprotect 命令结束时，自举程序会发送 ACK 字节并启动系统复位，以实施新 的选项字节配置。
;;;392    		*/
;;;393    		return;			//暂不处理
;;;394    	}
;;;395    	else
;;;396    	{
;;;397    	}	
;;;398    //	if(rxNum)
;;;399    //	{
;;;400    //		memcpy(ISP_Conf->ISP_DATA.ISP_TxBuffer, ISP_Conf->ISP_DATA.ISP_TvBuffer, rxNum);
;;;401    //		USART_DMASend(ISP_Conf->USARTx,(u32*)ISP_Conf->ISP_DATA.ISP_TxBuffer,rxNum);	//串口DMA发送程序	
;;;402    //	}
;;;403    }
000014  bd70              POP      {r4-r6,pc}
                  |L48.22|
000016  2d00              CMP      r5,#0                 ;283
000018  d141              BNE      |L48.158|
00001a  2179              MOVS     r1,#0x79              ;285
00001c  f88413e2          STRB     r1,[r4,#0x3e2]        ;285
000020  210b              MOVS     r1,#0xb               ;286
000022  f88413e3          STRB     r1,[r4,#0x3e3]        ;286
000026  2122              MOVS     r1,#0x22              ;287
000028  f88413e4          STRB     r1,[r4,#0x3e4]        ;287
00002c  2100              MOVS     r1,#0                 ;288
00002e  f88413e5          STRB     r1,[r4,#0x3e5]        ;288
000032  2101              MOVS     r1,#1                 ;289
000034  f88413e6          STRB     r1,[r4,#0x3e6]        ;289
000038  2102              MOVS     r1,#2                 ;290
00003a  f88413e7          STRB     r1,[r4,#0x3e7]        ;290
00003e  2111              MOVS     r1,#0x11              ;291
000040  f88413e8          STRB     r1,[r4,#0x3e8]        ;291
000044  2121              MOVS     r1,#0x21              ;292
000046  f88413e9          STRB     r1,[r4,#0x3e9]        ;292
00004a  2131              MOVS     r1,#0x31              ;293
00004c  f88413ea          STRB     r1,[r4,#0x3ea]        ;293
000050  2143              MOVS     r1,#0x43              ;294
000052  f88413eb          STRB     r1,[r4,#0x3eb]        ;294
000056  2163              MOVS     r1,#0x63              ;295
000058  f88413ec          STRB     r1,[r4,#0x3ec]        ;295
00005c  2173              MOVS     r1,#0x73              ;296
00005e  f88413ed          STRB     r1,[r4,#0x3ed]        ;296
000062  2182              MOVS     r1,#0x82              ;297
000064  f88413ee          STRB     r1,[r4,#0x3ee]        ;297
000068  2192              MOVS     r1,#0x92              ;298
00006a  f88413ef          STRB     r1,[r4,#0x3ef]        ;298
00006e  2179              MOVS     r1,#0x79              ;299
000070  f88413f0          STRB     r1,[r4,#0x3f0]        ;299
000074  2105              MOVS     r1,#5                 ;301
000076  4620              MOV      r0,r4                 ;301
000078  f7fffffe          BL       Usart_ISP_SetSlaveStatus
00007c  210f              MOVS     r1,#0xf               ;302
00007e  63a1              STR      r1,[r4,#0x38]         ;302
000080  f20431e2          ADD      r1,r4,#0x3e2          ;304
000084  f20420b6          ADD      r0,r4,#0x2b6          ;304
000088  6ba2              LDR      r2,[r4,#0x38]         ;304
00008a  f7fffffe          BL       __aeabi_memcpy
00008e  8f21              LDRH     r1,[r4,#0x38]         ;305
000090  b28a              UXTH     r2,r1                 ;305
000092  f20421b6          ADD      r1,r4,#0x2b6          ;305
000096  6820              LDR      r0,[r4,#0]            ;305
000098  f7fffffe          BL       USART_DMASend
00009c  e088              B        |L48.432|
                  |L48.158|
00009e  2d01              CMP      r5,#1                 ;308
0000a0  d122              BNE      |L48.232|
0000a2  2179              MOVS     r1,#0x79              ;310
0000a4  f88413e2          STRB     r1,[r4,#0x3e2]        ;310
0000a8  2122              MOVS     r1,#0x22              ;311
0000aa  f88413e3          STRB     r1,[r4,#0x3e3]        ;311
0000ae  2100              MOVS     r1,#0                 ;312
0000b0  f88413e4          STRB     r1,[r4,#0x3e4]        ;312
0000b4  f88413e5          STRB     r1,[r4,#0x3e5]        ;313
0000b8  2179              MOVS     r1,#0x79              ;314
0000ba  f88413e6          STRB     r1,[r4,#0x3e6]        ;314
0000be  2105              MOVS     r1,#5                 ;316
0000c0  4620              MOV      r0,r4                 ;316
0000c2  f7fffffe          BL       Usart_ISP_SetSlaveStatus
0000c6  2105              MOVS     r1,#5                 ;317
0000c8  63a1              STR      r1,[r4,#0x38]         ;317
0000ca  f20431e2          ADD      r1,r4,#0x3e2          ;319
0000ce  f20420b6          ADD      r0,r4,#0x2b6          ;319
0000d2  6ba2              LDR      r2,[r4,#0x38]         ;319
0000d4  f7fffffe          BL       __aeabi_memcpy
0000d8  8f21              LDRH     r1,[r4,#0x38]         ;320
0000da  b28a              UXTH     r2,r1                 ;320
0000dc  f20421b6          ADD      r1,r4,#0x2b6          ;320
0000e0  6820              LDR      r0,[r4,#0]            ;320
0000e2  f7fffffe          BL       USART_DMASend
0000e6  e063              B        |L48.432|
                  |L48.232|
0000e8  2d02              CMP      r5,#2                 ;322
0000ea  d123              BNE      |L48.308|
0000ec  2179              MOVS     r1,#0x79              ;324
0000ee  f88413e2          STRB     r1,[r4,#0x3e2]        ;324
0000f2  2101              MOVS     r1,#1                 ;325
0000f4  f88413e3          STRB     r1,[r4,#0x3e3]        ;325
0000f8  2104              MOVS     r1,#4                 ;326
0000fa  f88413e4          STRB     r1,[r4,#0x3e4]        ;326
0000fe  2110              MOVS     r1,#0x10              ;327
000100  f88413e5          STRB     r1,[r4,#0x3e5]        ;327
000104  2179              MOVS     r1,#0x79              ;328
000106  f88413e6          STRB     r1,[r4,#0x3e6]        ;328
00010a  2105              MOVS     r1,#5                 ;330
00010c  4620              MOV      r0,r4                 ;330
00010e  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000112  2105              MOVS     r1,#5                 ;331
000114  63a1              STR      r1,[r4,#0x38]         ;331
000116  f20431e2          ADD      r1,r4,#0x3e2          ;333
00011a  f20420b6          ADD      r0,r4,#0x2b6          ;333
00011e  6ba2              LDR      r2,[r4,#0x38]         ;333
000120  f7fffffe          BL       __aeabi_memcpy
000124  8f21              LDRH     r1,[r4,#0x38]         ;334
000126  b28a              UXTH     r2,r1                 ;334
000128  f20421b6          ADD      r1,r4,#0x2b6          ;334
00012c  6820              LDR      r0,[r4,#0]            ;334
00012e  f7fffffe          BL       USART_DMASend
000132  e03d              B        |L48.432|
                  |L48.308|
000134  2d11              CMP      r5,#0x11              ;336
000136  d107              BNE      |L48.328|
000138  210e              MOVS     r1,#0xe               ;338
00013a  4620              MOV      r0,r4                 ;338
00013c  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000140  4620              MOV      r0,r4                 ;339
000142  f7fffffe          BL       Usart_ISP_ACK
000146  e765              B        |L48.20|
                  |L48.328|
000148  2d21              CMP      r5,#0x21              ;342
00014a  d107              BNE      |L48.348|
00014c  2112              MOVS     r1,#0x12              ;344
00014e  4620              MOV      r0,r4                 ;344
000150  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000154  4620              MOV      r0,r4                 ;345
000156  f7fffffe          BL       Usart_ISP_ACK
00015a  e029              B        |L48.432|
                  |L48.348|
00015c  2d31              CMP      r5,#0x31              ;347
00015e  d107              BNE      |L48.368|
000160  210a              MOVS     r1,#0xa               ;349
000162  4620              MOV      r0,r4                 ;349
000164  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000168  4620              MOV      r0,r4                 ;350
00016a  f7fffffe          BL       Usart_ISP_ACK
00016e  e01f              B        |L48.432|
                  |L48.368|
000170  2d43              CMP      r5,#0x43              ;352
000172  d107              BNE      |L48.388|
000174  2106              MOVS     r1,#6                 ;354
000176  4620              MOV      r0,r4                 ;354
000178  f7fffffe          BL       Usart_ISP_SetSlaveStatus
00017c  4620              MOV      r0,r4                 ;355
00017e  f7fffffe          BL       Usart_ISP_ACK
000182  e015              B        |L48.432|
                  |L48.388|
000184  2d44              CMP      r5,#0x44              ;357
000186  d107              BNE      |L48.408|
000188  2106              MOVS     r1,#6                 ;359
00018a  4620              MOV      r0,r4                 ;359
00018c  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000190  4620              MOV      r0,r4                 ;360
000192  f7fffffe          BL       Usart_ISP_ACK
000196  e00b              B        |L48.432|
                  |L48.408|
000198  2d63              CMP      r5,#0x63              ;362
00019a  d100              BNE      |L48.414|
00019c  e73a              B        |L48.20|
                  |L48.414|
00019e  2d73              CMP      r5,#0x73              ;370
0001a0  d100              BNE      |L48.420|
0001a2  e737              B        |L48.20|
                  |L48.420|
0001a4  2d82              CMP      r5,#0x82              ;378
0001a6  d100              BNE      |L48.426|
0001a8  e734              B        |L48.20|
                  |L48.426|
0001aa  2d92              CMP      r5,#0x92              ;386
0001ac  d100              BNE      |L48.432|
0001ae  e731              B        |L48.20|
                  |L48.432|
0001b0  bf00              NOP      
0001b2  e72f              B        |L48.20|
;;;404    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_Erase||, CODE, READONLY, ALIGN=1

                  Usart_ISP_Erase PROC
;;;614    *******************************************************************************/
;;;615    void Usart_ISP_Erase(ISP_Conf_TypeDef *ISP_Conf)				//ISP擦除操作，接收到擦除命令后，应答，等待输入待擦除地址（全部擦除或者页擦除）等待擦除完成，完成后应答
000000  b510              PUSH     {r4,lr}
;;;616    {
000002  4604              MOV      r4,r0
;;;617    	//ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErase||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErased
;;;618    	#ifdef	Usart_ISP_Simulation 		//模拟从机
;;;619    	{
;;;620    		if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErase)	//开始擦除
;;;621    		{
;;;622    			if(ISP_Conf->ISP_DATA.WriteAddr==0xFF)	//全部擦除
;;;623    			{
;;;624    				Usart_ISP_ACK(ISP_Conf);													//ISP应答---擦除完成
;;;625    				Usart_ISP_Reset(ISP_Conf);												//重置编程器---恢复所有参数为默认值---模式切换后复位
;;;626    				Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitErased);	//状态为擦除完成
;;;627    			}
;;;628    		}
;;;629    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErased)	//等待擦除完成
;;;630    		{
;;;631    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);	//状态为擦除完成，ISP等待命令（作为从机)
;;;632    		}
;;;633    	}
;;;634    	#else
;;;635    	{
;;;636    		if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErase)	//开始擦除
000004  7ca0              LDRB     r0,[r4,#0x12]
000006  2807              CMP      r0,#7
000008  d107              BNE      |L49.26|
;;;637    		{
;;;638    			if(ISP_Conf->ISP_DATA.WriteAddr==0xFF)	//全部擦除
00000a  6ce0              LDR      r0,[r4,#0x4c]
00000c  28ff              CMP      r0,#0xff
00000e  d10e              BNE      |L49.46|
;;;639    			{
;;;640    				Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_Eraseing);			//设置从机状态--ISP正在擦除
000010  2108              MOVS     r1,#8
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000018  e009              B        |L49.46|
                  |L49.26|
;;;641    			}
;;;642    		}
;;;643    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErased)			//等待擦除完成
00001a  7ca0              LDRB     r0,[r4,#0x12]
00001c  2809              CMP      r0,#9
00001e  d106              BNE      |L49.46|
;;;644    		{
;;;645    			Usart_ISP_ACK(ISP_Conf);							//ISP应答---擦除完成
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       Usart_ISP_ACK
;;;646    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);	//状态为擦除完成，ISP等待命令（作为从机)
000026  2105              MOVS     r1,#5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       Usart_ISP_SetSlaveStatus
                  |L49.46|
;;;647    		}
;;;648    		
;;;649    	}	
;;;650    	#endif
;;;651    }
00002e  bd10              POP      {r4,pc}
;;;652    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_GetAddr||, CODE, READONLY, ALIGN=1

                  Usart_ISP_GetAddr PROC
;;;409    *******************************************************************************/
;;;410    void Usart_ISP_GetAddr(ISP_Conf_TypeDef *ISP_Conf)		//ISP获取写数据起始地址(主机->从机)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;411    {	
000004  4604              MOV      r4,r0
;;;412    	//ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitReadAddr||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWAddr||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitEraseAddr)
;;;413    	//需要接收地址的指令：读数据，写数据，擦除
;;;414    	if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitEraseAddr)			//ISP擦除操作，接收到擦除命令后，应答，等待输入待擦除地址（全部擦除或者页擦除）等待擦除完成，完成后应答
000006  7ca0              LDRB     r0,[r4,#0x12]
000008  2806              CMP      r0,#6
00000a  d10f              BNE      |L50.44|
;;;415    	{
;;;416    		unsigned char C0=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];
00000c  f894218a          LDRB     r2,[r4,#0x18a]
;;;417    		unsigned char C1=ISP_Conf->ISP_DATA.ISP_RvBuffer[1];
000010  f894318b          LDRB     r3,[r4,#0x18b]
;;;418    		C1=C1^0XFF;
000014  f08303ff          EOR      r3,r3,#0xff
;;;419    		if(C0!=C1)
000018  429a              CMP      r2,r3
00001a  d001              BEQ      |L50.32|
                  |L50.28|
;;;420    		{
;;;421    			return;
;;;422    		}
;;;423    		ISP_Conf->ISP_DATA.WriteAddr=C0;													//待写数据的起始地址--擦除为写入0xFF
;;;424    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitErase);						//等待接收待写入的数据
;;;425    	}
;;;426    	else
;;;427    	{
;;;428    		unsigned int addr=0x00;		//合并地址变量
;;;429    		unsigned char Bcc=BCC8(ISP_Conf->ISP_DATA.ISP_RvBuffer,4);		//异或校验;
;;;430    		if(Bcc!=ISP_Conf->ISP_DATA.ISP_RvBuffer[4])
;;;431    		{
;;;432    			return;
;;;433    		}
;;;434    		else		//合并地址---4字节
;;;435    		{		
;;;436    			addr=	(ISP_Conf->ISP_DATA.ISP_RvBuffer[0])<<24;
;;;437    			addr+=(ISP_Conf->ISP_DATA.ISP_RvBuffer[1])<<16;
;;;438    			addr+=(ISP_Conf->ISP_DATA.ISP_RvBuffer[2])<<8;
;;;439    			addr+=(ISP_Conf->ISP_DATA.ISP_RvBuffer[3]);
;;;440    		}
;;;441    		
;;;442    		if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitReadAddr)				//等待接收读数据起地址，接收到地址后应答，再等待待读取数据长度
;;;443    		{
;;;444    			ISP_Conf->ISP_DATA.ReadAddr=addr;														//待读数据的起始地址
;;;445    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitLengh);						//等待接收需要读取的数据长度
;;;446    			Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;447    		}
;;;448    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWAddr)			//等待接收写数据地址，接收到地址后应答，再等待待写入的数据
;;;449    		{
;;;450    			if(ISP_Conf->ISP_DATA.OffsetAddr==0)
;;;451    			{
;;;452    				ISP_Conf->ISP_DATA.OffsetAddr=addr;
;;;453    			}
;;;454    		
;;;455    			ISP_Conf->ISP_DATA.WriteAddr=addr;													//待写数据的起始地址
;;;456    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitWData);		//设置从机状态--等待接收待写入的数据
;;;457    //			ISP_Conf->ISP_SLAVE_STATUS=ISP_STATUS_WaitWData;						//等待接收待写入的数据
;;;458    			Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;459    		}
;;;460    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitGoAddr)			//等待接收写数据地址，接收到地址后应答，再等待待写入的数据
;;;461    		{
;;;462    			u32 timedelay=0;
;;;463    			ISP_Conf->ISP_DATA.GoAddr=addr;																//待写数据的起始地址
;;;464    			ISP_Conf->Connected=ISP_STATUS_UnConnect;											//ISP未连接（作为从机)---此为断开连接状态
;;;465    //			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_IDLE);						//ISP空闲状态，可以读写
;;;466    			Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;467    			while(timedelay++<0xFF);
;;;468    //			Usart_ISP_Reset(ISP_Conf);						//重置编程器---恢复所有参数为默认值
;;;469    		}
;;;470    	}
;;;471    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L50.32|
000020  64e2              STR      r2,[r4,#0x4c]         ;423
000022  2107              MOVS     r1,#7                 ;424
000024  4620              MOV      r0,r4                 ;424
000026  f7fffffe          BL       Usart_ISP_SetSlaveStatus
00002a  e046              B        |L50.186|
                  |L50.44|
00002c  2500              MOVS     r5,#0                 ;428
00002e  2104              MOVS     r1,#4                 ;429
000030  f50470c5          ADD      r0,r4,#0x18a          ;429
000034  f7fffffe          BL       BCC8
000038  4606              MOV      r6,r0                 ;429
00003a  f894018e          LDRB     r0,[r4,#0x18e]        ;430
00003e  42b0              CMP      r0,r6                 ;430
000040  d000              BEQ      |L50.68|
000042  e7eb              B        |L50.28|
                  |L50.68|
000044  f894018a          LDRB     r0,[r4,#0x18a]        ;436
000048  0605              LSLS     r5,r0,#24             ;436
00004a  f894018b          LDRB     r0,[r4,#0x18b]        ;437
00004e  eb054500          ADD      r5,r5,r0,LSL #16      ;437
000052  f894018c          LDRB     r0,[r4,#0x18c]        ;438
000056  eb052500          ADD      r5,r5,r0,LSL #8       ;438
00005a  f894018d          LDRB     r0,[r4,#0x18d]        ;439
00005e  4405              ADD      r5,r5,r0              ;439
000060  7ca0              LDRB     r0,[r4,#0x12]         ;442
000062  280e              CMP      r0,#0xe               ;442
000064  d108              BNE      |L50.120|
000066  6465              STR      r5,[r4,#0x44]         ;444
000068  2110              MOVS     r1,#0x10              ;445
00006a  4620              MOV      r0,r4                 ;445
00006c  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000070  4620              MOV      r0,r4                 ;446
000072  f7fffffe          BL       Usart_ISP_ACK
000076  e01f              B        |L50.184|
                  |L50.120|
000078  7ca0              LDRB     r0,[r4,#0x12]         ;448
00007a  280a              CMP      r0,#0xa               ;448
00007c  d10b              BNE      |L50.150|
00007e  6a60              LDR      r0,[r4,#0x24]         ;450
000080  b900              CBNZ     r0,|L50.132|
000082  6265              STR      r5,[r4,#0x24]         ;452
                  |L50.132|
000084  64e5              STR      r5,[r4,#0x4c]         ;455
000086  210b              MOVS     r1,#0xb               ;456
000088  4620              MOV      r0,r4                 ;456
00008a  f7fffffe          BL       Usart_ISP_SetSlaveStatus
00008e  4620              MOV      r0,r4                 ;458
000090  f7fffffe          BL       Usart_ISP_ACK
000094  e010              B        |L50.184|
                  |L50.150|
000096  7ca0              LDRB     r0,[r4,#0x12]         ;460
000098  2812              CMP      r0,#0x12              ;460
00009a  d10d              BNE      |L50.184|
00009c  2700              MOVS     r7,#0                 ;462
00009e  62e5              STR      r5,[r4,#0x2c]         ;463
0000a0  2001              MOVS     r0,#1                 ;464
0000a2  f8840a08          STRB     r0,[r4,#0xa08]        ;464
0000a6  4620              MOV      r0,r4                 ;466
0000a8  f7fffffe          BL       Usart_ISP_ACK
0000ac  bf00              NOP                            ;467
                  |L50.174|
0000ae  4638              MOV      r0,r7                 ;467
0000b0  1c7f              ADDS     r7,r7,#1              ;467
0000b2  28ff              CMP      r0,#0xff              ;467
0000b4  d3fb              BCC      |L50.174|
0000b6  bf00              NOP                            ;469
                  |L50.184|
0000b8  bf00              NOP                            ;470
                  |L50.186|
0000ba  bf00              NOP      
0000bc  e7ae              B        |L50.28|
;;;472    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_GetLengh||, CODE, READONLY, ALIGN=1

                  Usart_ISP_GetLengh PROC
;;;477    *******************************************************************************/
;;;478    void Usart_ISP_GetLengh(ISP_Conf_TypeDef *ISP_Conf)				//ISP获取需要读取的数据长度(主机->从机)，读数据时，传入地址后再传入待读取的数据长度
000000  b510              PUSH     {r4,lr}
;;;479    {	
000002  4602              MOV      r2,r0
;;;480    	//ISP获取需要读取的数据长度(主机->从机)，读数据时，传入地址后再传入待读取的数据长度，接收到长度数据后执行读数据操作，然后上传数据
;;;481    	unsigned char C0=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];
000004  f892318a          LDRB     r3,[r2,#0x18a]
;;;482    	unsigned char C1=ISP_Conf->ISP_DATA.ISP_RvBuffer[1];
000008  f892418b          LDRB     r4,[r2,#0x18b]
;;;483    	C1=C1^0XFF;
00000c  f08404ff          EOR      r4,r4,#0xff
;;;484    	if(C0!=C1)		//校验地址
000010  42a3              CMP      r3,r4
000012  d000              BEQ      |L51.22|
                  |L51.20|
;;;485    	{
;;;486    		return;
;;;487    	}
;;;488    	else
;;;489    	{
;;;490    		ISP_Conf->ISP_DATA.USARTSendLen=C0;										//需要往串口发送的数据个数
;;;491    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitReadData);	//设置从机状态--ISP等待读数据操作
;;;492    	}
;;;493    //		ISP_Conf->ISP_SLAVE_STATUS=ISP_STATUS_WaitReadData;	//ISP等待读数据操作
;;;494    }
000014  bd10              POP      {r4,pc}
                  |L51.22|
000016  6393              STR      r3,[r2,#0x38]         ;490
000018  210f              MOVS     r1,#0xf               ;491
00001a  4610              MOV      r0,r2                 ;491
00001c  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000020  bf00              NOP      
000022  e7f7              B        |L51.20|
;;;495    
                          ENDP


                          AREA ||i.Usart_ISP_GetSlaveStatus||, CODE, READONLY, ALIGN=1

                  Usart_ISP_GetSlaveStatus PROC
;;;657    *******************************************************************************/
;;;658    u8 Usart_ISP_GetSlaveStatus(ISP_Conf_TypeDef *ISP_Conf)	//返回从机状态值
000000  4601              MOV      r1,r0
;;;659    {	
;;;660    	return(ISP_Conf->ISP_SLAVE_STATUS);		//返回从机状态值
000002  7c88              LDRB     r0,[r1,#0x12]
;;;661    }
000004  4770              BX       lr
;;;662    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_MasterProcess||, CODE, READONLY, ALIGN=1

                  Usart_ISP_MasterProcess PROC
;;;173    *******************************************************************************/
;;;174    void Usart_ISP_MasterProcess(ISP_Conf_TypeDef *ISP_Conf)		//模块作为主机时的处理程序
000000  b510              PUSH     {r4,lr}
;;;175    {
000002  4604              MOV      r4,r0
;;;176    	Usart_MISP_StatusProcess(ISP_Conf);			//启动从机设备使从机运行
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       Usart_MISP_StatusProcess
;;;177    	Usart_ISP_Send(ISP_Conf);						//发送函数包括从机发送应答、发送地址、发送命令、发送数据
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       Usart_ISP_Send
;;;178    }
000010  bd10              POP      {r4,pc}
;;;179    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_NACK||, CODE, READONLY, ALIGN=1

                  Usart_ISP_NACK PROC
;;;260    *******************************************************************************/
;;;261    void Usart_ISP_NACK(ISP_Conf_TypeDef *ISP_Conf)		//ISP不应答
000000  b510              PUSH     {r4,lr}
;;;262    {
000002  4604              MOV      r4,r0
;;;263    	ISP_Conf->ISP_DATA.Command[0]=ISP_ANSWER_NACK;
000004  211f              MOVS     r1,#0x1f
000006  f884105c          STRB     r1,[r4,#0x5c]
;;;264    	USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.Command,1);	//串口DMA发送程序
00000a  2201              MOVS     r2,#1
00000c  f104015c          ADD      r1,r4,#0x5c
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_DMASend
;;;265    }
000016  bd10              POP      {r4,pc}
;;;266    
                          ENDP


                          AREA ||i.Usart_ISP_Process||, CODE, READONLY, ALIGN=1

                  Usart_ISP_Process PROC
;;;69     *******************************************************************************/
;;;70     void Usart_ISP_Process(ISP_Conf_TypeDef *ISP_Conf)
000000  b510              PUSH     {r4,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72     	if(ISP_Conf->ISP_FUN==ISP_SLAVE)				//模块作为从机----更新程序
000004  f89409fc          LDRB     r0,[r4,#0x9fc]
000008  28a1              CMP      r0,#0xa1
00000a  d103              BNE      |L55.20|
;;;73     	{
;;;74     		Usart_ISP_SlaveProcess(ISP_Conf);			//模块作为从机时的处理程序
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Usart_ISP_SlaveProcess
000012  e012              B        |L55.58|
                  |L55.20|
;;;75     	}
;;;76     	else if(ISP_Conf->ISP_FUN==ISP_MASTER)	//模块作为主机----烧录目标板
000014  f89409fc          LDRB     r0,[r4,#0x9fc]
000018  28a2              CMP      r0,#0xa2
00001a  d103              BNE      |L55.36|
;;;77     	{
;;;78     		Usart_ISP_MasterProcess(ISP_Conf);			//模块作为主机时的处理程序
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       Usart_ISP_MasterProcess
000022  e00a              B        |L55.58|
                  |L55.36|
;;;79     	}
;;;80     	else if(ISP_Conf->ISP_FUN==ISP_WaitDeliver)			//等待释放从机)
000024  f89409fc          LDRB     r0,[r4,#0x9fc]
000028  28a3              CMP      r0,#0xa3
00002a  d103              BNE      |L55.52|
;;;81     	{
;;;82     		Usart_ISP_CheckFun(ISP_Conf);					//检测ISP模块工作模式---空闲时检测
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       Usart_ISP_CheckFun
000032  e002              B        |L55.58|
                  |L55.52|
;;;83     	}
;;;84     	else
;;;85     	{
;;;86     		Usart_ISP_CheckFun(ISP_Conf);					//检测ISP模块工作模式---空闲时检测
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       Usart_ISP_CheckFun
                  |L55.58|
;;;87     	}	
;;;88     //	Usart_ISP_MasterProcess(ISP_Conf);			//模块作为主机时的处理程序
;;;89     //	Usart_ISP_SlaveProcess(ISP_Conf);			//模块作为从机时的处理程序
;;;90     }
00003a  bd10              POP      {r4,pc}
;;;91     /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_ReadMemory||, CODE, READONLY, ALIGN=1

                  Usart_ISP_ReadMemory PROC
;;;502    *******************************************************************************/
;;;503    void Usart_ISP_ReadMemory(ISP_Conf_TypeDef *ISP_Conf)		//ISP读数据（从机->主机）
000000  4770              BX       lr
;;;504    {	
;;;505    	#ifdef	Usart_ISP_Simulation 		//模拟从机
;;;506    	{
;;;507    		//*******************执行读数据操作
;;;508    //		ISP_Conf->ISP_DATA.ISP_TxBuffer[0]=0x79;
;;;509    //		memcpy(&ISP_Conf->ISP_DATA.ISP_TxBuffer[1], ISP_Conf->ISP_DATA.ISP_TvBuffer, ISP_Conf->ISP_DATA.SendLen+1);	//复制数据
;;;510    		Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitSData);		//ISP等待发送数据			
;;;511    	}
;;;512    	#else
;;;513    	{
;;;514    		//*******************执行读数据操作
;;;515    		//----此为等待外部Flash读取数据完成，当数据读取完成后，由外部程序设置ISP_STATUS_WaitSData状态
;;;516    		//1）外部检测到ISP_STATUS_WaitReadData状态后
;;;517    		//2）根据地址ReadAddr和待发送长度SendLen读取相应数据
;;;518    		//3）读取完成后，将数据复制到ISP_Conf->ISP_DATA.ISP_TvBuffer发送备份区
;;;519    		//4）设置ISP_STATUS_WaitSData状态，表示数据准备完成，等待发送
;;;520    	}
;;;521    	#endif
;;;522    }
;;;523    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_Reset||, CODE, READONLY, ALIGN=1

                  Usart_ISP_Reset PROC
;;;1071   *******************************************************************************/
;;;1072   void Usart_ISP_Reset(ISP_Conf_TypeDef *ISP_Conf)	//重置编程器---恢复所有参数为默认值
000000  b510              PUSH     {r4,lr}
;;;1073   {	
000002  4604              MOV      r4,r0
;;;1074   	//----------从机
;;;1075   	ISP_Conf->ISP_DATA.OffsetAddr				=	0;			//写从机时的地址偏移
000004  2000              MOVS     r0,#0
000006  6260              STR      r0,[r4,#0x24]
;;;1076   	ISP_Conf->ISP_DATA.StartAddr				=	0;			//起始地址
000008  2100              MOVS     r1,#0
00000a  62a1              STR      r1,[r4,#0x28]
;;;1077   	ISP_Conf->ISP_DATA.GoAddr						=	0;			//复位运行起始地址
00000c  62e1              STR      r1,[r4,#0x2c]
;;;1078   	
;;;1079   	ISP_Conf->ISP_DATA.ReceivedLen			=	0;			//串口接收的数据个数
00000e  6361              STR      r1,[r4,#0x34]
;;;1080   	ISP_Conf->ISP_DATA.USARTSendLen			=	0;			//需要往串口发送的数据个数---//当检测到SendLen不为0时自动发送数据
000010  63a1              STR      r1,[r4,#0x38]
;;;1081   	
;;;1082   	ISP_Conf->ISP_DATA.FLASHNumToSave		=	0;			//需要往FLASH里保存的数据个数---当此不为0时SPI-FLASH自动存储数据
000012  63e1              STR      r1,[r4,#0x3c]
;;;1083   	ISP_Conf->ISP_DATA.FLASHNumToRead		=	0;			//需要从FLASH里读取的数据个数---当此不为0时，SPI-FLASH自动通过WriteAddr地址从SPI-FLASH读取数据
000014  6421              STR      r1,[r4,#0x40]
;;;1084   	
;;;1085   	ISP_Conf->ISP_DATA.ReadAddr					=	0;			//读数据起始地址
000016  6461              STR      r1,[r4,#0x44]
;;;1086   	
;;;1087   	ISP_Conf->ISP_DATA.WriteAddr				=	0;			//写入数据起始地址
000018  64e1              STR      r1,[r4,#0x4c]
;;;1088   	ISP_Conf->ISP_DATA.WriteLen					=	0;			//需要写入的长度	
00001a  6521              STR      r1,[r4,#0x50]
;;;1089   
;;;1090   	ISP_Conf->ISP_DATA.SumHaveReceived	=	0;			//作为从机时总共接收到的数据个数
00001c  6561              STR      r1,[r4,#0x54]
;;;1091   	ISP_Conf->ISP_DATA.SumHaveWritten		=	0;			//主机总共往从机写入的数据个数
00001e  65a1              STR      r1,[r4,#0x58]
;;;1092   
;;;1093   	
;;;1094   	
;;;1095   	ISP_Conf->ISP_FUN										=	ISP_IDLE;						//ISP状态为空闲，根据RESET接口状态和BOOT0接口状态可以切换为MASTER或者SLAVE
000020  20a0              MOVS     r0,#0xa0
000022  f88409fc          STRB     r0,[r4,#0x9fc]
;;;1096   	ISP_Conf->ISP_SLAVE_STATUS					=	ISP_STATUS_IDLE;		//FLASH空闲状态，可以读写
000026  2000              MOVS     r0,#0
000028  74a0              STRB     r0,[r4,#0x12]
;;;1097   	ISP_Conf->SlaveLastStatus						=	ISP_STATUS_IDLE;		//存储从机上一个状态，根据上一个状态进行下一步操作
00002a  74e0              STRB     r0,[r4,#0x13]
;;;1098   	
;;;1099   	//---------主机
;;;1100   	ISP_Conf->ISP_MDATA.OffsetAddr			=0;
00002c  f8c40510          STR      r0,[r4,#0x510]
;;;1101   	ISP_Conf->ISP_MDATA.StartAddr				=0;
000030  f2405014          MOV      r0,#0x514
000034  5101              STR      r1,[r0,r4]
;;;1102   	ISP_Conf->ISP_MDATA.GoAddr					=0;
000036  1d00              ADDS     r0,r0,#4
000038  5101              STR      r1,[r0,r4]
;;;1103   	
;;;1104   	ISP_Conf->ISP_MDATA.ReceivedLen			=0;
00003a  f44f60a4          MOV      r0,#0x520
00003e  5101              STR      r1,[r0,r4]
;;;1105   	ISP_Conf->ISP_MDATA.USARTSendLen		=0;
000040  1d00              ADDS     r0,r0,#4
000042  5101              STR      r1,[r0,r4]
;;;1106   	
;;;1107   	ISP_Conf->ISP_MDATA.FLASHNumToSave	=0;
000044  1d00              ADDS     r0,r0,#4
000046  5101              STR      r1,[r0,r4]
;;;1108   	ISP_Conf->ISP_MDATA.FLASHNumToRead	=0;
000048  1d00              ADDS     r0,r0,#4
00004a  5101              STR      r1,[r0,r4]
;;;1109   	
;;;1110   	ISP_Conf->ISP_MDATA.ReadAddr				=0;
00004c  1d00              ADDS     r0,r0,#4
00004e  5101              STR      r1,[r0,r4]
;;;1111   	
;;;1112   	ISP_Conf->ISP_MDATA.WriteAddr				=0;
000050  f44f60a7          MOV      r0,#0x538
000054  5101              STR      r1,[r0,r4]
;;;1113   	ISP_Conf->ISP_MDATA.WriteLen				=0;
000056  1d00              ADDS     r0,r0,#4
000058  5101              STR      r1,[r0,r4]
;;;1114   	
;;;1115   	ISP_Conf->ISP_MDATA.SumHaveReceived	=0;
00005a  1d00              ADDS     r0,r0,#4
00005c  5101              STR      r1,[r0,r4]
;;;1116   	ISP_Conf->ISP_MDATA.SumHaveWritten	=0;
00005e  1d00              ADDS     r0,r0,#4
000060  5101              STR      r1,[r0,r4]
;;;1117   	
;;;1118   	ISP_Conf->ISP_MASTER_STATUS					=	ISP_MSTATUS_IDLE;		//ISP主机空闲状态----开始写前或者写完成后状态
000062  201e              MOVS     r0,#0x1e
000064  7520              STRB     r0,[r4,#0x14]
;;;1119   	ISP_Conf->MasterLastStatus					=	ISP_MSTATUS_IDLE;		//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作	
000066  7560              STRB     r0,[r4,#0x15]
;;;1120   	
;;;1121   	
;;;1122   	
;;;1123   	ISP_Conf->OverRunTime								=	0;									//超时时间	
000068  2000              MOVS     r0,#0
00006a  f8c40a00          STR      r0,[r4,#0xa00]
;;;1124   	ISP_Conf->TimeCount									=	0;									//计时时间	
00006e  f8c40a04          STR      r0,[r4,#0xa04]
;;;1125   	ISP_Conf->Connected=ISP_STATUS_UnConnect;							//ISP未连接（作为从机)
000072  2001              MOVS     r0,#1
000074  f8840a08          STRB     r0,[r4,#0xa08]
;;;1126   	
;;;1127   	memset(ISP_Conf->ISP_DATA.ISP_RxBuffer,0xFF, ISP_BufferSize);	//接收缓冲区
000078  22ff              MOVS     r2,#0xff
00007a  f44f7196          MOV      r1,#0x12c
00007e  f104005e          ADD      r0,r4,#0x5e
000082  f7fffffe          BL       __aeabi_memset
;;;1128   	memset(ISP_Conf->ISP_DATA.ISP_RvBuffer,0xFF, ISP_BufferSize);	//接收缓冲区--备份区
000086  22ff              MOVS     r2,#0xff
000088  f44f7196          MOV      r1,#0x12c
00008c  f50470c5          ADD      r0,r4,#0x18a
000090  f7fffffe          BL       __aeabi_memset
;;;1129   	memset(ISP_Conf->ISP_DATA.ISP_TxBuffer,0xFF, ISP_BufferSize);	//发送缓冲区
000094  22ff              MOVS     r2,#0xff
000096  f44f7196          MOV      r1,#0x12c
00009a  f20420b6          ADD      r0,r4,#0x2b6
00009e  f7fffffe          BL       __aeabi_memset
;;;1130   	memset(ISP_Conf->ISP_DATA.ISP_TvBuffer,0xFF, ISP_BufferSize);	//发送缓冲区--备份区
0000a2  22ff              MOVS     r2,#0xff
0000a4  f44f7196          MOV      r1,#0x12c
0000a8  f20430e2          ADD      r0,r4,#0x3e2
0000ac  f7fffffe          BL       __aeabi_memset
;;;1131   }
0000b0  bd10              POP      {r4,pc}
;;;1132   
                          ENDP


                          AREA ||i.Usart_ISP_Send||, CODE, READONLY, ALIGN=1

                  Usart_ISP_Send PROC
;;;1054   *******************************************************************************/
;;;1055   void Usart_ISP_Send(ISP_Conf_TypeDef *ISP_Conf)						//发送函数包括从机发送应答、发送地址、发送命令、发送数据
000000  b510              PUSH     {r4,lr}
;;;1056   {
000002  4604              MOV      r4,r0
;;;1057   	if(ISP_Conf->ISP_DATA.USARTSendLen)
000004  6ba0              LDR      r0,[r4,#0x38]
000006  b1b0              CBZ      r0,|L58.54|
;;;1058   	{
;;;1059   		memcpy(ISP_Conf->ISP_DATA.ISP_TxBuffer, ISP_Conf->ISP_DATA.ISP_TvBuffer,ISP_Conf->ISP_DATA.USARTSendLen);		//复制数据
000008  f20431e2          ADD      r1,r4,#0x3e2
00000c  f20420b6          ADD      r0,r4,#0x2b6
000010  6ba2              LDR      r2,[r4,#0x38]
000012  f7fffffe          BL       __aeabi_memcpy
;;;1060   		memset(ISP_Conf->ISP_DATA.ISP_TvBuffer,0xFF, ISP_BufferSize);	//接收缓冲区
000016  22ff              MOVS     r2,#0xff
000018  f44f7196          MOV      r1,#0x12c
00001c  f20430e2          ADD      r0,r4,#0x3e2
000020  f7fffffe          BL       __aeabi_memset
;;;1061   		USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_TxBuffer,ISP_Conf->ISP_DATA.USARTSendLen);			//串口DMA发送程序
000024  8f21              LDRH     r1,[r4,#0x38]
000026  b28a              UXTH     r2,r1
000028  f20421b6          ADD      r1,r4,#0x2b6
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       USART_DMASend
;;;1062   		ISP_Conf->ISP_DATA.USARTSendLen=0;
000032  2100              MOVS     r1,#0
000034  63a1              STR      r1,[r4,#0x38]
                  |L58.54|
;;;1063   	}
;;;1064   }
000036  bd10              POP      {r4,pc}
;;;1065   
                          ENDP


                          AREA ||i.Usart_ISP_SendBuffer||, CODE, READONLY, ALIGN=1

                  Usart_ISP_SendBuffer PROC
;;;589    *******************************************************************************/
;;;590    void Usart_ISP_SendBuffer(ISP_Conf_TypeDef *ISP_Conf)	//ISP上传数据（从机->主机)
000000  b510              PUSH     {r4,lr}
;;;591    {	
000002  4604              MOV      r4,r0
;;;592    
;;;593    	ISP_Conf->ISP_DATA.ISP_TxBuffer[0]=0x79;
000004  2179              MOVS     r1,#0x79
000006  f88412b6          STRB     r1,[r4,#0x2b6]
;;;594    	memcpy(&ISP_Conf->ISP_DATA.ISP_TxBuffer[1], ISP_Conf->ISP_DATA.ISP_TvBuffer, ISP_Conf->ISP_DATA.USARTSendLen+1);	//复制数据
00000a  6ba0              LDR      r0,[r4,#0x38]
00000c  1c42              ADDS     r2,r0,#1
00000e  f20431e2          ADD      r1,r4,#0x3e2
000012  f20420b7          ADD      r0,r4,#0x2b7
000016  f7fffffe          BL       __aeabi_memcpy
;;;595    	USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_TxBuffer,ISP_Conf->ISP_DATA.USARTSendLen+2);				//串口DMA发送程序
00001a  8f21              LDRH     r1,[r4,#0x38]
00001c  1c89              ADDS     r1,r1,#2
00001e  b28a              UXTH     r2,r1
000020  f20421b6          ADD      r1,r4,#0x2b6
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       USART_DMASend
;;;596    	Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);				//已经完成数据发送命令，状态更新为等待下一个命令ISP_STATUS_WaitCommand
00002a  2105              MOVS     r1,#5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       Usart_ISP_SetSlaveStatus
;;;597    
;;;598    	
;;;599    //	unsigned short Wlen=ISP_Conf->ISP_RvBuffer[0];	//获取要写入的数据长度（字节数)
;;;600    //	unsigned char Bcc=BCC8(ISP_Conf->ISP_RvBuffer,Wlen+2);		//异或校验;
;;;601    //	if(Bcc!=ISP_Conf->ISP_RvBuffer[Wlen+2])
;;;602    //	{
;;;603    //		return;
;;;604    //	}
;;;605    //	ISP_Conf->ISP_STATUS=ISP_STATUS_WRITE;		//FLASH执行写操作
;;;606    //	memcpy(ISP_Conf->ISP_TvBuffer, &ISP_Conf->ISP_RvBuffer[1], Wlen+1);
;;;607    //	Usart_ISP_ACK(ISP_Conf);						//ISP应答
;;;608    }
000032  bd10              POP      {r4,pc}
;;;609    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_ISP_SetSlaveStatus||, CODE, READONLY, ALIGN=1

                  Usart_ISP_SetSlaveStatus PROC
;;;667    *******************************************************************************/
;;;668    void Usart_ISP_SetSlaveStatus(ISP_Conf_TypeDef *ISP_Conf,ISP_SLAVE_STATUS_TypeDef Status)	//设置从机状态
000000  7481              STRB     r1,[r0,#0x12]
;;;669    {	
;;;670    	ISP_Conf->ISP_SLAVE_STATUS=Status;	//设置状态值
;;;671    }
000002  4770              BX       lr
;;;672    
                          ENDP


                          AREA ||i.Usart_ISP_SlaveProcess||, CODE, READONLY, ALIGN=2

                  Usart_ISP_SlaveProcess PROC
;;;96     *******************************************************************************/
;;;97     void Usart_ISP_SlaveProcess(ISP_Conf_TypeDef *ISP_Conf)		//模块作为从机时的处理程序
000000  b510              PUSH     {r4,lr}
;;;98     {
000002  4604              MOV      r4,r0
;;;99     	ISP_Conf->ISP_DATA.ReceivedLen=USART_ReadBufferIDLE(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_RvBuffer);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
000004  f50471c5          ADD      r1,r4,#0x18a
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_ReadBufferIDLE
00000e  6360              STR      r0,[r4,#0x34]
;;;100    	if(ISP_Conf->ISP_DATA.ReceivedLen)
000010  6b60              LDR      r0,[r4,#0x34]
000012  2800              CMP      r0,#0
000014  d056              BEQ      |L61.196|
;;;101    	{
;;;102    		ISP_Conf->OverRunTime=0;									//超时时间
000016  2000              MOVS     r0,#0
000018  f8c40a00          STR      r0,[r4,#0xa00]
;;;103    		if(ISP_Conf->ISP_DATA.ReceivedLen==1)			//单字节----识别波特率
00001c  6b60              LDR      r0,[r4,#0x34]
00001e  2801              CMP      r0,#1
000020  d122              BNE      |L61.104|
;;;104    		{
;;;105    			if(ISP_Conf->ISP_DATA.ISP_RvBuffer[0]==0x7F)	//自举应答
000022  f894018a          LDRB     r0,[r4,#0x18a]
000026  287f              CMP      r0,#0x7f
000028  d109              BNE      |L61.62|
;;;106    			{
;;;107    				if(ISP_Conf->Connected==ISP_STATUS_UnConnect)
00002a  f8940a08          LDRB     r0,[r4,#0xa08]
00002e  2801              CMP      r0,#1
000030  d106              BNE      |L61.64|
;;;108    				{
;;;109    					Usart_ISP_Reset(ISP_Conf);														//重置编程器---恢复所有参数为默认值
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       Usart_ISP_Reset
;;;110    					ISP_Conf->Connected=ISP_STATUS_WaitConnect;						//ISP等待连接（作为从机)
000038  2002              MOVS     r0,#2
00003a  f8840a08          STRB     r0,[r4,#0xa08]
                  |L61.62|
00003e  e07a              B        |L61.310|
                  |L61.64|
;;;111    				}
;;;112    				else if(ISP_Conf->Connected==ISP_STATUS_Connectting||ISP_Conf->Connected==ISP_STATUS_WaitConnect)
000040  f8940a08          LDRB     r0,[r4,#0xa08]
000044  2803              CMP      r0,#3
000046  d076              BEQ      |L61.310|
000048  f8940a08          LDRB     r0,[r4,#0xa08]
00004c  2802              CMP      r0,#2
00004e  d072              BEQ      |L61.310|
;;;113    				{
;;;114    				}
;;;115    				else if(ISP_Conf->Connected==ISP_STATUS_Connectted)
000050  f8940a08          LDRB     r0,[r4,#0xa08]
000054  2804              CMP      r0,#4
000056  d16e              BNE      |L61.310|
;;;116    				{					
;;;117    					Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);		//ISP等待命令（作为从机)
000058  2105              MOVS     r1,#5
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       Usart_ISP_SetSlaveStatus
;;;118    					Usart_ISP_ACK(ISP_Conf);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       Usart_ISP_ACK
000066  e066              B        |L61.310|
                  |L61.104|
;;;119    				}																							//ISP应答
;;;120    			}
;;;121    		}
;;;122    		else if(ISP_Conf->ISP_DATA.ReceivedLen==2&&ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitCommand)				//2字节---接收命令过程
000068  6b60              LDR      r0,[r4,#0x34]
00006a  2802              CMP      r0,#2
00006c  d106              BNE      |L61.124|
00006e  7ca0              LDRB     r0,[r4,#0x12]
000070  2805              CMP      r0,#5
000072  d103              BNE      |L61.124|
;;;123    		{
;;;124    			Usart_ISP_CommandRead(ISP_Conf);			//串口接收命令（主机->从机)
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       Usart_ISP_CommandRead
00007a  e05c              B        |L61.310|
                  |L61.124|
;;;125    		}
;;;126    		else if((ISP_Conf->ISP_DATA.ReceivedLen==5&&(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitReadAddr||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWAddr||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitGoAddr))||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitEraseAddr)				//5个字节---地址类数据接收地址过程
00007c  6b60              LDR      r0,[r4,#0x34]
00007e  2805              CMP      r0,#5
000080  d108              BNE      |L61.148|
000082  7ca0              LDRB     r0,[r4,#0x12]
000084  280e              CMP      r0,#0xe
000086  d008              BEQ      |L61.154|
000088  7ca0              LDRB     r0,[r4,#0x12]
00008a  280a              CMP      r0,#0xa
00008c  d005              BEQ      |L61.154|
00008e  7ca0              LDRB     r0,[r4,#0x12]
000090  2812              CMP      r0,#0x12
000092  d002              BEQ      |L61.154|
                  |L61.148|
000094  7ca0              LDRB     r0,[r4,#0x12]
000096  2806              CMP      r0,#6
000098  d103              BNE      |L61.162|
                  |L61.154|
;;;127    		{
;;;128    			Usart_ISP_GetAddr(ISP_Conf);						//ISP获取写数据起始地址(主机->从机)
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       Usart_ISP_GetAddr
0000a0  e049              B        |L61.310|
                  |L61.162|
;;;129    		}
;;;130    		else if(ISP_Conf->ISP_DATA.ReceivedLen==2&&ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitLengh)				//2字节---接收待处理数据长度，读数据时，传入地址后再传入待读取的数据长度
0000a2  6b60              LDR      r0,[r4,#0x34]
0000a4  2802              CMP      r0,#2
0000a6  d106              BNE      |L61.182|
0000a8  7ca0              LDRB     r0,[r4,#0x12]
0000aa  2810              CMP      r0,#0x10
0000ac  d103              BNE      |L61.182|
;;;131    		{
;;;132    			Usart_ISP_GetLengh(ISP_Conf);					//ISP获取需要读取的数据长度(主机->从机)，读数据时，传入地址后再传入待读取的数据长度
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       Usart_ISP_GetLengh
0000b4  e03f              B        |L61.310|
                  |L61.182|
;;;133    		}
;;;134    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWData)	//ISP等待接收待写入数据,写数据时，传完地址后等待传入数据，再执行写操作
0000b6  7ca0              LDRB     r0,[r4,#0x12]
0000b8  280b              CMP      r0,#0xb
0000ba  d13c              BNE      |L61.310|
;;;135    		{
;;;136    			Usart_ISP_WriteMemory(ISP_Conf);			//ISP写数据（主机->从机）写数据时，传完地址后等待传入数据，再执行写操作
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       Usart_ISP_WriteMemory
0000c2  e038              B        |L61.310|
                  |L61.196|
;;;137    		}
;;;138    				
;;;139    	}
;;;140    	else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitReadData)	//等待数据读取完成
0000c4  7ca0              LDRB     r0,[r4,#0x12]
0000c6  280f              CMP      r0,#0xf
0000c8  d103              BNE      |L61.210|
;;;141    	{
;;;142    		Usart_ISP_ReadMemory(ISP_Conf);															//ISP读数据（从机->主机）
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       Usart_ISP_ReadMemory
0000d0  e031              B        |L61.310|
                  |L61.210|
;;;143    	}	
;;;144    	else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitSData)			//ISP等待发送数据
0000d2  7ca0              LDRB     r0,[r4,#0x12]
0000d4  2811              CMP      r0,#0x11
0000d6  d103              BNE      |L61.224|
;;;145    	{
;;;146    		Usart_ISP_SendBuffer(ISP_Conf);															//ISP上传数据（从机->主机)
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       Usart_ISP_SendBuffer
0000de  e02a              B        |L61.310|
                  |L61.224|
;;;147    	}
;;;148    	else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErase||ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitErased)		//ISPISP等待擦除
0000e0  7ca0              LDRB     r0,[r4,#0x12]
0000e2  2807              CMP      r0,#7
0000e4  d002              BEQ      |L61.236|
0000e6  7ca0              LDRB     r0,[r4,#0x12]
0000e8  2809              CMP      r0,#9
0000ea  d103              BNE      |L61.244|
                  |L61.236|
;;;149    	{
;;;150    		Usart_ISP_Erase(ISP_Conf);						//ISP擦除操作，接收到擦除命令后，应答，等待输入待擦除地址（全部擦除或者页擦除）等待擦除完成，完成后应答
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       Usart_ISP_Erase
0000f2  e020              B        |L61.310|
                  |L61.244|
;;;151    	}
;;;152    	else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWrited)	//ISP等待接收待写入数据,写数据时，传完地址后等待传入数据，再执行写操作
0000f4  7ca0              LDRB     r0,[r4,#0x12]
0000f6  280d              CMP      r0,#0xd
0000f8  d103              BNE      |L61.258|
;;;153    	{
;;;154    		Usart_ISP_WriteMemory(ISP_Conf);			//ISP写数据（主机->从机）写数据时，传完地址后等待传入数据，再执行写操作
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       Usart_ISP_WriteMemory
000100  e019              B        |L61.310|
                  |L61.258|
;;;155    	}
;;;156    	else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitReset)	//程序下载完后从机需要重置
000102  7ca0              LDRB     r0,[r4,#0x12]
000104  2813              CMP      r0,#0x13
000106  d103              BNE      |L61.272|
;;;157    	{
;;;158    		Usart_ISP_CheckFun(ISP_Conf);					//检测ISP模块工作模式---空闲时检测
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       Usart_ISP_CheckFun
00010e  e012              B        |L61.310|
                  |L61.272|
;;;159    	}
;;;160    	else	if((ISP_Conf->ISP_SLAVE_STATUS!=ISP_STATUS_IDLE)||(ISP_Conf->ISP_FUN==ISP_SLAVE))				//非初始状态时超时复位
000110  7ca0              LDRB     r0,[r4,#0x12]
000112  b918              CBNZ     r0,|L61.284|
000114  f89409fc          LDRB     r0,[r4,#0x9fc]
000118  28a1              CMP      r0,#0xa1
00011a  d10c              BNE      |L61.310|
                  |L61.284|
;;;161    	{
;;;162    		ISP_Conf->OverRunTime=ISP_Conf->OverRunTime+1;					//超时时间
00011c  f8d40a00          LDR      r0,[r4,#0xa00]
000120  1c40              ADDS     r0,r0,#1
000122  f8c40a00          STR      r0,[r4,#0xa00]
;;;163    		if(ISP_Conf->OverRunTime>=5000000)				//约5秒
000126  4904              LDR      r1,|L61.312|
000128  f8d40a00          LDR      r0,[r4,#0xa00]
00012c  4288              CMP      r0,r1
00012e  d302              BCC      |L61.310|
;;;164    		Usart_ISP_Reset(ISP_Conf);								//重置编程器---恢复所有参数为默认值
000130  4620              MOV      r0,r4
000132  f7fffffe          BL       Usart_ISP_Reset
                  |L61.310|
;;;165    	}
;;;166    //	ISP_Conf->ISP_DATA.NumHaveRead=0;	//接收的数据个数
;;;167    }
000136  bd10              POP      {r4,pc}
;;;168    /*******************************************************************************
                          ENDP

                  |L61.312|
                          DCD      0x004c4b40

                          AREA ||i.Usart_ISP_WriteMemory||, CODE, READONLY, ALIGN=1

                  Usart_ISP_WriteMemory PROC
;;;528    *******************************************************************************/
;;;529    void Usart_ISP_WriteMemory(ISP_Conf_TypeDef *ISP_Conf)	//ISP写数据（主机->从机）写数据时，传完地址后等待传入数据，再执行写操作
000000  b570              PUSH     {r4-r6,lr}
;;;530    {	
000002  4604              MOV      r4,r0
;;;531    	#ifdef	Usart_ISP_Simulation 		//模拟从机
;;;532    	{
;;;533    		if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWData)		//ISP等待接收待写入数据
;;;534    		{
;;;535    			unsigned char	Wlen=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];						//要写入Flash的数据长度（字节数)
;;;536    			unsigned char Bcc=BCC8(ISP_Conf->ISP_DATA.ISP_RvBuffer,Wlen+2);		//异或校验;					
;;;537    			if(Bcc!=ISP_Conf->ISP_DATA.ISP_RvBuffer[Wlen+2])
;;;538    			{
;;;539    				return;
;;;540    			}
;;;541    			ISP_Conf->ISP_DATA.WriteLen=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];		//要写入Flash的数据长度（字节数)	
;;;542    			memcpy(ISP_Conf->ISP_DATA.ISP_TvBuffer, &ISP_Conf->ISP_DATA.ISP_RvBuffer[1], ISP_Conf->ISP_DATA.WriteLen+1);	//复制数据
;;;543    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitWrited);				//ISP等待写入完成
;;;544    		}
;;;545    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWrited)	//ISP等待写入完成
;;;546    		{
;;;547    			Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;548    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);				//ISP等待命令（作为从机)
;;;549    		}
;;;550    	}
;;;551    	#else
;;;552    	{
;;;553    		if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWData)		//ISP等待接收待写入数据
000004  7ca0              LDRB     r0,[r4,#0x12]
000006  280b              CMP      r0,#0xb
000008  d11d              BNE      |L62.70|
;;;554    		{
;;;555    			unsigned char	Wlen=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];						//要写入Flash的数据长度（字节数)
00000a  f894518a          LDRB     r5,[r4,#0x18a]
;;;556    			unsigned char Bcc=BCC8(ISP_Conf->ISP_DATA.ISP_RvBuffer,Wlen+2);		//异或校验;					
00000e  1ca9              ADDS     r1,r5,#2
000010  f50470c5          ADD      r0,r4,#0x18a
000014  f7fffffe          BL       BCC8
000018  4606              MOV      r6,r0
;;;557    			if(Bcc!=ISP_Conf->ISP_DATA.ISP_RvBuffer[Wlen+2])
00001a  f50470c5          ADD      r0,r4,#0x18a
00001e  1ca9              ADDS     r1,r5,#2
000020  5c40              LDRB     r0,[r0,r1]
000022  42b0              CMP      r0,r6
000024  d000              BEQ      |L62.40|
                  |L62.38|
;;;558    			{
;;;559    				return;
;;;560    			}
;;;561    			ISP_Conf->ISP_DATA.WriteLen=ISP_Conf->ISP_DATA.ISP_RvBuffer[0];		//要写入Flash的数据长度（字节数)	
;;;562    			//当外部检测到ISP_STATUS_WaitWrite状态时，根据ISP_Conf->ISP_DATA.WriteLen长度往Flash写入数据，写入完成到设置ISP_STATUS_WaitWrited状态
;;;563    			memcpy(ISP_Conf->ISP_DATA.ISP_RvBuffer, &ISP_Conf->ISP_DATA.ISP_RvBuffer[1], ISP_Conf->ISP_DATA.WriteLen+1);	//复制数据
;;;564    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitWrite);				//ISP等待写数据
;;;565    		}
;;;566    		else if(ISP_Conf->ISP_SLAVE_STATUS==ISP_STATUS_WaitWrited)	//ISP等待写入完成
;;;567    		{
;;;568    			//当外部检测到ISP_STATUS_WaitWrite状态时，根据ISP_Conf->ISP_DATA.WriteLen长度往Flash写入数据，写入完成到设置ISP_STATUS_WaitWrited状态
;;;569    			Usart_ISP_ACK(ISP_Conf);	//ISP应答
;;;570    			Usart_ISP_SetSlaveStatus(ISP_Conf,ISP_STATUS_WaitCommand);				//ISP等待命令（作为从机)
;;;571    		}
;;;572    	}
;;;573    	#endif
;;;574    //	unsigned short Wlen=ISP_Conf->ISP_RvBuffer[0];	//获取要写入的数据长度（字节数)
;;;575    //	unsigned char Bcc=BCC8(ISP_Conf->ISP_RvBuffer,Wlen+2);		//异或校验;
;;;576    //	if(Bcc!=ISP_Conf->ISP_RvBuffer[Wlen+2])
;;;577    //	{
;;;578    //		return;
;;;579    //	}
;;;580    //	ISP_Conf->ISP_STATUS=ISP_STATUS_WRITE;		//FLASH执行写操作
;;;581    //	memcpy(ISP_Conf->ISP_TvBuffer, &ISP_Conf->ISP_RvBuffer[1], Wlen+1);
;;;582    //	Usart_ISP_ACK(ISP_Conf);						//ISP应答
;;;583    }
000026  bd70              POP      {r4-r6,pc}
                  |L62.40|
000028  f894118a          LDRB     r1,[r4,#0x18a]        ;561
00002c  6521              STR      r1,[r4,#0x50]         ;561
00002e  6d20              LDR      r0,[r4,#0x50]         ;563
000030  1c42              ADDS     r2,r0,#1              ;563
000032  f204118b          ADD      r1,r4,#0x18b          ;563
000036  1e48              SUBS     r0,r1,#1              ;563
000038  f7fffffe          BL       __aeabi_memcpy
00003c  210c              MOVS     r1,#0xc               ;564
00003e  4620              MOV      r0,r4                 ;564
000040  f7fffffe          BL       Usart_ISP_SetSlaveStatus
000044  e009              B        |L62.90|
                  |L62.70|
000046  7ca0              LDRB     r0,[r4,#0x12]         ;566
000048  280d              CMP      r0,#0xd               ;566
00004a  d106              BNE      |L62.90|
00004c  4620              MOV      r0,r4                 ;569
00004e  f7fffffe          BL       Usart_ISP_ACK
000052  2105              MOVS     r1,#5                 ;570
000054  4620              MOV      r0,r4                 ;570
000056  f7fffffe          BL       Usart_ISP_SetSlaveStatus
                  |L62.90|
00005a  bf00              NOP      
00005c  e7e3              B        |L62.38|
;;;584    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_CommandSend||, CODE, READONLY, ALIGN=1

                  Usart_MISP_CommandSend PROC
;;;1017   *******************************************************************************/
;;;1018   void Usart_MISP_CommandSend(ISP_Conf_TypeDef *ISP_Conf,unsigned char Command)	//串口编程发送命令程序
000000  b570              PUSH     {r4-r6,lr}
;;;1019   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1020   	ISP_Conf->ISP_DATA.Command[0]=Command;
000006  f884505c          STRB     r5,[r4,#0x5c]
;;;1021   	ISP_Conf->ISP_DATA.Command[1]=Command^0XFF;
00000a  f08501ff          EOR      r1,r5,#0xff
00000e  f884105d          STRB     r1,[r4,#0x5d]
;;;1022   	USART_DMASend(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.Command,2);	//串口DMA发送程序
000012  2202              MOVS     r2,#2
000014  f104015c          ADD      r1,r4,#0x5c
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       USART_DMASend
;;;1023   }
00001e  bd70              POP      {r4-r6,pc}
;;;1024   /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_Connect||, CODE, READONLY, ALIGN=1

                  Usart_MISP_Connect PROC
;;;973    *******************************************************************************/
;;;974    void Usart_MISP_Connect(ISP_Conf_TypeDef *ISP_Conf)					//主机连接从机函数
000000  2201              MOVS     r2,#1
;;;975    {
;;;976    		ISP_Conf->ISP_DATA.USARTSendLen=1;										//发送一字节0x7F
000002  6382              STR      r2,[r0,#0x38]
;;;977    		ISP_Conf->ISP_DATA.ISP_TvBuffer[0]=0x7F;							//连接符
000004  227f              MOVS     r2,#0x7f
000006  f88023e2          STRB     r2,[r0,#0x3e2]
;;;978    }
00000a  4770              BX       lr
;;;979    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_GetDevice||, CODE, READONLY, ALIGN=1

                  Usart_MISP_GetDevice PROC
;;;953    *******************************************************************************/
;;;954    void Usart_MISP_GetDevice(ISP_Conf_TypeDef *ISP_Conf)			//获取从机芯片信息
000000  b510              PUSH     {r4,lr}
;;;955    {
000002  4604              MOV      r4,r0
;;;956    	Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_Get);				//串口编程发送命令程序//Get:获取当前自举程序版本及允许使用的命令
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       Usart_MISP_CommandSend
;;;957    }
00000c  bd10              POP      {r4,pc}
;;;958    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_GetFirmwareInf||, CODE, READONLY, ALIGN=1

                  Usart_MISP_GetFirmwareInf PROC
;;;943    *******************************************************************************/
;;;944    void Usart_MISP_GetFirmwareInf(ISP_Conf_TypeDef *ISP_Conf)			//从Flash中获取固件信息
000000  4770              BX       lr
;;;945    {
;;;946    	
;;;947    }
;;;948    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_GetStatus||, CODE, READONLY, ALIGN=1

                  Usart_MISP_GetStatus PROC
;;;933    }
;;;934    u8 Usart_MISP_GetStatus(ISP_Conf_TypeDef *ISP_Conf)	//返回从机状态值
000000  4601              MOV      r1,r0
;;;935    {	
;;;936    	return(ISP_Conf->ISP_MASTER_STATUS);		//返回从机状态值
000002  7d08              LDRB     r0,[r1,#0x14]
;;;937    }
000004  4770              BX       lr
;;;938    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_ReadAck||, CODE, READONLY, ALIGN=1

                  Usart_MISP_ReadAck PROC
;;;1029   *******************************************************************************/
;;;1030   bool Usart_MISP_ReadAck(ISP_Conf_TypeDef *ISP_Conf)			//主机读取从机应答:有应答返回TRUE，否则返回FALSE
000000  b510              PUSH     {r4,lr}
;;;1031   {
000002  4604              MOV      r4,r0
;;;1032   	ISP_Conf->ISP_DATA.ReceivedLen=USART_ReadBufferIDLE(ISP_Conf->USARTx,(u8*)ISP_Conf->ISP_DATA.ISP_RvBuffer);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的
000004  f50471c5          ADD      r1,r4,#0x18a
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_ReadBufferIDLE
00000e  6360              STR      r0,[r4,#0x34]
;;;1033   	if(ISP_Conf->ISP_DATA.ReceivedLen)
000010  6b60              LDR      r0,[r4,#0x34]
000012  b138              CBZ      r0,|L68.36|
;;;1034   	{
;;;1035   		if(ISP_Conf->ISP_DATA.ISP_RvBuffer[0]==0x79)
000014  f894018a          LDRB     r0,[r4,#0x18a]
000018  2879              CMP      r0,#0x79
00001a  d101              BNE      |L68.32|
;;;1036   		{
;;;1037   			return TRUE;
00001c  2001              MOVS     r0,#1
                  |L68.30|
;;;1038   		}
;;;1039   		else
;;;1040   		{
;;;1041   			return FALSE;
;;;1042   		}
;;;1043   	}
;;;1044   	return FALSE;
;;;1045   }
00001e  bd10              POP      {r4,pc}
                  |L68.32|
000020  2000              MOVS     r0,#0                 ;1041
000022  e7fc              B        |L68.30|
                  |L68.36|
000024  2000              MOVS     r0,#0                 ;1044
000026  e7fa              B        |L68.30|
;;;1046   
                          ENDP


                          AREA ||i.Usart_MISP_ResetDevice||, CODE, READONLY, ALIGN=1

                  Usart_MISP_ResetDevice PROC
;;;984    *******************************************************************************/
;;;985    void Usart_MISP_ResetDevice(ISP_Conf_TypeDef *ISP_Conf)			//复位从机设备--使从机进行ISP模式
000000  b510              PUSH     {r4,lr}
;;;986    {
000002  4604              MOV      r4,r0
;;;987    	GPIO_SetBits(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);		//BOOT0拉高
000004  8a21              LDRH     r1,[r4,#0x10]
000006  68e0              LDR      r0,[r4,#0xc]
000008  f7fffffe          BL       GPIO_SetBits
;;;988    	GPIO_ResetBits(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);	//RESET脚拉低
00000c  8921              LDRH     r1,[r4,#8]
00000e  6860              LDR      r0,[r4,#4]
000010  f7fffffe          BL       GPIO_ResetBits
;;;989    }
000014  bd10              POP      {r4,pc}
;;;990    /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_RunDevice||, CODE, READONLY, ALIGN=1

                  Usart_MISP_RunDevice PROC
;;;1006   *******************************************************************************/
;;;1007   void Usart_MISP_RunDevice(ISP_Conf_TypeDef *ISP_Conf)			//启动从机设备使从机正常运行
000000  b510              PUSH     {r4,lr}
;;;1008   {
000002  4604              MOV      r4,r0
;;;1009   	GPIO_ResetBits(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);		//BOOT0拉低
000004  8a21              LDRH     r1,[r4,#0x10]
000006  68e0              LDR      r0,[r4,#0xc]
000008  f7fffffe          BL       GPIO_ResetBits
;;;1010   	GPIO_SetBits(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//RESET脚拉高
00000c  8921              LDRH     r1,[r4,#8]
00000e  6860              LDR      r0,[r4,#4]
000010  f7fffffe          BL       GPIO_SetBits
;;;1011   }
000014  bd10              POP      {r4,pc}
;;;1012   /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_SetDevice||, CODE, READONLY, ALIGN=1

                  Usart_MISP_SetDevice PROC
;;;995    *******************************************************************************/
;;;996    void Usart_MISP_SetDevice(ISP_Conf_TypeDef *ISP_Conf)			//启动从机接收BOOT0使从机进行下载状态
000000  b510              PUSH     {r4,lr}
;;;997    {
000002  4604              MOV      r4,r0
;;;998    	GPIO_SetBits(ISP_Conf->BOOT0_CTL_PORT,ISP_Conf->BOOT0_CTL_Pin);			//BOOT0拉低
000004  8a21              LDRH     r1,[r4,#0x10]
000006  68e0              LDR      r0,[r4,#0xc]
000008  f7fffffe          BL       GPIO_SetBits
;;;999    	GPIO_SetBits(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//RESET脚拉高
00000c  8921              LDRH     r1,[r4,#8]
00000e  6860              LDR      r0,[r4,#4]
000010  f7fffffe          BL       GPIO_SetBits
;;;1000   }
000014  bd10              POP      {r4,pc}
;;;1001   /*******************************************************************************
                          ENDP


                          AREA ||i.Usart_MISP_StatusProcess||, CODE, READONLY, ALIGN=2

                  Usart_MISP_StatusProcess PROC
;;;692    *******************************************************************************/
;;;693    void Usart_MISP_StatusProcess(ISP_Conf_TypeDef *ISP_Conf)			//启动从机设备使从机运行
000000  b570              PUSH     {r4-r6,lr}
;;;694    {
000002  4604              MOV      r4,r0
;;;695    	if(ISP_Conf->OverRunTime++>2000000)			//10S超时---应答0.5S超时
000004  f8d41a00          LDR      r1,[r4,#0xa00]
000008  1c48              ADDS     r0,r1,#1
00000a  f8c40a00          STR      r0,[r4,#0xa00]
00000e  48e2              LDR      r0,|L72.920|
000010  4281              CMP      r1,r0
000012  d902              BLS      |L72.26|
;;;696    	{
;;;697    		Usart_ISP_Reset(ISP_Conf);						//重置编程器---恢复所有参数为默认值
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       Usart_ISP_Reset
                  |L72.26|
;;;698    	}
;;;699    	if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_IDLE)								//工作在主机模式下的空闲---准备开始检查有无从机连接
00001a  7d20              LDRB     r0,[r4,#0x14]
00001c  281e              CMP      r0,#0x1e
00001e  d10b              BNE      |L72.56|
;;;700    	{
;;;701    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_ResetDevice;
000020  201f              MOVS     r0,#0x1f
000022  7520              STRB     r0,[r4,#0x14]
;;;702    		Usart_MISP_RunDevice(ISP_Conf);						//启动从机设备使从机正常运行
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       Usart_MISP_RunDevice
;;;703    		ISP_Conf->OverRunTime=0;									//超时时间
00002a  2000              MOVS     r0,#0
00002c  f8c40a00          STR      r0,[r4,#0xa00]
;;;704    		Usart_MISP_GetFirmwareInf(ISP_Conf);			//从Flash中获取固件信息
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       Usart_MISP_GetFirmwareInf
000036  e1ae              B        |L72.918|
                  |L72.56|
;;;705    	}
;;;706    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_ResetDevice)		//执行上电复位
000038  7d20              LDRB     r0,[r4,#0x14]
00003a  281f              CMP      r0,#0x1f
00003c  d115              BNE      |L72.106|
;;;707    	{
;;;708    		if(ISP_Conf->TimeCount++<10000)					//计时时间--100mS
00003e  f8d41a04          LDR      r1,[r4,#0xa04]
000042  1c48              ADDS     r0,r1,#1
000044  f8c40a04          STR      r0,[r4,#0xa04]
000048  f2427010          MOV      r0,#0x2710
00004c  4281              CMP      r1,r0
00004e  d203              BCS      |L72.88|
;;;709    		{			
;;;710    			Usart_MISP_ResetDevice(ISP_Conf);			//复位从机设备--使从机进行ISP模式			
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       Usart_MISP_ResetDevice
                  |L72.86|
000056  e19e              B        |L72.918|
                  |L72.88|
;;;711    		}
;;;712    		else
;;;713    		{
;;;714    			ISP_Conf->TimeCount=0;																			//计时时间--清零
000058  2000              MOVS     r0,#0
00005a  f8c40a04          STR      r0,[r4,#0xa04]
;;;715    			ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteConnect;				//ISP主机准备连接----复位后检测从机
00005e  2020              MOVS     r0,#0x20
000060  7520              STRB     r0,[r4,#0x14]
;;;716    			Usart_MISP_SetDevice(ISP_Conf);															//启动从机接收BOOT0使从机进行下载状态
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       Usart_MISP_SetDevice
000068  e195              B        |L72.918|
                  |L72.106|
;;;717    		}
;;;718    	}
;;;719    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteConnect)	//ISP主机准备连接----复位后检测从机
00006a  7d20              LDRB     r0,[r4,#0x14]
00006c  2820              CMP      r0,#0x20
00006e  d106              BNE      |L72.126|
;;;720    	{
;;;721    		ISP_Conf->MasterLastStatus=ISP_MSTATUS_WriteConnect;					//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:等待应答
000070  7560              STRB     r0,[r4,#0x15]
;;;722    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WaitAck;							//ISP主机等待从机应答
000072  2029              MOVS     r0,#0x29
000074  7520              STRB     r0,[r4,#0x14]
;;;723    		Usart_MISP_Connect(ISP_Conf);																	//主机连接从机函数
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       Usart_MISP_Connect
00007c  e18b              B        |L72.918|
                  |L72.126|
;;;724    	}
;;;725    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_Connectted)		//ISP主机与从机已经连接完成---准备写入数据/检查有没有读写保护，有则需要解除保护，没有就开始写数据
00007e  7d20              LDRB     r0,[r4,#0x14]
000080  2821              CMP      r0,#0x21
000082  d107              BNE      |L72.148|
;;;726    	{
;;;727    		ISP_Conf->MasterLastStatus=ISP_MSTATUS_WriteGet;							//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:禁止所有Flash扇区的写保护
000084  2028              MOVS     r0,#0x28
000086  7560              STRB     r0,[r4,#0x15]
;;;728    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WaitAck;							//ISP主机等待从机应答
000088  2029              MOVS     r0,#0x29
00008a  7520              STRB     r0,[r4,#0x14]
;;;729    		Usart_MISP_GetDevice(ISP_Conf);																//Write Unprotect命令用于禁止所有Flash扇区的写保护。
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       Usart_MISP_GetDevice
000092  e180              B        |L72.918|
                  |L72.148|
;;;730    	}
;;;731    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteUnprotect)		//ISP主机与从机已经连接完成---准备写入数据/检查有没有读写保护，有则需要解除保护，没有就开始写数据
000094  7d20              LDRB     r0,[r4,#0x14]
000096  2822              CMP      r0,#0x22
000098  d106              BNE      |L72.168|
;;;732    	{
;;;733    		ISP_Conf->MasterLastStatus=ISP_MSTATUS_WriteUnprotect;				//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:禁止所有Flash扇区的写保护
00009a  7560              STRB     r0,[r4,#0x15]
;;;734    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WaitAck;							//ISP主机等待从机应答
00009c  2029              MOVS     r0,#0x29
00009e  7520              STRB     r0,[r4,#0x14]
;;;735    		Usart_MISP_WriteUnprotect(ISP_Conf);													//Write Unprotect命令用于禁止所有Flash扇区的写保护。
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       Usart_MISP_WriteUnprotect
0000a6  e176              B        |L72.918|
                  |L72.168|
;;;736    	}
;;;737    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WaitUnprotect)		//ISP主机与从机已经连接完成---准备写入数据/检查有没有读写保护，有则需要解除保护，没有就开始写数据
0000a8  7d20              LDRB     r0,[r4,#0x14]
0000aa  2823              CMP      r0,#0x23
0000ac  d103              BNE      |L72.182|
;;;738    	{
;;;739    		ISP_Conf->MasterLastStatus=ISP_MSTATUS_WaitUnprotect;				//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:禁止所有Flash扇区的写保护
0000ae  7560              STRB     r0,[r4,#0x15]
;;;740    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WaitAck;							//ISP主机等待从机应答
0000b0  2029              MOVS     r0,#0x29
0000b2  7520              STRB     r0,[r4,#0x14]
0000b4  e16f              B        |L72.918|
                  |L72.182|
;;;741    	}
;;;742    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_FlashUnprotected)		//已禁止所有Flash扇区的写保护，可以进行写操作
0000b6  7d20              LDRB     r0,[r4,#0x14]
0000b8  2824              CMP      r0,#0x24
0000ba  d108              BNE      |L72.206|
;;;743    	{
;;;744    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteEraseCMD;							//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:擦除
0000bc  202a              MOVS     r0,#0x2a
0000be  7560              STRB     r0,[r4,#0x15]
;;;745    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;										//ISP主机等待从机应答
0000c0  2029              MOVS     r0,#0x29
0000c2  7520              STRB     r0,[r4,#0x14]
;;;746    		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_Erase);									//串口编程发送命令程序---擦除
0000c4  2143              MOVS     r1,#0x43
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       Usart_MISP_CommandSend
0000cc  e163              B        |L72.918|
                  |L72.206|
;;;747    	}
;;;748    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteEraseConf)						//发送擦除参数
0000ce  7d20              LDRB     r0,[r4,#0x14]
0000d0  282b              CMP      r0,#0x2b
0000d2  d107              BNE      |L72.228|
;;;749    	{
;;;750    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteEraseConf;								//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash---需要应答
0000d4  7560              STRB     r0,[r4,#0x15]
;;;751    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;												//ISP主机等待从机应答
0000d6  2029              MOVS     r0,#0x29
0000d8  7520              STRB     r0,[r4,#0x14]
;;;752    		Usart_MISP_CommandSend(ISP_Conf,0xFF);																	//全部擦除
0000da  21ff              MOVS     r1,#0xff
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       Usart_MISP_CommandSend
0000e2  e158              B        |L72.918|
                  |L72.228|
;;;753    	}	
;;;754    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_EraseDone)						//已经完成擦除
0000e4  7d20              LDRB     r0,[r4,#0x14]
0000e6  282c              CMP      r0,#0x2c
0000e8  d103              BNE      |L72.242|
;;;755    	{
;;;756    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_GetFirmwareInf;								//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:从应用程序指定的地址开始将最多 256 个字节的数据写入 RAM 或 Flash---需要应答
0000ea  2025              MOVS     r0,#0x25
0000ec  7560              STRB     r0,[r4,#0x15]
;;;757    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_GetFirmwareInf;							//ISP主机等待从机应答
0000ee  7520              STRB     r0,[r4,#0x14]
0000f0  e151              B        |L72.918|
                  |L72.242|
;;;758    	}	
;;;759    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_GetedFirmwareInf)
0000f2  7d20              LDRB     r0,[r4,#0x14]
0000f4  2827              CMP      r0,#0x27
0000f6  d109              BNE      |L72.268|
;;;760    	{
;;;761    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteWM;	//ISP_MSTATUS_WriteData
0000f8  2030              MOVS     r0,#0x30
0000fa  7560              STRB     r0,[r4,#0x15]
;;;762    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WriteWM;
0000fc  7520              STRB     r0,[r4,#0x14]
;;;763    		ISP_Conf->ISP_MDATA.WriteAddr=ISP_Conf->ISP_MDATA.GoAddr;							//起始地址
0000fe  f44f60a3          MOV      r0,#0x518
000102  5901              LDR      r1,[r0,r4]
000104  f44f60a7          MOV      r0,#0x538
000108  5101              STR      r1,[r0,r4]
00010a  e144              B        |L72.918|
                  |L72.268|
;;;764    //		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_WM);										//写MM命令
;;;765    	}
;;;766    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_ReadFirmware)
00010c  7d20              LDRB     r0,[r4,#0x14]
00010e  282d              CMP      r0,#0x2d
000110  d102              BNE      |L72.280|
;;;767    	{
;;;768    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_ReadFirmware;
000112  7560              STRB     r0,[r4,#0x15]
;;;769    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_ReadFirmware;
000114  7520              STRB     r0,[r4,#0x14]
000116  e13e              B        |L72.918|
                  |L72.280|
;;;770    	}
;;;771    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WaitFirmware)
000118  7d20              LDRB     r0,[r4,#0x14]
00011a  282e              CMP      r0,#0x2e
00011c  d10b              BNE      |L72.310|
;;;772    	{
;;;773    		if(ISP_Conf->OverRunTime++>400000)				//复位后2秒内没连接上从机重新复位模块
00011e  f8d41a00          LDR      r1,[r4,#0xa00]
000122  1c48              ADDS     r0,r1,#1
000124  f8c40a00          STR      r0,[r4,#0xa00]
000128  489c              LDR      r0,|L72.924|
00012a  4281              CMP      r1,r0
00012c  d993              BLS      |L72.86|
;;;774    		{
;;;775    			Usart_ISP_Reset(ISP_Conf);							//重置编程器---恢复所有参数为默认值
00012e  4620              MOV      r0,r4
000130  f7fffffe          BL       Usart_ISP_Reset
000134  e12f              B        |L72.918|
                  |L72.310|
;;;776    		}
;;;777    	}
;;;778    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_GettedFirmware)	//获取到固件
000136  7d20              LDRB     r0,[r4,#0x14]
000138  282f              CMP      r0,#0x2f
00013a  d109              BNE      |L72.336|
;;;779    	{
;;;780    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteData;
00013c  2032              MOVS     r0,#0x32
00013e  7520              STRB     r0,[r4,#0x14]
;;;781    //		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;
;;;782    		ISP_Conf->ISP_MDATA.WriteAddr+=0xFF;
000140  f44f60a7          MOV      r0,#0x538
000144  5900              LDR      r0,[r0,r4]
000146  30ff              ADDS     r0,r0,#0xff
000148  f44f61a7          MOV      r1,#0x538
00014c  5108              STR      r0,[r1,r4]
00014e  e122              B        |L72.918|
                  |L72.336|
;;;783    	}
;;;784    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteWM)
000150  7d20              LDRB     r0,[r4,#0x14]
000152  2830              CMP      r0,#0x30
000154  d107              BNE      |L72.358|
;;;785    	{
;;;786    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteWM;
000156  7560              STRB     r0,[r4,#0x15]
;;;787    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;
000158  2029              MOVS     r0,#0x29
00015a  7520              STRB     r0,[r4,#0x14]
;;;788    		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_WM);										//写MM命令
00015c  2131              MOVS     r1,#0x31
00015e  4620              MOV      r0,r4
000160  f7fffffe          BL       Usart_MISP_CommandSend
000164  e117              B        |L72.918|
                  |L72.358|
;;;789    	}
;;;790    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteAddr)						//写地址
000166  7d20              LDRB     r0,[r4,#0x14]
000168  2831              CMP      r0,#0x31
00016a  d122              BNE      |L72.434|
;;;791    	{
;;;792    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteAddr;
00016c  7560              STRB     r0,[r4,#0x15]
;;;793    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;
00016e  2029              MOVS     r0,#0x29
000170  7520              STRB     r0,[r4,#0x14]
;;;794    		ISP_Conf->ISP_DATA.ISP_TvBuffer[0]=ISP_Conf->ISP_MDATA.WriteAddr>>24;
000172  f44f60a7          MOV      r0,#0x538
000176  5900              LDR      r0,[r0,r4]
000178  0e01              LSRS     r1,r0,#24
00017a  f88413e2          STRB     r1,[r4,#0x3e2]
;;;795    		ISP_Conf->ISP_DATA.ISP_TvBuffer[1]=ISP_Conf->ISP_MDATA.WriteAddr>>16;
00017e  f44f60a7          MOV      r0,#0x538
000182  5900              LDR      r0,[r0,r4]
000184  0c01              LSRS     r1,r0,#16
000186  f88413e3          STRB     r1,[r4,#0x3e3]
;;;796    		ISP_Conf->ISP_DATA.ISP_TvBuffer[2]=ISP_Conf->ISP_MDATA.WriteAddr>>8;
00018a  f44f60a7          MOV      r0,#0x538
00018e  5b00              LDRH     r0,[r0,r4]
000190  0a01              LSRS     r1,r0,#8
000192  f88413e4          STRB     r1,[r4,#0x3e4]
;;;797    		ISP_Conf->ISP_DATA.ISP_TvBuffer[3]=ISP_Conf->ISP_MDATA.WriteAddr>>0;
000196  f8941538          LDRB     r1,[r4,#0x538]
00019a  f88413e5          STRB     r1,[r4,#0x3e5]
;;;798    		ISP_Conf->ISP_DATA.ISP_TvBuffer[4]=BCC8(ISP_Conf->ISP_DATA.ISP_TvBuffer,4);		//异或校验
00019e  2104              MOVS     r1,#4
0001a0  f20430e2          ADD      r0,r4,#0x3e2
0001a4  f7fffffe          BL       BCC8
0001a8  f88403e6          STRB     r0,[r4,#0x3e6]
;;;799    //		ISP_Conf->ISP_MDATA.WriteAddr+=ISP_BufferSize;
;;;800    		ISP_Conf->ISP_DATA.USARTSendLen=5;
0001ac  2105              MOVS     r1,#5
0001ae  63a1              STR      r1,[r4,#0x38]
0001b0  e0f1              B        |L72.918|
                  |L72.434|
;;;801    //		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_WM);										//写MM命令
;;;802    	}
;;;803    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteData)						//写地址
0001b2  7d20              LDRB     r0,[r4,#0x14]
0001b4  2832              CMP      r0,#0x32
0001b6  d107              BNE      |L72.456|
;;;804    	{
;;;805    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteData;
0001b8  7560              STRB     r0,[r4,#0x15]
;;;806    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;
0001ba  2029              MOVS     r0,#0x29
0001bc  7520              STRB     r0,[r4,#0x14]
;;;807    		ISP_Conf->ISP_DATA.USARTSendLen=ISP_Conf->ISP_MDATA.WriteLen;
0001be  f240503c          MOV      r0,#0x53c
0001c2  5901              LDR      r1,[r0,r4]
0001c4  63a1              STR      r1,[r4,#0x38]
0001c6  e0e6              B        |L72.918|
                  |L72.456|
;;;808    //		ISP_Conf->ISP_MDATA.SumHaveWritten+=ISP_Conf->ISP_MDATA.WriteLen-2;
;;;809    //		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_WM);										//写MM命令
;;;810    	}
;;;811    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteGo)						//写地址
0001c8  7d20              LDRB     r0,[r4,#0x14]
0001ca  2836              CMP      r0,#0x36
0001cc  d107              BNE      |L72.478|
;;;812    	{
;;;813    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteGo;
0001ce  7560              STRB     r0,[r4,#0x15]
;;;814    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;
0001d0  2029              MOVS     r0,#0x29
0001d2  7520              STRB     r0,[r4,#0x14]
;;;815    		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_Go);										//写MM命令
0001d4  2121              MOVS     r1,#0x21
0001d6  4620              MOV      r0,r4
0001d8  f7fffffe          BL       Usart_MISP_CommandSend
0001dc  e0db              B        |L72.918|
                  |L72.478|
;;;816    	}
;;;817    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WriteGoAddr)						//写地址
0001de  7d20              LDRB     r0,[r4,#0x14]
0001e0  2837              CMP      r0,#0x37
0001e2  d123              BNE      |L72.556|
;;;818    	{
;;;819    		ISP_Conf->MasterLastStatus	=ISP_MSTATUS_WriteGoAddr;
0001e4  7560              STRB     r0,[r4,#0x15]
;;;820    		ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WaitAck;
0001e6  2029              MOVS     r0,#0x29
0001e8  7520              STRB     r0,[r4,#0x14]
;;;821    		
;;;822    		ISP_Conf->ISP_DATA.ISP_TvBuffer[0]=ISP_Conf->ISP_MDATA.StartAddr>>24;
0001ea  f2405014          MOV      r0,#0x514
0001ee  5900              LDR      r0,[r0,r4]
0001f0  0e01              LSRS     r1,r0,#24
0001f2  f88413e2          STRB     r1,[r4,#0x3e2]
;;;823    		ISP_Conf->ISP_DATA.ISP_TvBuffer[1]=ISP_Conf->ISP_MDATA.StartAddr>>16;
0001f6  f2405014          MOV      r0,#0x514
0001fa  5900              LDR      r0,[r0,r4]
0001fc  0c01              LSRS     r1,r0,#16
0001fe  f88413e3          STRB     r1,[r4,#0x3e3]
;;;824    		ISP_Conf->ISP_DATA.ISP_TvBuffer[2]=ISP_Conf->ISP_MDATA.StartAddr>>8;
000202  f2405014          MOV      r0,#0x514
000206  5b00              LDRH     r0,[r0,r4]
000208  0a01              LSRS     r1,r0,#8
00020a  f88413e4          STRB     r1,[r4,#0x3e4]
;;;825    		ISP_Conf->ISP_DATA.ISP_TvBuffer[3]=ISP_Conf->ISP_MDATA.StartAddr>>0;
00020e  f2405014          MOV      r0,#0x514
000212  5d01              LDRB     r1,[r0,r4]
000214  f88413e5          STRB     r1,[r4,#0x3e5]
;;;826    		ISP_Conf->ISP_DATA.ISP_TvBuffer[4]=BCC8(ISP_Conf->ISP_DATA.ISP_TvBuffer,4);		//异或校验
000218  2104              MOVS     r1,#4
00021a  f20430e2          ADD      r0,r4,#0x3e2
00021e  f7fffffe          BL       BCC8
000222  f88403e6          STRB     r0,[r4,#0x3e6]
;;;827    		ISP_Conf->ISP_DATA.USARTSendLen=5;
000226  2105              MOVS     r1,#5
000228  63a1              STR      r1,[r4,#0x38]
00022a  e0b4              B        |L72.918|
                  |L72.556|
;;;828    		
;;;829    //		Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_Go);										//写MM命令
;;;830    	}
;;;831    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_ResetDevice2)						//写地址
00022c  7d20              LDRB     r0,[r4,#0x14]
00022e  2838              CMP      r0,#0x38
000230  d11a              BNE      |L72.616|
;;;832    	{
;;;833    		u32 timedelay=0;
000232  2500              MOVS     r5,#0
;;;834    		Usart_MISP_ResetDevice(ISP_Conf);				//复位从机
000234  4620              MOV      r0,r4
000236  f7fffffe          BL       Usart_MISP_ResetDevice
;;;835    		while(timedelay++<0xFFF);
00023a  bf00              NOP      
                  |L72.572|
00023c  4628              MOV      r0,r5
00023e  1c6d              ADDS     r5,r5,#1
000240  f64071ff          MOV      r1,#0xfff
000244  4288              CMP      r0,r1
000246  d3f9              BCC      |L72.572|
;;;836    		Usart_MISP_RunDevice(ISP_Conf);					//启动从机设备使从机正常运行
000248  4620              MOV      r0,r4
00024a  f7fffffe          BL       Usart_MISP_RunDevice
;;;837    		while(timedelay++<0xFFF);
00024e  bf00              NOP      
                  |L72.592|
000250  4628              MOV      r0,r5
000252  1c6d              ADDS     r5,r5,#1
000254  f64071ff          MOV      r1,#0xfff
000258  4288              CMP      r0,r1
00025a  d3f9              BCC      |L72.592|
;;;838    		ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WaitDeliver;		//等待释放从机
00025c  2039              MOVS     r0,#0x39
00025e  7520              STRB     r0,[r4,#0x14]
;;;839    		ISP_Conf->ISP_FUN=ISP_WaitDeliver;			//等待释放从机
000260  20a3              MOVS     r0,#0xa3
000262  f88409fc          STRB     r0,[r4,#0x9fc]
;;;840    //		GPIO_Configuration_IPD(ISP_Conf->RESET_CTL_PORT,ISP_Conf->RESET_CTL_Pin);			//将GPIO相应管脚配置为下拉输入模式----V20170605
;;;841    //		while(1);
;;;842    		
;;;843    	}
000266  e096              B        |L72.918|
                  |L72.616|
;;;844    	
;;;845    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_GetFirmwareInf||ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WaitFirmwareInf)
000268  7d20              LDRB     r0,[r4,#0x14]
00026a  2825              CMP      r0,#0x25
00026c  d002              BEQ      |L72.628|
00026e  7d20              LDRB     r0,[r4,#0x14]
000270  2826              CMP      r0,#0x26
000272  d10b              BNE      |L72.652|
                  |L72.628|
;;;846    	{
;;;847    		if(ISP_Conf->OverRunTime++>400000)				//复位后2秒内没连接上从机重新复位模块
000274  f8d41a00          LDR      r1,[r4,#0xa00]
000278  1c48              ADDS     r0,r1,#1
00027a  f8c40a00          STR      r0,[r4,#0xa00]
00027e  4847              LDR      r0,|L72.924|
000280  4281              CMP      r1,r0
000282  d902              BLS      |L72.650|
;;;848    		{
;;;849    			Usart_ISP_Reset(ISP_Conf);							//重置编程器---恢复所有参数为默认值
000284  4620              MOV      r0,r4
000286  f7fffffe          BL       Usart_ISP_Reset
                  |L72.650|
00028a  e084              B        |L72.918|
                  |L72.652|
;;;850    		}
;;;851    	}
;;;852    	else if(ISP_Conf->ISP_MASTER_STATUS==ISP_MSTATUS_WaitAck)				//ISP主机等待从机应答以及等待超时处理
00028c  7d20              LDRB     r0,[r4,#0x14]
00028e  2829              CMP      r0,#0x29
000290  d17d              BNE      |L72.910|
;;;853    	{
;;;854    		bool Result=FALSE;				//定义布尔变量
000292  2500              MOVS     r5,#0
;;;855    		Result=Usart_MISP_ReadAck(ISP_Conf);					//主机读取从机应答:有应答返回TRUE，否则返回FALSE
000294  4620              MOV      r0,r4
000296  f7fffffe          BL       Usart_MISP_ReadAck
00029a  4605              MOV      r5,r0
;;;856    		if(Result==TRUE)					//接收到应答
00029c  2d01              CMP      r5,#1
00029e  d15c              BNE      |L72.858|
;;;857    		{
;;;858    			if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteConnect)			//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:等待应答
0002a0  7d60              LDRB     r0,[r4,#0x15]
0002a2  2820              CMP      r0,#0x20
0002a4  d102              BNE      |L72.684|
;;;859    			{
;;;860    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_Connectted;					//ISP主机与从机已经连接完成
0002a6  2021              MOVS     r0,#0x21
0002a8  7520              STRB     r0,[r4,#0x14]
0002aa  e073              B        |L72.916|
                  |L72.684|
;;;861    			}
;;;862    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteGet)	//禁止所有Flash扇区的写保护
0002ac  7d60              LDRB     r0,[r4,#0x15]
0002ae  2828              CMP      r0,#0x28
0002b0  d102              BNE      |L72.696|
;;;863    			{
;;;864    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteUnprotect;			//已禁止所有Flash扇区的写保护，可以进行写操作
0002b2  2022              MOVS     r0,#0x22
0002b4  7520              STRB     r0,[r4,#0x14]
0002b6  e06d              B        |L72.916|
                  |L72.696|
;;;865    			}
;;;866    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteUnprotect)	//禁止所有Flash扇区的写保护
0002b8  7d60              LDRB     r0,[r4,#0x15]
0002ba  2822              CMP      r0,#0x22
0002bc  d102              BNE      |L72.708|
;;;867    			{
;;;868    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WaitUnprotect;			//已禁止所有Flash扇区的写保护，可以进行写操作
0002be  2023              MOVS     r0,#0x23
0002c0  7520              STRB     r0,[r4,#0x14]
0002c2  e067              B        |L72.916|
                  |L72.708|
;;;869    			}
;;;870    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WaitUnprotect)	//禁止所有Flash扇区的写保护
0002c4  7d60              LDRB     r0,[r4,#0x15]
0002c6  2823              CMP      r0,#0x23
0002c8  d102              BNE      |L72.720|
;;;871    			{
;;;872    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_FlashUnprotected;			//已禁止所有Flash扇区的写保护，可以进行写操作
0002ca  2024              MOVS     r0,#0x24
0002cc  7520              STRB     r0,[r4,#0x14]
0002ce  e061              B        |L72.916|
                  |L72.720|
;;;873    			}
;;;874    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteEraseCMD)	//擦除应答
0002d0  7d60              LDRB     r0,[r4,#0x15]
0002d2  282a              CMP      r0,#0x2a
0002d4  d102              BNE      |L72.732|
;;;875    			{
;;;876    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteEraseConf;				//输入擦除参数
0002d6  202b              MOVS     r0,#0x2b
0002d8  7520              STRB     r0,[r4,#0x14]
0002da  e05b              B        |L72.916|
                  |L72.732|
;;;877    			}
;;;878    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteEraseConf)	//擦除参数
0002dc  7d60              LDRB     r0,[r4,#0x15]
0002de  282b              CMP      r0,#0x2b
0002e0  d102              BNE      |L72.744|
;;;879    			{
;;;880    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_EraseDone;						//擦除完成
0002e2  202c              MOVS     r0,#0x2c
0002e4  7520              STRB     r0,[r4,#0x14]
0002e6  e055              B        |L72.916|
                  |L72.744|
;;;881    			}
;;;882    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteWM)	//擦除参数
0002e8  7d60              LDRB     r0,[r4,#0x15]
0002ea  2830              CMP      r0,#0x30
0002ec  d102              BNE      |L72.756|
;;;883    			{
;;;884    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteAddr;						//擦除完成
0002ee  2031              MOVS     r0,#0x31
0002f0  7520              STRB     r0,[r4,#0x14]
0002f2  e04f              B        |L72.916|
                  |L72.756|
;;;885    			}
;;;886    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteAddr)	//写地址
0002f4  7d60              LDRB     r0,[r4,#0x15]
0002f6  2831              CMP      r0,#0x31
0002f8  d102              BNE      |L72.768|
;;;887    			{
;;;888    				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_ReadFirmware;						//擦除完成
0002fa  202d              MOVS     r0,#0x2d
0002fc  7520              STRB     r0,[r4,#0x14]
0002fe  e049              B        |L72.916|
                  |L72.768|
;;;889    			}
;;;890    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteData)	//擦除参数
000300  7d60              LDRB     r0,[r4,#0x15]
000302  2832              CMP      r0,#0x32
000304  d11d              BNE      |L72.834|
;;;891    			{
;;;892    				ISP_Conf->ISP_MDATA.SumHaveWritten+=ISP_Conf->ISP_MDATA.WriteLen-2;
000306  f2405044          MOV      r0,#0x544
00030a  5901              LDR      r1,[r0,r4]
00030c  f240503c          MOV      r0,#0x53c
000310  5900              LDR      r0,[r0,r4]
000312  1e80              SUBS     r0,r0,#2
000314  4401              ADD      r1,r1,r0
000316  f2405044          MOV      r0,#0x544
00031a  5101              STR      r1,[r0,r4]
;;;893    				if(ISP_Conf->ISP_MDATA.SumHaveWritten<ISP_Conf->ISP_MDATA.FirmwareLen)
00031c  5901              LDR      r1,[r0,r4]
00031e  f240501c          MOV      r0,#0x51c
000322  5900              LDR      r0,[r0,r4]
000324  4281              CMP      r1,r0
000326  d209              BCS      |L72.828|
;;;894    				{
;;;895    					ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteWM;						//擦除完成	
000328  2030              MOVS     r0,#0x30
00032a  7520              STRB     r0,[r4,#0x14]
;;;896    					ISP_Conf->ISP_MDATA.WriteAddr+=1;					
00032c  f44f60a7          MOV      r0,#0x538
000330  5900              LDR      r0,[r0,r4]
000332  1c40              ADDS     r0,r0,#1
000334  f44f61a7          MOV      r1,#0x538
000338  5108              STR      r0,[r1,r4]
00033a  e02b              B        |L72.916|
                  |L72.828|
;;;897    				}
;;;898    				else
;;;899    				{
;;;900    					ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteGo;						//擦除完成
00033c  2036              MOVS     r0,#0x36
00033e  7520              STRB     r0,[r4,#0x14]
000340  e028              B        |L72.916|
                  |L72.834|
;;;901    				}
;;;902    			}
;;;903    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteGo)				//写运行地址
000342  7d60              LDRB     r0,[r4,#0x15]
000344  2836              CMP      r0,#0x36
000346  d102              BNE      |L72.846|
;;;904    			{
;;;905    				ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_WriteGoAddr;
000348  2037              MOVS     r0,#0x37
00034a  7520              STRB     r0,[r4,#0x14]
00034c  e022              B        |L72.916|
                  |L72.846|
;;;906    			}
;;;907    			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteGoAddr)		//完成
00034e  7d60              LDRB     r0,[r4,#0x15]
000350  2837              CMP      r0,#0x37
000352  d11f              BNE      |L72.916|
;;;908    			{
;;;909    				ISP_Conf->ISP_MASTER_STATUS	=ISP_MSTATUS_ResetDevice2;
000354  2038              MOVS     r0,#0x38
000356  7520              STRB     r0,[r4,#0x14]
000358  e01c              B        |L72.916|
                  |L72.858|
;;;910    			}
;;;911    		}
;;;912    		else											//无应答
;;;913    		{
;;;914    			if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteConnect)			//存储主机上一个状态，根据上一个状态等到从机应答时进行下一步操作:等待应答
00035a  7d60              LDRB     r0,[r4,#0x15]
00035c  2820              CMP      r0,#0x20
00035e  d119              BNE      |L72.916|
;;;915    			{
;;;916    				if(ISP_Conf->TimeCount++>1000)						//计时时间--100mS,超时无应答，重新发送连接命令
000360  f8d41a04          LDR      r1,[r4,#0xa04]
000364  1c48              ADDS     r0,r1,#1
000366  f8c40a04          STR      r0,[r4,#0xa04]
00036a  f5b17f7a          CMP      r1,#0x3e8
00036e  d904              BLS      |L72.890|
;;;917    				{
;;;918    					ISP_Conf->TimeCount=0;									//计时时间--清零
000370  2000              MOVS     r0,#0
000372  f8c40a04          STR      r0,[r4,#0xa04]
;;;919    					ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteConnect;		//ISP主机准备连接----复位后检测从机
000376  2020              MOVS     r0,#0x20
000378  7520              STRB     r0,[r4,#0x14]
                  |L72.890|
;;;920    				}
;;;921    				if(ISP_Conf->OverRunTime++>100000)				//复位后0.5秒内没连接上从机重新复位模块
00037a  f8d41a00          LDR      r1,[r4,#0xa00]
00037e  1c48              ADDS     r0,r1,#1
000380  f8c40a00          STR      r0,[r4,#0xa00]
000384  4806              LDR      r0,|L72.928|
000386  4281              CMP      r1,r0
000388  d904              BLS      |L72.916|
;;;922    				{
;;;923    					Usart_ISP_Reset(ISP_Conf);							//重置编程器---恢复所有参数为默认值
00038a  4620              MOV      r0,r4
00038c  e000              B        |L72.912|
                  |L72.910|
00038e  e002              B        |L72.918|
                  |L72.912|
000390  f7fffffe          BL       Usart_ISP_Reset
                  |L72.916|
;;;924    				}
;;;925    			}
;;;926    //			else if(ISP_Conf->MasterLastStatus==ISP_MSTATUS_WriteUnprotect)	//禁止所有Flash扇区的写保护
;;;927    //			{
;;;928    //				ISP_Conf->ISP_MASTER_STATUS=ISP_MSTATUS_WriteUnprotect;			//已禁止所有Flash扇区的写保护，可以进行写操作
;;;929    //			}
;;;930    		}
;;;931    	}
000394  bf00              NOP      
                  |L72.918|
;;;932    	
;;;933    }
000396  bd70              POP      {r4-r6,pc}
;;;934    u8 Usart_MISP_GetStatus(ISP_Conf_TypeDef *ISP_Conf)	//返回从机状态值
                          ENDP

                  |L72.920|
                          DCD      0x001e8480
                  |L72.924|
                          DCD      0x00061a80
                  |L72.928|
                          DCD      0x000186a0

                          AREA ||i.Usart_MISP_WriteUnprotect||, CODE, READONLY, ALIGN=1

                  Usart_MISP_WriteUnprotect PROC
;;;963    *******************************************************************************/
;;;964    void Usart_MISP_WriteUnprotect(ISP_Conf_TypeDef *ISP_Conf)			//Write Unprotect命令用于禁止所有Flash扇区的写保护。
000000  b510              PUSH     {r4,lr}
;;;965    {
000002  4604              MOV      r4,r0
;;;966    	Usart_MISP_CommandSend(ISP_Conf,ISP_COMMAND_WU);	//串口编程发送命令程序
000004  2173              MOVS     r1,#0x73
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       Usart_MISP_CommandSend
;;;967    }
00000c  bd10              POP      {r4,pc}
;;;968    /*******************************************************************************
                          ENDP

