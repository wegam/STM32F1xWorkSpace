; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32f10x_tim.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32f10x_tim.crf ..\..\Library\STM32F10x_StdPeriph_Driver\SCR\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3053   *******************************************************************************/
;;;3054   static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3055                          u16 TIM_ICFilter)
;;;3056   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3057     u16 tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;3058   
;;;3059     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3060     TIMx->CCER &= CCER_CC1E_Reset;
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;3061   
;;;3062     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;3063     tmpccer = TIMx->CCER;
000016  8c02              LDRH     r2,[r0,#0x20]
;;;3064   
;;;3065     /* Select the Input and set the filter */
;;;3066     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000018  f64f760c          MOV      r6,#0xff0c
00001c  4031              ANDS     r1,r1,r6
;;;3067     tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4331              ORRS     r1,r1,r6
;;;3068   
;;;3069     /* Select the Polarity and set the CC1E Bit */
;;;3070     tmpccer &= CCER_CC1P_Reset;
000028  1e7e              SUBS     r6,r7,#1
00002a  4032              ANDS     r2,r2,r6
;;;3071     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
00002c  f0440601          ORR      r6,r4,#1
000030  4332              ORRS     r2,r2,r6
;;;3072   
;;;3073     /* Write to TIMx CCMR1 and CCER registers */
;;;3074     TIMx->CCMR1 = tmpccmr1;
000032  8301              STRH     r1,[r0,#0x18]
;;;3075     TIMx->CCER = tmpccer;
000034  8402              STRH     r2,[r0,#0x20]
;;;3076   }
000036  bdf0              POP      {r4-r7,pc}
;;;3077   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3099   *******************************************************************************/
;;;3100   static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3101                          u16 TIM_ICFilter)
;;;3102   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3103     u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3104   
;;;3105     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3106     TIMx->CCER &= CCER_CC2E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3107   
;;;3108     tmpccmr1 = TIMx->CCMR1;
000018  8b01              LDRH     r1,[r0,#0x18]
;;;3109     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3110     tmp = (u16)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;3111   
;;;3112     /* Select the Input and set the filter */
;;;3113     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3114     tmpccmr1 |= (u16)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  4339              ORRS     r1,r1,r7
;;;3115     tmpccmr1 |= (u16)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  4339              ORRS     r1,r1,r7
;;;3116   
;;;3117     /* Select the Polarity and set the CC2E Bit */
;;;3118     tmpccer &= CCER_CC2P_Reset;
00003e  f64f77df          MOV      r7,#0xffdf
000042  403a              ANDS     r2,r2,r7
;;;3119     tmpccer |=  tmp | CCER_CC2E_Set;
000044  f0460710          ORR      r7,r6,#0x10
000048  433a              ORRS     r2,r2,r7
;;;3120   
;;;3121     /* Write to TIMx CCMR1 and CCER registers */
;;;3122     TIMx->CCMR1 = tmpccmr1 ;
00004a  8301              STRH     r1,[r0,#0x18]
;;;3123     TIMx->CCER = tmpccer;
00004c  8402              STRH     r2,[r0,#0x20]
;;;3124   }
00004e  bdf0              POP      {r4-r7,pc}
;;;3125   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;3147   *******************************************************************************/
;;;3148   static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3149                          u16 TIM_ICFilter)
;;;3150   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3151     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3152   
;;;3153     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3154     TIMx->CCER &= CCER_CC3E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3155   
;;;3156     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3157     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3158     tmp = (u16)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;3159   
;;;3160     /* Select the Input and set the filter */
;;;3161     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000024  f64f770c          MOV      r7,#0xff0c
000028  4039              ANDS     r1,r1,r7
;;;3162     tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  4339              ORRS     r1,r1,r7
;;;3163   
;;;3164     /* Select the Polarity and set the CC3E Bit */
;;;3165     tmpccer &= CCER_CC3P_Reset;
000036  f64f57ff          MOV      r7,#0xfdff
00003a  403a              ANDS     r2,r2,r7
;;;3166     tmpccer |= tmp | CCER_CC3E_Set;
00003c  f4467780          ORR      r7,r6,#0x100
000040  433a              ORRS     r2,r2,r7
;;;3167   
;;;3168     /* Write to TIMx CCMR2 and CCER registers */
;;;3169     TIMx->CCMR2 = tmpccmr2;
000042  8381              STRH     r1,[r0,#0x1c]
;;;3170     TIMx->CCER = tmpccer;
000044  8402              STRH     r2,[r0,#0x20]
;;;3171   }
000046  bdf0              POP      {r4-r7,pc}
;;;3172   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;3194   *******************************************************************************/
;;;3195   static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3196                          u16 TIM_ICFilter)
;;;3197   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3198     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3199   
;;;3200     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3201     TIMx->CCER &= CCER_CC4E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3202   
;;;3203     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3204     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3205     tmp = (u16)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;3206   
;;;3207     /* Select the Input and set the filter */
;;;3208     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3209     tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  f64f7cff          MOV      r12,#0xffff
000036  ea0c3c03          AND      r12,r12,r3,LSL #12
00003a  ea47070c          ORR      r7,r7,r12
00003e  4339              ORRS     r1,r1,r7
;;;3210   
;;;3211     /* Select the Polarity and set the CC4E Bit */
;;;3212     tmpccer &= CCER_CC4P_Reset;
000040  f64d77ff          MOV      r7,#0xdfff
000044  403a              ANDS     r2,r2,r7
;;;3213     tmpccer |= tmp | CCER_CC4E_Set;
000046  f4465780          ORR      r7,r6,#0x1000
00004a  433a              ORRS     r2,r2,r7
;;;3214   
;;;3215     /* Write to TIMx CCMR2 and CCER registers */
;;;3216     TIMx->CCMR2 = tmpccmr2;
00004c  8381              STRH     r1,[r0,#0x1c]
;;;3217     TIMx->CCER = tmpccer ;
00004e  8402              STRH     r2,[r0,#0x20]
;;;3218   }
000050  bdf0              POP      {r4-r7,pc}
;;;3219   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1537   *******************************************************************************/
;;;1538   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;1539   {
;;;1540     /* Check the parameters */
;;;1541     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1542     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1543   
;;;1544     if (NewState != DISABLE)
;;;1545     {
;;;1546       /* Set the ARR Preload Bit */
;;;1547       TIMx->CR1 |= CR1_ARPE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;1548     }
;;;1549     else
;;;1550     {
;;;1551       /* Reset the ARR Preload Bit */
;;;1552       TIMx->CR1 &= CR1_ARPE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f240337f          MOV      r3,#0x37f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;1553     }
;;;1554   }
000016  4770              BX       lr
;;;1555   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;720    *******************************************************************************/
;;;721    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;722    {
;;;723      /* Check the parameters */
;;;724      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;725      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;726      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;727      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;728      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;729      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;730      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;731    
;;;732      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;733         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;734    
;;;735      TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;736                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;737                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;738                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;739    
;;;740    }
00001e  4770              BX       lr
;;;741    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;806    *******************************************************************************/
;;;807    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;808    {
;;;809      /* Set the default configuration */
;;;810      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;811      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;812      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;813      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;814      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;815      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;816      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;817    }
000010  4770              BX       lr
;;;818    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1620   *******************************************************************************/
;;;1621   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1622   { 
;;;1623     /* Check the parameters */
;;;1624     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1625     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1626   
;;;1627     if (NewState != DISABLE)
;;;1628     {
;;;1629       /* Set the CCPC Bit */
;;;1630       TIMx->CR2 |= CR2_CCPC_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1631     }
;;;1632     else
;;;1633     {
;;;1634       /* Reset the CCPC Bit */
;;;1635       TIMx->CR2 &= CR2_CCPC_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1636     }
;;;1637   }
000016  4770              BX       lr
;;;1638   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;2253   *******************************************************************************/
;;;2254   void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;2255   {
;;;2256     /* Check the parameters */
;;;2257     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2258     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2259     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2260   
;;;2261     /* Reset the CCxE Bit */
;;;2262     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2263   
;;;2264     /* Set or reset the CCxE Bit */ 
;;;2265     TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  fa02f401          LSL      r4,r2,r1
000012  b2a4              UXTH     r4,r4
000014  4323              ORRS     r3,r3,r4
000016  8403              STRH     r3,[r0,#0x20]
;;;2266   }
000018  bd10              POP      {r4,pc}
;;;2267   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2281   *******************************************************************************/
;;;2282   void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2283   {
;;;2284     /* Check the parameters */
;;;2285     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2286     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2287     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2288   
;;;2289     /* Reset the CCxNE Bit */
;;;2290     TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2291   
;;;2292     /* Set or reset the CCxNE Bit */ 
;;;2293     TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  fa02f401          LSL      r4,r2,r1
000012  b2a4              UXTH     r4,r4
000014  4323              ORRS     r3,r3,r4
000016  8403              STRH     r3,[r0,#0x20]
;;;2294   }
000018  bd10              POP      {r4,pc}
;;;2295   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2949   *******************************************************************************/
;;;2950   void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2951   {  
;;;2952     /* Check the parameters */
;;;2953     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2954     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2955     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2956      
;;;2957     /* Clear the flags */
;;;2958     TIMx->SR = (u16)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2959   }
000004  4770              BX       lr
;;;2960   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;3021   *******************************************************************************/
;;;3022   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
000000  43ca              MVNS     r2,r1
;;;3023   {
;;;3024     /* Check the parameters */
;;;3025     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3026     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;3027   
;;;3028     /* Clear the IT pending Bit */
;;;3029     TIMx->SR = (u16)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;3030   }
000004  4770              BX       lr
;;;3031   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1914   *******************************************************************************/
;;;1915   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1916   {
;;;1917     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1918   
;;;1919     /* Check the parameters */
;;;1920     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1921     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1922   
;;;1923     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1924   
;;;1925     /* Reset the OC1CE Bit */
;;;1926     tmpccmr1 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1927   
;;;1928     /* Enable or Disable the Output Compare Clear Bit */
;;;1929     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1930   
;;;1931     /* Write to TIMx CCMR1 register */
;;;1932     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1933   }
000010  4770              BX       lr
;;;1934   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1946   *******************************************************************************/
;;;1947   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1948   {
;;;1949     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1950   
;;;1951     /* Check the parameters */
;;;1952     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1953     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1954   
;;;1955     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1956   
;;;1957     /* Reset the OC2CE Bit */
;;;1958     tmpccmr1 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1959   
;;;1960     /* Enable or Disable the Output Compare Clear Bit */
;;;1961     tmpccmr1 |= (u16)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1962   
;;;1963     /* Write to TIMx CCMR1 register */
;;;1964     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;1965   }
000016  4770              BX       lr
;;;1966   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1978   *******************************************************************************/
;;;1979   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1980   {
;;;1981     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1982   
;;;1983     /* Check the parameters */
;;;1984     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1985     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1986   
;;;1987     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1988   
;;;1989     /* Reset the OC3CE Bit */
;;;1990     tmpccmr2 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1991   
;;;1992     /* Enable or Disable the Output Compare Clear Bit */
;;;1993     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1994   
;;;1995     /* Write to TIMx CCMR2 register */
;;;1996     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1997   }
000010  4770              BX       lr
;;;1998   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;2010   *******************************************************************************/
;;;2011   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000000  460a              MOV      r2,r1
;;;2012   {
;;;2013     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;2014   
;;;2015     /* Check the parameters */
;;;2016     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2017     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;2018   
;;;2019     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;2020   
;;;2021     /* Reset the OC4CE Bit */
;;;2022     tmpccmr2 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;2023   
;;;2024     /* Enable or Disable the Output Compare Clear Bit */
;;;2025     tmpccmr2 |= (u16)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;2026   
;;;2027     /* Write to TIMx CCMR2 register */
;;;2028     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;2029   }
000016  4770              BX       lr
;;;2030   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;827    *******************************************************************************/
;;;828    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;829    {
;;;830      /* Check the parameters */
;;;831      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;832      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;833      
;;;834      if (NewState != DISABLE)
;;;835      {
;;;836        /* Enable the TIM Counter */
;;;837        TIMx->CR1 |= CR1_CEN_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;838      }
;;;839      else
;;;840      {
;;;841        /* Disable the TIM Counter */
;;;842        TIMx->CR1 &= CR1_CEN_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fe          MOV      r3,#0x3fe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;843      }
;;;844    }
000016  4770              BX       lr
;;;845    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1265   *******************************************************************************/
;;;1266   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;1267   {
;;;1268     u16 tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;1269   
;;;1270     /* Check the parameters */
;;;1271     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1272     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1273   
;;;1274     tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;1275   
;;;1276     /* Reset the CMS and DIR Bits */
;;;1277     tmpcr1 &= CR1_CounterMode_Mask;
000006  f240338f          MOV      r3,#0x38f
00000a  4019              ANDS     r1,r1,r3
;;;1278   
;;;1279     /* Set the Counter Mode */
;;;1280     tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;1281   
;;;1282     /* Write to TIMx CR1 register */
;;;1283     TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;1284   }
000010  4770              BX       lr
;;;1285   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;854    *******************************************************************************/
;;;855    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;856    {
;;;857      /* Check the parameters */
;;;858      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;859      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;860    
;;;861      if (NewState != DISABLE)
;;;862      {
;;;863        /* Enable the TIM Main Output */
;;;864        TIMx->BDTR |= BDTR_MOE_Set;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;865      }
;;;866      else
;;;867      {
;;;868        /* Disable the TIM Main Output */
;;;869        TIMx->BDTR &= BDTR_MOE_Reset;
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;870      }  
;;;871    }
00001c  4770              BX       lr
;;;872    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;987    *******************************************************************************/
;;;988    void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;989    { 
;;;990      /* Check the parameters */
;;;991      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;992      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;993      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;994      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;995      
;;;996      if (NewState != DISABLE)
;;;997      {
;;;998        /* Enable the DMA sources */
;;;999        TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;1000     }
;;;1001     else
;;;1002     {
;;;1003       /* Disable the DMA sources */
;;;1004       TIMx->DIER &= (u16)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;1005     }
;;;1006   }
000010  4770              BX       lr
;;;1007   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;958    *******************************************************************************/
;;;959    void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;960    {
;;;961      /* Check the parameters */
;;;962      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;963      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;964      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;965    
;;;966      /* Set the DMA Base and the DMA Burst Length */
;;;967      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;968    }
000008  4770              BX       lr
;;;969    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;133    *******************************************************************************/
;;;134    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;135    {
000002  4604              MOV      r4,r0
;;;136      /* Check the parameters */
;;;137      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;138     
;;;139      switch (*(u32*)&TIMx)
000004  4934              LDR      r1,|L22.216|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d045              BEQ      |L22.152|
00000c  dc0c              BGT      |L22.40|
00000e  f1b44f80          CMP      r4,#0x40000000
000012  d01d              BEQ      |L22.80|
000014  4831              LDR      r0,|L22.220|
000016  4420              ADD      r0,r0,r4
000018  b318              CBZ      r0,|L22.98|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d029              BEQ      |L22.116|
000020  f5b06f00          CMP      r0,#0x800
000024  d154              BNE      |L22.208|
000026  e02e              B        |L22.134|
                  |L22.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d03d              BEQ      |L22.170|
00002e  f5b03f8e          CMP      r0,#0x11c00
000032  d003              BEQ      |L22.60|
000034  f5b03f92          CMP      r0,#0x12400
000038  d14a              BNE      |L22.208|
00003a  e03f              B        |L22.188|
                  |L22.60|
;;;140      {
;;;141        case TIM1_BASE:
;;;142          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  02c8              LSLS     r0,r1,#11
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;143          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000044  2100              MOVS     r1,#0
000046  f44f6000          MOV      r0,#0x800
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;144          break; 
00004e  e040              B        |L22.210|
                  |L22.80|
;;;145          
;;;146        case TIM2_BASE:
;;;147          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;148          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;149          break;
000060  e037              B        |L22.210|
                  |L22.98|
;;;150     
;;;151        case TIM3_BASE:
;;;152          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;153          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00006a  2100              MOVS     r1,#0
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154          break;
000072  e02e              B        |L22.210|
                  |L22.116|
;;;155     
;;;156        case TIM4_BASE:
;;;157          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000074  2101              MOVS     r1,#1
000076  2004              MOVS     r0,#4
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00007c  2100              MOVS     r1,#0
00007e  2004              MOVS     r0,#4
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159          break;
000084  e025              B        |L22.210|
                  |L22.134|
;;;160          
;;;161        case TIM5_BASE:
;;;162          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000086  2101              MOVS     r1,#1
000088  2008              MOVS     r0,#8
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;163          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2008              MOVS     r0,#8
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;164          break;
000096  e01c              B        |L22.210|
                  |L22.152|
;;;165          
;;;166        case TIM6_BASE:
;;;167          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000098  2101              MOVS     r1,#1
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;168          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;169          break;
0000a8  e013              B        |L22.210|
                  |L22.170|
;;;170          
;;;171        case TIM7_BASE:
;;;172          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  2020              MOVS     r0,#0x20
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;173          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000b2  2100              MOVS     r1,#0
0000b4  2020              MOVS     r0,#0x20
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;174          break;
0000ba  e00a              B        |L22.210|
                  |L22.188|
;;;175          
;;;176        case TIM8_BASE:
;;;177          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  0348              LSLS     r0,r1,#13
0000c0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;178          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  f44f5000          MOV      r0,#0x2000
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;179          break; 
0000ce  e000              B        |L22.210|
                  |L22.208|
;;;180          
;;;181        default:
;;;182          break;
0000d0  bf00              NOP      
                  |L22.210|
0000d2  bf00              NOP                            ;144
;;;183      }
;;;184    }
0000d4  bd10              POP      {r4,pc}
;;;185    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L22.216|
                          DCD      0x40001000
                  |L22.220|
                          DCD      0xbffffc00

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1114   *******************************************************************************/
;;;1115   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1116                                u16 ExtTRGFilter)
;;;1117   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1118     u16 tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;1119   
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1122     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1123     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1124     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1125   
;;;1126     /* Configure the ETR Clock source */
;;;1127     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;1128     
;;;1129     /* Get the TIMx SMCR register value */
;;;1130     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;1131   
;;;1132     /* Reset the SMS Bits */
;;;1133     tmpsmcr &= SMCR_SMS_Mask;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;1134     /* Select the External clock mode1 */
;;;1135     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;1136   
;;;1137     /* Select the Trigger selection : ETRF */
;;;1138     tmpsmcr &= SMCR_TS_Mask;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;1139     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;1140   
;;;1141     /* Write to TIMx SMCR */
;;;1142     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;1143   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1144   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1164   *******************************************************************************/
;;;1165   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1166                                u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
;;;1167   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1168     /* Check the parameters */
;;;1169     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1170     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1171     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1172     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1173   
;;;1174     /* Configure the ETR Clock source */
;;;1175     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;1176   
;;;1177     /* Enable the External clock mode2 */
;;;1178     TIMx->SMCR |= SMCR_ECE_Set;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;1179   }
00001e  bdf0              POP      {r4-r7,pc}
;;;1180   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1200   *******************************************************************************/
;;;1201   void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000000  b570              PUSH     {r4-r6,lr}
;;;1202                      u16 ExtTRGFilter)
;;;1203   {
000002  460c              MOV      r4,r1
;;;1204     u16 tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1208     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1209     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1210     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1211   
;;;1212     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;1213   
;;;1214     /* Reset the ETR Bits */
;;;1215     tmpsmcr &= SMCR_ETR_Mask;
000008  b2c9              UXTB     r1,r1
;;;1216   
;;;1217     /* Set the Prescaler, the Filter value and the Polarity */
;;;1218     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
00000a  ea440502          ORR      r5,r4,r2
00000e  f64f76ff          MOV      r6,#0xffff
000012  ea062603          AND      r6,r6,r3,LSL #8
000016  4335              ORRS     r5,r5,r6
000018  4329              ORRS     r1,r1,r5
;;;1219   
;;;1220     /* Write to TIMx SMCR */
;;;1221     TIMx->SMCR = tmpsmcr;
00001a  8101              STRH     r1,[r0,#8]
;;;1222   }
00001c  bd70              POP      {r4-r6,pc}
;;;1223   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1348   *******************************************************************************/
;;;1349   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1350                                   u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
;;;1351   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;1352     u16 tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;1353     u16 tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;1354     u16 tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;1355       
;;;1356     /* Check the parameters */
;;;1357     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1358     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1359     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1360     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1361   
;;;1362     /* Get the TIMx SMCR register value */
;;;1363     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;1364   
;;;1365     /* Get the TIMx CCMR1 register value */
;;;1366     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;1367   
;;;1368     /* Get the TIMx CCER register value */
;;;1369     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;1370   
;;;1371     /* Set the encoder Mode */
;;;1372     tmpsmcr &= SMCR_SMS_Mask;
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;1373     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;1374   
;;;1375     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1376     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;1377     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;1378   
;;;1379     /* Set the TI1 and the TI2 Polarities */
;;;1380     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;1381     tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;1382   
;;;1383     /* Write to TIMx SMCR */
;;;1384     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;1385   
;;;1386     /* Write to TIMx CCMR1 */
;;;1387     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;1388   
;;;1389     /* Write to TIMx CCER */
;;;1390     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;1391   }
000040  bdf0              POP      {r4-r7,pc}
;;;1392   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1406   *******************************************************************************/
;;;1407   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1408   {
;;;1409     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1410   
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1413     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1414   
;;;1415     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1416   
;;;1417     /* Reset the OC1M Bits */
;;;1418     tmpccmr1 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1419   
;;;1420     /* Configure The Forced output Mode */
;;;1421     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1422   
;;;1423     /* Write to TIMx CCMR1 register */
;;;1424     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1425   }
000010  4770              BX       lr
;;;1426   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1440   *******************************************************************************/
;;;1441   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1442   {
;;;1443     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1444   
;;;1445     /* Check the parameters */
;;;1446     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1447     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1448   
;;;1449     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1450   
;;;1451     /* Reset the OC2M Bits */
;;;1452     tmpccmr1 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1453   
;;;1454     /* Configure The Forced output Mode */
;;;1455     tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1456   
;;;1457     /* Write to TIMx CCMR1 register */
;;;1458     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1459   }
000018  4770              BX       lr
;;;1460   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1474   *******************************************************************************/
;;;1475   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1476   {
;;;1477     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1478   
;;;1479     /* Check the parameters */
;;;1480     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1481     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1482   
;;;1483     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1484   
;;;1485     /* Reset the OC1M Bits */
;;;1486     tmpccmr2 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1487   
;;;1488     /* Configure The Forced output Mode */
;;;1489     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1490   
;;;1491     /* Write to TIMx CCMR2 register */
;;;1492     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1493   }
000010  4770              BX       lr
;;;1494   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1508   *******************************************************************************/
;;;1509   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1510   {
;;;1511     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1512   
;;;1513     /* Check the parameters */
;;;1514     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1515     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1516     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1517   
;;;1518     /* Reset the OC2M Bits */
;;;1519     tmpccmr2 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1520   
;;;1521     /* Configure The Forced output Mode */
;;;1522     tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1523   
;;;1524     /* Write to TIMx CCMR2 register */
;;;1525     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1526   }
000018  4770              BX       lr
;;;1527   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;927    *******************************************************************************/
;;;928    void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;929    { 
;;;930      /* Check the parameters */
;;;931      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;932      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;933      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;934    
;;;935      /* Set the event sources */
;;;936      TIMx->EGR = TIM_EventSource;
;;;937    }
000002  4770              BX       lr
;;;938    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2795   *******************************************************************************/
;;;2796   u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2797   {
;;;2798     /* Check the parameters */
;;;2799     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2800   
;;;2801     /* Get the Capture 1 Register value */
;;;2802     return TIMx->CCR1;
000002  8e88              LDRH     r0,[r1,#0x34]
;;;2803   }
000004  4770              BX       lr
;;;2804   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2812   *******************************************************************************/
;;;2813   u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2814   {
;;;2815     /* Check the parameters */
;;;2816     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2817   
;;;2818     /* Get the Capture 2 Register value */
;;;2819     return TIMx->CCR2;
000002  8f08              LDRH     r0,[r1,#0x38]
;;;2820   }
000004  4770              BX       lr
;;;2821   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2829   *******************************************************************************/
;;;2830   u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2831   {
;;;2832     /* Check the parameters */
;;;2833     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2834   
;;;2835     /* Get the Capture 3 Register value */
;;;2836     return TIMx->CCR3;
000002  8f88              LDRH     r0,[r1,#0x3c]
;;;2837   }
000004  4770              BX       lr
;;;2838   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2846   *******************************************************************************/
;;;2847   u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2848   {
;;;2849     /* Check the parameters */
;;;2850     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2851   
;;;2852     /* Get the Capture 4 Register value */
;;;2853     return TIMx->CCR4;
000002  f8b10040          LDRH     r0,[r1,#0x40]
;;;2854   }
000006  4770              BX       lr
;;;2855   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2862   *******************************************************************************/
;;;2863   u16 TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2864   {
;;;2865     /* Check the parameters */
;;;2866     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2867   
;;;2868     /* Get the Counter Register value */
;;;2869     return TIMx->CNT;
000002  8c88              LDRH     r0,[r1,#0x24]
;;;2870   }
000004  4770              BX       lr
;;;2871   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2908   *******************************************************************************/
;;;2909   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2910   { 
;;;2911     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2912   
;;;2913     /* Check the parameters */
;;;2914     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2915     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2916     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2917     
;;;2918     if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;2919     {
;;;2920       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2921     }
;;;2922     else
;;;2923     {
;;;2924       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2925     }
;;;2926     return bitstatus;
;;;2927   }
000010  4770              BX       lr
;;;2928   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2978   *******************************************************************************/
;;;2979   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2980   {
000002  4602              MOV      r2,r0
;;;2981     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2982     u16 itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2983   
;;;2984     /* Check the parameters */
;;;2985     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2986     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2987     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2988      
;;;2989     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2990     
;;;2991     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2992   
;;;2993     if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2994     {
;;;2995       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2996     }
;;;2997     else
;;;2998     {
;;;2999       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;3000     }
;;;3001     return bitstatus;
;;;3002   }
000020  bd30              POP      {r4,r5,pc}
;;;3003   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2878   *******************************************************************************/
;;;2879   u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2880   {
;;;2881     /* Check the parameters */
;;;2882     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2883   
;;;2884     /* Get the Prescaler Register value */
;;;2885     return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;2886   }
000004  4770              BX       lr
;;;2887   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;584    *******************************************************************************/
;;;585    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;586    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;587      /* Check the parameters */
;;;588      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;589      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;590      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;591      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;592      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;593      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;594      
;;;595      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;596      {
;;;597        /* TI1 Configuration */
;;;598        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;599                   TIM_ICInitStruct->TIM_ICSelection,
;;;600                   TIM_ICInitStruct->TIM_ICFilter);
;;;601    
;;;602        /* Set the Input Capture Prescaler value */
;;;603        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;604      }
;;;605      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;606      {
;;;607        /* TI2 Configuration */
;;;608        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;609                   TIM_ICInitStruct->TIM_ICSelection,
;;;610                   TIM_ICInitStruct->TIM_ICFilter);
;;;611    
;;;612        /* Set the Input Capture Prescaler value */
;;;613        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;614      }
;;;615      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;616      {
;;;617        /* TI3 Configuration */
;;;618        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;619                   TIM_ICInitStruct->TIM_ICSelection,
;;;620                   TIM_ICInitStruct->TIM_ICFilter);
;;;621    
;;;622        /* Set the Input Capture Prescaler value */
;;;623        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;624      }
;;;625      else
;;;626      {
;;;627        /* TI4 Configuration */
;;;628        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;629                   TIM_ICInitStruct->TIM_ICSelection,
;;;630                   TIM_ICInitStruct->TIM_ICFilter);
;;;631    
;;;632        /* Set the Input Capture Prescaler value */
;;;633        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;634      }
;;;635    }
00006c  bd70              POP      {r4-r6,pc}
;;;636    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;788    *******************************************************************************/
;;;789    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;790    {
;;;791      /* Set the default configuration */
;;;792      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;793      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;794      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;795      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;796      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;797    }
000010  4770              BX       lr
;;;798    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;892    *******************************************************************************/
;;;893    void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;894    {  
;;;895      /* Check the parameters */
;;;896      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;897      assert_param(IS_TIM_IT(TIM_IT));
;;;898      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;899      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;900      
;;;901      if (NewState != DISABLE)
;;;902      {
;;;903        /* Enable the Interrupt sources */
;;;904        TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;905      }
;;;906      else
;;;907      {
;;;908        /* Disable the Interrupt sources */
;;;909        TIMx->DIER &= (u16)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;910      }
;;;911    }
000010  4770              BX       lr
;;;912    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;1037   *******************************************************************************/
;;;1038   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1039   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1042     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1043   
;;;1044     /* Select the Internal Trigger */
;;;1045     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;1046   
;;;1047     /* Select the External clock mode1 */
;;;1048     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;1049   }
000016  bd30              POP      {r4,r5,pc}
;;;1050   /*******************************************************************************
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;1015   *******************************************************************************/
;;;1016   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;1017   {
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1020   
;;;1021     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;1022     TIMx->SMCR &=  SMCR_SMS_Mask;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;1023   }
00000a  4770              BX       lr
;;;1024   /*******************************************************************************
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1782   *******************************************************************************/
;;;1783   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1784   {
;;;1785     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1786   
;;;1787     /* Check the parameters */
;;;1788     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1789     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1790   
;;;1791     /* Get the TIMx CCMR1 register value */
;;;1792     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1793   
;;;1794     /* Reset the OC1FE Bit */
;;;1795     tmpccmr1 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1796   
;;;1797     /* Enable or Disable the Output Compare Fast Bit */
;;;1798     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1799   
;;;1800     /* Write to TIMx CCMR1 */
;;;1801     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1802   }
000010  4770              BX       lr
;;;1803   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;236    *******************************************************************************/
;;;237    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
;;;239      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;240       
;;;241      /* Check the parameters */
;;;242      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;243      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;244      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;245      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;246    
;;;247      /* Disable the Channel 1: Reset the CC1E Bit */
;;;248      TIMx->CCER &= CCER_CC1E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;249      
;;;250      /* Get the TIMx CCER register value */
;;;251      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;252    
;;;253      /* Get the TIMx CR2 register value */
;;;254      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;255      
;;;256      /* Get the TIMx CCMR1 register value */
;;;257      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;258        
;;;259      /* Reset the Output Compare Mode Bits */
;;;260      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;261      
;;;262      /* Select the Output Compare Mode */
;;;263      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;264      
;;;265      /* Reset the Output Polarity level */
;;;266      tmpccer &= CCER_CC1P_Reset;
000022  1e75              SUBS     r5,r6,#1
000024  402a              ANDS     r2,r2,r5
;;;267    
;;;268      /* Set the Output Compare Polarity */
;;;269      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000026  890d              LDRH     r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;270      
;;;271      /* Set the Output State */
;;;272      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002a  884d              LDRH     r5,[r1,#2]
00002c  432a              ORRS     r2,r2,r5
;;;273      
;;;274      /* Set the Capture Compare Register value */
;;;275      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00002e  88cd              LDRH     r5,[r1,#6]
000030  8685              STRH     r5,[r0,#0x34]
;;;276      
;;;277      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000032  4d0f              LDR      r5,|L46.112|
000034  42a8              CMP      r0,r5
000036  d002              BEQ      |L46.62|
000038  4d0e              LDR      r5,|L46.116|
00003a  42a8              CMP      r0,r5
00003c  d113              BNE      |L46.102|
                  |L46.62|
;;;278      {
;;;279        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;280        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;281        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;282        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;283        
;;;284        /* Reset the Output N Polarity level */
;;;285        tmpccer &= CCER_CC1NP_Reset;
00003e  f64f75f7          MOV      r5,#0xfff7
000042  402a              ANDS     r2,r2,r5
;;;286    
;;;287        /* Set the Output N Polarity */
;;;288        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000044  894d              LDRH     r5,[r1,#0xa]
000046  432a              ORRS     r2,r2,r5
;;;289    
;;;290        /* Reset the Output N State */
;;;291        tmpccer &= CCER_CC1NE_Reset;
000048  f64f75fb          MOV      r5,#0xfffb
00004c  402a              ANDS     r2,r2,r5
;;;292        
;;;293        /* Set the Output N State */
;;;294        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004e  888d              LDRH     r5,[r1,#4]
000050  432a              ORRS     r2,r2,r5
;;;295    
;;;296        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;297        tmpcr2 &= CR2_OIS1_Reset;
000052  f64765ff          MOV      r5,#0x7eff
000056  402b              ANDS     r3,r3,r5
;;;298        tmpcr2 &= CR2_OIS1N_Reset;
000058  f64755ff          MOV      r5,#0x7dff
00005c  402b              ANDS     r3,r3,r5
;;;299    
;;;300        /* Set the Output Idle state */
;;;301        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  898d              LDRH     r5,[r1,#0xc]
000060  432b              ORRS     r3,r3,r5
;;;302    
;;;303        /* Set the Output N Idle state */
;;;304        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  89cd              LDRH     r5,[r1,#0xe]
000064  432b              ORRS     r3,r3,r5
                  |L46.102|
;;;305      }
;;;306      /* Write to TIMx CR2 */
;;;307      TIMx->CR2 = tmpcr2;
000066  8083              STRH     r3,[r0,#4]
;;;308      
;;;309      /* Write to TIMx CCMR1 */
;;;310      TIMx->CCMR1 = tmpccmrx;
000068  8304              STRH     r4,[r0,#0x18]
;;;311      
;;;312      /* Write to TIMx CCER */
;;;313      TIMx->CCER = tmpccer;
00006a  8402              STRH     r2,[r0,#0x20]
;;;314    }
00006c  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP

00006e  0000              DCW      0x0000
                  |L46.112|
                          DCD      0x40012c00
                  |L46.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;2071   *******************************************************************************/
;;;2072   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;2073   {
;;;2074     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2075   
;;;2076     /* Check the parameters */
;;;2077     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2078     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2079      
;;;2080     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2081   
;;;2082     /* Set or Reset the CC1NP Bit */
;;;2083     tmpccer &= CCER_CC1NP_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;2084     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;2085   
;;;2086     /* Write to TIMx CCER register */
;;;2087     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;2088   }
000010  4770              BX       lr
;;;2089   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;2042   *******************************************************************************/
;;;2043   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2044   {
;;;2045     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2046   
;;;2047     /* Check the parameters */
;;;2048     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2049     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2050   
;;;2051     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2052   
;;;2053     /* Set or Reset the CC1P Bit */
;;;2054     tmpccer &= CCER_CC1P_Reset;
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;2055     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;2056   
;;;2057     /* Write to TIMx CCER register */
;;;2058     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;2059   }
000010  4770              BX       lr
;;;2060   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1651   *******************************************************************************/
;;;1652   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1653   {
;;;1654     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1655   
;;;1656     /* Check the parameters */
;;;1657     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1658     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1659   
;;;1660     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1661   
;;;1662     /* Reset the OC1PE Bit */
;;;1663     tmpccmr1 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1664   
;;;1665     /* Enable or Disable the Output Compare Preload feature */
;;;1666     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1667   
;;;1668     /* Write to TIMx CCMR1 register */
;;;1669     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1670   }
000010  4770              BX       lr
;;;1671   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1815   *******************************************************************************/
;;;1816   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1817   {
;;;1818     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1819   
;;;1820     /* Check the parameters */
;;;1821     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1822     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1823   
;;;1824     /* Get the TIMx CCMR1 register value */
;;;1825     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1826   
;;;1827     /* Reset the OC2FE Bit */
;;;1828     tmpccmr1 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1829   
;;;1830     /* Enable or Disable the Output Compare Fast Bit */
;;;1831     tmpccmr1 |= (u16)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1832   
;;;1833     /* Write to TIMx CCMR1 */
;;;1834     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1835   }
000018  4770              BX       lr
;;;1836   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;327    *******************************************************************************/
;;;328    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;329    {
;;;330      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;331       
;;;332      /* Check the parameters */
;;;333      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;334      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;335      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;336      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;337    
;;;338      /* Disable the Channel 2: Reset the CC2E Bit */
;;;339      TIMx->CCER &= CCER_CC2E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;340      
;;;341      /* Get the TIMx CCER register value */  
;;;342      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;343    
;;;344      /* Get the TIMx CR2 register value */
;;;345      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;346      
;;;347      /* Get the TIMx CCMR1 register value */
;;;348      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;349        
;;;350      /* Reset the Output Compare Mode Bits */
;;;351      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;352      
;;;353      /* Select the Output Compare Mode */
;;;354      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;355      
;;;356      /* Reset the Output Polarity level */
;;;357      tmpccer &= CCER_CC2P_Reset;
00002a  f64f75df          MOV      r5,#0xffdf
00002e  402a              ANDS     r2,r2,r5
;;;358    
;;;359      /* Set the Output Compare Polarity */
;;;360      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000030  890d              LDRH     r5,[r1,#8]
000032  ea061505          AND      r5,r6,r5,LSL #4
000036  432a              ORRS     r2,r2,r5
;;;361      
;;;362      /* Set the Output State */
;;;363      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea061505          AND      r5,r6,r5,LSL #4
00003e  432a              ORRS     r2,r2,r5
;;;364      
;;;365      /* Set the Capture Compare Register value */
;;;366      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000040  88cd              LDRH     r5,[r1,#6]
000042  8705              STRH     r5,[r0,#0x38]
;;;367      
;;;368      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000044  4d13              LDR      r5,|L51.148|
000046  42a8              CMP      r0,r5
000048  d002              BEQ      |L51.80|
00004a  4d13              LDR      r5,|L51.152|
00004c  42a8              CMP      r0,r5
00004e  d11d              BNE      |L51.140|
                  |L51.80|
;;;369      {
;;;370        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;371        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;372        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;373        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;374        
;;;375        /* Reset the Output N Polarity level */
;;;376        tmpccer &= CCER_CC2NP_Reset;
000050  f64f757f          MOV      r5,#0xff7f
000054  402a              ANDS     r2,r2,r5
;;;377    
;;;378        /* Set the Output N Polarity */
;;;379        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000056  894d              LDRH     r5,[r1,#0xa]
000058  f64f76ff          MOV      r6,#0xffff
00005c  ea061505          AND      r5,r6,r5,LSL #4
000060  432a              ORRS     r2,r2,r5
;;;380    
;;;381        /* Reset the Output N State */
;;;382        tmpccer &= CCER_CC2NE_Reset;
000062  f64f75bf          MOV      r5,#0xffbf
000066  402a              ANDS     r2,r2,r5
;;;383        
;;;384        /* Set the Output N State */
;;;385        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
000068  888d              LDRH     r5,[r1,#4]
00006a  ea061505          AND      r5,r6,r5,LSL #4
00006e  432a              ORRS     r2,r2,r5
;;;386    
;;;387        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;388        tmpcr2 &= CR2_OIS2_Reset;
000070  f64735ff          MOV      r5,#0x7bff
000074  402b              ANDS     r3,r3,r5
;;;389        tmpcr2 &= CR2_OIS2N_Reset;
000076  f24775ff          MOV      r5,#0x77ff
00007a  402b              ANDS     r3,r3,r5
;;;390    
;;;391        /* Set the Output Idle state */
;;;392        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00007c  898d              LDRH     r5,[r1,#0xc]
00007e  ea060585          AND      r5,r6,r5,LSL #2
000082  432b              ORRS     r3,r3,r5
;;;393    
;;;394        /* Set the Output N Idle state */
;;;395        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000084  89cd              LDRH     r5,[r1,#0xe]
000086  ea060585          AND      r5,r6,r5,LSL #2
00008a  432b              ORRS     r3,r3,r5
                  |L51.140|
;;;396      }
;;;397    
;;;398      /* Write to TIMx CR2 */
;;;399      TIMx->CR2 = tmpcr2;
00008c  8083              STRH     r3,[r0,#4]
;;;400      
;;;401      /* Write to TIMx CCMR1 */
;;;402      TIMx->CCMR1 = tmpccmrx;
00008e  8304              STRH     r4,[r0,#0x18]
;;;403      
;;;404      /* Write to TIMx CCER */
;;;405      TIMx->CCER = tmpccer;
000090  8402              STRH     r2,[r0,#0x20]
;;;406    }
000092  bd70              POP      {r4-r6,pc}
;;;407    
                          ENDP

                  |L51.148|
                          DCD      0x40012c00
                  |L51.152|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;2130   *******************************************************************************/
;;;2131   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;2132   {
;;;2133     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2134   
;;;2135     /* Check the parameters */
;;;2136     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2137     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2138     
;;;2139     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2140   
;;;2141     /* Set or Reset the CC2NP Bit */
;;;2142     tmpccer &= CCER_CC2NP_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;2143     tmpccer |= (u16)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;2144   
;;;2145     /* Write to TIMx CCER register */
;;;2146     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2147   }
000018  4770              BX       lr
;;;2148   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;2101   *******************************************************************************/
;;;2102   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2103   {
;;;2104     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2105   
;;;2106     /* Check the parameters */
;;;2107     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2108     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2109   
;;;2110     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2111   
;;;2112     /* Set or Reset the CC2P Bit */
;;;2113     tmpccer &= CCER_CC2P_Reset;
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;2114     tmpccer |= (u16)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;2115   
;;;2116     /* Write to TIMx CCER register */
;;;2117     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2118   }
000018  4770              BX       lr
;;;2119   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1684   *******************************************************************************/
;;;1685   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1686   {
;;;1687     u16 tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1688   
;;;1689     /* Check the parameters */
;;;1690     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1691     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1692   
;;;1693     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1694   
;;;1695     /* Reset the OC2PE Bit */
;;;1696     tmpccmr1 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1697   
;;;1698     /* Enable or Disable the Output Compare Preload feature */
;;;1699     tmpccmr1 |= (u16)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1700   
;;;1701     /* Write to TIMx CCMR1 register */
;;;1702     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1703   }
000018  4770              BX       lr
;;;1704   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1848   *******************************************************************************/
;;;1849   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1850   {
;;;1851     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1852   
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1855     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1856   
;;;1857     /* Get the TIMx CCMR2 register value */
;;;1858     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1859   
;;;1860     /* Reset the OC3FE Bit */
;;;1861     tmpccmr2 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1862   
;;;1863     /* Enable or Disable the Output Compare Fast Bit */
;;;1864     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1865   
;;;1866     /* Write to TIMx CCMR2 */
;;;1867     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1868   }
000010  4770              BX       lr
;;;1869   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;419    *******************************************************************************/
;;;420    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;421    {
;;;422      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;423       
;;;424      /* Check the parameters */
;;;425      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;426      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;427      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;428      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;429    
;;;430      /* Disable the Channel 2: Reset the CC2E Bit */
;;;431      TIMx->CCER &= CCER_CC3E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;432      
;;;433      /* Get the TIMx CCER register value */
;;;434      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;435    
;;;436      /* Get the TIMx CR2 register value */
;;;437      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;438      
;;;439      /* Get the TIMx CCMR2 register value */
;;;440      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;441        
;;;442      /* Reset the Output Compare Mode Bits */
;;;443      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;444      
;;;445      /* Select the Output Compare Mode */
;;;446      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;447      
;;;448      /* Reset the Output Polarity level */
;;;449      tmpccer &= CCER_CC3P_Reset;
000022  f64f55ff          MOV      r5,#0xfdff
000026  402a              ANDS     r2,r2,r5
;;;450    
;;;451      /* Set the Output Compare Polarity */
;;;452      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000028  890d              LDRH     r5,[r1,#8]
00002a  f64f76ff          MOV      r6,#0xffff
00002e  ea062505          AND      r5,r6,r5,LSL #8
000032  432a              ORRS     r2,r2,r5
;;;453      
;;;454      /* Set the Output State */
;;;455      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
000034  884d              LDRH     r5,[r1,#2]
000036  ea062505          AND      r5,r6,r5,LSL #8
00003a  432a              ORRS     r2,r2,r5
;;;456      
;;;457      /* Set the Capture Compare Register value */
;;;458      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00003c  88cd              LDRH     r5,[r1,#6]
00003e  8785              STRH     r5,[r0,#0x3c]
;;;459      
;;;460      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000040  4d13              LDR      r5,|L56.144|
000042  42a8              CMP      r0,r5
000044  d002              BEQ      |L56.76|
000046  4d13              LDR      r5,|L56.148|
000048  42a8              CMP      r0,r5
00004a  d11d              BNE      |L56.136|
                  |L56.76|
;;;461      {
;;;462        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;463        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;464        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;465        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;466        
;;;467        /* Reset the Output N Polarity level */
;;;468        tmpccer &= CCER_CC3NP_Reset;
00004c  f24f75ff          MOV      r5,#0xf7ff
000050  402a              ANDS     r2,r2,r5
;;;469    
;;;470        /* Set the Output N Polarity */
;;;471        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000052  894d              LDRH     r5,[r1,#0xa]
000054  f64f76ff          MOV      r6,#0xffff
000058  ea062505          AND      r5,r6,r5,LSL #8
00005c  432a              ORRS     r2,r2,r5
;;;472    
;;;473        /* Reset the Output N State */
;;;474        tmpccer &= CCER_CC3NE_Reset;
00005e  f64f35ff          MOV      r5,#0xfbff
000062  402a              ANDS     r2,r2,r5
;;;475        
;;;476        /* Set the Output N State */
;;;477        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
000064  888d              LDRH     r5,[r1,#4]
000066  ea062505          AND      r5,r6,r5,LSL #8
00006a  432a              ORRS     r2,r2,r5
;;;478    
;;;479        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;480        tmpcr2 &= CR2_OIS3_Reset;
00006c  f64675ff          MOV      r5,#0x6fff
000070  402b              ANDS     r3,r3,r5
;;;481        tmpcr2 &= CR2_OIS3N_Reset;
000072  f64575ff          MOV      r5,#0x5fff
000076  402b              ANDS     r3,r3,r5
;;;482    
;;;483        /* Set the Output Idle state */
;;;484        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000078  898d              LDRH     r5,[r1,#0xc]
00007a  ea061505          AND      r5,r6,r5,LSL #4
00007e  432b              ORRS     r3,r3,r5
;;;485    
;;;486        /* Set the Output N Idle state */
;;;487        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000080  89cd              LDRH     r5,[r1,#0xe]
000082  ea061505          AND      r5,r6,r5,LSL #4
000086  432b              ORRS     r3,r3,r5
                  |L56.136|
;;;488      }
;;;489    
;;;490      /* Write to TIMx CR2 */
;;;491      TIMx->CR2 = tmpcr2;
000088  8083              STRH     r3,[r0,#4]
;;;492      
;;;493      /* Write to TIMx CCMR2 */
;;;494      TIMx->CCMR2 = tmpccmrx;
00008a  8384              STRH     r4,[r0,#0x1c]
;;;495      
;;;496      /* Write to TIMx CCER */
;;;497      TIMx->CCER = tmpccer;
00008c  8402              STRH     r2,[r0,#0x20]
;;;498    }
00008e  bd70              POP      {r4-r6,pc}
;;;499    
                          ENDP

                  |L56.144|
                          DCD      0x40012c00
                  |L56.148|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;2189   *******************************************************************************/
;;;2190   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;2191   {
;;;2192     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2193    
;;;2194     /* Check the parameters */
;;;2195     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2196     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2197       
;;;2198     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2199   
;;;2200     /* Set or Reset the CC3NP Bit */
;;;2201     tmpccer &= CCER_CC3NP_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;2202     tmpccer |= (u16)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;2203   
;;;2204     /* Write to TIMx CCER register */
;;;2205     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2206   }
000018  4770              BX       lr
;;;2207   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;2160   *******************************************************************************/
;;;2161   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2162   {
;;;2163     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2164   
;;;2165     /* Check the parameters */
;;;2166     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2167     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2168   
;;;2169     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2170   
;;;2171     /* Set or Reset the CC3P Bit */
;;;2172     tmpccer &= CCER_CC3P_Reset;
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;2173     tmpccer |= (u16)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;2174   
;;;2175     /* Write to TIMx CCER register */
;;;2176     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2177   }
000018  4770              BX       lr
;;;2178   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1717   *******************************************************************************/
;;;1718   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1719   {
;;;1720     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1721   
;;;1722     /* Check the parameters */
;;;1723     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1724     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1725   
;;;1726     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1727   
;;;1728     /* Reset the OC3PE Bit */
;;;1729     tmpccmr2 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1730   
;;;1731     /* Enable or Disable the Output Compare Preload feature */
;;;1732     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1733   
;;;1734     /* Write to TIMx CCMR2 register */
;;;1735     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1736   }
000010  4770              BX       lr
;;;1737   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1881   *******************************************************************************/
;;;1882   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1883   {
;;;1884     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1885   
;;;1886     /* Check the parameters */
;;;1887     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1888     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1889   
;;;1890     /* Get the TIMx CCMR2 register value */
;;;1891     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1892   
;;;1893     /* Reset the OC4FE Bit */
;;;1894     tmpccmr2 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1895   
;;;1896     /* Enable or Disable the Output Compare Fast Bit */
;;;1897     tmpccmr2 |= (u16)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1898   
;;;1899     /* Write to TIMx CCMR2 */
;;;1900     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1901   }
000018  4770              BX       lr
;;;1902   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;511    *******************************************************************************/
;;;512    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
;;;514      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;515       
;;;516      /* Check the parameters */
;;;517      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;518      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;519      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;520      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;521    
;;;522      /* Disable the Channel 2: Reset the CC4E Bit */
;;;523      TIMx->CCER &= CCER_CC4E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;524      
;;;525      /* Get the TIMx CCER register value */
;;;526      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;527    
;;;528      /* Get the TIMx CR2 register value */
;;;529      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;530      
;;;531      /* Get the TIMx CCMR2 register value */
;;;532      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;533        
;;;534      /* Reset the Output Compare Mode Bits */
;;;535      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;536      
;;;537      /* Select the Output Compare Mode */
;;;538      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;539      
;;;540      /* Reset the Output Polarity level */
;;;541      tmpccer &= CCER_CC4P_Reset;
00002a  f64d75ff          MOV      r5,#0xdfff
00002e  402a              ANDS     r2,r2,r5
;;;542    
;;;543      /* Set the Output Compare Polarity */
;;;544      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000030  890d              LDRH     r5,[r1,#8]
000032  ea063505          AND      r5,r6,r5,LSL #12
000036  432a              ORRS     r2,r2,r5
;;;545      
;;;546      /* Set the Output State */
;;;547      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea063505          AND      r5,r6,r5,LSL #12
00003e  432a              ORRS     r2,r2,r5
;;;548      
;;;549      /* Set the Capture Compare Register value */
;;;550      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000040  88cd              LDRH     r5,[r1,#6]
000042  f8a05040          STRH     r5,[r0,#0x40]
;;;551      
;;;552      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000046  4d09              LDR      r5,|L61.108|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L61.82|
00004c  4d08              LDR      r5,|L61.112|
00004e  42a8              CMP      r0,r5
000050  d107              BNE      |L61.98|
                  |L61.82|
;;;553      {
;;;554        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;555    
;;;556        /* Reset the Ouput Compare IDLE State */
;;;557        tmpcr2 &= CR2_OIS4_Reset;
000052  f3c3030d          UBFX     r3,r3,#0,#14
;;;558    
;;;559        /* Set the Output Idle state */
;;;560        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000056  898d              LDRH     r5,[r1,#0xc]
000058  f64f76ff          MOV      r6,#0xffff
00005c  ea061585          AND      r5,r6,r5,LSL #6
000060  432b              ORRS     r3,r3,r5
                  |L61.98|
;;;561      }
;;;562    
;;;563      /* Write to TIMx CR2 */
;;;564      TIMx->CR2 = tmpcr2;
000062  8083              STRH     r3,[r0,#4]
;;;565      
;;;566      /* Write to TIMx CCMR2 */  
;;;567      TIMx->CCMR2 = tmpccmrx;
000064  8384              STRH     r4,[r0,#0x1c]
;;;568      
;;;569      /* Write to TIMx CCER */
;;;570      TIMx->CCER = tmpccer;
000066  8402              STRH     r2,[r0,#0x20]
;;;571    }
000068  bd70              POP      {r4-r6,pc}
;;;572    
                          ENDP

00006a  0000              DCW      0x0000
                  |L61.108|
                          DCD      0x40012c00
                  |L61.112|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;2219   *******************************************************************************/
;;;2220   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;2221   {
;;;2222     u16 tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;2223   
;;;2224     /* Check the parameters */
;;;2225     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2226     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2227   
;;;2228     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;2229   
;;;2230     /* Set or Reset the CC4P Bit */
;;;2231     tmpccer &= CCER_CC4P_Reset;
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;2232     tmpccer |= (u16)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;2233   
;;;2234     /* Write to TIMx CCER register */
;;;2235     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;2236   }
000018  4770              BX       lr
;;;2237   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1750   *******************************************************************************/
;;;1751   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1752   {
;;;1753     u16 tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1754   
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1757     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1758   
;;;1759     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1760   
;;;1761     /* Reset the OC4PE Bit */
;;;1762     tmpccmr2 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1763   
;;;1764     /* Enable or Disable the Output Compare Preload feature */
;;;1765     tmpccmr2 |= (u16)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1766   
;;;1767     /* Write to TIMx CCMR2 register */
;;;1768     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1769   }
000018  4770              BX       lr
;;;1770   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;767    *******************************************************************************/
;;;768    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;769    {
;;;770      /* Set the default configuration */
;;;771      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;772      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;773      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;774      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;775      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;776      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;777      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;778      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;779    }
000012  4770              BX       lr
;;;780    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;649    *******************************************************************************/
;;;650    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;651    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;652      u16 icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;653      u16 icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;654    
;;;655      /* Check the parameters */
;;;656      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;657    
;;;658      /* Select the Opposite Input Polarity */
;;;659      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;660      {
;;;661        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;662      }
;;;663      else
;;;664      {
;;;665        icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;666      }
;;;667    
;;;668      /* Select the Opposite Input */
;;;669      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;670      {
;;;671        icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;672      }
;;;673      else
;;;674      {
;;;675        icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;676      }
;;;677    
;;;678      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;679      {
;;;680        /* TI1 Configuration */
;;;681        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;682                   TIM_ICInitStruct->TIM_ICFilter);
;;;683    
;;;684        /* Set the Input Capture Prescaler value */
;;;685        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;686    
;;;687        /* TI2 Configuration */
;;;688        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;689    
;;;690        /* Set the Input Capture Prescaler value */
;;;691        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;692      }
;;;693      else
;;;694      { 
;;;695        /* TI2 Configuration */
;;;696        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;697                   TIM_ICInitStruct->TIM_ICFilter);
;;;698    
;;;699        /* Set the Input Capture Prescaler value */
;;;700        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;701    
;;;702        /* TI1 Configuration */
;;;703        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;704    
;;;705        /* Set the Input Capture Prescaler value */
;;;706        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;707      }
;;;708    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;709    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1237   *******************************************************************************/
;;;1238   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1239   {
;;;1240     /* Check the parameters */
;;;1241     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1242     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1243   
;;;1244     /* Set the Prescaler value */
;;;1245     TIMx->PSC = Prescaler;
;;;1246   
;;;1247     /* Set or reset the UG Bit */
;;;1248     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1249   }
000004  4770              BX       lr
;;;1250   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1592   *******************************************************************************/
;;;1593   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;1594   {
;;;1595     /* Check the parameters */
;;;1596     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1597     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1598   
;;;1599     if (NewState != DISABLE)
;;;1600     {
;;;1601       /* Set the CCDS Bit */
;;;1602       TIMx->CR2 |= CR2_CCDS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;1603     }
;;;1604     else
;;;1605     {
;;;1606       /* Reset the CCDS Bit */
;;;1607       TIMx->CR2 &= CR2_CCDS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L67.22|
;;;1608     }
;;;1609   }
000016  4770              BX       lr
;;;1610   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1564   *******************************************************************************/
;;;1565   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1566   {
;;;1567     /* Check the parameters */
;;;1568     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1569     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1570   
;;;1571     if (NewState != DISABLE)
;;;1572     {
;;;1573       /* Set the COM Bit */
;;;1574       TIMx->CR2 |= CR2_CCUS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1575     }
;;;1576     else
;;;1577     {
;;;1578       /* Reset the COM Bit */
;;;1579       TIMx->CR2 &= CR2_CCUS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;1580     }
;;;1581   }
000016  4770              BX       lr
;;;1582   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2415   *******************************************************************************/
;;;2416   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2417   {
;;;2418     /* Check the parameters */
;;;2419     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2420     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2421   
;;;2422     if (NewState != DISABLE)
;;;2423     {
;;;2424       /* Set the TI1S Bit */
;;;2425       TIMx->CR2 |= CR2_TI1S_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2426     }
;;;2427     else
;;;2428     {
;;;2429       /* Reset the TI1S Bit */
;;;2430       TIMx->CR2 &= CR2_TI1S_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2431     }
;;;2432   }
000016  4770              BX       lr
;;;2433   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1303   *******************************************************************************/
;;;1304   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;1305   {
;;;1306     u16 tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;1307   
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1310     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1311   
;;;1312     /* Get the TIMx SMCR register value */
;;;1313     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;1314   
;;;1315     /* Reset the TS Bits */
;;;1316     tmpsmcr &= SMCR_TS_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1317   
;;;1318     /* Set the Input Trigger source */
;;;1319     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;1320   
;;;1321     /* Write to TIMx SMCR */
;;;1322     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;1323   }
000010  4770              BX       lr
;;;1324   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2531   *******************************************************************************/
;;;2532   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2533   {
;;;2534     /* Check the parameters */
;;;2535     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2536     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2537   
;;;2538     /* Reset the MSM Bit */
;;;2539     TIMx->SMCR &= SMCR_MSM_Reset;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2540     
;;;2541     /* Set or Reset the MSM Bit */
;;;2542     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2543   }
000010  4770              BX       lr
;;;2544   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2321   *******************************************************************************/
;;;2322   void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;2323   {
;;;2324     /* Check the parameters */
;;;2325     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2326     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2327     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2328     
;;;2329     /* Disable the Channel: Reset the CCxE Bit */
;;;2330     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2331   
;;;2332     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
00000c  b109              CBZ      r1,|L72.18|
00000e  2908              CMP      r1,#8
000010  d112              BNE      |L72.56|
                  |L72.18|
;;;2333     {
;;;2334       /* Reset the OCxM bits in the CCMRx register */
;;;2335       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
000012  f1000318          ADD      r3,r0,#0x18
000016  eb030361          ADD      r3,r3,r1,ASR #1
00001a  681b              LDR      r3,[r3,#0]
00001c  f64f748f          MOV      r4,#0xff8f
000020  4023              ANDS     r3,r3,r4
000022  f1000418          ADD      r4,r0,#0x18
000026  eb040461          ADD      r4,r4,r1,ASR #1
00002a  6023              STR      r3,[r4,#0]
;;;2336      
;;;2337       /* Configure the OCxM bits in the CCMRx register */
;;;2338       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
00002c  f1000318          ADD      r3,r0,#0x18
000030  eb030361          ADD      r3,r3,r1,ASR #1
000034  601a              STR      r2,[r3,#0]
000036  e018              B        |L72.106|
                  |L72.56|
;;;2339   
;;;2340     }
;;;2341     else
;;;2342     {
;;;2343       /* Reset the OCxM bits in the CCMRx register */
;;;2344       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000038  1f0b              SUBS     r3,r1,#4
00003a  f3c3044e          UBFX     r4,r3,#1,#15
00003e  f1000318          ADD      r3,r0,#0x18
000042  591b              LDR      r3,[r3,r4]
000044  f64874ff          MOV      r4,#0x8fff
000048  4023              ANDS     r3,r3,r4
00004a  1f0c              SUBS     r4,r1,#4
00004c  f3c4054e          UBFX     r5,r4,#1,#15
000050  f1000418          ADD      r4,r0,#0x18
000054  5163              STR      r3,[r4,r5]
;;;2345       
;;;2346       /* Configure the OCxM bits in the CCMRx register */
;;;2347       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
000056  f64f73ff          MOV      r3,#0xffff
00005a  ea032402          AND      r4,r3,r2,LSL #8
00005e  1f0b              SUBS     r3,r1,#4
000060  f3c3054e          UBFX     r5,r3,#1,#15
000064  f1000318          ADD      r3,r0,#0x18
000068  515c              STR      r4,[r3,r5]
                  |L72.106|
;;;2348     }
;;;2349   }
00006a  bd30              POP      {r4,r5,pc}
;;;2350   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2444   *******************************************************************************/
;;;2445   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2446   {
;;;2447     /* Check the parameters */
;;;2448     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2449     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2450   
;;;2451     /* Reset the OPM Bit */
;;;2452     TIMx->CR1 &= CR1_OPM_Reset;
000002  f24033f7          MOV      r3,#0x3f7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2453   
;;;2454     /* Configure the OPM Mode */
;;;2455     TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2456   }
000010  4770              BX       lr
;;;2457   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2477   *******************************************************************************/
;;;2478   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2479   {
;;;2480     /* Check the parameters */
;;;2481     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2482     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2483     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2484   
;;;2485     /* Reset the MMS Bits */
;;;2486     TIMx->CR2 &= CR2_MMS_Mask;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2487   
;;;2488     /* Select the TRGO source */
;;;2489     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2490   }
000010  4770              BX       lr
;;;2491   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2505   *******************************************************************************/
;;;2506   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2507   {
;;;2508     /* Check the parameters */
;;;2509     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2510     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2511   
;;;2512     /* Reset the SMS Bits */
;;;2513     TIMx->SMCR &= SMCR_SMS_Mask;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2514   
;;;2515     /* Select the Slave Mode */
;;;2516     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2517   }
000010  4770              BX       lr
;;;2518   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2569   *******************************************************************************/
;;;2570   void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2571   {
;;;2572     /* Check the parameters */
;;;2573     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2574   
;;;2575     /* Set the Autoreload Register value */
;;;2576     TIMx->ARR = Autoreload;
;;;2577   }
000002  4770              BX       lr
;;;2578   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2775   *******************************************************************************/
;;;2776   void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2777   {
;;;2778     /* Check the parameters */
;;;2779     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2780     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2781   
;;;2782     /* Reset the CKD Bits */
;;;2783     TIMx->CR1 &= CR1_CKD_Mask;
000002  b2d2              UXTB     r2,r2
000004  8002              STRH     r2,[r0,#0]
;;;2784   
;;;2785     /* Set the CKD value */
;;;2786     TIMx->CR1 |= TIM_CKD;
000006  8802              LDRH     r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  8002              STRH     r2,[r0,#0]
;;;2787   }
00000c  4770              BX       lr
;;;2788   /*******************************************************************************
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2587   *******************************************************************************/
;;;2588   void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2589   {
;;;2590     /* Check the parameters */
;;;2591     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2592   
;;;2593     /* Set the Capture Compare1 Register value */
;;;2594     TIMx->CCR1 = Compare1;
;;;2595   }
000002  4770              BX       lr
;;;2596   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2605   *******************************************************************************/
;;;2606   void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2607   {
;;;2608     /* Check the parameters */
;;;2609     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2610   
;;;2611     /* Set the Capture Compare2 Register value */
;;;2612     TIMx->CCR2 = Compare2;
;;;2613   }
000002  4770              BX       lr
;;;2614   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2623   *******************************************************************************/
;;;2624   void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2625   {
;;;2626     /* Check the parameters */
;;;2627     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2628   
;;;2629     /* Set the Capture Compare3 Register value */
;;;2630     TIMx->CCR3 = Compare3;
;;;2631   }
000002  4770              BX       lr
;;;2632   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2641   *******************************************************************************/
;;;2642   void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2643   {
;;;2644     /* Check the parameters */
;;;2645     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2646   
;;;2647     /* Set the Capture Compare4 Register value */
;;;2648     TIMx->CCR4 = Compare4;
;;;2649   }
000004  4770              BX       lr
;;;2650   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2552   *******************************************************************************/
;;;2553   void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2554   {
;;;2555     /* Check the parameters */
;;;2556     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2557   
;;;2558     /* Set the Counter Register value */
;;;2559     TIMx->CNT = Counter;
;;;2560   }
000002  4770              BX       lr
;;;2561   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2665   *******************************************************************************/
;;;2666   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2667   {
;;;2668     /* Check the parameters */
;;;2669     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2670     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2671   
;;;2672     /* Reset the IC1PSC Bits */
;;;2673     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2674   
;;;2675     /* Set the IC1PSC value */
;;;2676     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2677   }
000010  4770              BX       lr
;;;2678   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2693   *******************************************************************************/
;;;2694   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2695   {
;;;2696     /* Check the parameters */
;;;2697     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2698     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2699   
;;;2700     /* Reset the IC2PSC Bits */
;;;2701     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2702   
;;;2703     /* Set the IC2PSC value */
;;;2704     TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2705   }
000018  4770              BX       lr
;;;2706   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2721   *******************************************************************************/
;;;2722   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2723   {
;;;2724     /* Check the parameters */
;;;2725     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2726     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2727   
;;;2728     /* Reset the IC3PSC Bits */
;;;2729     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2730   
;;;2731     /* Set the IC3PSC value */
;;;2732     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2733   }
000010  4770              BX       lr
;;;2734   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2749   *******************************************************************************/
;;;2750   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2751   {  
;;;2752     /* Check the parameters */
;;;2753     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2754     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2755   
;;;2756     /* Reset the IC4PSC Bits */
;;;2757     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2758   
;;;2759     /* Set the IC4PSC value */
;;;2760     TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2761   }
000018  4770              BX       lr
;;;2762   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1068   *******************************************************************************/
;;;1069   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1070                                   u16 TIM_ICPolarity, u16 ICFilter)
;;;1071   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1074     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1075     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1076     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1077   
;;;1078     /* Configure the Timer Input Clock Source */
;;;1079     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;1080     {
;;;1081       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;1082     }
;;;1083     else
;;;1084     {
;;;1085       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;1086     }
;;;1087   
;;;1088     /* Select the Trigger source */
;;;1089     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1090   
;;;1091     /* Select the External clock mode1 */
;;;1092     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;1093   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1094   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;197    *******************************************************************************/
;;;198    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  8802              LDRH     r2,[r0,#0]
;;;199    {
;;;200      /* Check the parameters */
;;;201      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;202      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;203      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;204    
;;;205      /* Select the Counter Mode and set the clock division */
;;;206      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
000002  f002028f          AND      r2,r2,#0x8f
000006  8002              STRH     r2,[r0,#0]
;;;207      TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
000008  88ca              LDRH     r2,[r1,#6]
00000a  884b              LDRH     r3,[r1,#2]
00000c  431a              ORRS     r2,r2,r3
00000e  8803              LDRH     r3,[r0,#0]
000010  431a              ORRS     r2,r2,r3
000012  8002              STRH     r2,[r0,#0]
;;;208                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;209      /* Set the Autoreload value */
;;;210      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000014  888a              LDRH     r2,[r1,#4]
000016  8582              STRH     r2,[r0,#0x2c]
;;;211    
;;;212      /* Set the Prescaler value */
;;;213      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000018  880a              LDRH     r2,[r1,#0]
00001a  8502              STRH     r2,[r0,#0x28]
;;;214    
;;;215      /* Generate an update event to reload the Prescaler value immediatly */
;;;216      TIMx->EGR = TIM_PSCReloadMode_Immediate;
00001c  2201              MOVS     r2,#1
00001e  8282              STRH     r2,[r0,#0x14]
;;;217        
;;;218      if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
000020  4a04              LDR      r2,|L88.52|
000022  4290              CMP      r0,r2
000024  d002              BEQ      |L88.44|
000026  4a04              LDR      r2,|L88.56|
000028  4290              CMP      r0,r2
00002a  d101              BNE      |L88.48|
                  |L88.44|
;;;219      {
;;;220        /* Set the Repetition Counter value */
;;;221        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00002c  7a0a              LDRB     r2,[r1,#8]
00002e  8602              STRH     r2,[r0,#0x30]
                  |L88.48|
;;;222      }        
;;;223    }
000030  4770              BX       lr
;;;224    
                          ENDP

000032  0000              DCW      0x0000
                  |L88.52|
                          DCD      0x40012c00
                  |L88.56|
                          DCD      0x40013400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;749    *******************************************************************************/
;;;750    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;751    {
;;;752      /* Set the default configuration */
;;;753      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;754      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;755      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;756      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;757      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;758    }
000010  4770              BX       lr
;;;759    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2359   *******************************************************************************/
;;;2360   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;2361   {
;;;2362     /* Check the parameters */
;;;2363     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2364     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2365   
;;;2366     if (NewState != DISABLE)
;;;2367     {
;;;2368       /* Set the Update Disable Bit */
;;;2369       TIMx->CR1 |= CR1_UDIS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;2370     }
;;;2371     else
;;;2372     {
;;;2373       /* Reset the Update Disable Bit */
;;;2374       TIMx->CR1 &= CR1_UDIS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fd          MOV      r3,#0x3fd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L90.22|
;;;2375     }
;;;2376   }
000016  4770              BX       lr
;;;2377   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2388   *******************************************************************************/
;;;2389   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;2390   {
;;;2391     /* Check the parameters */
;;;2392     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2393     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2394   
;;;2395     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2396     {
;;;2397       /* Set the URS Bit */
;;;2398       TIMx->CR1 |= CR1_URS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;2399     }
;;;2400     else
;;;2401     {
;;;2402       /* Reset the URS Bit */
;;;2403       TIMx->CR1 &= CR1_URS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fb          MOV      r3,#0x3fb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;2404     }
;;;2405   }
000016  4770              BX       lr
;;;2406   
                          ENDP

