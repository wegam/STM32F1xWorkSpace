; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_spi.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_spi.crf ..\..\Driver\WOW\SCR\STM32_SPI.C]
                          THUMB

                          AREA ||i.SPI_CLK_HIGH||, CODE, READONLY, ALIGN=1

                  SPI_CLK_HIGH PROC
;;;294    }
;;;295    void SPI_CLK_HIGH(SPIDef *pInfo)
000000  8a01              LDRH     r1,[r0,#0x10]
;;;296    {
;;;297    	pInfo->Port.CLK_PORT->BSRR 	= pInfo->Port.CLK_Pin;
000002  68c2              LDR      r2,[r0,#0xc]
000004  6111              STR      r1,[r2,#0x10]
;;;298    }
000006  4770              BX       lr
;;;299    void SPI_MOSI_LOW(SPIDef *pInfo)
                          ENDP


                          AREA ||i.SPI_CLK_LOW||, CODE, READONLY, ALIGN=1

                  SPI_CLK_LOW PROC
;;;290    }
;;;291    void SPI_CLK_LOW(SPIDef *pInfo)
000000  8a01              LDRH     r1,[r0,#0x10]
;;;292    {
;;;293    	pInfo->Port.CLK_PORT->BRR 	= pInfo->Port.CLK_Pin;
000002  68c2              LDR      r2,[r0,#0xc]
000004  6151              STR      r1,[r2,#0x14]
;;;294    }
000006  4770              BX       lr
;;;295    void SPI_CLK_HIGH(SPIDef *pInfo)
                          ENDP


                          AREA ||i.SPI_CS_HIGH||, CODE, READONLY, ALIGN=1

                  SPI_CS_HIGH PROC
;;;286    }
;;;287    void SPI_CS_HIGH(SPIDef *pInfo)
000000  8901              LDRH     r1,[r0,#8]
;;;288    {
;;;289    	pInfo->Port.CS_PORT->BSRR		= pInfo->Port.CS_Pin;
000002  6842              LDR      r2,[r0,#4]
000004  6111              STR      r1,[r2,#0x10]
;;;290    }
000006  4770              BX       lr
;;;291    void SPI_CLK_LOW(SPIDef *pInfo)
                          ENDP


                          AREA ||i.SPI_CS_LOW||, CODE, READONLY, ALIGN=1

                  SPI_CS_LOW PROC
;;;282    
;;;283    void SPI_CS_LOW(SPIDef *pInfo)
000000  8901              LDRH     r1,[r0,#8]
;;;284    {
;;;285    	pInfo->Port.CS_PORT->BRR		= pInfo->Port.CS_Pin;
000002  6842              LDR      r2,[r0,#4]
000004  6151              STR      r1,[r2,#0x14]
;;;286    }
000006  4770              BX       lr
;;;287    void SPI_CS_HIGH(SPIDef *pInfo)
                          ENDP


                          AREA ||i.SPI_DMAReadWrite||, CODE, READONLY, ALIGN=2

                  SPI_DMAReadWrite PROC
;;;363    *******************************************************************************/
;;;364    unsigned short SPI_DMAReadWrite(SPI_TypeDef* SPIx,unsigned char *tx_buffer,unsigned char *rx_buffer,unsigned short BufferSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;365    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;366      switch(*(u32*)&SPIx)
00000c  481d              LDR      r0,|L5.132|
00000e  4428              ADD      r0,r0,r5
000010  2800              CMP      r0,#0
000012  d132              BNE      |L5.122|
;;;367      {
;;;368        case SPI2_BASE:
;;;369          //-------------------------检查读缓冲有无数据
;;;370        if(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) != RESET)  //发送完成
000014  2102              MOVS     r1,#2
000016  481b              LDR      r0,|L5.132|
000018  4240              RSBS     r0,r0,#0
00001a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00001e  b358              CBZ      r0,|L5.120|
;;;371        {
;;;372          if(0!=DMA1_Channel4->CNDTR)       //接收到数据---需要先将数据缓存读出
000020  4819              LDR      r0,|L5.136|
000022  6c80              LDR      r0,[r0,#0x48]
000024  b160              CBZ      r0,|L5.64|
;;;373          {
;;;374            unsigned  short RxdNum;  //读到的数据
;;;375            DMA1_Channel4->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel4,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR
000026  4918              LDR      r1,|L5.136|
000028  6c49              LDR      r1,[r1,#0x44]
00002a  f0210101          BIC      r1,r1,#1
00002e  4a16              LDR      r2,|L5.136|
000030  6451              STR      r1,[r2,#0x44]
;;;376            RxdNum  = DMA1_Channel4->CNDTR;
000032  4611              MOV      r1,r2
000034  6c89              LDR      r1,[r1,#0x48]
000036  b288              UXTH     r0,r1
;;;377            DMA1_Channel4->CNDTR  = 0;                  //清除接收计数
000038  2100              MOVS     r1,#0
00003a  6491              STR      r1,[r2,#0x48]
                  |L5.60|
;;;378            return RxdNum;      //返回读到的数据大小
;;;379          }
;;;380          else if(0 ==  DMA1_Channel5->CNDTR)   //发送缓存为空---表示可以进行新的发送
;;;381          {
;;;382            //-----------------------重新设定接收缓存地址
;;;383            DMA1_Channel4->CNDTR 	=BufferSize;					  //设定待发送缓冲区大小
;;;384            DMA1_Channel4->CMAR = (u32)rx_buffer;
;;;385            DMA1_Channel4->CCR |=(u32)0x00000001;			  //DMA_Cmd(DMA1_Channel4,ENABLE);//DMA接收开启3
;;;386            
;;;387            DMA1_Channel5->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel5,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;388            DMA1->IFCR = DMA1_FLAG_GL5;										//DMA_ClearFlag(DMA1_FLAG_TC5);	//清除标志						
;;;389            DMA1_Channel5->CNDTR 	=BufferSize;					  //设定待发送缓冲区大小
;;;390            DMA1_Channel5->CMAR 	=(u32)tx_buffer;			  //发送缓冲区
;;;391            DMA1_Channel5->CCR |=(u32)0x00000001;			  //DMA_Cmd(DMA1_Channel5,ENABLE);//DMA发送开启3
;;;392            return 0;
;;;393          }
;;;394        }
;;;395          break;
;;;396        default:break;
;;;397      }
;;;398      return 0xFFFF;
;;;399    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L5.64|
000040  4811              LDR      r0,|L5.136|
000042  6dc0              LDR      r0,[r0,#0x5c]         ;380
000044  b9c0              CBNZ     r0,|L5.120|
000046  4810              LDR      r0,|L5.136|
000048  6484              STR      r4,[r0,#0x48]         ;383
00004a  6507              STR      r7,[r0,#0x50]         ;384
00004c  6c40              LDR      r0,[r0,#0x44]         ;385
00004e  f0400001          ORR      r0,r0,#1              ;385
000052  490d              LDR      r1,|L5.136|
000054  6448              STR      r0,[r1,#0x44]         ;385
000056  4608              MOV      r0,r1                 ;387
000058  6d80              LDR      r0,[r0,#0x58]         ;387
00005a  f0200001          BIC      r0,r0,#1              ;387
00005e  6588              STR      r0,[r1,#0x58]         ;387
000060  f44f3080          MOV      r0,#0x10000           ;388
000064  6048              STR      r0,[r1,#4]            ;388
000066  4608              MOV      r0,r1                 ;389
000068  65c4              STR      r4,[r0,#0x5c]         ;389
00006a  6646              STR      r6,[r0,#0x64]         ;390
00006c  6d80              LDR      r0,[r0,#0x58]         ;391
00006e  f0400001          ORR      r0,r0,#1              ;391
000072  6588              STR      r0,[r1,#0x58]         ;391
000074  2000              MOVS     r0,#0                 ;392
000076  e7e1              B        |L5.60|
                  |L5.120|
000078  e000              B        |L5.124|
                  |L5.122|
00007a  bf00              NOP                            ;396
                  |L5.124|
00007c  bf00              NOP                            ;395
00007e  f64f70ff          MOV      r0,#0xffff            ;398
000082  e7db              B        |L5.60|
;;;400    /*******************************************************************************
                          ENDP

                  |L5.132|
                          DCD      0xbfffc800
                  |L5.136|
                          DCD      0x40020000

                          AREA ||i.SPI_DMASend||, CODE, READONLY, ALIGN=2

                  SPI_DMASend PROC
;;;319    *******************************************************************************/
;;;320    unsigned short SPI_DMASend(SPI_TypeDef* SPIx,unsigned char *tx_buffer,unsigned short BufferSize)
000000  b510              PUSH     {r4,lr}
;;;321    {
000002  4603              MOV      r3,r0
;;;322    //  spiTxBuff
;;;323      switch(*(u32*)&SPIx)
000004  481f              LDR      r0,|L6.132|
000006  4418              ADD      r0,r0,r3
000008  b1e0              CBZ      r0,|L6.68|
00000a  f5b04f78          CMP      r0,#0xf800
00000e  d134              BNE      |L6.122|
;;;324      {
;;;325        case SPI1_BASE:
;;;326          if(   (DMA1_Channel3->CNDTR==0)										//通道空闲--已发完数据
000010  481d              LDR      r0,|L6.136|
000012  6b40              LDR      r0,[r0,#0x34]
000014  b120              CBZ      r0,|L6.32|
;;;327            ||( (DMA1_Channel3->CCR&0x00000001)==0))				//通道未开启
000016  481c              LDR      r0,|L6.136|
000018  6b00              LDR      r0,[r0,#0x30]
00001a  f0000001          AND      r0,r0,#1
00001e  b980              CBNZ     r0,|L6.66|
                  |L6.32|
;;;328            {
;;;329              DMA1_Channel3->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel5,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
000020  4819              LDR      r0,|L6.136|
000022  6b00              LDR      r0,[r0,#0x30]
000024  f0200001          BIC      r0,r0,#1
000028  4c17              LDR      r4,|L6.136|
00002a  6320              STR      r0,[r4,#0x30]
;;;330              DMA1->IFCR = DMA1_FLAG_GL3;										//DMA_ClearFlag(DMA1_FLAG_TC5);	//清除标志						
00002c  15a0              ASRS     r0,r4,#22
00002e  6060              STR      r0,[r4,#4]
;;;331              DMA1_Channel3->CNDTR 	=BufferSize;					  //设定待发送缓冲区大小
000030  4620              MOV      r0,r4
000032  6342              STR      r2,[r0,#0x34]
;;;332              DMA1_Channel3->CMAR 	=(u32)tx_buffer;			  //发送缓冲区
000034  63c1              STR      r1,[r0,#0x3c]
;;;333              DMA1_Channel3->CCR |=(u32)0x00000001;			  //DMA_Cmd(DMA1_Channel5,ENABLE);//DMA发送开启3
000036  6b00              LDR      r0,[r0,#0x30]
000038  f0400001          ORR      r0,r0,#1
00003c  6320              STR      r0,[r4,#0x30]
;;;334              return BufferSize;
00003e  4610              MOV      r0,r2
                  |L6.64|
;;;335            }
;;;336    		case SPI2_BASE:
;;;337          if(   (DMA1_Channel5->CNDTR==0)										//通道空闲--已发完数据
;;;338            ||( (DMA1_Channel5->CCR&0x00000001)==0))				//通道未开启
;;;339            {
;;;340              DMA1_Channel5->CCR &= (u32)0xFFFFFFFE;				//DMA_Cmd(DMA1_Channel5,DISABLE);//DMA发送关闭，只能在DMA关闭情况下才可以写入CNDTR					
;;;341              DMA1->IFCR = DMA1_FLAG_GL5;										//DMA_ClearFlag(DMA1_FLAG_TC5);	//清除标志						
;;;342              DMA1_Channel5->CNDTR 	=BufferSize;					  //设定待发送缓冲区大小
;;;343              DMA1_Channel5->CMAR 	=(u32)tx_buffer;			  //发送缓冲区
;;;344              DMA1_Channel5->CCR |=(u32)0x00000001;			  //DMA_Cmd(DMA1_Channel5,ENABLE);//DMA发送开启3
;;;345              return BufferSize;
;;;346            }
;;;347    //        else
;;;348    //        {
;;;349    //          //链表缓存
;;;350    //        }
;;;351          break;
;;;352        default:break;
;;;353      }  
;;;354    }
000040  bd10              POP      {r4,pc}
                  |L6.66|
000042  bf00              NOP                            ;336
                  |L6.68|
000044  4810              LDR      r0,|L6.136|
000046  6dc0              LDR      r0,[r0,#0x5c]         ;337
000048  b120              CBZ      r0,|L6.84|
00004a  480f              LDR      r0,|L6.136|
00004c  6d80              LDR      r0,[r0,#0x58]         ;338
00004e  f0000001          AND      r0,r0,#1              ;338
000052  b988              CBNZ     r0,|L6.120|
                  |L6.84|
000054  480c              LDR      r0,|L6.136|
000056  6d80              LDR      r0,[r0,#0x58]         ;340
000058  f0200001          BIC      r0,r0,#1              ;340
00005c  4c0a              LDR      r4,|L6.136|
00005e  65a0              STR      r0,[r4,#0x58]         ;340
000060  f44f3080          MOV      r0,#0x10000           ;341
000064  6060              STR      r0,[r4,#4]            ;341
000066  4620              MOV      r0,r4                 ;342
000068  65c2              STR      r2,[r0,#0x5c]         ;342
00006a  6641              STR      r1,[r0,#0x64]         ;343
00006c  6d80              LDR      r0,[r0,#0x58]         ;344
00006e  f0400001          ORR      r0,r0,#1              ;344
000072  65a0              STR      r0,[r4,#0x58]         ;344
000074  4610              MOV      r0,r2                 ;345
000076  e7e3              B        |L6.64|
                  |L6.120|
000078  e000              B        |L6.124|
                  |L6.122|
00007a  bf00              NOP                            ;352
                  |L6.124|
00007c  bf00              NOP                            ;351
00007e  bf00              NOP      
000080  e7de              B        |L6.64|
;;;355    /*******************************************************************************
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      0xbfffc800
                  |L6.136|
                          DCD      0x40020000

                          AREA ||i.SPI_Delay||, CODE, READONLY, ALIGN=1

                  SPI_Delay PROC
;;;49     *******************************************************************************/
;;;50     void SPI_Delay(unsigned long Time)
000000  bf00              NOP      
                  |L7.2|
;;;51     {
;;;52     	while(Time--);
000002  1e01              SUBS     r1,r0,#0
000004  f1a00001          SUB      r0,r0,#1
000008  d1fb              BNE      |L7.2|
;;;53     }
00000a  4770              BX       lr
;;;54     /*******************************************************************************
                          ENDP


                          AREA ||i.SPI_Initialize||, CODE, READONLY, ALIGN=1

                  SPI_Initialize PROC
;;;62     *******************************************************************************/
;;;63     void SPI_Initialize(SPIDef* pInfo)
000000  b510              PUSH     {r4,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65     //	SPISYS	=	pInfo;						//指针指向
;;;66     	SPI_InitializeSPI(pInfo);	//普通SPI接口配置
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI_InitializeSPI
;;;67     //	SPI_InitializeNR(pInfo);
;;;68     	GPIO_Configuration_OPP50	(pInfo->Port.CS_PORT,pInfo->Port.CS_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00000a  8921              LDRH     r1,[r4,#8]
00000c  6860              LDR      r0,[r4,#4]
00000e  f7fffffe          BL       GPIO_Configuration_OPP50
;;;69     }
000012  bd10              POP      {r4,pc}
;;;70     /*******************************************************************************
                          ENDP


                          AREA ||i.SPI_InitializeDMA||, CODE, READONLY, ALIGN=2

                  SPI_InitializeDMA PROC
;;;180    *******************************************************************************/
;;;181    void SPI_InitializeDMA(SPIDef *pInfo)		//SPI_FLASH_DMA方式配置
000000  b5f0              PUSH     {r4-r7,lr}
;;;182    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
;;;183    /**-----------------------------------------------------------------------------------------------------
;;;184    	********SPI_DMA的通信过程********
;;;185    	● 设置外设地址
;;;186    	● 设置存储器地址
;;;187    	● 设置传输数据量
;;;188    	● 设置通道的配置信息
;;;189    	● 使能DMA通道，启动传输
;;;190    	
;;;191    	● 发送时，在每次TXE被设置为’1’时发出DMA请求，DMA控制器则写数据至SPI_DR寄存器，TXE标志因此而被清除。
;;;192    	● 接收时，在每次RXNE被设置为’1’时发出DMA请求，DMA控制器则从SPI_DR寄存器读出数据，RXNE标志因此而被清除。
;;;193    -----------------------------------------------------------------------------------------------------**/
;;;194    	//1)**********定义相关结构体
;;;195    	SPI_InitTypeDef  SPI_InitStructure;
;;;196    	GPIO_InitTypeDef GPIO_InitStructure;
;;;197    	DMA_InitTypeDef	DMA_Initstructure;
;;;198    	DMA_Channel_TypeDef* DMAx_Channeltx=0;				//DMA发送通道请求信号---当DMA串口发送数据完成时，会发起DMA中断
000006  2600              MOVS     r6,#0
;;;199    	DMA_Channel_TypeDef* DMAx_Channelrx=0;				//DMA接收通道请求信号---DMA串口接收由串口发起中断，因此此处接收通道中断不使用
000008  2700              MOVS     r7,#0
;;;200    	SPI_TypeDef *	SPIx	=	pInfo->Port.SPIx;
00000a  682c              LDR      r4,[r5,#0]
;;;201    	//2)**********基本SPI配置
;;;202    	SPI_InitializeSPI(pInfo);					//普通SPI接口配置--未开中断和DMA
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       SPI_InitializeSPI
;;;203    
;;;204    	//3)**********SPI通道选择
;;;205    	switch(*(u32*)&SPIx)
000012  4836              LDR      r0,|L9.236|
000014  4420              ADD      r0,r0,r4
000016  b168              CBZ      r0,|L9.52|
000018  f5b06f80          CMP      r0,#0x400
00001c  d013              BEQ      |L9.70|
00001e  f5b04f78          CMP      r0,#0xf800
000022  d118              BNE      |L9.86|
;;;206    	{
;;;207    		case	SPI1_BASE:
;;;208    										DMAx_Channeltx=DMA1_Channel3;
000024  4e32              LDR      r6,|L9.240|
;;;209    										DMAx_Channelrx=DMA1_Channel2;
000026  4f32              LDR      r7,|L9.240|
000028  3f14              SUBS     r7,r7,#0x14
;;;210    										RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
00002a  2101              MOVS     r1,#1
00002c  4608              MOV      r0,r1
00002e  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;211    					break;
000032  e011              B        |L9.88|
                  |L9.52|
;;;212    		case	SPI2_BASE:
;;;213    										DMAx_Channeltx=DMA1_Channel5;
000034  4e2e              LDR      r6,|L9.240|
000036  3628              ADDS     r6,r6,#0x28
;;;214    										DMAx_Channelrx=DMA1_Channel4;
000038  4f2d              LDR      r7,|L9.240|
00003a  3714              ADDS     r7,r7,#0x14
;;;215    										RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
00003c  2101              MOVS     r1,#1
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;216    					break;
000044  e008              B        |L9.88|
                  |L9.70|
;;;217    		case	SPI3_BASE:
;;;218    										DMAx_Channeltx=DMA2_Channel1;
000046  4e2b              LDR      r6,|L9.244|
;;;219    										DMAx_Channelrx=DMA2_Channel2;
000048  4f2a              LDR      r7,|L9.244|
00004a  3714              ADDS     r7,r7,#0x14
;;;220    										RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2,ENABLE);
00004c  2101              MOVS     r1,#1
00004e  2002              MOVS     r0,#2
000050  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;221    					break;
000054  e000              B        |L9.88|
                  |L9.86|
;;;222    		default	:	break;
000056  bf00              NOP      
                  |L9.88|
000058  bf00              NOP                            ;211
;;;223    	}
;;;224    	//4)**********SPI_DMA配置
;;;225    
;;;226    		//5)**********DMA发送初始化，外设作为DMA的目的端
;;;227    		DMA_Initstructure.DMA_PeripheralBaseAddr =  (u32)(&SPIx->DR);	//DMA外设源地址
00005a  f104000c          ADD      r0,r4,#0xc
00005e  9000              STR      r0,[sp,#0]
;;;228    		DMA_Initstructure.DMA_MemoryBaseAddr     = (u32)spiTxBuff;						//DMA数据内存地址
000060  4825              LDR      r0,|L9.248|
000062  9001              STR      r0,[sp,#4]
;;;229    		DMA_Initstructure.DMA_DIR = DMA_DIR_PeripheralDST;												//DMA_DIR_PeripheralDST（外设作为DMA的目的端），DMA_DIR_PeripheralSRC（外设作为数据传输的来源）
000064  2010              MOVS     r0,#0x10
000066  9002              STR      r0,[sp,#8]
;;;230    		DMA_Initstructure.DMA_BufferSize = spiBufsize; 													  //指定DMA通道的DMA缓存的大小
000068  0100              LSLS     r0,r0,#4
00006a  9003              STR      r0,[sp,#0xc]
;;;231    		DMA_Initstructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;					//DMA_PeripheralInc_Enable（外设地址寄存器递增），DMA_PeripheralInc_Disable（外设地址寄存器不变），
00006c  2000              MOVS     r0,#0
00006e  9004              STR      r0,[sp,#0x10]
;;;232    		DMA_Initstructure.DMA_MemoryInc =DMA_MemoryInc_Enable;										//DMA_MemoryInc_Enable（内存地址寄存器递增），DMA_MemoryInc_Disable（内存地址寄存器不变）
000070  2080              MOVS     r0,#0x80
000072  9005              STR      r0,[sp,#0x14]
;;;233    		DMA_Initstructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;		//外设数据宽度--DMA_PeripheralDataSize_Byte（数据宽度为8位），DMA_PeripheralDataSize_HalfWord（数据宽度为16位），DMA_PeripheralDataSize_Word（数据宽度为32位）
000074  2000              MOVS     r0,#0
000076  9006              STR      r0,[sp,#0x18]
;;;234    		DMA_Initstructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;						//内存数据宽度--DMA_MemoryDataSize_Byte（数据宽度为8位），DMA_MemoryDataSize_HalfWord（数据宽度为16位），DMA_MemoryDataSize_Word（数据宽度为32位）
000078  9007              STR      r0,[sp,#0x1c]
;;;235    		DMA_Initstructure.DMA_Mode = DMA_Mode_Normal;															//DMA工作模式--DMA_Mode_Normal（只传送一次）, DMA_Mode_Circular（不停地传送）
00007a  9008              STR      r0,[sp,#0x20]
;;;236    		DMA_Initstructure.DMA_Priority = DMA_Priority_High; 											//DMA通道的转输优先级--DMA_Priority_VeryHigh（非常高）DMA_Priority_High（高)，DMA_Priority_Medium（中），DMA_Priority_Low（低）
00007c  f44f5000          MOV      r0,#0x2000
000080  9009              STR      r0,[sp,#0x24]
;;;237    		DMA_Initstructure.DMA_M2M = DMA_M2M_Disable;															//DMA通道的内存到内存传输--DMA_M2M_Enable(设置为内存到内存传输)，DMA_M2M_Disable（非内存到内存传输）
000082  2000              MOVS     r0,#0
000084  900a              STR      r0,[sp,#0x28]
;;;238    		DMA_Init(DMAx_Channeltx,&DMA_Initstructure);															//初始化DMA
000086  4669              MOV      r1,sp
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       DMA_Init
;;;239    
;;;240    		//6)**********DMA接收初始化，外设作为DMA的源端
;;;241    		DMA_Initstructure.DMA_PeripheralBaseAddr =  (u32)(&SPIx->DR);	//DMA外设源地址
00008e  f104000c          ADD      r0,r4,#0xc
000092  9000              STR      r0,[sp,#0]
;;;242    		DMA_Initstructure.DMA_MemoryBaseAddr     = 	(u32)spiTxBuff;						//DMA数据内存地址
000094  4818              LDR      r0,|L9.248|
000096  9001              STR      r0,[sp,#4]
;;;243    		DMA_Initstructure.DMA_DIR = DMA_DIR_PeripheralSRC;												//DMA_DIR_PeripheralDST（外设作为DMA的目的端），DMA_DIR_PeripheralSRC（外设作为数据传输的来源）
000098  2000              MOVS     r0,#0
00009a  9002              STR      r0,[sp,#8]
;;;244    		DMA_Initstructure.DMA_BufferSize = spiBufsize; 													  //指定DMA通道的DMA缓存的大小
00009c  f44f7080          MOV      r0,#0x100
0000a0  9003              STR      r0,[sp,#0xc]
;;;245    		DMA_Initstructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;					//DMA_PeripheralInc_Enable（外设地址寄存器递增），DMA_PeripheralInc_Disable（外设地址寄存器不变），
0000a2  2000              MOVS     r0,#0
0000a4  9004              STR      r0,[sp,#0x10]
;;;246    		DMA_Initstructure.DMA_MemoryInc =DMA_MemoryInc_Enable;										//DMA_MemoryInc_Enable（内存地址寄存器递增），DMA_MemoryInc_Disable（内存地址寄存器不变）
0000a6  2080              MOVS     r0,#0x80
0000a8  9005              STR      r0,[sp,#0x14]
;;;247    		DMA_Initstructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;		//外设数据宽度--DMA_PeripheralDataSize_Byte（数据宽度为8位），DMA_PeripheralDataSize_HalfWord（数据宽度为16位），DMA_PeripheralDataSize_Word（数据宽度为32位）
0000aa  2000              MOVS     r0,#0
0000ac  9006              STR      r0,[sp,#0x18]
;;;248    		DMA_Initstructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;						//内存数据宽度--DMA_MemoryDataSize_Byte（数据宽度为8位），DMA_MemoryDataSize_HalfWord（数据宽度为16位），DMA_MemoryDataSize_Word（数据宽度为32位）
0000ae  9007              STR      r0,[sp,#0x1c]
;;;249    		DMA_Initstructure.DMA_Mode = DMA_Mode_Normal;															//DMA工作模式--DMA_Mode_Normal（只传送一次）, DMA_Mode_Circular（不停地传送）
0000b0  9008              STR      r0,[sp,#0x20]
;;;250    		DMA_Initstructure.DMA_Priority = DMA_Priority_High; 											//DMA通道的转输优先级--DMA_Priority_VeryHigh（非常高）DMA_Priority_High（高)，DMA_Priority_Medium（中），DMA_Priority_Low（低）
0000b2  f44f5000          MOV      r0,#0x2000
0000b6  9009              STR      r0,[sp,#0x24]
;;;251    		DMA_Initstructure.DMA_M2M = DMA_M2M_Disable;															//DMA通道的内存到内存传输--DMA_M2M_Enable(设置为内存到内存传输)，DMA_M2M_Disable（非内存到内存传输）
0000b8  2000              MOVS     r0,#0
0000ba  900a              STR      r0,[sp,#0x28]
;;;252    		DMA_Init(DMAx_Channelrx,&DMA_Initstructure);															//初始化DMA
0000bc  4669              MOV      r1,sp
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       DMA_Init
;;;253    		
;;;254    		//7)**********DMA通道中断初始化---此为DMA发送中断----DMA发送完成中断
;;;255    			
;;;256    		SPI_I2S_DMACmd(SPIx, SPI_I2S_DMAReq_Tx, ENABLE);								//开启DMA发送
0000c4  2201              MOVS     r2,#1
0000c6  2102              MOVS     r1,#2
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       SPI_I2S_DMACmd
;;;257    		SPI_I2S_DMACmd(SPIx, SPI_I2S_DMAReq_Rx, ENABLE);								//开启DMA接收
0000ce  2201              MOVS     r2,#1
0000d0  4611              MOV      r1,r2
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       SPI_I2S_DMACmd
;;;258    		//使能SPIx
;;;259    //		SPI_Cmd(SPIx, ENABLE);
;;;260    		
;;;261    		//9.2)**********使能相关DMA通道传输完成中断
;;;262    		DMA_Cmd(DMAx_Channelrx,ENABLE);	
0000d8  2101              MOVS     r1,#1
0000da  4638              MOV      r0,r7
0000dc  f7fffffe          BL       DMA_Cmd
;;;263    		DMA_Cmd(DMAx_Channeltx,ENABLE);
0000e0  2101              MOVS     r1,#1
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       DMA_Cmd
;;;264    
;;;265    
;;;266      
;;;267    	//使能SPIx
;;;268    //	SPI_Cmd(SPIx, DISABLE);
;;;269    //  SPI_Cmd(SPIx, ENABLE);
;;;270    //		//3)**********使能SPIx_NESS为主输出模式
;;;271    //	if((SPIx->CR1&0X0200)!=SPI_NSS_Soft)						//如果在主机模式下的片选方式为硬件（SPI_NSS_Hard）方式，此处必须打开，否则NSS无信号
;;;272    //	{
;;;273    //		SPI_SSOutputCmd(SPIx, ENABLE);								//如果在主机模式下的片选方式为硬件（SPI_NSS_Hard）方式，此处必须打开，否则NSS无信号,需要在SPI_Cmd(pInfo->Port.SPIx, ENABLE)开启
;;;274    //	}
;;;275    //	else
;;;276    //	{
;;;277    //		SPI_SSOutputCmd(SPIx, DISABLE);								//如果在主机模式下的片选方式为硬件（SPI_NSS_Hard）方式，此处必须打开，否则NSS无信号
;;;278    //	}
;;;279    }
0000e8  b00b              ADD      sp,sp,#0x2c
0000ea  bdf0              POP      {r4-r7,pc}
;;;280    
                          ENDP

                  |L9.236|
                          DCD      0xbfffc800
                  |L9.240|
                          DCD      0x40020030
                  |L9.244|
                          DCD      0x40020408
                  |L9.248|
                          DCD      spiTxBuff

                          AREA ||i.SPI_InitializeNR||, CODE, READONLY, ALIGN=1

                  SPI_InitializeNR PROC
;;;78     *******************************************************************************/
;;;79     void SPI_InitializeNR(SPIDef* pInfo)					//普通SPI接口配置
000000  b570              PUSH     {r4-r6,lr}
;;;80     {
000002  4604              MOV      r4,r0
;;;81     	SPIPortDef		*Port;	
;;;82     //	SPISYS		=	pInfo;
;;;83     	Port			=	&(pInfo->Port);
000004  4625              MOV      r5,r4
;;;84     	
;;;85     	GPIO_Configuration_OPP50	(Port->CS_PORT,				Port->CS_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000006  8929              LDRH     r1,[r5,#8]
000008  6868              LDR      r0,[r5,#4]
00000a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;86     	GPIO_Configuration_OPP50	(Port->CLK_PORT,			Port->CLK_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00000e  8a29              LDRH     r1,[r5,#0x10]
000010  68e8              LDR      r0,[r5,#0xc]
000012  f7fffffe          BL       GPIO_Configuration_OPP50
;;;87     	GPIO_Configuration_OPP50	(Port->MOSI_PORT,			Port->MOSI_Pin);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000016  8c29              LDRH     r1,[r5,#0x20]
000018  69e8              LDR      r0,[r5,#0x1c]
00001a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;88     	GPIO_Configuration_IPU		(Port->MISO_PORT,			Port->MISO_Pin);				//将GPIO相应管脚配置为上拉输入模式----V20170605
00001e  8b29              LDRH     r1,[r5,#0x18]
000020  6968              LDR      r0,[r5,#0x14]
000022  f7fffffe          BL       GPIO_Configuration_IPU
;;;89     }
000026  bd70              POP      {r4-r6,pc}
;;;90     /*******************************************************************************
                          ENDP


                          AREA ||i.SPI_InitializeSPI||, CODE, READONLY, ALIGN=2

                  SPI_InitializeSPI PROC
;;;95     *******************************************************************************/
;;;96     void SPI_InitializeSPI(SPIDef *pInfo)
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;98     	//1)**********定义相关结构体
;;;99     	SPI_InitTypeDef  SPI_InitStructure;
;;;100    	GPIO_InitTypeDef GPIO_InitStructure;
;;;101    	SPI_TypeDef *SPIx	=	pInfo->Port.SPIx;
000006  6825              LDR      r5,[r4,#0]
;;;102    	unsigned char SPIx_CsFlg=1;		//如果使用纯硬件SPIx（含CS脚），SPIx_CsFlg=1，否则SPIx_CsFlg=0；
000008  2601              MOVS     r6,#1
;;;103    
;;;104    	//2)**********相关GPIO配置
;;;105    	switch(*(u32*)&SPIx)
00000a  4863              LDR      r0,|L11.408|
00000c  4428              ADD      r0,r0,r5
00000e  b1d8              CBZ      r0,|L11.72|
000010  f5b06f80          CMP      r0,#0x400
000014  d02f              BEQ      |L11.118|
000016  f5b04f78          CMP      r0,#0xf800
00001a  d150              BNE      |L11.190|
;;;106    	{
;;;107    		case	SPI1_BASE://PA4-NSS;PA5-SCK;PA6-MISO;PA7-MOSI;
;;;108    										RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 ,ENABLE);			//开启SPI时钟
00001c  2101              MOVS     r1,#1
00001e  0308              LSLS     r0,r1,#12
000020  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;109    										RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO|RCC_APB2Periph_GPIOA, ENABLE);
000024  2101              MOVS     r1,#1
000026  2005              MOVS     r0,#5
000028  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;110    										GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
00002c  20f0              MOVS     r0,#0xf0
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;111    										GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000032  2018              MOVS     r0,#0x18
000034  f88d0003          STRB     r0,[sp,#3]
;;;112    										GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000038  2003              MOVS     r0,#3
00003a  f88d0002          STRB     r0,[sp,#2]
;;;113    										GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4856              LDR      r0,|L11.412|
000042  f7fffffe          BL       GPIO_Init
;;;114    					break;
000046  e03b              B        |L11.192|
                  |L11.72|
;;;115    		case	SPI2_BASE://PB12-NSS;PB13-SCK;PB14-MISO;PB15-MOSI;
;;;116    										RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2 ,ENABLE);				//开启SPI时钟	
000048  2101              MOVS     r1,#1
00004a  0388              LSLS     r0,r1,#14
00004c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;117    										RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO|RCC_APB2Periph_GPIOB, ENABLE);
000050  2101              MOVS     r1,#1
000052  2009              MOVS     r0,#9
000054  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;118    										GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
000058  f44f4070          MOV      r0,#0xf000
00005c  f8ad0000          STRH     r0,[sp,#0]
;;;119    										GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000060  2003              MOVS     r0,#3
000062  f88d0002          STRB     r0,[sp,#2]
;;;120    										GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出
000066  2018              MOVS     r0,#0x18
000068  f88d0003          STRB     r0,[sp,#3]
;;;121    										GPIO_Init(GPIOB, &GPIO_InitStructure);
00006c  4669              MOV      r1,sp
00006e  484c              LDR      r0,|L11.416|
000070  f7fffffe          BL       GPIO_Init
;;;122    					break;
000074  e024              B        |L11.192|
                  |L11.118|
;;;123    		case	SPI3_BASE://PA15-NSS;PB3-SCK;PB4-MISO;PB5-MOSI;
;;;124    										RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3 ,ENABLE);
000076  2101              MOVS     r1,#1
000078  03c8              LSLS     r0,r1,#15
00007a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;125    										RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE);
00007e  2101              MOVS     r1,#1
000080  200d              MOVS     r0,#0xd
000082  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;126    										GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
000086  2038              MOVS     r0,#0x38
000088  f8ad0000          STRH     r0,[sp,#0]
;;;127    										GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00008c  2003              MOVS     r0,#3
00008e  f88d0002          STRB     r0,[sp,#2]
;;;128    										GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF_PP;  		//复用推挽输出
000092  2018              MOVS     r0,#0x18
000094  f88d0003          STRB     r0,[sp,#3]
;;;129    										GPIO_Init(GPIOB, &GPIO_InitStructure);
000098  4669              MOV      r1,sp
00009a  4841              LDR      r0,|L11.416|
00009c  f7fffffe          BL       GPIO_Init
;;;130    										//2.2)**********SPI_NSS配置		
;;;131    										GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_15;
0000a0  f44f4000          MOV      r0,#0x8000
0000a4  f8ad0000          STRH     r0,[sp,#0]
;;;132    										GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a8  2003              MOVS     r0,#3
0000aa  f88d0002          STRB     r0,[sp,#2]
;;;133    										GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF_PP;  		//复用推挽输出
0000ae  2018              MOVS     r0,#0x18
0000b0  f88d0003          STRB     r0,[sp,#3]
;;;134    										GPIO_Init(GPIOA, &GPIO_InitStructure);
0000b4  4669              MOV      r1,sp
0000b6  4839              LDR      r0,|L11.412|
0000b8  f7fffffe          BL       GPIO_Init
;;;135    					break;
0000bc  e000              B        |L11.192|
                  |L11.190|
;;;136    		default		: break;
0000be  bf00              NOP      
                  |L11.192|
0000c0  bf00              NOP                            ;114
;;;137    	}
;;;138    	//3)**********SPI配置选项
;;;139    	//3.1)----------SPI波特率检查
;;;140    	if(
0000c2  8c60              LDRH     r0,[r4,#0x22]
0000c4  b108              CBZ      r0,|L11.202|
0000c6  2001              MOVS     r0,#1
0000c8  e000              B        |L11.204|
                  |L11.202|
0000ca  2000              MOVS     r0,#0
                  |L11.204|
0000cc  8c61              LDRH     r1,[r4,#0x22]
0000ce  2908              CMP      r1,#8
0000d0  d001              BEQ      |L11.214|
0000d2  2101              MOVS     r1,#1
0000d4  e000              B        |L11.216|
                  |L11.214|
0000d6  2100              MOVS     r1,#0
                  |L11.216|
0000d8  4008              ANDS     r0,r0,r1
0000da  8c61              LDRH     r1,[r4,#0x22]
0000dc  2910              CMP      r1,#0x10
0000de  d001              BEQ      |L11.228|
0000e0  2101              MOVS     r1,#1
0000e2  e000              B        |L11.230|
                  |L11.228|
0000e4  2100              MOVS     r1,#0
                  |L11.230|
0000e6  4008              ANDS     r0,r0,r1
0000e8  8c61              LDRH     r1,[r4,#0x22]
0000ea  2918              CMP      r1,#0x18
0000ec  d001              BEQ      |L11.242|
0000ee  2101              MOVS     r1,#1
0000f0  e000              B        |L11.244|
                  |L11.242|
0000f2  2100              MOVS     r1,#0
                  |L11.244|
0000f4  4008              ANDS     r0,r0,r1
0000f6  8c61              LDRH     r1,[r4,#0x22]
0000f8  2920              CMP      r1,#0x20
0000fa  d001              BEQ      |L11.256|
0000fc  2101              MOVS     r1,#1
0000fe  e000              B        |L11.258|
                  |L11.256|
000100  2100              MOVS     r1,#0
                  |L11.258|
000102  4008              ANDS     r0,r0,r1
000104  8c61              LDRH     r1,[r4,#0x22]
000106  2928              CMP      r1,#0x28
000108  d001              BEQ      |L11.270|
00010a  2101              MOVS     r1,#1
00010c  e000              B        |L11.272|
                  |L11.270|
00010e  2100              MOVS     r1,#0
                  |L11.272|
000110  4008              ANDS     r0,r0,r1
000112  8c61              LDRH     r1,[r4,#0x22]
000114  2930              CMP      r1,#0x30
000116  d001              BEQ      |L11.284|
000118  2101              MOVS     r1,#1
00011a  e000              B        |L11.286|
                  |L11.284|
00011c  2100              MOVS     r1,#0
                  |L11.286|
00011e  4008              ANDS     r0,r0,r1
000120  8c61              LDRH     r1,[r4,#0x22]
000122  2938              CMP      r1,#0x38
000124  d001              BEQ      |L11.298|
000126  2101              MOVS     r1,#1
000128  e000              B        |L11.300|
                  |L11.298|
00012a  2100              MOVS     r1,#0
                  |L11.300|
00012c  4008              ANDS     r0,r0,r1
00012e  b108              CBZ      r0,|L11.308|
;;;141    			(SPI_BaudRatePrescaler_2  !=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;142    		&(SPI_BaudRatePrescaler_4		!=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;143    		&(SPI_BaudRatePrescaler_8		!=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;144    		&(SPI_BaudRatePrescaler_16  !=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;145    		&(SPI_BaudRatePrescaler_32  !=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;146    		&(SPI_BaudRatePrescaler_64  !=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;147    		&(SPI_BaudRatePrescaler_128	!=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;148    		&(SPI_BaudRatePrescaler_256	!=	pInfo->Port.SPI_BaudRatePrescaler_x)
;;;149    		)
;;;150    	{
;;;151    		//未设置波特率使用最高
;;;152    		pInfo->Port.SPI_BaudRatePrescaler_x	=	SPI_BaudRatePrescaler_2;
000130  2000              MOVS     r0,#0
000132  8460              STRH     r0,[r4,#0x22]
                  |L11.308|
;;;153    	}
;;;154    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;				//设置方向				（2线全双工、2线只接收、一线发送、一线接收）
000134  2000              MOVS     r0,#0
000136  f8ad0004          STRH     r0,[sp,#4]
;;;155    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;															//模式         	（从或主设备）
00013a  f44f7082          MOV      r0,#0x104
00013e  f8ad0006          STRH     r0,[sp,#6]
;;;156    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;													//宽度         	（8或16位）
000142  2000              MOVS     r0,#0
000144  f8ad0008          STRH     r0,[sp,#8]
;;;157    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;																//时钟极性     	（低或高）
000148  2002              MOVS     r0,#2
00014a  f8ad000a          STRH     r0,[sp,#0xa]
;;;158    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;															//时钟相位     	（第一个或第二个跳变沿）	
00014e  2001              MOVS     r0,#1
000150  f8ad000c          STRH     r0,[sp,#0xc]
;;;159    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;												//最先发送的位 	（最低位，还是最高位在先）
000154  2000              MOVS     r0,#0
000156  f8ad0012          STRH     r0,[sp,#0x12]
;;;160    	SPI_InitStructure.SPI_CRCPolynomial = 7;																	//设置crc多项式	（数字）如7
00015a  2007              MOVS     r0,#7
00015c  f8ad0014          STRH     r0,[sp,#0x14]
;;;161    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;																	//片选方式     	（硬件或软件方式）
000160  f44f7000          MOV      r0,#0x200
000164  f8ad000e          STRH     r0,[sp,#0xe]
;;;162    	SPI_InitStructure.SPI_BaudRatePrescaler = pInfo->Port.SPI_BaudRatePrescaler_x;				//波特率预分频 	（从2---256分频）
000168  8c60              LDRH     r0,[r4,#0x22]
00016a  f8ad0010          STRH     r0,[sp,#0x10]
;;;163    	SPI_Init(pInfo->Port.SPIx,&SPI_InitStructure);
00016e  a901              ADD      r1,sp,#4
000170  6820              LDR      r0,[r4,#0]
000172  f7fffffe          BL       SPI_Init
;;;164    	
;;;165    
;;;166    //	//3)**********使能SPIx_NESS为主输出模式，NSS主输出模式需要外接上拉电阻，否则无法实现关闭SPI时NSS脚上拉为高电平
;;;167    	if((pInfo->Port.SPIx->CR1&0X0200)!=SPI_NSS_Soft)						//如果在主机模式下的片选方式为硬件（SPI_NSS_Hard）方式，此处必须打开，否则NSS无信号
000176  6820              LDR      r0,[r4,#0]
000178  8800              LDRH     r0,[r0,#0]
00017a  f4007000          AND      r0,r0,#0x200
00017e  f5b07f00          CMP      r0,#0x200
000182  d003              BEQ      |L11.396|
;;;168    	{
;;;169    		SPI_SSOutputCmd(pInfo->Port.SPIx, ENABLE);			//如果在主机模式下的片选方式为硬件（SPI_NSS_Hard）方式，此处必须打开，否则NSS无信号,需要在SPI_Cmd(pInfo->Port.SPIx, ENABLE)开启
000184  2101              MOVS     r1,#1
000186  6820              LDR      r0,[r4,#0]
000188  f7fffffe          BL       SPI_SSOutputCmd
                  |L11.396|
;;;170    	}
;;;171      SPI_Cmd(pInfo->Port.SPIx, ENABLE);				//使能SPI
00018c  2101              MOVS     r1,#1
00018e  6820              LDR      r0,[r4,#0]
000190  f7fffffe          BL       SPI_Cmd
;;;172    }
000194  b006              ADD      sp,sp,#0x18
000196  bd70              POP      {r4-r6,pc}
;;;173    /*******************************************************************************
                          ENDP

                  |L11.408|
                          DCD      0xbfffc800
                  |L11.412|
                          DCD      0x40010800
                  |L11.416|
                          DCD      0x40010c00

                          AREA ||i.SPI_MISO_In||, CODE, READONLY, ALIGN=1

                  SPI_MISO_In PROC
;;;306    }
;;;307    unsigned char SPI_MISO_In(SPIDef *pInfo)
000000  4601              MOV      r1,r0
;;;308    {
;;;309    	return(pInfo->Port.MISO_PORT->IDR 	&	pInfo->Port.MISO_Pin);
000002  6948              LDR      r0,[r1,#0x14]
000004  6880              LDR      r0,[r0,#8]
000006  7e0a              LDRB     r2,[r1,#0x18]
000008  4010              ANDS     r0,r0,r2
00000a  b2c0              UXTB     r0,r0
;;;310    }
00000c  4770              BX       lr
;;;311    /*******************************************************************************
                          ENDP


                          AREA ||i.SPI_MOSI_HIGH||, CODE, READONLY, ALIGN=1

                  SPI_MOSI_HIGH PROC
;;;302    }
;;;303    void SPI_MOSI_HIGH(SPIDef *pInfo)
000000  8a01              LDRH     r1,[r0,#0x10]
;;;304    {
;;;305    	pInfo->Port.CLK_PORT->BSRR 	= pInfo->Port.CLK_Pin;
000002  68c2              LDR      r2,[r0,#0xc]
000004  6111              STR      r1,[r2,#0x10]
;;;306    }
000006  4770              BX       lr
;;;307    unsigned char SPI_MISO_In(SPIDef *pInfo)
                          ENDP


                          AREA ||i.SPI_MOSI_LOW||, CODE, READONLY, ALIGN=1

                  SPI_MOSI_LOW PROC
;;;298    }
;;;299    void SPI_MOSI_LOW(SPIDef *pInfo)
000000  8a01              LDRH     r1,[r0,#0x10]
;;;300    {
;;;301    	pInfo->Port.CLK_PORT->BRR 	= pInfo->Port.CLK_Pin;
000002  68c2              LDR      r2,[r0,#0xc]
000004  6151              STR      r1,[r2,#0x14]
;;;302    }
000006  4770              BX       lr
;;;303    void SPI_MOSI_HIGH(SPIDef *pInfo)
                          ENDP


                          AREA ||i.SPI_ReadBufferSPI||, CODE, READONLY, ALIGN=1

                  SPI_ReadBufferSPI PROC
;;;499    *******************************************************************************/
;;;500    void SPI_ReadBufferSPI(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;501    										SPIDef *pInfo,
;;;502    										u8 *Buffer,
;;;503    										u16 BufferSize										
;;;504    										)
;;;505    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;506    	unsigned short bufferNum=0;
00000a  2400              MOVS     r4,#0
;;;507    //	SPI_Cmd(SPIx, ENABLE);
;;;508    //	SPI_CS_LOW;
;;;509    	for(bufferNum=0;bufferNum<BufferSize;bufferNum++)
00000c  bf00              NOP      
00000e  e006              B        |L15.30|
                  |L15.16|
;;;510    	{
;;;511    		Buffer[bufferNum]	=	SPI_ReadWriteByteSPI(pInfo,0xFF);
000010  21ff              MOVS     r1,#0xff
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       SPI_ReadWriteByteSPI
000018  5528              STRB     r0,[r5,r4]
00001a  1c60              ADDS     r0,r4,#1              ;509
00001c  b284              UXTH     r4,r0                 ;509
                  |L15.30|
00001e  42b4              CMP      r4,r6                 ;509
000020  dbf6              BLT      |L15.16|
;;;512    	}
;;;513    //	SPI_Cmd(SPIx, DISABLE);
;;;514    //	SPI_CS_HIGH;
;;;515    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;516    
                          ENDP


                          AREA ||i.SPI_ReadWriteByteNR||, CODE, READONLY, ALIGN=1

                  SPI_ReadWriteByteNR PROC
;;;408    *******************************************************************************/
;;;409    unsigned char	SPI_ReadWriteByteNR(SPIDef *pInfo,unsigned char Byte)
000000  b570              PUSH     {r4-r6,lr}
;;;410    {
000002  4606              MOV      r6,r0
000004  460b              MOV      r3,r1
;;;411    	unsigned char i	=	0;	
000006  2500              MOVS     r5,#0
;;;412    	unsigned char Recv	=	0;	
000008  2400              MOVS     r4,#0
;;;413    
;;;414    	for(i=0;i<8;i++)
00000a  bf00              NOP      
00000c  e01c              B        |L16.72|
                  |L16.14|
;;;415    	{
;;;416    		Recv<<=1;
00000e  0660              LSLS     r0,r4,#25
000010  0e04              LSRS     r4,r0,#24
;;;417    		SPI_CLK_LOW(pInfo);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SPI_CLK_LOW
;;;418    		if((Byte&0x80)	==	0x80)
000018  f0030080          AND      r0,r3,#0x80
00001c  2880              CMP      r0,#0x80
00001e  d103              BNE      |L16.40|
;;;419    		{
;;;420    			SPI_MOSI_HIGH(pInfo);
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       SPI_MOSI_HIGH
000026  e002              B        |L16.46|
                  |L16.40|
;;;421    		}
;;;422    		else
;;;423    		{
;;;424    			SPI_MOSI_LOW(pInfo);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       SPI_MOSI_LOW
                  |L16.46|
;;;425    		}
;;;426    		if(SPI_MISO_In(pInfo))
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       SPI_MISO_In
000034  b108              CBZ      r0,|L16.58|
;;;427    		{
;;;428    			Recv	|=	0x01;
000036  f0440401          ORR      r4,r4,#1
                  |L16.58|
;;;429    		}		
;;;430    		SPI_CLK_HIGH(pInfo);
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       SPI_CLK_HIGH
;;;431    		Byte<<=1;		
000040  0658              LSLS     r0,r3,#25
000042  0e03              LSRS     r3,r0,#24
000044  1c68              ADDS     r0,r5,#1              ;414
000046  b2c5              UXTB     r5,r0                 ;414
                  |L16.72|
000048  2d08              CMP      r5,#8                 ;414
00004a  dbe0              BLT      |L16.14|
;;;432    	}
;;;433    	return Recv;
00004c  4620              MOV      r0,r4
;;;434    }
00004e  bd70              POP      {r4-r6,pc}
;;;435    /*******************************************************************************
                          ENDP


                          AREA ||i.SPI_ReadWriteByteSPI||, CODE, READONLY, ALIGN=1

                  SPI_ReadWriteByteSPI PROC
;;;440    *******************************************************************************/
;;;441    u8	SPI_ReadWriteByteSPI(SPIDef *pInfo,unsigned char Data)
000000  b570              PUSH     {r4-r6,lr}
;;;442    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;443    //____________定义变量
;;;444    	u16 retry=0;													//用来进行超时计数
000006  2500              MOVS     r5,#0
;;;445    	//____________等待发送缓冲区为空
;;;446    	while(SPI_I2S_GetFlagStatus(pInfo->Port.SPIx, SPI_I2S_FLAG_TXE) == RESET) 		//检查指令SPI发送标志是否为空
000008  e007              B        |L17.26|
                  |L17.10|
;;;447    	{
;;;448    		retry++;
00000a  1c68              ADDS     r0,r5,#1
00000c  b285              UXTH     r5,r0
;;;449    		if(retry>5000)
00000e  f2413088          MOV      r0,#0x1388
000012  4285              CMP      r5,r0
000014  dd01              BLE      |L17.26|
;;;450    			return 0;
000016  2000              MOVS     r0,#0
                  |L17.24|
;;;451    	}	
;;;452    	//____________发送数据
;;;453    	SPI_I2S_SendData(pInfo->Port.SPIx, Data);				//发送数据
;;;454    	//____________等待接收数据
;;;455    	retry=0;	
;;;456    	while(SPI_I2S_GetFlagStatus(pInfo->Port.SPIx, SPI_I2S_FLAG_RXNE) == RESET)		//检查指令SPI接收完成标志设置与否
;;;457    	{
;;;458    		retry++;
;;;459    		if(retry>5000)
;;;460    			return 0;
;;;461    	}
;;;462    	while (SPI_I2S_GetFlagStatus(pInfo->Port.SPIx, SPI_I2S_FLAG_BSY) == SET);
;;;463    	//____________返回接收到的数据
;;;464    	return SPI_I2S_ReceiveData(pInfo->Port.SPIx); 			//返回接收到的数据	
;;;465    }
000018  bd70              POP      {r4-r6,pc}
                  |L17.26|
00001a  2102              MOVS     r1,#2                 ;446
00001c  6820              LDR      r0,[r4,#0]            ;446
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0                 ;446
000024  d0f1              BEQ      |L17.10|
000026  4631              MOV      r1,r6                 ;453
000028  6820              LDR      r0,[r4,#0]            ;453
00002a  f7fffffe          BL       SPI_I2S_SendData
00002e  2500              MOVS     r5,#0                 ;455
000030  e007              B        |L17.66|
                  |L17.50|
000032  1c68              ADDS     r0,r5,#1              ;458
000034  b285              UXTH     r5,r0                 ;458
000036  f2413088          MOV      r0,#0x1388            ;459
00003a  4285              CMP      r5,r0                 ;459
00003c  dd01              BLE      |L17.66|
00003e  2000              MOVS     r0,#0                 ;460
000040  e7ea              B        |L17.24|
                  |L17.66|
000042  2101              MOVS     r1,#1                 ;456
000044  6820              LDR      r0,[r4,#0]            ;456
000046  f7fffffe          BL       SPI_I2S_GetFlagStatus
00004a  2800              CMP      r0,#0                 ;456
00004c  d0f1              BEQ      |L17.50|
00004e  bf00              NOP                            ;462
                  |L17.80|
000050  2180              MOVS     r1,#0x80              ;462
000052  6820              LDR      r0,[r4,#0]            ;462
000054  f7fffffe          BL       SPI_I2S_GetFlagStatus
000058  2801              CMP      r0,#1                 ;462
00005a  d0f9              BEQ      |L17.80|
00005c  6820              LDR      r0,[r4,#0]            ;464
00005e  f7fffffe          BL       SPI_I2S_ReceiveData
000062  b2c0              UXTB     r0,r0                 ;464
000064  e7d8              B        |L17.24|
;;;466    /*******************************************************************************
                          ENDP


                          AREA ||i.SPI_WriteBufferSPI||, CODE, READONLY, ALIGN=1

                  SPI_WriteBufferSPI PROC
;;;474    *******************************************************************************/
;;;475    void SPI_WriteBufferSPI(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;476    										SPIDef *pInfo,
;;;477    										u8 *Buffer,
;;;478    										u16 BufferSize										
;;;479    										)
;;;480    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;481    	unsigned short bufferNum=0;
00000a  2400              MOVS     r4,#0
;;;482    //	SPI_Cmd(SPIx, ENABLE);
;;;483    //	SPI_CS_LOW;
;;;484    	for(bufferNum=0;bufferNum<BufferSize;bufferNum++)
00000c  bf00              NOP      
00000e  e005              B        |L18.28|
                  |L18.16|
;;;485    	{
;;;486    		SPI_ReadWriteByteSPI(pInfo,Buffer[bufferNum]);
000010  5d29              LDRB     r1,[r5,r4]
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       SPI_ReadWriteByteSPI
000018  1c60              ADDS     r0,r4,#1              ;484
00001a  b284              UXTH     r4,r0                 ;484
                  |L18.28|
00001c  42b4              CMP      r4,r6                 ;484
00001e  dbf7              BLT      |L18.16|
;;;487    	}
;;;488    //	SPI_Cmd(SPIx, DISABLE);
;;;489    //	SPI_CS_HIGH;
;;;490    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;491    /*******************************************************************************
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  spiTxBuff
                          %        256
