; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32f10x_gpio.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32f10x_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32f10x_gpio.crf ..\..\Library\STM32F10x_StdPeriph_Driver\SCR\stm32f10x_gpio.c]
                          THUMB

                          AREA ||i.GPIO_AFIODeInit||, CODE, READONLY, ALIGN=1

                  GPIO_AFIODeInit PROC
;;;106    *******************************************************************************/
;;;107    void GPIO_AFIODeInit(void)
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109      RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;110      RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;111    }
000012  bd10              POP      {r4,pc}
;;;112    
                          ENDP


                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;50     *******************************************************************************/
;;;51     void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  b510              PUSH     {r4,lr}
;;;52     {
000002  4604              MOV      r4,r0
;;;53       /* Check the parameters */
;;;54       assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;55       
;;;56       switch (*(u32*)&GPIOx)
000004  492d              LDR      r1,|L2.188|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d02f              BEQ      |L2.108|
00000c  dc09              BGT      |L2.34|
00000e  482c              LDR      r0,|L2.192|
000010  4420              ADD      r0,r0,r4
000012  b180              CBZ      r0,|L2.54|
000014  f5b06f80          CMP      r0,#0x400
000018  d016              BEQ      |L2.72|
00001a  f5b06f00          CMP      r0,#0x800
00001e  d14a              BNE      |L2.182|
000020  e01b              B        |L2.90|
                  |L2.34|
000022  f5b06f80          CMP      r0,#0x400
000026  d02a              BEQ      |L2.126|
000028  f5b06f00          CMP      r0,#0x800
00002c  d030              BEQ      |L2.144|
00002e  f5b06f40          CMP      r0,#0xc00
000032  d140              BNE      |L2.182|
000034  e035              B        |L2.162|
                  |L2.54|
;;;57       {
;;;58         case GPIOA_BASE:
;;;59           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
000036  2101              MOVS     r1,#1
000038  2004              MOVS     r0,#4
00003a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;60           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
00003e  2100              MOVS     r1,#0
000040  2004              MOVS     r0,#4
000042  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;61           break;
000046  e037              B        |L2.184|
                  |L2.72|
;;;62     
;;;63         case GPIOB_BASE:
;;;64           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
000048  2101              MOVS     r1,#1
00004a  2008              MOVS     r0,#8
00004c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;65           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
000050  2100              MOVS     r1,#0
000052  2008              MOVS     r0,#8
000054  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;66           break;
000058  e02e              B        |L2.184|
                  |L2.90|
;;;67     
;;;68         case GPIOC_BASE:
;;;69           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
00005a  2101              MOVS     r1,#1
00005c  2010              MOVS     r0,#0x10
00005e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;70           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
000062  2100              MOVS     r1,#0
000064  2010              MOVS     r0,#0x10
000066  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;71           break;
00006a  e025              B        |L2.184|
                  |L2.108|
;;;72     
;;;73         case GPIOD_BASE:
;;;74           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2020              MOVS     r0,#0x20
000070  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;75           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
000074  2100              MOVS     r1,#0
000076  2020              MOVS     r0,#0x20
000078  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;76           break;
00007c  e01c              B        |L2.184|
                  |L2.126|
;;;77           
;;;78         case GPIOE_BASE:
;;;79           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
00007e  2101              MOVS     r1,#1
000080  2040              MOVS     r0,#0x40
000082  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;80           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
000086  2100              MOVS     r1,#0
000088  2040              MOVS     r0,#0x40
00008a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;81           break; 
00008e  e013              B        |L2.184|
                  |L2.144|
;;;82     
;;;83         case GPIOF_BASE:
;;;84           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
000090  2101              MOVS     r1,#1
000092  2080              MOVS     r0,#0x80
000094  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;85           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
000098  2100              MOVS     r1,#0
00009a  2080              MOVS     r0,#0x80
00009c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;86           break;
0000a0  e00a              B        |L2.184|
                  |L2.162|
;;;87     
;;;88         case GPIOG_BASE:
;;;89           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  0208              LSLS     r0,r1,#8
0000a6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;90           RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
0000aa  2100              MOVS     r1,#0
0000ac  f44f7080          MOV      r0,#0x100
0000b0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;91           break;                       
0000b4  e000              B        |L2.184|
                  |L2.182|
;;;92     
;;;93         default:
;;;94           break;
0000b6  bf00              NOP      
                  |L2.184|
0000b8  bf00              NOP                            ;61
;;;95       }
;;;96     }
0000ba  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  |L2.188|
                          DCD      0x40011400
                  |L2.192|
                          DCD      0xbffef800

                          AREA ||i.GPIO_EXTILineConfig||, CODE, READONLY, ALIGN=2

                  GPIO_EXTILineConfig PROC
;;;569    *******************************************************************************/
;;;570    void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
000000  b530              PUSH     {r4,r5,lr}
;;;571    {
;;;572      u32 tmp = 0x00;
000002  2200              MOVS     r2,#0
;;;573    
;;;574      /* Check the parameters */
;;;575      assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
;;;576      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;577      
;;;578      tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
000004  078b              LSLS     r3,r1,#30
000006  0f1c              LSRS     r4,r3,#28
000008  230f              MOVS     r3,#0xf
00000a  fa03f204          LSL      r2,r3,r4
;;;579    
;;;580      AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
00000e  4b0b              LDR      r3,|L3.60|
000010  108c              ASRS     r4,r1,#2
000012  f8533024          LDR      r3,[r3,r4,LSL #2]
000016  4393              BICS     r3,r3,r2
000018  4c08              LDR      r4,|L3.60|
00001a  108d              ASRS     r5,r1,#2
00001c  f8443025          STR      r3,[r4,r5,LSL #2]
;;;581      AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
000020  4623              MOV      r3,r4
000022  108c              ASRS     r4,r1,#2
000024  f8533024          LDR      r3,[r3,r4,LSL #2]
000028  078c              LSLS     r4,r1,#30
00002a  0f24              LSRS     r4,r4,#28
00002c  fa00f404          LSL      r4,r0,r4
000030  4323              ORRS     r3,r3,r4
000032  4c02              LDR      r4,|L3.60|
000034  108d              ASRS     r5,r1,#2
000036  f8443025          STR      r3,[r4,r5,LSL #2]
;;;582    }
00003a  bd30              POP      {r4,r5,pc}
;;;583    
                          ENDP

                  |L3.60|
                          DCD      0x40010008

                          AREA ||i.GPIO_EventOutputCmd||, CODE, READONLY, ALIGN=2

                  GPIO_EventOutputCmd PROC
;;;476    *******************************************************************************/
;;;477    void GPIO_EventOutputCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L4.8|
;;;478    {
;;;479      /* Check the parameters */
;;;480      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;481      
;;;482      *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
000002  61c8              STR      r0,[r1,#0x1c]
;;;483    }
000004  4770              BX       lr
;;;484    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x42200000

                          AREA ||i.GPIO_EventOutputConfig||, CODE, READONLY, ALIGN=2

                  GPIO_EventOutputConfig PROC
;;;451    *******************************************************************************/
;;;452    void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
000000  4602              MOV      r2,r0
;;;453    {
;;;454      u32 tmpreg = 0x00;
000002  2000              MOVS     r0,#0
;;;455    
;;;456      /* Check the parameters */
;;;457      assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
;;;458      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;459        
;;;460      tmpreg = AFIO->EVCR;
000004  4b05              LDR      r3,|L5.28|
000006  6818              LDR      r0,[r3,#0]
;;;461      /* Clear the PORT[6:4] and PIN[3:0] bits */
;;;462      tmpreg &= EVCR_PORTPINCONFIG_MASK;
000008  f64f7380          MOV      r3,#0xff80
00000c  4018              ANDS     r0,r0,r3
;;;463      tmpreg |= (u32)GPIO_PortSource << 0x04;
00000e  ea401002          ORR      r0,r0,r2,LSL #4
;;;464      tmpreg |= GPIO_PinSource;
000012  4308              ORRS     r0,r0,r1
;;;465    
;;;466      AFIO->EVCR = tmpreg;
000014  4b01              LDR      r3,|L5.28|
000016  6018              STR      r0,[r3,#0]
;;;467    }
000018  4770              BX       lr
;;;468    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40010000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;123    *******************************************************************************/
;;;124    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
000004  4602              MOV      r2,r0
;;;126      u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2000              MOVS     r0,#0
00000c  2300              MOVS     r3,#0
;;;127      u32 tmpreg = 0x00, pinmask = 0x00;
00000e  2400              MOVS     r4,#0
000010  2700              MOVS     r7,#0
;;;128    	if(0	==	GPIOx)
000012  b90a              CBNZ     r2,|L6.24|
                  |L6.20|
;;;129    	{
;;;130    		return;
;;;131    	}
;;;132      /* Check the parameters */
;;;133      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;134      assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;135      assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;136    	assert_param(IS_GET_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));   
;;;137      
;;;138    /*---------------------------- GPIO Mode Configuration -----------------------*/
;;;139      currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
;;;140    
;;;141      if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
;;;142      { 
;;;143        /* Check the parameters */
;;;144        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;145        /* Output mode */
;;;146        currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
;;;147      }
;;;148    
;;;149    /*---------------------------- GPIO CRL Configuration ------------------------*/
;;;150      /* Configure the eight low port pins */
;;;151      if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
;;;152      {
;;;153        tmpreg = GPIOx->CRL;
;;;154    
;;;155        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
;;;156        {
;;;157          pos = ((u32)0x01) << pinpos;
;;;158          /* Get the port pins position */
;;;159          currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
;;;160    
;;;161          if (currentpin == pos)
;;;162          {
;;;163            pos = pinpos << 2;
;;;164            /* Clear the corresponding low control register bits */
;;;165            pinmask = ((u32)0x0F) << pos;
;;;166            tmpreg &= ~pinmask;
;;;167    
;;;168            /* Write the mode configuration in the corresponding bits */
;;;169            tmpreg |= (currentmode << pos);
;;;170    
;;;171            /* Reset the corresponding ODR bit */
;;;172            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
;;;173            {
;;;174              GPIOx->BRR = (((u32)0x01) << pinpos);
;;;175            }
;;;176            /* Set the corresponding ODR bit */
;;;177            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
;;;178            {
;;;179              GPIOx->BSRR = (((u32)0x01) << pinpos);
;;;180            }
;;;181          }
;;;182        }
;;;183        GPIOx->CRL = tmpreg;
;;;184      }
;;;185    
;;;186    /*---------------------------- GPIO CRH Configuration ------------------------*/
;;;187      /* Configure the eight high port pins */
;;;188      if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
;;;189      {
;;;190        tmpreg = GPIOx->CRH;
;;;191        for (pinpos = 0x00; pinpos < 0x08; pinpos++)
;;;192        {
;;;193          pos = (((u32)0x01) << (pinpos + 0x08));
;;;194          /* Get the port pins position */
;;;195          currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
;;;196          if (currentpin == pos)
;;;197          {
;;;198            pos = pinpos << 2;
;;;199            /* Clear the corresponding high control register bits */
;;;200            pinmask = ((u32)0x0F) << pos;
;;;201            tmpreg &= ~pinmask;
;;;202    
;;;203            /* Write the mode configuration in the corresponding bits */
;;;204            tmpreg |= (currentmode << pos);
;;;205    
;;;206            /* Reset the corresponding ODR bit */
;;;207            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
;;;208            {
;;;209              GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
;;;210            }
;;;211            /* Set the corresponding ODR bit */
;;;212            if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
;;;213            {
;;;214              GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
;;;215            }
;;;216          }
;;;217        }
;;;218        GPIOx->CRH = tmpreg;
;;;219      }
;;;220    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L6.24|
000018  f891c003          LDRB     r12,[r1,#3]           ;139
00001c  f00c050f          AND      r5,r12,#0xf           ;139
000020  f891c003          LDRB     r12,[r1,#3]           ;141
000024  f00c0c10          AND      r12,r12,#0x10         ;141
000028  f1bc0f00          CMP      r12,#0                ;141
00002c  d003              BEQ      |L6.54|
00002e  f891c002          LDRB     r12,[r1,#2]           ;146
000032  ea4c0505          ORR      r5,r12,r5             ;146
                  |L6.54|
000036  f891c000          LDRB     r12,[r1,#0]           ;151
00003a  f1bc0f00          CMP      r12,#0                ;151
00003e  d030              BEQ      |L6.162|
000040  6814              LDR      r4,[r2,#0]            ;153
000042  2000              MOVS     r0,#0                 ;155
000044  e02a              B        |L6.156|
                  |L6.70|
000046  f04f0c01          MOV      r12,#1                ;157
00004a  fa0cf300          LSL      r3,r12,r0             ;157
00004e  f8b1c000          LDRH     r12,[r1,#0]           ;159
000052  ea0c0603          AND      r6,r12,r3             ;159
000056  429e              CMP      r6,r3                 ;161
000058  d11f              BNE      |L6.154|
00005a  0083              LSLS     r3,r0,#2              ;163
00005c  f04f0c0f          MOV      r12,#0xf              ;165
000060  fa0cf703          LSL      r7,r12,r3             ;165
000064  43bc              BICS     r4,r4,r7              ;166
000066  fa05fc03          LSL      r12,r5,r3             ;169
00006a  ea4c0404          ORR      r4,r12,r4             ;169
00006e  f891c003          LDRB     r12,[r1,#3]           ;172
000072  f1bc0f28          CMP      r12,#0x28             ;172
000076  d105              BNE      |L6.132|
000078  f04f0c01          MOV      r12,#1                ;174
00007c  fa0cfc00          LSL      r12,r12,r0            ;174
000080  f8c2c014          STR      r12,[r2,#0x14]        ;174
                  |L6.132|
000084  f891c003          LDRB     r12,[r1,#3]           ;177
000088  f1bc0f48          CMP      r12,#0x48             ;177
00008c  d105              BNE      |L6.154|
00008e  f04f0c01          MOV      r12,#1                ;179
000092  fa0cfc00          LSL      r12,r12,r0            ;179
000096  f8c2c010          STR      r12,[r2,#0x10]        ;179
                  |L6.154|
00009a  1c40              ADDS     r0,r0,#1              ;155
                  |L6.156|
00009c  2808              CMP      r0,#8                 ;155
00009e  d3d2              BCC      |L6.70|
0000a0  6014              STR      r4,[r2,#0]            ;183
                  |L6.162|
0000a2  f8b1c000          LDRH     r12,[r1,#0]           ;188
0000a6  f1bc0fff          CMP      r12,#0xff             ;188
0000aa  dd34              BLE      |L6.278|
0000ac  6854              LDR      r4,[r2,#4]            ;190
0000ae  2000              MOVS     r0,#0                 ;191
0000b0  e02e              B        |L6.272|
                  |L6.178|
0000b2  f1000c08          ADD      r12,r0,#8             ;193
0000b6  f04f0801          MOV      r8,#1                 ;193
0000ba  fa08f30c          LSL      r3,r8,r12             ;193
0000be  f8b1c000          LDRH     r12,[r1,#0]           ;195
0000c2  ea0c0603          AND      r6,r12,r3             ;195
0000c6  429e              CMP      r6,r3                 ;196
0000c8  d121              BNE      |L6.270|
0000ca  0083              LSLS     r3,r0,#2              ;198
0000cc  f04f0c0f          MOV      r12,#0xf              ;200
0000d0  fa0cf703          LSL      r7,r12,r3             ;200
0000d4  43bc              BICS     r4,r4,r7              ;201
0000d6  fa05fc03          LSL      r12,r5,r3             ;204
0000da  ea4c0404          ORR      r4,r12,r4             ;204
0000de  f891c003          LDRB     r12,[r1,#3]           ;207
0000e2  f1bc0f28          CMP      r12,#0x28             ;207
0000e6  d105              BNE      |L6.244|
0000e8  f1000c08          ADD      r12,r0,#8             ;209
0000ec  fa08f80c          LSL      r8,r8,r12             ;209
0000f0  f8c28014          STR      r8,[r2,#0x14]         ;209
                  |L6.244|
0000f4  f891c003          LDRB     r12,[r1,#3]           ;212
0000f8  f1bc0f48          CMP      r12,#0x48             ;212
0000fc  d107              BNE      |L6.270|
0000fe  f1000c08          ADD      r12,r0,#8             ;214
000102  f04f0801          MOV      r8,#1                 ;214
000106  fa08f80c          LSL      r8,r8,r12             ;214
00010a  f8c28010          STR      r8,[r2,#0x10]         ;214
                  |L6.270|
00010e  1c40              ADDS     r0,r0,#1              ;191
                  |L6.272|
000110  2808              CMP      r0,#8                 ;191
000112  d3ce              BCC      |L6.178|
000114  6054              STR      r4,[r2,#4]            ;218
                  |L6.278|
000116  bf00              NOP      
000118  e77c              B        |L6.20|
;;;221    
                          ENDP


                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;418    *******************************************************************************/
;;;419    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  f44f3280          MOV      r2,#0x10000
;;;420    {
;;;421      u32 tmp = 0x00010000;
;;;422      
;;;423      /* Check the parameters */
;;;424      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;425      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;426      
;;;427      tmp |= GPIO_Pin;
000004  430a              ORRS     r2,r2,r1
;;;428      /* Set LCKK bit */
;;;429      GPIOx->LCKR = tmp;
000006  6182              STR      r2,[r0,#0x18]
;;;430      /* Reset LCKK bit */
;;;431      GPIOx->LCKR =  GPIO_Pin;
000008  6181              STR      r1,[r0,#0x18]
;;;432      /* Set LCKK bit */
;;;433      GPIOx->LCKR = tmp;
00000a  6182              STR      r2,[r0,#0x18]
;;;434      /* Read LCKK bit*/
;;;435      tmp = GPIOx->LCKR;
00000c  6982              LDR      r2,[r0,#0x18]
;;;436      /* Read LCKK bit*/
;;;437      tmp = GPIOx->LCKR;
00000e  6982              LDR      r2,[r0,#0x18]
;;;438    }
000010  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.GPIO_PinRemapConfig||, CODE, READONLY, ALIGN=2

                  GPIO_PinRemapConfig PROC
;;;519    *******************************************************************************/
;;;520    void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
000000  b5f0              PUSH     {r4-r7,lr}
;;;521    {
000002  460a              MOV      r2,r1
;;;522      u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
000008  2100              MOVS     r1,#0
00000a  2500              MOVS     r5,#0
;;;523    
;;;524      /* Check the parameters */
;;;525      assert_param(IS_GPIO_REMAP(GPIO_Remap));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;527      
;;;528      tmpreg = AFIO->MAPR;
00000c  4e17              LDR      r6,|L8.108|
00000e  6871              LDR      r1,[r6,#4]
;;;529    
;;;530      tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
000010  f3c04503          UBFX     r5,r0,#16,#4
;;;531      tmp = GPIO_Remap & LSB_MASK;
000014  b283              UXTH     r3,r0
;;;532    
;;;533      if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
000016  f4001640          AND      r6,r0,#0x300000
00001a  f5b61f40          CMP      r6,#0x300000
00001e  d108              BNE      |L8.50|
;;;534      {
;;;535        tmpreg &= DBGAFR_SWJCFG_MASK;
000020  f0216170          BIC      r1,r1,#0xf000000
;;;536        AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
000024  4e11              LDR      r6,|L8.108|
000026  6876              LDR      r6,[r6,#4]
000028  f0266670          BIC      r6,r6,#0xf000000
00002c  4f0f              LDR      r7,|L8.108|
00002e  607e              STR      r6,[r7,#4]
000030  e012              B        |L8.88|
                  |L8.50|
;;;537      }
;;;538      else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
000032  f4001680          AND      r6,r0,#0x100000
000036  f5b61f80          CMP      r6,#0x100000
00003a  d106              BNE      |L8.74|
;;;539      {
;;;540        tmp1 = ((u32)0x03) << tmpmask;
00003c  2603              MOVS     r6,#3
00003e  fa06f405          LSL      r4,r6,r5
;;;541        tmpreg &= ~tmp1;
000042  43a1              BICS     r1,r1,r4
;;;542        tmpreg |= ~DBGAFR_SWJCFG_MASK;
000044  f0416170          ORR      r1,r1,#0xf000000
000048  e006              B        |L8.88|
                  |L8.74|
;;;543      }
;;;544      else
;;;545      {
;;;546        tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
00004a  0d46              LSRS     r6,r0,#21
00004c  0136              LSLS     r6,r6,#4
00004e  fa03f606          LSL      r6,r3,r6
000052  43b1              BICS     r1,r1,r6
;;;547        tmpreg |= ~DBGAFR_SWJCFG_MASK;
000054  f0416170          ORR      r1,r1,#0xf000000
                  |L8.88|
;;;548      }
;;;549    
;;;550      if (NewState != DISABLE)
000058  b122              CBZ      r2,|L8.100|
;;;551      {
;;;552        tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
00005a  0d46              LSRS     r6,r0,#21
00005c  0136              LSLS     r6,r6,#4
00005e  fa03f606          LSL      r6,r3,r6
000062  4331              ORRS     r1,r1,r6
                  |L8.100|
;;;553      }
;;;554    
;;;555      AFIO->MAPR = tmpreg;
000064  4e01              LDR      r6,|L8.108|
000066  6071              STR      r1,[r6,#4]
;;;556    }
000068  bdf0              POP      {r4-r7,pc}
;;;557    
                          ENDP

00006a  0000              DCW      0x0000
                  |L8.108|
                          DCD      0x40010000

                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;272    *******************************************************************************/
;;;273    u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  4601              MOV      r1,r0
;;;274    {
;;;275      /* Check the parameters */
;;;276      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;277      
;;;278      return ((u16)GPIOx->IDR);
000002  6888              LDR      r0,[r1,#8]
000004  b280              UXTH     r0,r0
;;;279    }
000006  4770              BX       lr
;;;280    
                          ENDP


                          AREA ||i.GPIO_ReadInputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputDataBit PROC
;;;246    *******************************************************************************/
;;;247    u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  4602              MOV      r2,r0
;;;248    {
;;;249      u8 bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;250      
;;;251      /* Check the parameters */
;;;252      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;253      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;254      
;;;255      if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
000004  6893              LDR      r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L10.14|
;;;256      {
;;;257        bitstatus = (u8)Bit_SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L10.16|
                  |L10.14|
;;;258      }
;;;259      else
;;;260      {
;;;261        bitstatus = (u8)Bit_RESET;
00000e  2000              MOVS     r0,#0
                  |L10.16|
;;;262      }
;;;263      return bitstatus;
;;;264    }
000010  4770              BX       lr
;;;265    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;315    *******************************************************************************/
;;;316    u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  4601              MOV      r1,r0
;;;317    {
;;;318      /* Check the parameters */
;;;319      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;320        
;;;321      return ((u16)GPIOx->ODR);
000002  68c8              LDR      r0,[r1,#0xc]
000004  b280              UXTH     r0,r0
;;;322    }
000006  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.GPIO_ReadOutputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputDataBit PROC
;;;289    *******************************************************************************/
;;;290    u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  4602              MOV      r2,r0
;;;291    {
;;;292      u8 bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;293    
;;;294      /* Check the parameters */
;;;295      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;296      assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
;;;297      
;;;298      if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
000004  68d3              LDR      r3,[r2,#0xc]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L12.14|
;;;299      {
;;;300        bitstatus = (u8)Bit_SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L12.16|
                  |L12.14|
;;;301      }
;;;302      else
;;;303      {
;;;304        bitstatus = (u8)Bit_RESET;
00000e  2000              MOVS     r0,#0
                  |L12.16|
;;;305      }
;;;306      return bitstatus;
;;;307    }
000010  4770              BX       lr
;;;308    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;352    *******************************************************************************/
;;;353    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  6141              STR      r1,[r0,#0x14]
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;357      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;358      
;;;359      GPIOx->BRR = GPIO_Pin;
;;;360    }
000002  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;333    *******************************************************************************/
;;;334    void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
000000  6101              STR      r1,[r0,#0x10]
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;338      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;339      
;;;340      GPIOx->BSRR = GPIO_Pin;
;;;341    }
000002  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.GPIO_StructInit||, CODE, READONLY, ALIGN=1

                  GPIO_StructInit PROC
;;;229    *******************************************************************************/
;;;230    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;231    {
;;;232      /* Reset GPIO init structure parameters values */
;;;233      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
000004  8001              STRH     r1,[r0,#0]
;;;234      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
000006  2102              MOVS     r1,#2
000008  7081              STRB     r1,[r0,#2]
;;;235      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
00000a  2104              MOVS     r1,#4
00000c  70c1              STRB     r1,[r0,#3]
;;;236    }
00000e  4770              BX       lr
;;;237    
                          ENDP


                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;400    *******************************************************************************/
;;;401    void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
000000  60c1              STR      r1,[r0,#0xc]
;;;402    {
;;;403      /* Check the parameters */
;;;404      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;405      
;;;406      GPIOx->ODR = PortVal;
;;;407    }
000002  4770              BX       lr
;;;408    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;374    *******************************************************************************/
;;;375    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
000000  b10a              CBZ      r2,|L17.6|
;;;376    {
;;;377      /* Check the parameters */
;;;378      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;379      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;380      assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
;;;381      
;;;382      if (BitVal != Bit_RESET)
;;;383      {
;;;384        GPIOx->BSRR = GPIO_Pin;
000002  6101              STR      r1,[r0,#0x10]
000004  e000              B        |L17.8|
                  |L17.6|
;;;385      }
;;;386      else
;;;387      {
;;;388        GPIOx->BRR = GPIO_Pin;
000006  6141              STR      r1,[r0,#0x14]
                  |L17.8|
;;;389      }
;;;390    }
000008  4770              BX       lr
;;;391    
                          ENDP

