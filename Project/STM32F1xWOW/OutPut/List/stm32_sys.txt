; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_sys.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_sys.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_sys.crf ..\..\Driver\WOW\SCR\STM32_SYS.C]
                          THUMB

                          AREA ||i.RCC_Configuration_HSE||, CODE, READONLY, ALIGN=1

                  RCC_Configuration_HSE PROC
;;;49     *******************************************************************************/
;;;50     void RCC_Configuration_HSE(void)
000000  b570              PUSH     {r4-r6,lr}
;;;51     {
;;;52     	unsigned	short	retry	=	0;
000002  2600              MOVS     r6,#0
;;;53     	unsigned	long	time	=	0;
000004  2500              MOVS     r5,#0
;;;54     	ErrorStatus HSEStartUpStatus;
;;;55     	/* RCC system reset(for debug purpose) */
;;;56     	RCC_DeInit();																	//复位系统时钟
000006  f7fffffe          BL       RCC_DeInit
;;;57     	
;;;58     	/* Enable HSE */
;;;59     	RCC_HSEConfig(RCC_HSE_ON);										//打开外部高速时钟
00000a  f44f3080          MOV      r0,#0x10000
00000e  f7fffffe          BL       RCC_HSEConfig
;;;60     	
;;;61     	while(time++<0xFFFF);
000012  bf00              NOP      
                  |L1.20|
000014  4628              MOV      r0,r5
000016  1c6d              ADDS     r5,r5,#1
000018  f64f71ff          MOV      r1,#0xffff
00001c  4288              CMP      r0,r1
00001e  d3f9              BCC      |L1.20|
;;;62     	
;;;63     		
;;;64     	/* Wait till HSE is ready */
;;;65     	HSEStartUpStatus = RCC_WaitForHSEStartUp();		//等待外部高速时钟启动
000020  f7fffffe          BL       RCC_WaitForHSEStartUp
000024  4604              MOV      r4,r0
;;;66     	
;;;67     	if(HSEStartUpStatus == SUCCESS)
000026  2c01              CMP      r4,#1
000028  d125              BNE      |L1.118|
;;;68     	{
;;;69     		/* Enable Prefetch Buffer */
;;;70     		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);	//使能或者失能预取指缓存
00002a  2010              MOVS     r0,#0x10
00002c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;71     		
;;;72     		/* Flash 2 wait state */
;;;73     		FLASH_SetLatency(FLASH_Latency_2);					//设置代码延时值
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       FLASH_SetLatency
;;;74     		
;;;75     		/* HCLK = SYSCLK */
;;;76     		RCC_HCLKConfig(RCC_SYSCLK_Div1); 						//设置AHB时钟（HCLK）
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       RCC_HCLKConfig
;;;77     		
;;;78     		/* PCLK2 = HCLK */
;;;79     		RCC_PCLK2Config(RCC_HCLK_Div1); 						//设置高速AHB时钟（PCLK2）
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       RCC_PCLK2Config
;;;80     		
;;;81     		/* PCLK1 = HCLK/2 */
;;;82     		RCC_PCLK1Config(RCC_HCLK_Div2);							//设置低速AHB时钟（PCLK1）
000042  02a0              LSLS     r0,r4,#10
000044  f7fffffe          BL       RCC_PCLK1Config
;;;83     		
;;;84     		/* PLLCLK = 8MHz * 9 = 72 MHz */
;;;85     		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);	//设置PLL时钟源及倍频系数
000048  f44f11e0          MOV      r1,#0x1c0000
00004c  0420              LSLS     r0,r4,#16
00004e  f7fffffe          BL       RCC_PLLConfig
;;;86     		
;;;87     		/* Enable PLL */ 
;;;88     		RCC_PLLCmd(ENABLE);			//使能或者失能PLL
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       RCC_PLLCmd
;;;89     		
;;;90     		/* Wait till PLL is ready */
;;;91     		while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000058  bf00              NOP      
                  |L1.90|
00005a  2039              MOVS     r0,#0x39
00005c  f7fffffe          BL       RCC_GetFlagStatus
000060  2800              CMP      r0,#0
000062  d0fa              BEQ      |L1.90|
;;;92     		{
;;;93     		}
;;;94     		
;;;95     		/* Select PLL as system clock source */
;;;96     		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);	//设置系统时钟源（SYSCLK）
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_SYSCLKConfig
;;;97     		
;;;98     		/* Wait till PLL is used as system clock source */
;;;99     		while(RCC_GetSYSCLKSource() != 0x08)				//返回用作系统时钟的时钟源
00006a  bf00              NOP      
                  |L1.108|
00006c  f7fffffe          BL       RCC_GetSYSCLKSource
000070  2808              CMP      r0,#8
000072  d1fb              BNE      |L1.108|
                  |L1.116|
;;;100    		{
;;;101    		}
;;;102    		return;		//
;;;103    	}
;;;104    	else		//启动内部晶振
;;;105    	{
;;;106    		RCC_Configuration_HSI();
;;;107    	}
;;;108    //	GPIO_DeInitAll();				//将所有的GPIO关闭----V20170605
;;;109    }
000074  bd70              POP      {r4-r6,pc}
                  |L1.118|
000076  f7fffffe          BL       RCC_Configuration_HSI
00007a  bf00              NOP      
00007c  e7fa              B        |L1.116|
;;;110    /*******************************************************************************
                          ENDP


                          AREA ||i.RCC_Configuration_HSI||, CODE, READONLY, ALIGN=1

                  RCC_Configuration_HSI PROC
;;;116    *******************************************************************************/
;;;117    void RCC_Configuration_HSI(void)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119    //	unsigned char temp=0;
;;;120    //	unsigned char PLL;
;;;121    //	//	RCC->CR|=0x00040000;  //????????HSEON
;;;122    ////	RCC->CR|=0x00010000;  //????????HSEON
;;;123    ////	while(!(RCC->CR>>17));//????????
;;;124    //	RCC->CFGR=0X00000400; //APB1=DIV2;APB2=DIV1;AHB=DIV1;
;;;125    //	PLL-=2;//??2???
;;;126    //	RCC->CFGR|=PLL<<18;   //??PLL? 2~16
;;;127    ////	RCC->CFGR|=1<<16;	  //PLLSRC ON 
;;;128    //	FLASH->ACR|=0x32;	  //FLASH 2?????
;;;129    
;;;130    //	RCC->CR|=0x01000000;  //PLLON
;;;131    //	while(!(RCC->CR>>25));//??PLL??
;;;132    //	RCC->CFGR|=0x00000002;//PLL??????	 
;;;133    //	while(temp!=0x02)     //??PLL??????????
;;;134    //	{   
;;;135    //		temp=RCC->CFGR>>2;
;;;136    //		temp&=0x03;
;;;137    //	}
;;;138    		
;;;139    		
;;;140    	RCC_DeInit();	/*将外设RCC寄存器重设为缺省值?*/ 
000002  f7fffffe          BL       RCC_DeInit
;;;141    	RCC_HSICmd(ENABLE); 
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       RCC_HSICmd
;;;142    	while(RCC_GetFlagStatus(RCC_FLAG_HSIRDY)==RESET);//等待HSI就绪 
00000c  bf00              NOP      
                  |L2.14|
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       RCC_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0fa              BEQ      |L2.14|
;;;143    	RCC_HCLKConfig(RCC_SYSCLK_Div1);			/*设置AHB时钟（HCLK）?RCC_SYSCLK_Div1――AHB时钟=系统时*/	
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       RCC_HCLKConfig
;;;144    	RCC_PCLK2Config(RCC_HCLK_Div1);				/*设置高速AHB时钟（PCLK2)RCC_HCLK_Div1――APB2时钟=HCLK*/	
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_PCLK2Config
;;;145    	RCC_PCLK1Config(RCC_HCLK_Div2);				/*设置低速AHB时钟（PCLK1）RCC_HCLK_Div2――APB1时钟=HCLK/2*/	
000024  f44f6080          MOV      r0,#0x400
000028  f7fffffe          BL       RCC_PCLK1Config
;;;146    	FLASH_SetLatency(FLASH_Latency_2);			/*设置FLASH存储器延时时钟周期数FLASH_Latency_2  2延时周期*/	
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       FLASH_SetLatency
;;;147    	FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);	/*选择FLASH预取指缓存的模,预取指缓存使能*/ 
000032  2010              MOVS     r0,#0x10
000034  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;148    	RCC_PLLConfig(RCC_PLLSource_HSI_Div2,RCC_PLLMul_16);	/*设置PLL时钟源及倍频系数，频率为8/2*16=64Mhz*/	
000038  f44f1160          MOV      r1,#0x380000
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       RCC_PLLConfig
;;;149    	RCC_PLLCmd(ENABLE);										/*使能PLL*/ 
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       RCC_PLLCmd
;;;150    	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET)	/*检查指定的RCC标志位(PLL准备好标志)设置与否*/	
000048  e002              B        |L2.80|
                  |L2.74|
;;;151    	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);			/*设置系统时钟（SYSCLK）*/	 
00004a  2002              MOVS     r0,#2
00004c  f7fffffe          BL       RCC_SYSCLKConfig
                  |L2.80|
000050  2039              MOVS     r0,#0x39              ;150
000052  f7fffffe          BL       RCC_GetFlagStatus
000056  2800              CMP      r0,#0                 ;150
000058  d0f7              BEQ      |L2.74|
;;;152    	while(RCC_GetSYSCLKSource()!=0x08);					/*0x08：PLL作为系统时钟*/ 	
00005a  bf00              NOP      
                  |L2.92|
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L2.92|
;;;153    
;;;154    	GPIO_DeInitAll();				//将所有的GPIO关闭----V20170605
000064  f7fffffe          BL       GPIO_DeInitAll
;;;155    }
000068  bd10              POP      {r4,pc}
;;;156    
                          ENDP


                          AREA ||i.SYSCLKConfig_STOP||, CODE, READONLY, ALIGN=1

                  SYSCLKConfig_STOP PROC
;;;164    *******************************************************************************/
;;;165    void SYSCLKConfig_STOP(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167    	ErrorStatus HSEStartUpStatus;
;;;168    	
;;;169      /* Enable HSE */
;;;170      RCC_HSEConfig(RCC_HSE_ON);
000002  f44f3080          MOV      r0,#0x10000
000006  f7fffffe          BL       RCC_HSEConfig
;;;171    
;;;172      /* Wait till HSE is ready */
;;;173      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000a  f7fffffe          BL       RCC_WaitForHSEStartUp
00000e  4604              MOV      r4,r0
;;;174    
;;;175      if(HSEStartUpStatus == SUCCESS)
000010  2c01              CMP      r4,#1
000012  d10f              BNE      |L3.52|
;;;176      {
;;;177        /* Enable PLL */ 
;;;178        RCC_PLLCmd(ENABLE);
000014  f7fffffe          BL       RCC_PLLCmd
;;;179    
;;;180        /* Wait till PLL is ready */
;;;181        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000018  bf00              NOP      
                  |L3.26|
00001a  2039              MOVS     r0,#0x39
00001c  f7fffffe          BL       RCC_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0fa              BEQ      |L3.26|
;;;182        {
;;;183        }
;;;184    
;;;185        /* Select PLL as system clock source */
;;;186        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RCC_SYSCLKConfig
;;;187    
;;;188        /* Wait till PLL is used as system clock source */
;;;189        while(RCC_GetSYSCLKSource() != 0x08)
00002a  bf00              NOP      
                  |L3.44|
00002c  f7fffffe          BL       RCC_GetSYSCLKSource
000030  2808              CMP      r0,#8
000032  d1fb              BNE      |L3.44|
                  |L3.52|
;;;190        {
;;;191        }
;;;192      }
;;;193    }
000034  bd10              POP      {r4,pc}
;;;194    
                          ENDP


                          AREA ||i.SYS_Configuration||, CODE, READONLY, ALIGN=1

                  SYS_Configuration PROC
;;;33     *******************************************************************************/
;;;34     void SYS_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;35     {
;;;36     #ifdef	HSE_USE
;;;37     	RCC_Configuration_HSE();
000002  f7fffffe          BL       RCC_Configuration_HSE
;;;38     #else
;;;39     	RCC_Configuration_HSI();
;;;40     #endif
;;;41     }
000006  bd10              POP      {r4,pc}
;;;42     
                          ENDP

