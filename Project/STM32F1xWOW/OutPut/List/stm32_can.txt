; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_can.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_can.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_can.crf ..\..\Driver\WOW\SCR\STM32_CAN.C]
                          THUMB

                          AREA ||i.CAN_Configuration_IT||, CODE, READONLY, ALIGN=2

                  CAN_Configuration_IT PROC
;;;202    *******************************************************************************/
;;;203    void CAN_Configuration_IT(u32 CAN_BaudRate)					//CAN配置---中断方式
000000  b530              PUSH     {r4,r5,lr}
;;;204    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;205    //	CAN_INIT();
;;;206    	//基本配置：以系统时钟72MHz为计算，RCC_APB1PeriphClock时钟频率为36MHz,配置最高波特率为4MHz
;;;207    	//根据传入参数(CAN_BaudRate)自动计算分频值以得到实际需要波特率
;;;208    	//配置过程：
;;;209    	//1)定义相关结构体
;;;210    	GPIO_InitTypeDef	GPIO_InitStructure;					//GPIO结构体
;;;211    	CAN_InitTypeDef		CAN_InitStructure;					//CAN结构体
;;;212    	NVIC_InitTypeDef	NVIC_InitStructure;
;;;213    	
;;;214    	u16 CAN_Prescaler=0;	//CAN_Prescaler设定了一个时间单位的长度，它的范围是1到1024。
000006  2500              MOVS     r5,#0
;;;215    	
;;;216    	
;;;217    	//2)************开启相关时钟（GPIO,CAN)
;;;218    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO |RCC_APB2Periph_GPIOA, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;219    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
000010  2101              MOVS     r1,#1
000012  0648              LSLS     r0,r1,#25
000014  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;220    	
;;;221    	//3)************GPIO脚配置，使用CAN1默认引脚，其它引脚后续再补充	
;;;222    	//3.1)**********CAN_RX默认接收引脚配置，PA11
;;;223    	GPIO_InitStructure.GPIO_Pin		= GPIO_Pin_11; 
000018  f44f6000          MOV      r0,#0x800
00001c  f8ad0010          STRH     r0,[sp,#0x10]
;;;224    	GPIO_InitStructure.GPIO_Speed	= GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0012          STRB     r0,[sp,#0x12]
;;;225    	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_IPU;
000026  2048              MOVS     r0,#0x48
000028  f88d0013          STRB     r0,[sp,#0x13]
;;;226    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  a904              ADD      r1,sp,#0x10
00002e  482f              LDR      r0,|L1.236|
000030  f7fffffe          BL       GPIO_Init
;;;227    	//3.2)**********CAN_TX默认发送引脚配置，PA12
;;;228    	GPIO_InitStructure.GPIO_Pin		= GPIO_Pin_12; 
000034  f44f5080          MOV      r0,#0x1000
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;229    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003c  2003              MOVS     r0,#3
00003e  f88d0012          STRB     r0,[sp,#0x12]
;;;230    	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_AF_PP;
000042  2018              MOVS     r0,#0x18
000044  f88d0013          STRB     r0,[sp,#0x13]
;;;231    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000048  a904              ADD      r1,sp,#0x10
00004a  4828              LDR      r0,|L1.236|
00004c  f7fffffe          BL       GPIO_Init
;;;232    	
;;;233    	//4)**********CAN初始化 
;;;234    	//CAN波特率 = RCC_APB1PeriphClock/(CAN_SJW+CAN_BS1+CAN_BS2)/CAN_Prescaler; 
;;;235    	//将RCC_APB1PeriphClock/(CAN_SJW+CAN_BS1+CAN_BS2)设置为4MHz
;;;236    	//CAN_Prescaler根据需要的波特率自动计算分频值
;;;237    	//注意：总体配置保持tBS1>=tBS2 tBS2>=1个CAN时钟周期  tBS2>=2tSJW
;;;238    	
;;;239    	//4.1)**********CAN模式参数
;;;240      CAN_InitStructure.CAN_TTCM=DISABLE;		//CAN_TTCM用来使能或者失能时间触发通讯模式，可以设置这个参数的值为ENABLE或者DISABLE。
000050  2000              MOVS     r0,#0
000052  f88d0004          STRB     r0,[sp,#4]
;;;241    																				//->0：禁止时间触发通信模式；
;;;242    																				//->1：允许时间触发通信模式。
;;;243    																				//->在该模式下，CAN硬件的内部定时器被激活，并且被用于产生(发送与接收邮箱的)时间戳，分别存储在CAN_RDTxR/CAN_TDTxR寄存器中。
;;;244    																				//->内部定时器在每个CAN位时间累加。内部定时器在接收和发送的帧起始位的采样点位置被采样，并生成时间戳
;;;245    	
;;;246      CAN_InitStructure.CAN_ABOM=DISABLE;		//CAN_ABOM用来使能或者失能自动离线管理，可以设置这个参数的值为ENABLE或者DISABLE。
000056  f88d0005          STRB     r0,[sp,#5]
;;;247    																				//该位决定CAN硬件在什么条件下可以退出离线状态。
;;;248    																				//->如果ABOM位为’1’，bxCAN进入离线状态后，就自动开启恢复过程。
;;;249    																				//->如果ABOM位为’0’，软件必须先请求bxCAN进入然后再退出初始化模式，随后恢复过程才被开启。
;;;250    																				//->当TEC大于255时，bxCAN就进入离线状态，同时CAN_ESR寄存器的BOFF位被置’1’。在离线状态下，bxCAN无法接收和发送报文。
;;;251    	
;;;252      CAN_InitStructure.CAN_AWUM=DISABLE;		//CAN_AWUM用来使能或者失能自动唤醒模式，可以设置这个参数的值为ENABLE或者DISABLE。
00005a  f88d0006          STRB     r0,[sp,#6]
;;;253    																				//该位决定CAN处在睡眠模式时由硬件还是软件唤醒
;;;254    																				//->0：睡眠模式通过清除CAN_MCR寄存器的SLEEP位，由软件唤醒；
;;;255    																				//->1：睡眠模式通过检测CAN报文，由硬件自动唤醒。唤醒的同时，硬件自动对CAN_MSR寄存器的SLEEP和SLAK位清’0’ 。
;;;256    	
;;;257      CAN_InitStructure.CAN_NART=DISABLE;		//CAN_NARM用来使能或者失能非自动重传输模式，可以设置这个参数的值为ENABLE或者DISABLE。
00005e  f88d0007          STRB     r0,[sp,#7]
;;;258    																				//->0：按照CAN标准，CAN硬件在发送报文失败时会一直自动重传直到发送成功；
;;;259    																				//->1：CAN报文只被发送1次，不管发送的结果如何(成功、出错或仲裁丢失)。
;;;260    	
;;;261      CAN_InitStructure.CAN_RFLM=DISABLE;		//CAN_RFLM用来使能或者失能接收FIFO锁定模式，可以设置这个参数的值为ENABLE或者DISABLE。
000062  f88d0008          STRB     r0,[sp,#8]
;;;262    																				//->0：在接收溢出时FIFO未被锁定，当接收FIFO的报文未被读出，下一个收到的报文会覆盖原有的报文；
;;;263    																				//->1：在接收溢出时FIFO被锁定，当接收FIFO的报文未被读出，下一个收到的报文会被丢弃。
;;;264    	
;;;265      CAN_InitStructure.CAN_TXFP=DISABLE;		//CAN_TXFP用来使能或者失能发送FIFO优先级，可以设置这个参数的值为ENABLE或者DISABLE。
000066  f88d0009          STRB     r0,[sp,#9]
;;;266    																				//当有多个报文同时在等待发送时，该位决定这些报文的发送顺序
;;;267    																				//->0：优先级由报文的标识符来决定；
;;;268    																				//->1：优先级由发送请求的顺序来决定。
;;;269    	
;;;270      CAN_InitStructure.CAN_Mode=CAN_Mode_Normal;			//CAN_Mode设置了CAN的工作模式，<CAN operating mode>.给出了该参数可取的值
00006a  f88d000a          STRB     r0,[sp,#0xa]
;;;271    																									//CAN_Mode_Normal:CAN硬件工作在正常模式
;;;272    																									//CAN_Mode_LoopBack:CAN硬件工作在环回模式
;;;273    																																		//在环回模式下，bxCAN把发送的报文当作接收的报文并保存(如果可以通过接收过滤)在接收邮箱里。
;;;274    																																		//环回模式可用于自测试。为了避免外部的影响，在环回模式下CAN内核忽略确认错误(在数据/远程帧的确认位时刻，不检测是否有显性位)。
;;;275    																																		//在环回模式下，bxCAN在内部把Tx输出回馈到Rx输入上，而完全忽略CANRX引脚的实际状态。发送的报文可以在CANTX引脚上检测到。
;;;276    																									//CAN_Mode_Silent:CAN硬件工作在静默模式
;;;277    																																		//->在静默模式下，bxCAN可以正常地接收数据帧和远程帧，但只能发出隐性位，而不能真正发送报文。
;;;278    																																		//->如果bxCAN需要发出显性位(确认位、过载标志、主动错误标志)，那么这样的显性位在内部被接回来从而可以被CAN内核检测到，
;;;279    																																		//->同时CAN总线不会受到影响而仍然维持在隐性位状态。因此，静默模式通常用于分析CAN总线的活动，
;;;280    																																		//->而不会对总线造成影响－显性位(确认位、错误帧)不会真正发送到总线上。
;;;281    																									//CAN_Mode_Silent_LoopBack:CAN硬件工作在静默环回模式
;;;282    																																		//->可以选择环回静默模式。该模式可用于“热自测试”，即可以像环回模式那样测试bxCAN，但却不会影响CANTX和CANRX所连接的整个CAN系统。
;;;283    																																		//->在环回静默模式下，CANRX引脚与CAN总线断开，同时CANTX引脚被驱动到隐性位状态。
;;;284    																																		
;;;285    	//4.1)**********CAN波特率配置
;;;286    	//4.1.1)********根据需求波特率设置分频值
;;;287    	CAN_Prescaler=4000000/CAN_BaudRate;
00006e  4820              LDR      r0,|L1.240|
000070  fbb0f0f4          UDIV     r0,r0,r4
000074  b285              UXTH     r5,r0
;;;288    	if(CAN_Prescaler<1||CAN_Prescaler>1024)
;;;289    	{
;;;290    //		warning: "sdfdf";
;;;291    	}
;;;292    	
;;;293    	CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;	//CAN_SJW定义了重新同步跳跃宽度(SJW)，即在每位中可以延长或缩短多少个时间单位的上限，<CAN synchronisation jump width>给出了该参数可取的值
000076  2000              MOVS     r0,#0
000078  f88d000b          STRB     r0,[sp,#0xb]
;;;294    																					//CAN_SJW_1tq:重新同步跳跃宽度1个时间单位
;;;295    																					//CAN_SJW_2tq:重新同步跳跃宽度2个时间单位
;;;296    																					//CAN_SJW_3tq:重新同步跳跃宽度3个时间单位
;;;297    																					//CAN_SJW_4tq:重新同步跳跃宽度4个时间单位
;;;298      CAN_InitStructure.CAN_BS1=CAN_BS1_5tq;	//CAN_BS1设定了时间段1的时间单位数目，<time quantum in bit segment 1>给出了该参数可取的值
00007c  2004              MOVS     r0,#4
00007e  f88d000c          STRB     r0,[sp,#0xc]
;;;299    	
;;;300      CAN_InitStructure.CAN_BS2=CAN_BS2_3tq;	//CAN_BS2设定了时间段1的时间单位数目，<time quantum in bit segment 2>给出了该参数可取的值
000082  2002              MOVS     r0,#2
000084  f88d000d          STRB     r0,[sp,#0xd]
;;;301    	
;;;302      CAN_InitStructure.CAN_Prescaler=CAN_Prescaler;			//CAN_Prescaler设定了一个时间单位的长度，它的范围是1到1024。
000088  f8ad500e          STRH     r5,[sp,#0xe]
;;;303    	
;;;304      CAN_Init(&CAN_InitStructure);	
00008c  a801              ADD      r0,sp,#4
00008e  f7fffffe          BL       CAN_Init
;;;305    	
;;;306    	NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN_RX0_IRQChannel;
000092  2014              MOVS     r0,#0x14
000094  f88d0000          STRB     r0,[sp,#0]
;;;307    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000098  2003              MOVS     r0,#3
00009a  f88d0001          STRB     r0,[sp,#1]
;;;308    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00009e  2000              MOVS     r0,#0
0000a0  f88d0002          STRB     r0,[sp,#2]
;;;309    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000a4  2001              MOVS     r0,#1
0000a6  f88d0003          STRB     r0,[sp,#3]
;;;310    	NVIC_Init(&NVIC_InitStructure);
0000aa  4668              MOV      r0,sp
0000ac  f7fffffe          BL       NVIC_Init
;;;311        
;;;312    	NVIC_InitStructure.NVIC_IRQChannel = USB_HP_CAN_TX_IRQChannel;
0000b0  2013              MOVS     r0,#0x13
0000b2  f88d0000          STRB     r0,[sp,#0]
;;;313    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
0000b6  2003              MOVS     r0,#3
0000b8  f88d0001          STRB     r0,[sp,#1]
;;;314    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000bc  2000              MOVS     r0,#0
0000be  f88d0002          STRB     r0,[sp,#2]
;;;315    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000c2  2001              MOVS     r0,#1
0000c4  f88d0003          STRB     r0,[sp,#3]
;;;316    	NVIC_Init(&NVIC_InitStructure);
0000c8  4668              MOV      r0,sp
0000ca  f7fffffe          BL       NVIC_Init
;;;317    	
;;;318    	CAN_ITConfig(CAN_IT_FMP0 | CAN_IT_FF0 | CAN_IT_FOV0, ENABLE);  	// fifo0中断
0000ce  2101              MOVS     r1,#1
0000d0  200e              MOVS     r0,#0xe
0000d2  f7fffffe          BL       CAN_ITConfig
;;;319    	CAN_ITConfig(CAN_IT_FMP1 | CAN_IT_FF1 | CAN_IT_FOV1, DISABLE);  // fifo1中断
0000d6  2100              MOVS     r1,#0
0000d8  2070              MOVS     r0,#0x70
0000da  f7fffffe          BL       CAN_ITConfig
;;;320    	CAN_ITConfig(CAN_IT_TME, DISABLE); 
0000de  2100              MOVS     r1,#0
0000e0  2001              MOVS     r0,#1
0000e2  f7fffffe          BL       CAN_ITConfig
;;;321    	
;;;322    	              // 发送中断
;;;323    		 
;;;324    	/* Enable CAN FIFO 0 overrun interrupt */
;;;325    //	CAN_ITConfig(CAN_IT_FOV0, ENABLE);	
;;;326    }
0000e6  b005              ADD      sp,sp,#0x14
0000e8  bd30              POP      {r4,r5,pc}
;;;327    /*******************************************************************************
                          ENDP

0000ea  0000              DCW      0x0000
                  |L1.236|
                          DCD      0x40010800
                  |L1.240|
                          DCD      0x003d0900

                          AREA ||i.CAN_Configuration_NR||, CODE, READONLY, ALIGN=2

                  CAN_Configuration_NR PROC
;;;93     *******************************************************************************/
;;;94     void CAN_Configuration_NR(u32 CAN_BaudRate)					//CAN配置--标志位查询方式
000000  b57f              PUSH     {r0-r6,lr}
;;;95     {
000002  4604              MOV      r4,r0
;;;96     //	CAN_INIT();
;;;97     	//基本配置：以系统时钟72MHz为计算，RCC_APB1PeriphClock时钟频率为36MHz,配置最高波特率为4MHz
;;;98     	//根据传入参数(CAN_BaudRate)自动计算分频值以得到实际需要波特率
;;;99     	//配置过程：
;;;100    	//1)定义相关结构体
;;;101    	GPIO_InitTypeDef	GPIO_InitStructure;					//GPIO结构体
;;;102    	CAN_InitTypeDef		CAN_InitStructure;					//CAN结构体
;;;103    	
;;;104    	u16 CAN_Prescaler=0;	//CAN_Prescaler设定了一个时间单位的长度，它的范围是1到1024。
000004  2500              MOVS     r5,#0
;;;105    	
;;;106    	
;;;107    	//2)************开启相关时钟（GPIO,CAN)
;;;108    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO |RCC_APB2Periph_GPIOA, ENABLE);
000006  2101              MOVS     r1,#1
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;109    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0648              LSLS     r0,r1,#25
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;110    	
;;;111    	//3)************GPIO脚配置，使用CAN1默认引脚，其它引脚后续再补充	
;;;112    	//3.1)**********CAN_RX默认接收引脚配置，PA11
;;;113    	GPIO_InitStructure.GPIO_Pin		= GPIO_Pin_11; 
000016  f44f6000          MOV      r0,#0x800
00001a  f8ad000c          STRH     r0,[sp,#0xc]
;;;114    	GPIO_InitStructure.GPIO_Speed	= GPIO_Speed_50MHz;
00001e  2003              MOVS     r0,#3
000020  f88d000e          STRB     r0,[sp,#0xe]
;;;115    	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_IPU;
000024  2048              MOVS     r0,#0x48
000026  f88d000f          STRB     r0,[sp,#0xf]
;;;116    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002a  a903              ADD      r1,sp,#0xc
00002c  4819              LDR      r0,|L2.148|
00002e  f7fffffe          BL       GPIO_Init
;;;117    	//3.2)**********CAN_TX默认发送引脚配置，PA12
;;;118    	GPIO_InitStructure.GPIO_Pin		= GPIO_Pin_12; 
000032  f44f5080          MOV      r0,#0x1000
000036  f8ad000c          STRH     r0,[sp,#0xc]
;;;119    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  2003              MOVS     r0,#3
00003c  f88d000e          STRB     r0,[sp,#0xe]
;;;120    	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_AF_PP;
000040  2018              MOVS     r0,#0x18
000042  f88d000f          STRB     r0,[sp,#0xf]
;;;121    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000046  a903              ADD      r1,sp,#0xc
000048  4812              LDR      r0,|L2.148|
00004a  f7fffffe          BL       GPIO_Init
;;;122    	
;;;123    	//4)**********CAN初始化 
;;;124    	//CAN波特率 = RCC_APB1PeriphClock/(CAN_SJW+CAN_BS1+CAN_BS2)/CAN_Prescaler; 
;;;125    	//将RCC_APB1PeriphClock/(CAN_SJW+CAN_BS1+CAN_BS2)设置为4MHz
;;;126    	//CAN_Prescaler根据需要的波特率自动计算分频值
;;;127    	//注意：总体配置保持tBS1>=tBS2 tBS2>=1个CAN时钟周期  tBS2>=2tSJW
;;;128    	
;;;129    	//4.1)**********CAN模式参数
;;;130      CAN_InitStructure.CAN_TTCM=DISABLE;		//CAN_TTCM用来使能或者失能时间触发通讯模式，可以设置这个参数的值为ENABLE或者DISABLE。
00004e  2000              MOVS     r0,#0
000050  f88d0000          STRB     r0,[sp,#0]
;;;131    																				//->0：禁止时间触发通信模式；
;;;132    																				//->1：允许时间触发通信模式。
;;;133    																				//->在该模式下，CAN硬件的内部定时器被激活，并且被用于产生(发送与接收邮箱的)时间戳，分别存储在CAN_RDTxR/CAN_TDTxR寄存器中。
;;;134    																				//->内部定时器在每个CAN位时间累加。内部定时器在接收和发送的帧起始位的采样点位置被采样，并生成时间戳
;;;135    	
;;;136      CAN_InitStructure.CAN_ABOM=DISABLE;		//CAN_ABOM用来使能或者失能自动离线管理，可以设置这个参数的值为ENABLE或者DISABLE。
000054  f88d0001          STRB     r0,[sp,#1]
;;;137    																				//该位决定CAN硬件在什么条件下可以退出离线状态。
;;;138    																				//->如果ABOM位为’1’，bxCAN进入离线状态后，就自动开启恢复过程。
;;;139    																				//->如果ABOM位为’0’，软件必须先请求bxCAN进入然后再退出初始化模式，随后恢复过程才被开启。
;;;140    																				//->当TEC大于255时，bxCAN就进入离线状态，同时CAN_ESR寄存器的BOFF位被置’1’。在离线状态下，bxCAN无法接收和发送报文。
;;;141    	
;;;142      CAN_InitStructure.CAN_AWUM=DISABLE;		//CAN_AWUM用来使能或者失能自动唤醒模式，可以设置这个参数的值为ENABLE或者DISABLE。
000058  f88d0002          STRB     r0,[sp,#2]
;;;143    																				//该位决定CAN处在睡眠模式时由硬件还是软件唤醒
;;;144    																				//->0：睡眠模式通过清除CAN_MCR寄存器的SLEEP位，由软件唤醒；
;;;145    																				//->1：睡眠模式通过检测CAN报文，由硬件自动唤醒。唤醒的同时，硬件自动对CAN_MSR寄存器的SLEEP和SLAK位清’0’ 。
;;;146    	
;;;147      CAN_InitStructure.CAN_NART=DISABLE;		//CAN_NARM用来使能或者失能非自动重传输模式，可以设置这个参数的值为ENABLE或者DISABLE。
00005c  f88d0003          STRB     r0,[sp,#3]
;;;148    																				//->0：按照CAN标准，CAN硬件在发送报文失败时会一直自动重传直到发送成功；
;;;149    																				//->1：CAN报文只被发送1次，不管发送的结果如何(成功、出错或仲裁丢失)。
;;;150    	
;;;151      CAN_InitStructure.CAN_RFLM=DISABLE;		//CAN_RFLM用来使能或者失能接收FIFO锁定模式，可以设置这个参数的值为ENABLE或者DISABLE。
000060  f88d0004          STRB     r0,[sp,#4]
;;;152    																				//->0：在接收溢出时FIFO未被锁定，当接收FIFO的报文未被读出，下一个收到的报文会覆盖原有的报文；
;;;153    																				//->1：在接收溢出时FIFO被锁定，当接收FIFO的报文未被读出，下一个收到的报文会被丢弃。
;;;154    	
;;;155      CAN_InitStructure.CAN_TXFP=DISABLE;		//CAN_TXFP用来使能或者失能发送FIFO优先级，可以设置这个参数的值为ENABLE或者DISABLE。
000064  f88d0005          STRB     r0,[sp,#5]
;;;156    																				//当有多个报文同时在等待发送时，该位决定这些报文的发送顺序
;;;157    																				//->0：优先级由报文的标识符来决定；
;;;158    																				//->1：优先级由发送请求的顺序来决定。
;;;159    	
;;;160      CAN_InitStructure.CAN_Mode=CAN_Mode_Normal;			//CAN_Mode设置了CAN的工作模式，<CAN operating mode>.给出了该参数可取的值
000068  f88d0006          STRB     r0,[sp,#6]
;;;161    																									//CAN_Mode_Normal:CAN硬件工作在正常模式
;;;162    																									//CAN_Mode_LoopBack:CAN硬件工作在环回模式
;;;163    																																		//在环回模式下，bxCAN把发送的报文当作接收的报文并保存(如果可以通过接收过滤)在接收邮箱里。
;;;164    																																		//环回模式可用于自测试。为了避免外部的影响，在环回模式下CAN内核忽略确认错误(在数据/远程帧的确认位时刻，不检测是否有显性位)。
;;;165    																																		//在环回模式下，bxCAN在内部把Tx输出回馈到Rx输入上，而完全忽略CANRX引脚的实际状态。发送的报文可以在CANTX引脚上检测到。
;;;166    																									//CAN_Mode_Silent:CAN硬件工作在静默模式
;;;167    																																		//->在静默模式下，bxCAN可以正常地接收数据帧和远程帧，但只能发出隐性位，而不能真正发送报文。
;;;168    																																		//->如果bxCAN需要发出显性位(确认位、过载标志、主动错误标志)，那么这样的显性位在内部被接回来从而可以被CAN内核检测到，
;;;169    																																		//->同时CAN总线不会受到影响而仍然维持在隐性位状态。因此，静默模式通常用于分析CAN总线的活动，
;;;170    																																		//->而不会对总线造成影响－显性位(确认位、错误帧)不会真正发送到总线上。
;;;171    																									//CAN_Mode_Silent_LoopBack:CAN硬件工作在静默环回模式
;;;172    																																		//->可以选择环回静默模式。该模式可用于“热自测试”，即可以像环回模式那样测试bxCAN，但却不会影响CANTX和CANRX所连接的整个CAN系统。
;;;173    																																		//->在环回静默模式下，CANRX引脚与CAN总线断开，同时CANTX引脚被驱动到隐性位状态。
;;;174    																																		
;;;175    	//4.1)**********CAN波特率配置
;;;176    	//4.1.1)********根据需求波特率设置分频值
;;;177    	CAN_Prescaler=4000000/CAN_BaudRate;
00006c  480a              LDR      r0,|L2.152|
00006e  fbb0f0f4          UDIV     r0,r0,r4
000072  b285              UXTH     r5,r0
;;;178    	if(CAN_Prescaler<1||CAN_Prescaler>1024)
;;;179    	{
;;;180    //		warning: "sdfdf";
;;;181    	}
;;;182    	
;;;183    	CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;	//CAN_SJW定义了重新同步跳跃宽度(SJW)，即在每位中可以延长或缩短多少个时间单位的上限，<CAN synchronisation jump width>给出了该参数可取的值
000074  2000              MOVS     r0,#0
000076  f88d0007          STRB     r0,[sp,#7]
;;;184    																					//CAN_SJW_1tq:重新同步跳跃宽度1个时间单位
;;;185    																					//CAN_SJW_2tq:重新同步跳跃宽度2个时间单位
;;;186    																					//CAN_SJW_3tq:重新同步跳跃宽度3个时间单位
;;;187    																					//CAN_SJW_4tq:重新同步跳跃宽度4个时间单位
;;;188      CAN_InitStructure.CAN_BS1=CAN_BS1_5tq;	//CAN_BS1设定了时间段1的时间单位数目，<time quantum in bit segment 1>给出了该参数可取的值
00007a  2004              MOVS     r0,#4
00007c  f88d0008          STRB     r0,[sp,#8]
;;;189    	
;;;190      CAN_InitStructure.CAN_BS2=CAN_BS2_3tq;	//CAN_BS2设定了时间段1的时间单位数目，<time quantum in bit segment 2>给出了该参数可取的值
000080  2002              MOVS     r0,#2
000082  f88d0009          STRB     r0,[sp,#9]
;;;191    	
;;;192      CAN_InitStructure.CAN_Prescaler=CAN_Prescaler;			//CAN_Prescaler设定了一个时间单位的长度，它的范围是1到1024。
000086  f8ad500a          STRH     r5,[sp,#0xa]
;;;193    	
;;;194      CAN_Init(&CAN_InitStructure);	
00008a  4668              MOV      r0,sp
00008c  f7fffffe          BL       CAN_Init
;;;195    	
;;;196    }
000090  bd7f              POP      {r0-r6,pc}
;;;197    /*******************************************************************************
                          ENDP

000092  0000              DCW      0x0000
                  |L2.148|
                          DCD      0x40010800
                  |L2.152|
                          DCD      0x003d0900

                          AREA ||i.CAN_ExtTX_DATA||, CODE, READONLY, ALIGN=1

                  CAN_ExtTX_DATA PROC
;;;693    *******************************************************************************/
;;;694    void CAN_ExtTX_DATA(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;695    										u32 CAN_ID,			//CAN地址
;;;696    										u8 length,			//设定待传输消息的帧长度。它的取值范围是0到8。
;;;697    										u8 *Data				//数据数组地址														
;;;698    )
;;;699    {
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
;;;700    	CanTxMsg TxMessage;
;;;701    	u8	TransmitMailbox = 0;
00000c  f04f0800          MOV      r8,#0
;;;702    	u32	i;
;;;703    
;;;704    //	TxMessage.StdId=CAN_ID;				//标准帧ID
;;;705    //	TxMessage.IDE=CAN_ID_STD;			//使用标准标识符
;;;706    	
;;;707    	TxMessage.ExtId=CAN_ID;					//扩展帧ID	
000010  9602              STR      r6,[sp,#8]
;;;708    	TxMessage.IDE=CAN_ID_EXT;				//使用扩展帧标识符
000012  2004              MOVS     r0,#4
000014  f88d000c          STRB     r0,[sp,#0xc]
;;;709    	
;;;710    	TxMessage.RTR=CAN_RTR_DATA;			//数据帧	
000018  2000              MOVS     r0,#0
00001a  f88d000d          STRB     r0,[sp,#0xd]
;;;711    	
;;;712    	TxMessage.DLC=length;						//DLC用来设定待传输消息的帧长度。它的取值范围是0到8。
00001e  f88d500e          STRB     r5,[sp,#0xe]
;;;713    	
;;;714    	for(	i	=	0;i<length;i++)
000022  2400              MOVS     r4,#0
000024  e004              B        |L3.48|
                  |L3.38|
;;;715    	{
;;;716    		TxMessage.Data[i]=Data[i];
000026  5d39              LDRB     r1,[r7,r4]
000028  f10d000f          ADD      r0,sp,#0xf
00002c  5501              STRB     r1,[r0,r4]
00002e  1c64              ADDS     r4,r4,#1              ;714
                  |L3.48|
000030  42ac              CMP      r4,r5                 ;714
000032  d3f8              BCC      |L3.38|
;;;717    	}
;;;718    //	TxMessage.Data[0]=Data[0];
;;;719    //	TxMessage.Data[1]=Data[1];
;;;720    //	TxMessage.Data[2]=Data[2];
;;;721    //	TxMessage.Data[3]=Data[3];
;;;722    //	TxMessage.Data[4]=Data[4];
;;;723    //	TxMessage.Data[5]=Data[5];
;;;724    //	TxMessage.Data[6]=Data[6];
;;;725    //	TxMessage.Data[7]=Data[7];
;;;726    	
;;;727    	TransmitMailbox = CAN_Transmit(&TxMessage);			//开始一个消息的传输
000034  a801              ADD      r0,sp,#4
000036  f7fffffe          BL       CAN_Transmit
00003a  4680              MOV      r8,r0
;;;728    	i = 0;
00003c  2400              MOVS     r4,#0
;;;729    	// 用于检查消息传输是否正常
;;;730    	while((CAN_TransmitStatus(TransmitMailbox) != CANTXOK) && (i != 0xFF))
00003e  e000              B        |L3.66|
                  |L3.64|
;;;731    	{
;;;732    		i++;
000040  1c64              ADDS     r4,r4,#1
                  |L3.66|
000042  4640              MOV      r0,r8                 ;730
000044  f7fffffe          BL       CAN_TransmitStatus
000048  2801              CMP      r0,#1                 ;730
00004a  d001              BEQ      |L3.80|
00004c  2cff              CMP      r4,#0xff              ;730
00004e  d1f7              BNE      |L3.64|
                  |L3.80|
;;;733    	}
;;;734    	i = 0;
000050  2400              MOVS     r4,#0
;;;735    	// 检查返回的挂号的信息数目
;;;736    	while((CAN_MessagePending(CAN_FIFO0) < 1) && (i != 0xFF))
000052  e000              B        |L3.86|
                  |L3.84|
;;;737    	{
;;;738    		i++;
000054  1c64              ADDS     r4,r4,#1
                  |L3.86|
000056  2000              MOVS     r0,#0                 ;736
000058  f7fffffe          BL       CAN_MessagePending
00005c  2801              CMP      r0,#1                 ;736
00005e  da01              BGE      |L3.100|
000060  2cff              CMP      r4,#0xff              ;736
000062  d1f7              BNE      |L3.84|
                  |L3.100|
;;;739    	}
;;;740    
;;;741    }
000064  b006              ADD      sp,sp,#0x18
000066  e8bd81f0          POP      {r4-r8,pc}
;;;742    /*******************************************************************************
                          ENDP


                          AREA ||i.CAN_FilterInitConfiguration_ExtData||, CODE, READONLY, ALIGN=1

                  CAN_FilterInitConfiguration_ExtData PROC
;;;439    *******************************************************************************/
;;;440    void CAN_FilterInitConfiguration_ExtData(
000000  b57f              PUSH     {r0-r6,lr}
;;;441    																	u8 CAN_GROUP,			//过滤器组---bxCAN为应用程序提供了14个位宽可变的、可配置的过滤器组(13~0)，以便只接收那些软件需要的报文
;;;442    																	u32 CAN_ID,				//
;;;443    																	u32 MaskId				//位匹配，如果是相应位为1表示必须与CAN_ID匹配
;;;444    )		//CAN滤波器配置
;;;445    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;446    	//说明：
;;;447    	//--在CAN协议里，报文的标识符不代表节点的地址，而是跟报文的内容相关的。因此，发送者以广播的形式把报文发送给所有的接收者。
;;;448    	//节点在接收报文时,根据标识符(CAN ID)的值决定软件是否需要该报文；如果需要，就拷贝到SRAM里；如果不需要，报文就被丢弃且无需软件的干预。
;;;449      //--为满足这一需求，bxCAN为应用程序提供了14个位宽可变的、可配置的过滤器组(13~0)，以便只接收那些软件需要的报文。硬件过滤的做法节省了CPU开销，
;;;450    	//否则就必须由软件过滤从而占用一定的CPU开销。每个过滤器组x由2个32位寄存器，CAN_FxR0和CAN_FxR1组成。
;;;451    	
;;;452    	//扩展帧和标准帧的区别在于：
;;;453    	//扩展帧的仲裁域有29位，可以出现2^29中报文，且在数据链路上是有间隙的(对操作者透明)。标准帧的仲裁域是连续的11位，可以出现2^11种报文；
;;;454    	//控制帧中的DLC(数据长度)完全相同，但保留位不同，标准帧IDE、R0，扩展帧R1、R0，必须以显性电平发送(由数据链路层操作)，对程序员透明；
;;;455    	//其它的都一模一样，所以，其实CAN标准帧和扩展帧只是在ID的长度上不一样，以能扩展更多的CAN节点，更好地支持上层协议而已。
;;;456    	
;;;457    	//bxCAN模块可以完全自动地接收和发送CAN报文；且完全支持标准标识符STID(11位000-7FF)和扩展标识符EXID(29位0000 0000-1FFF FFFF)。
;;;458    	CAN_FilterInitTypeDef		CAN_FilterInitStructure;
;;;459    //	CAN_ID=0X317;
;;;460    
;;;461      //1.3)**********CAN滤波器初始化
;;;462    	//1.3.1---------过滤器组
;;;463      CAN_FilterInitStructure.CAN_FilterNumber=CAN_GROUP;						//设置过滤器组0，范围为0~13
000008  f88d5000          STRB     r5,[sp,#0]
;;;464    	
;;;465    	
;;;466    	//1.3)**********下面根据设置的参数不同来决定can总线can总线的配置情况：注：slave_id为要过滤的id号。
;;;467    		/*
;;;468    			//1、对扩展数据帧进行过滤:(只接收扩展数据帧)	(注：标准帧数据帧、标准远程帧和扩展远程帧均被过滤)
;;;469    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<3)&0xFFFF0000)>>16;
;;;470    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<3)|CAN_ID_EXT|CAN_RTR_DATA)&0xFFFF;
;;;471    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;472    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;473    
;;;474    			//2、对扩展远程帧过滤:(只接收扩展远程帧)
;;;475    			CAN_FilterInitStructure.CAN_FilterIdHigh  	 	= (((u32)slave_id<<3)&0xFFFF0000)>>16;
;;;476    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<3)|CAN_ID_EXT|CAN_RTR_REMOTE)&0xFFFF;
;;;477    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;478    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;479    
;;;480    			//3、对标准远程帧过滤:(只接收标准远程帧)
;;;481    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<21)&0xffff0000)>>16;
;;;482    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<21)|CAN_ID_STD|CAN_RTR_REMOTE)&0xffff;
;;;483    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;484    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;485    			
;;;486    			//4、对标准数据帧过滤:(只接收标准数据帧)
;;;487    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<21)&0xffff0000)>>16;
;;;488    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<21)|CAN_ID_STD|CAN_RTR_DATA)&0xffff;
;;;489    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;490    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;491    
;;;492    			//5、对扩展帧进行过滤:(扩展帧不会被过滤掉)
;;;493    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<3)&0xFFFF0000)>>16;
;;;494    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<3)|CAN_ID_EXT)&0xFFFF;
;;;495    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;496    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFC;
;;;497    			
;;;498    			//6、对标准帧进行过滤:(标准帧不会被过滤掉)
;;;499    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<21)&0xffff0000)>>16;
;;;500    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<21)|CAN_ID_STD)&0xffff;
;;;501    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;502    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFC;
;;;503    			*/
;;;504    
;;;505    
;;;506    	//1.3.2---------过滤器的过滤模式
;;;507    	//● 当过滤器为屏蔽模式时，标识符寄存器对应的ID内容可为任意一需求接收的ID值，
;;;508    	//● 当同时要接收标准帧和扩展帧时，标识符寄存器对应IDE位也随意设置，
;;;509    	//● 屏蔽寄存器的IDE位设置为0，表示不关心标准帧还是扩展帧。
;;;510    	//● 而屏蔽寄存器对应的ID内容为各需求接收的ID值依次异或的结果再取反。
;;;511      CAN_FilterInitStructure.CAN_FilterMode=CAN_FilterMode_IdMask;	//STM32提供两种过滤模式供用户设置：屏蔽位模式和标识符列表模式。
00000c  2000              MOVS     r0,#0
00000e  f88d0001          STRB     r0,[sp,#1]
;;;512    																																//->CAN_FilterMode_IdMask：标识符屏蔽位模式
;;;513    																																//-->A,为了过滤出一组标识符，应该设置过滤器组工作在屏蔽位模式。
;;;514    																																//-->B,在屏蔽位模式下，标识符寄存器和屏蔽寄存器一起，指定报文标识符的任何一位，应该按照“必须匹配”或“不用关心”处理。
;;;515    																																
;;;516    																																//->CAN_FilterMode_IdList：标识符列表模式
;;;517    																																//-->A,为了过滤出一个标识符，应该设置过滤器组工作在标识符列表模式。
;;;518    																																//-->B, 在标识符列表模式下，屏蔽寄存器也被当作标识符寄存器用。因此，不是采用一个标识符加一个屏蔽位的方式，
;;;519    																																//------而是使用2个标识符寄存器。接收报文标识符的每一位都必须跟过滤器标识符相同。
;;;520    	//1.3.3---------过滤器位宽																															
;;;521      CAN_FilterInitStructure.CAN_FilterScale=CAN_FilterScale_32bit;//过滤器位宽
000012  2001              MOVS     r0,#1
000014  f88d0002          STRB     r0,[sp,#2]
;;;522    																																//->CAN_FilterScale_Two16bit：2个16位过滤器	
;;;523    																																//->CAN_FilterScale_One32bit：1个32位过滤器
;;;524    	//1.3.4---------标识位寄存器的设置 (发送邮箱标识符寄存器 (CAN_TIxR) (x=0..2))																															
;;;525      CAN_FilterInitStructure.CAN_FilterIdHigh=(((u32)CAN_ID<<3)&0xFFFF0000)>>16;;						//设定过滤器标识符（32位位宽时为其高段位，16位位宽时为第一个）。它的范围是0x0000到0xFFFF。																																
000018  f3c4304f          UBFX     r0,r4,#13,#16
00001c  f8ad0004          STRH     r0,[sp,#4]
;;;526      CAN_FilterInitStructure.CAN_FilterIdLow=(((u32)CAN_ID<<3)|CAN_ID_EXT|CAN_RTR_DATA)&0xFFFF;;								//设定过滤器标识符（32位位宽时为其低段位，16位位宽时为第二个）。它的范围是0x0000到0xFFFF。
000020  2004              MOVS     r0,#4
000022  eb0000c4          ADD      r0,r0,r4,LSL #3
000026  b280              UXTH     r0,r0
000028  f8ad0006          STRH     r0,[sp,#6]
;;;527    	//1.3.5---------屏蔽寄存器的设置 
;;;528      CAN_FilterInitStructure.CAN_FilterMaskIdHigh=0xFFFF;					//设定过滤器屏蔽标识符或者过滤器标识符（32位位宽时为其高段位，16位位宽时为第一个）。它的范围是0x0000到0xFFFF。
00002c  f64f70ff          MOV      r0,#0xffff
000030  f8ad0008          STRH     r0,[sp,#8]
;;;529      CAN_FilterInitStructure.CAN_FilterMaskIdLow=0xFFFF;						//设定过滤器屏蔽标识符或者过滤器标识符（32位位宽时为其低段位，16位位宽时为第二个）。它的范围是0x0000到0xFFFF。
000034  f8ad000a          STRH     r0,[sp,#0xa]
;;;530    	//1.3.6---------过滤器组关联
;;;531      CAN_FilterInitStructure.CAN_FilterFIFOAssignment=0;						//设定指向过滤器的FIFO（0或1）此过滤器组关联到接收FIFO0
000038  2000              MOVS     r0,#0
00003a  f8ad000c          STRH     r0,[sp,#0xc]
;;;532    																																//->CAN_FilterFIFO0：过滤器FIFO0指向过滤器x
;;;533    																																//->CAN_FilterFIFO1：过滤器FIFO1指向过滤器x
;;;534    	//1.3.7---------激活此过滤器组																															
;;;535      CAN_FilterInitStructure.CAN_FilterActivation=ENABLE;					//使能或者失能过滤器。该参数可取的值为ENABLE或者DISABLE。
00003e  2001              MOVS     r0,#1
000040  f88d000e          STRB     r0,[sp,#0xe]
;;;536    	//1.3.7---------设置过滤器
;;;537      CAN_FilterInit(&CAN_FilterInitStructure);
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       CAN_FilterInit
;;;538    }
00004a  bd7f              POP      {r0-r6,pc}
;;;539    /*******************************************************************************
                          ENDP


                          AREA ||i.CAN_FilterInitConfiguration_StdData||, CODE, READONLY, ALIGN=1

                  CAN_FilterInitConfiguration_StdData PROC
;;;333    *******************************************************************************/
;;;334    void CAN_FilterInitConfiguration_StdData(
000000  b57f              PUSH     {r0-r6,lr}
;;;335    																	u8 CAN_GROUP,			//过滤器组---bxCAN为应用程序提供了14个位宽可变的、可配置的过滤器组(13~0)，以便只接收那些软件需要的报文
;;;336    																	u16 CAN_ID,				//
;;;337    																	u16 MaskId				//位匹配，如果是相应位为1表示必须与CAN_ID对应位匹配
;;;338    )		//CAN滤波器配置
;;;339    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;340    	//说明：
;;;341    	//--在CAN协议里，报文的标识符不代表节点的地址，而是跟报文的内容相关的。因此，发送者以广播的形式把报文发送给所有的接收者。
;;;342    	//节点在接收报文时,根据标识符(CAN ID)的值决定软件是否需要该报文；如果需要，就拷贝到SRAM里；如果不需要，报文就被丢弃且无需软件的干预。
;;;343      //--为满足这一需求，bxCAN为应用程序提供了14个位宽可变的、可配置的过滤器组(13~0)，以便只接收那些软件需要的报文。硬件过滤的做法节省了CPU开销，
;;;344    	//否则就必须由软件过滤从而占用一定的CPU开销。每个过滤器组x由2个32位寄存器，CAN_FxR0和CAN_FxR1组成。
;;;345    	
;;;346    	//扩展帧和标准帧的区别在于：
;;;347    	//扩展帧的仲裁域有29位，可以出现2^29中报文，且在数据链路上是有间隙的(对操作者透明)。标准帧的仲裁域是连续的11位，可以出现2^11种报文；
;;;348    	//控制帧中的DLC(数据长度)完全相同，但保留位不同，标准帧IDE、R0，扩展帧R1、R0，必须以显性电平发送(由数据链路层操作)，对程序员透明；
;;;349    	//其它的都一模一样，所以，其实CAN标准帧和扩展帧只是在ID的长度上不一样，以能扩展更多的CAN节点，更好地支持上层协议而已。
;;;350    	
;;;351    	//bxCAN模块可以完全自动地接收和发送CAN报文；且完全支持标准标识符STID(11位000-7FF)和扩展标识符EXID(29位0000 0000-1FFF FFFF)。
;;;352    	CAN_FilterInitTypeDef		CAN_FilterInitStructure;
;;;353    //	CAN_ID=0X317;
;;;354    
;;;355      //1.3)**********CAN滤波器初始化
;;;356    	//1.3.1---------过滤器组
;;;357      CAN_FilterInitStructure.CAN_FilterNumber=CAN_GROUP;						//设置过滤器组0，范围为0~13
000008  f88d6000          STRB     r6,[sp,#0]
;;;358    	
;;;359    	
;;;360    	//1.3)**********下面根据设置的参数不同来决定can总线can总线的配置情况：注：slave_id为要过滤的id号。
;;;361    		/*
;;;362    			//1、对扩展数据帧进行过滤:(只接收扩展数据帧)	(注：标准帧数据帧、标准远程帧和扩展远程帧均被过滤)
;;;363    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<3)&0xFFFF0000)>>16;
;;;364    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<3)|CAN_ID_EXT|CAN_RTR_DATA)&0xFFFF;
;;;365    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;366    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;367    
;;;368    			//2、对扩展远程帧过滤:(只接收扩展远程帧)
;;;369    			CAN_FilterInitStructure.CAN_FilterIdHigh  	 	= (((u32)slave_id<<3)&0xFFFF0000)>>16;
;;;370    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<3)|CAN_ID_EXT|CAN_RTR_REMOTE)&0xFFFF;
;;;371    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;372    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;373    
;;;374    			//3、对标准远程帧过滤:(只接收标准远程帧)
;;;375    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<21)&0xffff0000)>>16;
;;;376    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<21)|CAN_ID_STD|CAN_RTR_REMOTE)&0xffff;
;;;377    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;378    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;379    			
;;;380    			//4、对标准数据帧过滤:(只接收标准数据帧)
;;;381    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<21)&0xffff0000)>>16;
;;;382    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<21)|CAN_ID_STD|CAN_RTR_DATA)&0xffff;
;;;383    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;384    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFF;
;;;385    
;;;386    			//5、对扩展帧进行过滤:(扩展帧不会被过滤掉)
;;;387    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<3)&0xFFFF0000)>>16;
;;;388    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<3)|CAN_ID_EXT)&0xFFFF;
;;;389    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;390    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFC;
;;;391    			
;;;392    			//6、对标准帧进行过滤:(标准帧不会被过滤掉)
;;;393    			CAN_FilterInitStructure.CAN_FilterIdHigh   		= (((u32)slave_id<<21)&0xffff0000)>>16;
;;;394    			CAN_FilterInitStructure.CAN_FilterIdLow   		= (((u32)slave_id<<21)|CAN_ID_STD)&0xffff;
;;;395    			CAN_FilterInitStructure.CAN_FilterMaskIdHigh  = 0xFFFF;
;;;396    			CAN_FilterInitStructure.CAN_FilterMaskIdLow   = 0xFFFC;
;;;397    			*/
;;;398    
;;;399    
;;;400    	//1.3.2---------过滤器的过滤模式
;;;401    	//● 当过滤器为屏蔽模式时，标识符寄存器对应的ID内容可为任意一需求接收的ID值，
;;;402    	//● 当同时要接收标准帧和扩展帧时，标识符寄存器对应IDE位也随意设置，
;;;403    	//● 屏蔽寄存器的IDE位设置为0，表示不关心标准帧还是扩展帧。
;;;404    	//● 而屏蔽寄存器对应的ID内容为各需求接收的ID值依次异或的结果再取反。
;;;405      CAN_FilterInitStructure.CAN_FilterMode=CAN_FilterMode_IdMask;	//STM32提供两种过滤模式供用户设置：屏蔽位模式和标识符列表模式。
00000c  2000              MOVS     r0,#0
00000e  f88d0001          STRB     r0,[sp,#1]
;;;406    																																//->CAN_FilterMode_IdMask：标识符屏蔽位模式
;;;407    																																//-->A,为了过滤出一组标识符，应该设置过滤器组工作在屏蔽位模式。
;;;408    																																//-->B,在屏蔽位模式下，标识符寄存器和屏蔽寄存器一起，指定报文标识符的任何一位，应该按照“必须匹配”或“不用关心”处理。
;;;409    																																
;;;410    																																//->CAN_FilterMode_IdList：标识符列表模式
;;;411    																																//-->A,为了过滤出一个标识符，应该设置过滤器组工作在标识符列表模式。
;;;412    																																//-->B, 在标识符列表模式下，屏蔽寄存器也被当作标识符寄存器用。因此，不是采用一个标识符加一个屏蔽位的方式，
;;;413    																																//------而是使用2个标识符寄存器。接收报文标识符的每一位都必须跟过滤器标识符相同。
;;;414    	//1.3.3---------过滤器位宽																															
;;;415      CAN_FilterInitStructure.CAN_FilterScale=CAN_FilterScale_32bit;//过滤器位宽
000012  2001              MOVS     r0,#1
000014  f88d0002          STRB     r0,[sp,#2]
;;;416    																																//->CAN_FilterScale_Two16bit：2个16位过滤器	
;;;417    																																//->CAN_FilterScale_One32bit：1个32位过滤器
;;;418    	//1.3.4---------标识位寄存器的设置 (发送邮箱标识符寄存器 (CAN_TIxR) (x=0..2))																															
;;;419      CAN_FilterInitStructure.CAN_FilterIdHigh=(((u32)CAN_ID<<21)&0xffff0000)>>16;	//设定过滤器标识符（32位位宽时为其高段位，16位位宽时为第一个）。它的范围是0x0000到0xFFFF。																																
000018  0560              LSLS     r0,r4,#21
00001a  0c00              LSRS     r0,r0,#16
00001c  f8ad0004          STRH     r0,[sp,#4]
;;;420      CAN_FilterInitStructure.CAN_FilterIdLow=0x0000;																//设定过滤器标识符（32位位宽时为其低段位，16位位宽时为第二个）。它的范围是0x0000到0xFFFF。
000020  2000              MOVS     r0,#0
000022  f8ad0006          STRH     r0,[sp,#6]
;;;421    	//1.3.5---------屏蔽寄存器的设置 
;;;422      CAN_FilterInitStructure.CAN_FilterMaskIdHigh=(((u32)MaskId<<21)&0xffff0000)>>16;					//设定过滤器屏蔽标识符或者过滤器标识符（32位位宽时为其高段位，16位位宽时为第一个）。它的范围是0x0000到0xFFFF。
000026  0568              LSLS     r0,r5,#21
000028  0c00              LSRS     r0,r0,#16
00002a  f8ad0008          STRH     r0,[sp,#8]
;;;423      CAN_FilterInitStructure.CAN_FilterMaskIdLow=0xFFFF;						//设定过滤器屏蔽标识符或者过滤器标识符（32位位宽时为其低段位，16位位宽时为第二个）。它的范围是0x0000到0xFFFF。
00002e  f64f70ff          MOV      r0,#0xffff
000032  f8ad000a          STRH     r0,[sp,#0xa]
;;;424    	//1.3.6---------过滤器组关联
;;;425      CAN_FilterInitStructure.CAN_FilterFIFOAssignment=0;						//设定指向过滤器的FIFO（0或1）此过滤器组关联到接收FIFO0
000036  2000              MOVS     r0,#0
000038  f8ad000c          STRH     r0,[sp,#0xc]
;;;426    																																//->CAN_FilterFIFO0：过滤器FIFO0指向过滤器x
;;;427    																																//->CAN_FilterFIFO1：过滤器FIFO1指向过滤器x
;;;428    	//1.3.7---------激活此过滤器组																															
;;;429      CAN_FilterInitStructure.CAN_FilterActivation=ENABLE;					//使能或者失能过滤器。该参数可取的值为ENABLE或者DISABLE。
00003c  2001              MOVS     r0,#1
00003e  f88d000e          STRB     r0,[sp,#0xe]
;;;430    	//1.3.7---------设置过滤器
;;;431      CAN_FilterInit(&CAN_FilterInitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       CAN_FilterInit
;;;432    }
000048  bd7f              POP      {r0-r6,pc}
;;;433    /*******************************************************************************
                          ENDP


                          AREA ||i.CAN_PinSet||, CODE, READONLY, ALIGN=2

                  CAN_PinSet PROC
;;;565    *******************************************************************************/
;;;566    ErrorStatus CAN_PinSet(CANRemap_TypeDef CANRemap_Status)						//
000000  b538              PUSH     {r3-r5,lr}
;;;567    {
000002  4604              MOV      r4,r0
;;;568    	GPIO_InitTypeDef GPIO_InitStructure;					//GPIO结构体	
;;;569    	
;;;570    	assert_param(IS_CANRemap_Status(CANRemap_Status));
;;;571    //*****************************CAN默认引脚配置**********************************
;;;572    	if(CANRemap_Status==CANRemapNone)
000004  b9ec              CBNZ     r4,|L6.66|
;;;573    	{
;;;574    		//1.1)**********CAN_RX默认接收引脚配置，PA11
;;;575    		GPIO_InitStructure.GPIO_Pin		= GPIO_Pin_11; 
000006  f44f6000          MOV      r0,#0x800
00000a  f8ad0000          STRH     r0,[sp,#0]
;;;576    		GPIO_InitStructure.GPIO_Speed	= GPIO_Speed_50MHz;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;577    		GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_IPU;
000014  2048              MOVS     r0,#0x48
000016  f88d0003          STRB     r0,[sp,#3]
;;;578    		GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  482d              LDR      r0,|L6.212|
00001e  f7fffffe          BL       GPIO_Init
;;;579    		//1.2)**********CAN_TX默认发送引脚配置，PA12
;;;580    		GPIO_InitStructure.GPIO_Pin		= GPIO_Pin_12; 
000022  f44f5080          MOV      r0,#0x1000
000026  f8ad0000          STRH     r0,[sp,#0]
;;;581    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002a  2003              MOVS     r0,#3
00002c  f88d0002          STRB     r0,[sp,#2]
;;;582    		GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_AF_PP;
000030  2018              MOVS     r0,#0x18
000032  f88d0003          STRB     r0,[sp,#3]
;;;583    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000036  4669              MOV      r1,sp
000038  4826              LDR      r0,|L6.212|
00003a  f7fffffe          BL       GPIO_Init
;;;584    		//1.3)**********返回配置状态
;;;585    		return SUCCESS;				//返回配置成功
00003e  2001              MOVS     r0,#1
                  |L6.64|
;;;586    	}
;;;587    	
;;;588    //*****************************CAN重定义地址1模式引脚配置**********************************
;;;589    	else if(CANRemap_Status==CANRemap1)
;;;590    	{
;;;591    		//1.1)**********CAN_RX重定义地址1模式接收引脚配置，PB8 
;;;592    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; 
;;;593    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;594    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 
;;;595    		GPIO_Init(GPIOB, &GPIO_InitStructure); 
;;;596    		//1.2)**********CAN_RX重定义地址1模式发送引脚配置，PB9  
;;;597    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; 
;;;598    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;599    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; 
;;;600    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;601    		//1.3)********** Configure CAN Remap 重影射
;;;602    		GPIO_PinRemapConfig(GPIO_Remap1_CAN, ENABLE);
;;;603    		//1.4)**********返回配置状态
;;;604    		return SUCCESS;				//返回配置成功
;;;605    		
;;;606    	}
;;;607    
;;;608    //*****************************CAN重定义地址2模式引脚配置**********************************
;;;609    	else if(CANRemap_Status==CANRemap2)
;;;610    	{
;;;611    		//1.1)**********CAN_RX重定义地址2模式接收引脚配置，PD0 
;;;612    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; 
;;;613    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;614    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 
;;;615    		GPIO_Init(GPIOD, &GPIO_InitStructure); 
;;;616    		//1.2)**********CAN_RX重定义地址2模式发送引脚配置，PD1  
;;;617    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; 
;;;618    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;619    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; 
;;;620    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;621    		//1.3)********** Configure CAN Remap 重影射
;;;622    		GPIO_PinRemapConfig(GPIO_Remap2_CAN, ENABLE);
;;;623    		//1.4)**********返回配置状态
;;;624    		return SUCCESS;				//返回配置成功
;;;625    	}
;;;626    	else
;;;627    		return ERROR;			//返回配置失败
;;;628    }
000040  bd38              POP      {r3-r5,pc}
                  |L6.66|
000042  2c01              CMP      r4,#1                 ;589
000044  d120              BNE      |L6.136|
000046  0220              LSLS     r0,r4,#8              ;592
000048  f8ad0000          STRH     r0,[sp,#0]            ;592
00004c  2003              MOVS     r0,#3                 ;593
00004e  f88d0002          STRB     r0,[sp,#2]            ;593
000052  2048              MOVS     r0,#0x48              ;594
000054  f88d0003          STRB     r0,[sp,#3]            ;594
000058  4669              MOV      r1,sp                 ;595
00005a  481f              LDR      r0,|L6.216|
00005c  f7fffffe          BL       GPIO_Init
000060  0260              LSLS     r0,r4,#9              ;597
000062  f8ad0000          STRH     r0,[sp,#0]            ;597
000066  2003              MOVS     r0,#3                 ;598
000068  f88d0002          STRB     r0,[sp,#2]            ;598
00006c  2018              MOVS     r0,#0x18              ;599
00006e  f88d0003          STRB     r0,[sp,#3]            ;599
000072  4669              MOV      r1,sp                 ;600
000074  4818              LDR      r0,|L6.216|
000076  f7fffffe          BL       GPIO_Init
00007a  2101              MOVS     r1,#1                 ;602
00007c  f44f10ea          MOV      r0,#0x1d4000          ;602
000080  f7fffffe          BL       GPIO_PinRemapConfig
000084  2001              MOVS     r0,#1                 ;604
000086  e7db              B        |L6.64|
                  |L6.136|
000088  2c02              CMP      r4,#2                 ;609
00008a  d120              BNE      |L6.206|
00008c  2001              MOVS     r0,#1                 ;612
00008e  f8ad0000          STRH     r0,[sp,#0]            ;612
000092  2003              MOVS     r0,#3                 ;613
000094  f88d0002          STRB     r0,[sp,#2]            ;613
000098  2048              MOVS     r0,#0x48              ;614
00009a  f88d0003          STRB     r0,[sp,#3]            ;614
00009e  4669              MOV      r1,sp                 ;615
0000a0  480e              LDR      r0,|L6.220|
0000a2  f7fffffe          BL       GPIO_Init
0000a6  2002              MOVS     r0,#2                 ;617
0000a8  f8ad0000          STRH     r0,[sp,#0]            ;617
0000ac  2003              MOVS     r0,#3                 ;618
0000ae  f88d0002          STRB     r0,[sp,#2]            ;618
0000b2  2018              MOVS     r0,#0x18              ;619
0000b4  f88d0003          STRB     r0,[sp,#3]            ;619
0000b8  4669              MOV      r1,sp                 ;620
0000ba  4808              LDR      r0,|L6.220|
0000bc  f7fffffe          BL       GPIO_Init
0000c0  2101              MOVS     r1,#1                 ;622
0000c2  f44f10eb          MOV      r0,#0x1d6000          ;622
0000c6  f7fffffe          BL       GPIO_PinRemapConfig
0000ca  2001              MOVS     r0,#1                 ;624
0000cc  e7b8              B        |L6.64|
                  |L6.206|
0000ce  2000              MOVS     r0,#0                 ;627
0000d0  e7b6              B        |L6.64|
;;;629    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L6.212|
                          DCD      0x40010800
                  |L6.216|
                          DCD      0x40010c00
                  |L6.220|
                          DCD      0x40011400

                          AREA ||i.CAN_RX_DATA||, CODE, READONLY, ALIGN=2

                  CAN_RX_DATA PROC
;;;748    *******************************************************************************/
;;;749    u8 CAN_RX_DATA(CanRxMsg *RxMessage)
000000  b510              PUSH     {r4,lr}
;;;750    {
000002  4604              MOV      r4,r0
;;;751    //	if(SET == CAN_GetITStatus(CAN_IT_FF0))
;;;752    //	{
;;;753    //		CAN_ClearITPendingBit(CAN_IT_FF0);
;;;754    //		return 0;
;;;755    //	}
;;;756    //	else if(SET == CAN_GetITStatus(CAN_IT_FOV0))
;;;757    //	{
;;;758    //		CAN_ClearITPendingBit(CAN_IT_FOV0);
;;;759    //		return 0;
;;;760    //	}
;;;761    //	else
;;;762    //	{
;;;763    		CAN_ClearITPendingBit(CAN_IT_FF0);
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       CAN_ClearITPendingBit
;;;764    		CAN_ClearITPendingBit(CAN_IT_FF0);
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       CAN_ClearITPendingBit
;;;765    		//========================检查收件箱0是否有数据
;;;766    		if(0	!=	(CAN->RF0R&0x03))	//FMP0[1:0]: FIFO 0 报文数目 (FIFO 0 message pending) FIFO 0报文数目这2位反映了当前接收FIFO 0中存放的报文数目。
000010  480c              LDR      r0,|L7.68|
000012  6800              LDR      r0,[r0,#0]
000014  f0000003          AND      r0,r0,#3
000018  b128              CBZ      r0,|L7.38|
;;;767    		{
;;;768    			
;;;769    			CAN_Receive(CAN_FIFO0, RxMessage);
00001a  4621              MOV      r1,r4
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       CAN_Receive
;;;770    			
;;;771    			return 1;
000022  2001              MOVS     r0,#1
                  |L7.36|
;;;772    		}
;;;773    		//========================检查收件箱1是否有数据
;;;774    		else if(0	!=	(CAN->RF1R&0x03))	//FMP0[1:0]: FIFO 0 报文数目 (FIFO 0 message pending) FIFO 0报文数目这2位反映了当前接收FIFO 0中存放的报文数目。
;;;775    		{
;;;776    			CAN_Receive(CAN_FIFO1, RxMessage);
;;;777    			return 1;
;;;778    		}
;;;779    //	}
;;;780    	
;;;781    	return 0;
;;;782    }
000024  bd10              POP      {r4,pc}
                  |L7.38|
000026  4807              LDR      r0,|L7.68|
000028  1d00              ADDS     r0,r0,#4              ;774
00002a  6800              LDR      r0,[r0,#0]            ;774
00002c  f0000003          AND      r0,r0,#3              ;774
000030  b128              CBZ      r0,|L7.62|
000032  4621              MOV      r1,r4                 ;776
000034  2001              MOVS     r0,#1                 ;776
000036  f7fffffe          BL       CAN_Receive
00003a  2001              MOVS     r0,#1                 ;777
00003c  e7f2              B        |L7.36|
                  |L7.62|
00003e  2000              MOVS     r0,#0                 ;781
000040  e7f0              B        |L7.36|
;;;783    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x4000640c

                          AREA ||i.CAN_StdTX_DATA||, CODE, READONLY, ALIGN=1

                  CAN_StdTX_DATA PROC
;;;638    *******************************************************************************/
;;;639    void CAN_StdTX_DATA(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;640    										u16 CAN_ID,			//CAN地址
;;;641    										u8 length,			//设定待传输消息的帧长度。它的取值范围是0到8。
;;;642    										u8 *Data				//数据										
;;;643    )
;;;644    {
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
;;;645    	CanTxMsg TxMessage;
;;;646    	u8	TransmitMailbox = 0;
00000c  f04f0800          MOV      r8,#0
;;;647    	u32	i;
;;;648    
;;;649    	TxMessage.StdId=CAN_ID;						//标准帧ID
000010  9601              STR      r6,[sp,#4]
;;;650    	TxMessage.IDE=CAN_ID_STD;					//使用标准标识符
000012  2000              MOVS     r0,#0
000014  f88d000c          STRB     r0,[sp,#0xc]
;;;651    	
;;;652    //	TxMessage.ExtId=CAN_ID;					//扩展帧ID
;;;653    //	TxMessage.IDE=CAN_ID_EXT;				//使用扩展帧标识符
;;;654    	
;;;655    	TxMessage.RTR=CAN_RTR_DATA;				//数据帧
000018  f88d000d          STRB     r0,[sp,#0xd]
;;;656    	
;;;657    	TxMessage.DLC=length;							//DLC用来设定待传输消息的帧长度。它的取值范围是0到8。
00001c  f88d500e          STRB     r5,[sp,#0xe]
;;;658    	
;;;659    	for(	i	=	0;i<length;i++)
000020  2400              MOVS     r4,#0
000022  e004              B        |L8.46|
                  |L8.36|
;;;660    	{
;;;661    		TxMessage.Data[i]=Data[i];
000024  5d39              LDRB     r1,[r7,r4]
000026  f10d000f          ADD      r0,sp,#0xf
00002a  5501              STRB     r1,[r0,r4]
00002c  1c64              ADDS     r4,r4,#1              ;659
                  |L8.46|
00002e  42ac              CMP      r4,r5                 ;659
000030  d3f8              BCC      |L8.36|
;;;662    	}
;;;663    	
;;;664    //	TxMessage.Data[0]=Data[0];
;;;665    //	TxMessage.Data[1]=Data[1];
;;;666    //	TxMessage.Data[2]=Data[2];
;;;667    //	TxMessage.Data[3]=Data[3];
;;;668    //	TxMessage.Data[4]=Data[4];
;;;669    //	TxMessage.Data[5]=Data[5];
;;;670    //	TxMessage.Data[6]=Data[6];
;;;671    //	TxMessage.Data[7]=Data[7];
;;;672    	TransmitMailbox = CAN_Transmit(&TxMessage);
000032  a801              ADD      r0,sp,#4
000034  f7fffffe          BL       CAN_Transmit
000038  4680              MOV      r8,r0
;;;673    	i = 0;
00003a  2400              MOVS     r4,#0
;;;674    	// 用于检查消息传输是否正常
;;;675    	while((CAN_TransmitStatus(TransmitMailbox) != CANTXOK) && (i <= 0xFF))
00003c  e000              B        |L8.64|
                  |L8.62|
;;;676    	{
;;;677    		i++;
00003e  1c64              ADDS     r4,r4,#1
                  |L8.64|
000040  4640              MOV      r0,r8                 ;675
000042  f7fffffe          BL       CAN_TransmitStatus
000046  2801              CMP      r0,#1                 ;675
000048  d001              BEQ      |L8.78|
00004a  2cff              CMP      r4,#0xff              ;675
00004c  d9f7              BLS      |L8.62|
                  |L8.78|
;;;678    	}
;;;679    	i = 0;
00004e  2400              MOVS     r4,#0
;;;680    	// 检查返回的挂号的信息数目
;;;681    	while((CAN_MessagePending(CAN_FIFO0) < 1) && (i <= 0xFF))
000050  e000              B        |L8.84|
                  |L8.82|
;;;682    	{
;;;683    		i++;
000052  1c64              ADDS     r4,r4,#1
                  |L8.84|
000054  2000              MOVS     r0,#0                 ;681
000056  f7fffffe          BL       CAN_MessagePending
00005a  2801              CMP      r0,#1                 ;681
00005c  da01              BGE      |L8.98|
00005e  2cff              CMP      r4,#0xff              ;681
000060  d9f7              BLS      |L8.82|
                  |L8.98|
;;;684    	}
;;;685    
;;;686    }
000062  b006              ADD      sp,sp,#0x18
000064  e8bd81f0          POP      {r4-r8,pc}
;;;687    /*******************************************************************************
                          ENDP

