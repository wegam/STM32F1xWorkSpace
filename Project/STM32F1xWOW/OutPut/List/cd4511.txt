; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\cd4511.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\cd4511.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\cd4511.crf ..\..\Driver\Components\SCR\CD4511.C]
                          THUMB

                          AREA ||i.CD4511_Clear||, CODE, READONLY, ALIGN=1

                  CD4511_Clear PROC
;;;153    *******************************************************************************/
;;;154    void CD4511_Clear(CD4511Def *pInfo)		//清除输出：bitA~bitG输出低电平
000000  b510              PUSH     {r4,lr}
;;;155    {
000002  4604              MOV      r4,r0
;;;156    	GPIO_ResetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);			//A/A0
000004  88a1              LDRH     r1,[r4,#4]
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       GPIO_ResetBits
;;;157    	GPIO_SetBits	(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);			//B/A1
00000c  89a1              LDRH     r1,[r4,#0xc]
00000e  68a0              LDR      r0,[r4,#8]
000010  f7fffffe          BL       GPIO_SetBits
;;;158    	GPIO_ResetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);			//C/A2
000014  8aa1              LDRH     r1,[r4,#0x14]
000016  6920              LDR      r0,[r4,#0x10]
000018  f7fffffe          BL       GPIO_ResetBits
;;;159    	GPIO_SetBits	(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);			//D/A3
00001c  8ba1              LDRH     r1,[r4,#0x1c]
00001e  69a0              LDR      r0,[r4,#0x18]
000020  f7fffffe          BL       GPIO_SetBits
;;;160    	
;;;161    //	GPIO_ResetBits(pInfo->Port.Seg1_PORT, pInfo->Port.Seg1_Pin);			//C/A2
;;;162    //	GPIO_ResetBits(pInfo->Port.Seg2_PORT, pInfo->Port.Seg2_Pin);			//C/A2
;;;163    //	GPIO_ResetBits(pInfo->Port.Seg3_PORT, pInfo->Port.Seg3_Pin);			//C/A2
;;;164    	
;;;165    //	unsigned char		i	=	0;
;;;166    //	unsigned long		*Port			=	NULL;
;;;167    //	unsigned short 	*Pin			=	NULL;					//GPIO_Pin_x
;;;168    //	
;;;169    //	Port	=	(unsigned long*)&(pInfo->Port.A0_PORT);
;;;170    //	Pin		=	(unsigned short*)&(pInfo->Port.A0_Pin);
;;;171    //	GPIO_ResetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);			//A/A0
;;;172    //	GPIO_SetBits	(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);			//B/A1
;;;173    //	GPIO_ResetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);			//C/A2
;;;174    //	GPIO_SetBits	(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);			//D/A3
;;;175    	
;;;176    //	for(i	=	0;	i<pInfo->Data.Num;	i++)
;;;177    //	{
;;;178    //		GPIO_ResetBits((GPIO_TypeDef*)(*Port), (unsigned short)*Pin);
;;;179    //		Port	+=	2;
;;;180    //		Pin		+=	2;
;;;181    //	}
;;;182    }
000024  bd10              POP      {r4,pc}
;;;183    /*******************************************************************************
                          ENDP


                          AREA ||i.CD4511_Delay||, CODE, READONLY, ALIGN=1

                  CD4511_Delay PROC
;;;29     *******************************************************************************/
;;;30     void CD4511_Delay(u32 time)
000000  bf00              NOP      
                  |L2.2|
;;;31     {
;;;32     	while(time--);
000002  1e01              SUBS     r1,r0,#0
000004  f1a00001          SUB      r0,r0,#1
000008  d1fb              BNE      |L2.2|
;;;33     }
00000a  4770              BX       lr
;;;34     /*******************************************************************************
                          ENDP


                          AREA ||i.CD4511_DisplayOFF||, CODE, READONLY, ALIGN=1

                  CD4511_DisplayOFF PROC
;;;289    *******************************************************************************/
;;;290    void CD4511_DisplayOFF(CD4511Def *pInfo)			//关闭显示---关NPN三极管
000000  b510              PUSH     {r4,lr}
;;;291    {
000002  4604              MOV      r4,r0
;;;292    	GPIO_ResetBits(pInfo->Port.Seg1_PORT,pInfo->Port.Seg1_Pin);
000004  8ca1              LDRH     r1,[r4,#0x24]
000006  6a20              LDR      r0,[r4,#0x20]
000008  f7fffffe          BL       GPIO_ResetBits
;;;293    	GPIO_ResetBits(pInfo->Port.Seg2_PORT,pInfo->Port.Seg2_Pin);
00000c  8da1              LDRH     r1,[r4,#0x2c]
00000e  6aa0              LDR      r0,[r4,#0x28]
000010  f7fffffe          BL       GPIO_ResetBits
;;;294    	GPIO_ResetBits(pInfo->Port.Seg3_PORT,pInfo->Port.Seg3_Pin);
000014  8ea1              LDRH     r1,[r4,#0x34]
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       GPIO_ResetBits
;;;295    	CD4511_Delay(1000);
00001c  f44f707a          MOV      r0,#0x3e8
000020  f7fffffe          BL       CD4511_Delay
;;;296    }
000024  bd10              POP      {r4,pc}
;;;297    /*******************************************************************************
                          ENDP


                          AREA ||i.CD4511_DisplayON||, CODE, READONLY, ALIGN=1

                  CD4511_DisplayON PROC
;;;302    *******************************************************************************/
;;;303    void CD4511_DisplayON(CD4511Def *pInfo)			//开显示---关NPN三极管
000000  b510              PUSH     {r4,lr}
;;;304    {
000002  4604              MOV      r4,r0
;;;305    	GPIO_SetBits(pInfo->Port.Seg1_PORT,pInfo->Port.Seg1_Pin);
000004  8ca1              LDRH     r1,[r4,#0x24]
000006  6a20              LDR      r0,[r4,#0x20]
000008  f7fffffe          BL       GPIO_SetBits
;;;306    	GPIO_SetBits(pInfo->Port.Seg2_PORT,pInfo->Port.Seg2_Pin);
00000c  8da1              LDRH     r1,[r4,#0x2c]
00000e  6aa0              LDR      r0,[r4,#0x28]
000010  f7fffffe          BL       GPIO_SetBits
;;;307    	GPIO_SetBits(pInfo->Port.Seg3_PORT,pInfo->Port.Seg3_Pin);
000014  8ea1              LDRH     r1,[r4,#0x34]
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       GPIO_SetBits
;;;308    	CD4511_Delay(1000);
00001c  f44f707a          MOV      r0,#0x3e8
000020  f7fffffe          BL       CD4511_Delay
;;;309    }
000024  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.CD4511_Initialize||, CODE, READONLY, ALIGN=1

                  CD4511_Initialize PROC
;;;39     *******************************************************************************/
;;;40     void CD4511_Initialize(CD4511Def *pInfo)
000000  b510              PUSH     {r4,lr}
;;;41     {
000002  4604              MOV      r4,r0
;;;42     //	unsigned char		i	=	0;
;;;43     //	unsigned long		*Port			=	NULL;
;;;44     //	unsigned long 	*Pin			=	NULL;					//GPIO_Pin_x
;;;45     	
;;;46     	GPIO_Configuration_OPP50	(pInfo->Port.A0_PORT,		pInfo->Port.A0_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000004  88a1              LDRH     r1,[r4,#4]
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       GPIO_Configuration_OPP50
;;;47     	GPIO_Configuration_OPP50	(pInfo->Port.A1_PORT,		pInfo->Port.A1_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00000c  89a1              LDRH     r1,[r4,#0xc]
00000e  68a0              LDR      r0,[r4,#8]
000010  f7fffffe          BL       GPIO_Configuration_OPP50
;;;48     	GPIO_Configuration_OPP50	(pInfo->Port.A2_PORT,		pInfo->Port.A2_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000014  8aa1              LDRH     r1,[r4,#0x14]
000016  6920              LDR      r0,[r4,#0x10]
000018  f7fffffe          BL       GPIO_Configuration_OPP50
;;;49     	GPIO_Configuration_OPP50	(pInfo->Port.A3_PORT,		pInfo->Port.A3_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00001c  8ba1              LDRH     r1,[r4,#0x1c]
00001e  69a0              LDR      r0,[r4,#0x18]
000020  f7fffffe          BL       GPIO_Configuration_OPP50
;;;50     	
;;;51     	GPIO_Configuration_OPP50	(pInfo->Port.Seg1_PORT,		pInfo->Port.Seg1_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000024  8ca1              LDRH     r1,[r4,#0x24]
000026  6a20              LDR      r0,[r4,#0x20]
000028  f7fffffe          BL       GPIO_Configuration_OPP50
;;;52     	GPIO_Configuration_OPP50	(pInfo->Port.Seg2_PORT,		pInfo->Port.Seg2_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
00002c  8da1              LDRH     r1,[r4,#0x2c]
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  f7fffffe          BL       GPIO_Configuration_OPP50
;;;53     	GPIO_Configuration_OPP50	(pInfo->Port.Seg3_PORT,		pInfo->Port.Seg3_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
000034  8ea1              LDRH     r1,[r4,#0x34]
000036  6b20              LDR      r0,[r4,#0x30]
000038  f7fffffe          BL       GPIO_Configuration_OPP50
;;;54     	
;;;55     //	for(i	=	0;	i<pInfo->Data.Num;	i++)
;;;56     //	{
;;;57     //		GPIO_Configuration_OPP50	((GPIO_TypeDef*)*Port,(unsigned short)*Pin);		//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度2MHz----V20170605
;;;58     //		GPIO_ResetBits((GPIO_TypeDef*)(*Port), (unsigned short)*Pin);
;;;59     //		Port	+=	2;
;;;60     //		Pin		+=	2;
;;;61     //	}
;;;62     }
00003c  bd10              POP      {r4,pc}
;;;63     /*******************************************************************************
                          ENDP


                          AREA ||i.CD4511_Process||, CODE, READONLY, ALIGN=1

                  CD4511_Process PROC
;;;68     *******************************************************************************/
;;;69     void CD4511_Process(CD4511Def *pInfo)
000000  b5f8              PUSH     {r3-r7,lr}
;;;70     {
000002  4604              MOV      r4,r0
;;;71     	unsigned char		i;
;;;72     	unsigned short	Data;					//显示的数据
;;;73     	unsigned short	Time;					//计时器
;;;74     	CD4511BcdDef*		CD4511Bcd;		//BCD码结构体
;;;75     	
;;;76     	Data	=	pInfo->Data.Data;
000004  8f60              LDRH     r0,[r4,#0x3a]
000006  9000              STR      r0,[sp,#0]
;;;77     	Time	=	pInfo->Data.Time;
000008  8fa0              LDRH     r0,[r4,#0x3c]
00000a  b287              UXTH     r7,r0
;;;78     	
;;;79     	i	=	Time%3;				//三位数码管
00000c  2003              MOVS     r0,#3
00000e  fb97f1f0          SDIV     r1,r7,r0
000012  fb007011          MLS      r0,r0,r1,r7
000016  b2c6              UXTB     r6,r0
;;;80     	
;;;81     	if(pInfo->Data.Time++>=10000)
000018  6be2              LDR      r2,[r4,#0x3c]
00001a  1c50              ADDS     r0,r2,#1
00001c  63e0              STR      r0,[r4,#0x3c]
00001e  f2427010          MOV      r0,#0x2710
000022  4282              CMP      r2,r0
000024  d301              BCC      |L6.42|
;;;82     	{
;;;83     		pInfo->Data.Time	=	0;
000026  2100              MOVS     r1,#0
000028  63e1              STR      r1,[r4,#0x3c]
                  |L6.42|
;;;84     	}
;;;85     	//=============先关闭数码管显示
;;;86     	GPIO_ResetBits(pInfo->Port.Seg1_PORT, pInfo->Port.Seg1_Pin);			//SEG1
00002a  8ca1              LDRH     r1,[r4,#0x24]
00002c  6a20              LDR      r0,[r4,#0x20]
00002e  f7fffffe          BL       GPIO_ResetBits
;;;87     	GPIO_ResetBits(pInfo->Port.Seg2_PORT, pInfo->Port.Seg2_Pin);			//SEG2
000032  8da1              LDRH     r1,[r4,#0x2c]
000034  6aa0              LDR      r0,[r4,#0x28]
000036  f7fffffe          BL       GPIO_ResetBits
;;;88     	GPIO_ResetBits(pInfo->Port.Seg3_PORT, pInfo->Port.Seg3_Pin);			//SEG3
00003a  8ea1              LDRH     r1,[r4,#0x34]
00003c  6b20              LDR      r0,[r4,#0x30]
00003e  f7fffffe          BL       GPIO_ResetBits
;;;89     	
;;;90     	//=============取出显示数值
;;;91     	switch(i)
000042  b126              CBZ      r6,|L6.78|
000044  2e01              CMP      r6,#1
000046  d00c              BEQ      |L6.98|
000048  2e02              CMP      r6,#2
00004a  d11f              BNE      |L6.140|
00004c  e016              B        |L6.124|
                  |L6.78|
;;;92     	{
;;;93     		case 0:Data	=	Data%10;break;//显示个位
00004e  f8bd0000          LDRH     r0,[sp,#0]
000052  210a              MOVS     r1,#0xa
000054  fb90f2f1          SDIV     r2,r0,r1
000058  fb010012          MLS      r0,r1,r2,r0
00005c  b280              UXTH     r0,r0
00005e  9000              STR      r0,[sp,#0]
000060  e015              B        |L6.142|
                  |L6.98|
;;;94     		case 1:Data	=	(Data%100)/10;break;//显示十位
000062  f8bd0000          LDRH     r0,[sp,#0]
000066  2164              MOVS     r1,#0x64
000068  fb90f2f1          SDIV     r2,r0,r1
00006c  fb010012          MLS      r0,r1,r2,r0
000070  210a              MOVS     r1,#0xa
000072  fb90f0f1          SDIV     r0,r0,r1
000076  b280              UXTH     r0,r0
000078  9000              STR      r0,[sp,#0]
00007a  e008              B        |L6.142|
                  |L6.124|
;;;95     		case 2:Data	=	(Data/100);break;//显示百位
00007c  f8bd0000          LDRH     r0,[sp,#0]
000080  2164              MOVS     r1,#0x64
000082  fb90f0f1          SDIV     r0,r0,r1
000086  b280              UXTH     r0,r0
000088  9000              STR      r0,[sp,#0]
00008a  e000              B        |L6.142|
                  |L6.140|
;;;96     		default :break;
00008c  bf00              NOP      
                  |L6.142|
00008e  bf00              NOP                            ;93
;;;97     	}
;;;98     	
;;;99     	CD4511Bcd	=	(CD4511BcdDef*)&Data;				//转换为BCD码
000090  466d              MOV      r5,sp
;;;100    	
;;;101    	if(CD4511Bcd->A)
000092  7828              LDRB     r0,[r5,#0]
000094  f0000001          AND      r0,r0,#1
000098  b120              CBZ      r0,|L6.164|
;;;102    	{
;;;103    		GPIO_SetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);
00009a  88a1              LDRH     r1,[r4,#4]
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       GPIO_SetBits
0000a2  e003              B        |L6.172|
                  |L6.164|
;;;104    	}
;;;105    	else
;;;106    	{
;;;107    		GPIO_ResetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);			//A/A0
0000a4  88a1              LDRH     r1,[r4,#4]
0000a6  6820              LDR      r0,[r4,#0]
0000a8  f7fffffe          BL       GPIO_ResetBits
                  |L6.172|
;;;108    	}
;;;109    	if(CD4511Bcd->B)
0000ac  7828              LDRB     r0,[r5,#0]
0000ae  f3c00040          UBFX     r0,r0,#1,#1
0000b2  b120              CBZ      r0,|L6.190|
;;;110    	{
;;;111    		GPIO_SetBits(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);
0000b4  89a1              LDRH     r1,[r4,#0xc]
0000b6  68a0              LDR      r0,[r4,#8]
0000b8  f7fffffe          BL       GPIO_SetBits
0000bc  e003              B        |L6.198|
                  |L6.190|
;;;112    	}
;;;113    	else
;;;114    	{
;;;115    		GPIO_ResetBits(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);			//B/A1
0000be  89a1              LDRH     r1,[r4,#0xc]
0000c0  68a0              LDR      r0,[r4,#8]
0000c2  f7fffffe          BL       GPIO_ResetBits
                  |L6.198|
;;;116    	}
;;;117    	if(CD4511Bcd->C)
0000c6  7828              LDRB     r0,[r5,#0]
0000c8  f3c00080          UBFX     r0,r0,#2,#1
0000cc  b120              CBZ      r0,|L6.216|
;;;118    	{
;;;119    		GPIO_SetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);
0000ce  8aa1              LDRH     r1,[r4,#0x14]
0000d0  6920              LDR      r0,[r4,#0x10]
0000d2  f7fffffe          BL       GPIO_SetBits
0000d6  e003              B        |L6.224|
                  |L6.216|
;;;120    	}
;;;121    	else
;;;122    	{
;;;123    		GPIO_ResetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);			//C/A2
0000d8  8aa1              LDRH     r1,[r4,#0x14]
0000da  6920              LDR      r0,[r4,#0x10]
0000dc  f7fffffe          BL       GPIO_ResetBits
                  |L6.224|
;;;124    	}
;;;125    	if(CD4511Bcd->D)
0000e0  7828              LDRB     r0,[r5,#0]
0000e2  f3c000c0          UBFX     r0,r0,#3,#1
0000e6  b120              CBZ      r0,|L6.242|
;;;126    	{
;;;127    		GPIO_SetBits(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);
0000e8  8ba1              LDRH     r1,[r4,#0x1c]
0000ea  69a0              LDR      r0,[r4,#0x18]
0000ec  f7fffffe          BL       GPIO_SetBits
0000f0  e003              B        |L6.250|
                  |L6.242|
;;;128    	}
;;;129    	else
;;;130    	{
;;;131    		GPIO_ResetBits(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);			//D/A3
0000f2  8ba1              LDRH     r1,[r4,#0x1c]
0000f4  69a0              LDR      r0,[r4,#0x18]
0000f6  f7fffffe          BL       GPIO_ResetBits
                  |L6.250|
;;;132    	}
;;;133    	//=============打开相应数码管位
;;;134    	switch(i)
0000fa  b126              CBZ      r6,|L6.262|
0000fc  2e01              CMP      r6,#1
0000fe  d007              BEQ      |L6.272|
000100  2e02              CMP      r6,#2
000102  d10f              BNE      |L6.292|
000104  e009              B        |L6.282|
                  |L6.262|
;;;135    	{
;;;136    		case 0:GPIO_SetBits(pInfo->Port.Seg1_PORT, pInfo->Port.Seg1_Pin);			//SEG1
000106  8ca1              LDRH     r1,[r4,#0x24]
000108  6a20              LDR      r0,[r4,#0x20]
00010a  f7fffffe          BL       GPIO_SetBits
;;;137    					break;
00010e  e00a              B        |L6.294|
                  |L6.272|
;;;138    		case 1:GPIO_SetBits(pInfo->Port.Seg2_PORT, pInfo->Port.Seg2_Pin);			//SEG1
000110  8da1              LDRH     r1,[r4,#0x2c]
000112  6aa0              LDR      r0,[r4,#0x28]
000114  f7fffffe          BL       GPIO_SetBits
;;;139    					break;
000118  e005              B        |L6.294|
                  |L6.282|
;;;140    		case 2:GPIO_SetBits(pInfo->Port.Seg3_PORT, pInfo->Port.Seg3_Pin);			//SEG1
00011a  8ea1              LDRH     r1,[r4,#0x34]
00011c  6b20              LDR      r0,[r4,#0x30]
00011e  f7fffffe          BL       GPIO_SetBits
;;;141    					break;
000122  e000              B        |L6.294|
                  |L6.292|
;;;142    		default: break;		
000124  bf00              NOP      
                  |L6.294|
000126  bf00              NOP                            ;137
;;;143    	}
;;;144    }
000128  bdf8              POP      {r3-r7,pc}
;;;145    /*******************************************************************************
                          ENDP


                          AREA ||i.CD4511_WriteData||, CODE, READONLY, ALIGN=1

                  CD4511_WriteData PROC
;;;191    *******************************************************************************/
;;;192    void CD4511_WriteData(CD4511Def *pInfo,unsigned short num)		//BCD转换为Segment输出 只输出0~9
000000  8741              STRH     r1,[r0,#0x3a]
;;;193    {
;;;194    	pInfo->Data.Data	=	num;
;;;195    //	CD4511BcdDef*	CD4511Bcd;		//BCD码结构体
;;;196    //	
;;;197    //	num	=	num%10;			//限定在1位数
;;;198    //	
;;;199    //	CD4511Bcd	=	(CD4511BcdDef*)&num;				//转换为BCD码
;;;200    //	
;;;201    //	if(CD4511Bcd->A)
;;;202    //	{
;;;203    //		GPIO_SetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);
;;;204    //	}
;;;205    //	else
;;;206    //	{
;;;207    //		GPIO_ResetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);			//A/A0
;;;208    //	}
;;;209    //	if(CD4511Bcd->B)
;;;210    //	{
;;;211    //		GPIO_SetBits(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);
;;;212    //	}
;;;213    //	else
;;;214    //	{
;;;215    //		GPIO_ResetBits(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);			//B/A1
;;;216    //	}
;;;217    //	if(CD4511Bcd->C)
;;;218    //	{
;;;219    //		GPIO_SetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);
;;;220    //	}
;;;221    //	else
;;;222    //	{
;;;223    //		GPIO_ResetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);			//C/A2
;;;224    //	}
;;;225    //	if(CD4511Bcd->D)
;;;226    //	{
;;;227    //		GPIO_SetBits(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);
;;;228    //	}
;;;229    //	else
;;;230    //	{
;;;231    //		GPIO_ResetBits(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);			//D/A3
;;;232    //	}
;;;233    }
000002  4770              BX       lr
;;;234    /*******************************************************************************
                          ENDP


                          AREA ||i.CD4511_WriteDataNum||, CODE, READONLY, ALIGN=1

                  CD4511_WriteDataNum PROC
;;;242    *******************************************************************************/
;;;243    void CD4511_WriteDataNum(CD4511Def *pInfo,unsigned short num)		//BCD转换为Segment输出 只输出0~9
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245    	CD4511BcdDef*	CD4511Bcd;		//BCD码结构体
;;;246    	
;;;247    	num	=	num%10;			//限定在1位数
000004  f8bd0004          LDRH     r0,[sp,#4]
000008  210a              MOVS     r1,#0xa
00000a  fb90f2f1          SDIV     r2,r0,r1
00000e  fb010012          MLS      r0,r1,r2,r0
000012  b280              UXTH     r0,r0
000014  9001              STR      r0,[sp,#4]
;;;248    	
;;;249    	CD4511Bcd	=	(CD4511BcdDef*)&num;				//转换为BCD码
000016  ad01              ADD      r5,sp,#4
;;;250    	
;;;251    	if(CD4511Bcd->A)
000018  7828              LDRB     r0,[r5,#0]
00001a  f0000001          AND      r0,r0,#1
00001e  b120              CBZ      r0,|L8.42|
;;;252    	{
;;;253    		GPIO_SetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);
000020  88a1              LDRH     r1,[r4,#4]
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       GPIO_SetBits
000028  e003              B        |L8.50|
                  |L8.42|
;;;254    	}
;;;255    	else
;;;256    	{
;;;257    		GPIO_ResetBits(pInfo->Port.A0_PORT, pInfo->Port.A0_Pin);			//A/A0
00002a  88a1              LDRH     r1,[r4,#4]
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       GPIO_ResetBits
                  |L8.50|
;;;258    	}
;;;259    	if(CD4511Bcd->B)
000032  7828              LDRB     r0,[r5,#0]
000034  f3c00040          UBFX     r0,r0,#1,#1
000038  b120              CBZ      r0,|L8.68|
;;;260    	{
;;;261    		GPIO_SetBits(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);
00003a  89a1              LDRH     r1,[r4,#0xc]
00003c  68a0              LDR      r0,[r4,#8]
00003e  f7fffffe          BL       GPIO_SetBits
000042  e003              B        |L8.76|
                  |L8.68|
;;;262    	}
;;;263    	else
;;;264    	{
;;;265    		GPIO_ResetBits(pInfo->Port.A1_PORT, pInfo->Port.A1_Pin);			//B/A1
000044  89a1              LDRH     r1,[r4,#0xc]
000046  68a0              LDR      r0,[r4,#8]
000048  f7fffffe          BL       GPIO_ResetBits
                  |L8.76|
;;;266    	}
;;;267    	if(CD4511Bcd->C)
00004c  7828              LDRB     r0,[r5,#0]
00004e  f3c00080          UBFX     r0,r0,#2,#1
000052  b120              CBZ      r0,|L8.94|
;;;268    	{
;;;269    		GPIO_SetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);
000054  8aa1              LDRH     r1,[r4,#0x14]
000056  6920              LDR      r0,[r4,#0x10]
000058  f7fffffe          BL       GPIO_SetBits
00005c  e003              B        |L8.102|
                  |L8.94|
;;;270    	}
;;;271    	else
;;;272    	{
;;;273    		GPIO_ResetBits(pInfo->Port.A2_PORT, pInfo->Port.A2_Pin);			//C/A2
00005e  8aa1              LDRH     r1,[r4,#0x14]
000060  6920              LDR      r0,[r4,#0x10]
000062  f7fffffe          BL       GPIO_ResetBits
                  |L8.102|
;;;274    	}
;;;275    	if(CD4511Bcd->D)
000066  7828              LDRB     r0,[r5,#0]
000068  f3c000c0          UBFX     r0,r0,#3,#1
00006c  b120              CBZ      r0,|L8.120|
;;;276    	{
;;;277    		GPIO_SetBits(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);
00006e  8ba1              LDRH     r1,[r4,#0x1c]
000070  69a0              LDR      r0,[r4,#0x18]
000072  f7fffffe          BL       GPIO_SetBits
000076  e003              B        |L8.128|
                  |L8.120|
;;;278    	}
;;;279    	else
;;;280    	{
;;;281    		GPIO_ResetBits(pInfo->Port.A3_PORT, pInfo->Port.A3_Pin);			//D/A3
000078  8ba1              LDRH     r1,[r4,#0x1c]
00007a  69a0              LDR      r0,[r4,#0x18]
00007c  f7fffffe          BL       GPIO_ResetBits
                  |L8.128|
;;;282    	}
;;;283    }
000080  bd7c              POP      {r2-r6,pc}
;;;284    /*******************************************************************************
                          ENDP

