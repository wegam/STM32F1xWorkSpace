; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_flash.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_flash.crf ..\..\Driver\WOW\SCR\STM32_FLASH.C]
                          THUMB

                          AREA ||i.STM32_FLASH_Erase||, CODE, READONLY, ALIGN=2

                  STM32_FLASH_Erase PROC
;;;252    *******************************************************************************/
;;;253    void STM32_FLASH_Erase(u32 WriteAddr,u16 NumToWrite)	//擦除FLASH
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;254    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;255      u32 secpos;	   //扇区地址
;;;256    	u16 secoff;	   //扇区内偏移地址(16位字计算)
;;;257    	u16 secremain; //扇区内剩余地址(16位字计算)	   
;;;258     	u16 i;    
;;;259    	u32 offaddr;   //去掉0X08000000后的地址
;;;260    	if(WriteAddr<STM32_FLASH_BASE||(WriteAddr>=(STM32_FLASH_BASE+1024*STM32_FLASH_SIZE)))
000008  f1b76f00          CMP      r7,#0x8000000
00000c  d302              BCC      |L1.20|
00000e  4826              LDR      r0,|L1.168|
000010  4287              CMP      r7,r0
000012  d301              BCC      |L1.24|
                  |L1.20|
;;;261    		return;//非法地址
;;;262    	
;;;263    	FLASH_Unlock();						//解锁
;;;264    	
;;;265    	offaddr		=	WriteAddr-STM32_FLASH_BASE;		//实际偏移地址.
;;;266    	secpos		=	offaddr/STM_SECTOR_SIZE;			//扇区地址  0~127 for STM32F103RBT6
;;;267    	secoff		=	(offaddr%STM_SECTOR_SIZE)/2;		//在扇区内的偏移(2个字节为基本单位.)
;;;268    	secremain	=	STM_SECTOR_SIZE/2-secoff;		//扇区剩余空间大小
;;;269    	
;;;270    	if(NumToWrite	<=	secremain)
;;;271    		secremain	=	NumToWrite;//不大于该扇区范围
;;;272    	
;;;273    	while(1) 
;;;274    	{	
;;;275    		STM32_FLASH_Read(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE,STM32_FLASH_BUF,STM_SECTOR_SIZE/2);//读出整个扇区的内容
;;;276    		for(i=0;i<secremain;i++)	//校验数据
;;;277    		{
;;;278    			if(STM32_FLASH_BUF[secoff+i]!=0XFFFF)
;;;279    				break;//需要擦除  	  
;;;280    		}
;;;281    		if(i<secremain)//需要擦除
;;;282    		{
;;;283    			FLASH_ErasePage(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE);//擦除这个扇区
;;;284    		}
;;;285    		if(NumToWrite	==	secremain)
;;;286    			break;	//写入结束了
;;;287    		else			//写入未结束
;;;288    		{
;;;289    			secpos++;				//扇区地址增1
;;;290    			secoff=0;				//偏移位置为0 	 
;;;291    			WriteAddr		+=	secremain;		//写地址偏移	   
;;;292    		  NumToWrite	-=	secremain;	//字节(16位)数递减
;;;293    			if(NumToWrite>(STM_SECTOR_SIZE/2))
;;;294    				secremain	=	STM_SECTOR_SIZE/2;	//下一个扇区还是写不完
;;;295    			else
;;;296    				secremain	=	NumToWrite;					//下一个扇区可以写完了
;;;297    		}	 
;;;298    	};	
;;;299    	FLASH_Lock();//上锁
;;;300    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L1.24|
000018  f7fffffe          BL       FLASH_Unlock
00001c  f1a76a00          SUB      r10,r7,#0x8000000     ;265
000020  ea4f269a          LSR      r6,r10,#10            ;266
000024  f3ca0948          UBFX     r9,r10,#1,#9          ;267
000028  f5c97400          RSB      r4,r9,#0x200          ;268
00002c  42a5              CMP      r5,r4                 ;270
00002e  dc00              BGT      |L1.50|
000030  462c              MOV      r4,r5                 ;271
                  |L1.50|
000032  e033              B        |L1.156|
                  |L1.52|
000034  f04f6100          MOV      r1,#0x8000000         ;275
000038  eb012086          ADD      r0,r1,r6,LSL #10      ;275
00003c  148a              ASRS     r2,r1,#18             ;275
00003e  491b              LDR      r1,|L1.172|
000040  f7fffffe          BL       STM32_FLASH_Read
000044  f04f0800          MOV      r8,#0                 ;276
000048  e00d              B        |L1.102|
                  |L1.74|
00004a  eb090008          ADD      r0,r9,r8              ;278
00004e  4917              LDR      r1,|L1.172|
000050  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;278
000054  f64f71ff          MOV      r1,#0xffff            ;278
000058  4288              CMP      r0,r1                 ;278
00005a  d000              BEQ      |L1.94|
00005c  e005              B        |L1.106|
                  |L1.94|
00005e  f1080001          ADD      r0,r8,#1              ;276
000062  fa1ff880          UXTH     r8,r0                 ;276
                  |L1.102|
000066  45a0              CMP      r8,r4                 ;276
000068  dbef              BLT      |L1.74|
                  |L1.106|
00006a  bf00              NOP                            ;279
00006c  45a0              CMP      r8,r4                 ;281
00006e  da05              BGE      |L1.124|
000070  f04f6100          MOV      r1,#0x8000000         ;283
000074  eb012086          ADD      r0,r1,r6,LSL #10      ;283
000078  f7fffffe          BL       FLASH_ErasePage
                  |L1.124|
00007c  42a5              CMP      r5,r4                 ;285
00007e  d100              BNE      |L1.130|
000080  e00d              B        |L1.158|
                  |L1.130|
000082  1c76              ADDS     r6,r6,#1              ;289
000084  f04f0900          MOV      r9,#0                 ;290
000088  4427              ADD      r7,r7,r4              ;291
00008a  1b28              SUBS     r0,r5,r4              ;292
00008c  b285              UXTH     r5,r0                 ;292
00008e  f5b57f00          CMP      r5,#0x200             ;293
000092  dd02              BLE      |L1.154|
000094  f44f7400          MOV      r4,#0x200             ;294
000098  e000              B        |L1.156|
                  |L1.154|
00009a  462c              MOV      r4,r5                 ;296
                  |L1.156|
00009c  e7ca              B        |L1.52|
                  |L1.158|
00009e  bf00              NOP                            ;286
0000a0  f7fffffe          BL       FLASH_Lock
0000a4  bf00              NOP      
0000a6  e7b5              B        |L1.20|
;;;301    //============================================================================================
                          ENDP

                  |L1.168|
                          DCD      0x08020000
                  |L1.172|
                          DCD      STM32_FLASH_BUF

                          AREA ||i.STM32_FLASH_Read||, CODE, READONLY, ALIGN=1

                  STM32_FLASH_Read PROC
;;;231    *******************************************************************************/
;;;232    void STM32_FLASH_Read(u32 StartAddr,u16 *pBuffer,u16 NumToRead)		//从指定地址开始读出指定长度的数据   	
000000  b530              PUSH     {r4,r5,lr}
;;;233    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;234    	u16 i;
;;;235    	for(i=0;i<NumToRead;i++)
000008  2200              MOVS     r2,#0
00000a  e007              B        |L2.28|
                  |L2.12|
;;;236    	{
;;;237    		pBuffer[i]	=		STM32_FLASH_ReadHalfWord(StartAddr);//读取2个字节.
00000c  4618              MOV      r0,r3
00000e  f7fffffe          BL       STM32_FLASH_ReadHalfWord
000012  f8240012          STRH     r0,[r4,r2,LSL #1]
;;;238    		StartAddr		+=	2;//偏移2个字节.	
000016  1c9b              ADDS     r3,r3,#2
000018  1c50              ADDS     r0,r2,#1              ;235
00001a  b282              UXTH     r2,r0                 ;235
                  |L2.28|
00001c  42aa              CMP      r2,r5                 ;235
00001e  dbf5              BLT      |L2.12|
;;;239    	}
;;;240    }
000020  bd30              POP      {r4,r5,pc}
;;;241    
                          ENDP


                          AREA ||i.STM32_FLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  STM32_FLASH_ReadHalfWord PROC
;;;52     *******************************************************************************/
;;;53     u16 STM32_FLASH_ReadHalfWord(u32 Addr)		//读取指定地址的半字(16位数据)
000000  4601              MOV      r1,r0
;;;54     {
;;;55     	return *(vu16*)Addr; 
000002  8808              LDRH     r0,[r1,#0]
;;;56     }
000004  4770              BX       lr
;;;57     
                          ENDP


                          AREA ||i.STM32_FLASH_Write||, CODE, READONLY, ALIGN=2

                  STM32_FLASH_Write PROC
;;;88     *******************************************************************************/
;;;89     void STM32_FLASH_Write(u32 StartAddr,u16 *pBuffer,u16 NumToWrite)		//从指定地址写入指定长度的数据
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;90     {
000004  4604              MOV      r4,r0
000006  4617              MOV      r7,r2
;;;91     	u32 PageAddress;						//页地址
;;;92     	u16 PageAddressOffset;			//页内偏移地址(16位字计算)
;;;93     	u16 RemainderSpace;					//页内剩余存储空间(16位字计算)
;;;94     	u16 NumWaitToWrite;					//等待写入的长度(16位字计算)	
;;;95     	u16 TotalHaveWritten	=	0;	//已写入的长度(16位字计算)
000008  f04f0b00          MOV      r11,#0
;;;96      	u16 i;    
;;;97     
;;;98     	if((StartAddr<STM32_FLASH_BASE)||(StartAddr>=(STM32_FLASH_BASE+1024*STM32_FLASH_SIZE)))		//地址不在合法范围内
00000c  f1b46f00          CMP      r4,#0x8000000
000010  d302              BCC      |L4.24|
000012  482f              LDR      r0,|L4.208|
000014  4284              CMP      r4,r0
000016  d301              BCC      |L4.28|
                  |L4.24|
;;;99     		return;					//非法地址	
;;;100    	
;;;101    	FLASH_Unlock();		//解锁
;;;102    	//FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
;;;103    	if(StartAddr>STM32_FLASH_BASE)
;;;104    	{
;;;105    		PageAddress				=	StartAddr-(StartAddr-STM32_FLASH_BASE)%STM_SECTOR_SIZE;		//计算起始页地址----擦除是按页擦除
;;;106    	}
;;;107    	//PageAddress				=	(StartAddr-STM32_FLASH_BASE)/STM_SECTOR_SIZE	+	STM32_FLASH_BASE;		//计算起始页地址----擦除是按页擦除
;;;108    	//PageAddress				=	0x08008000;		//计算起始页地址----擦除是按页擦除
;;;109    	PageAddressOffset	=	((StartAddr-STM32_FLASH_BASE)%STM_SECTOR_SIZE)/2;									//在扇区内的偏移(2个字节为基本单位.)----计算在扇区内的起始地址
;;;110    	RemainderSpace		=	STM_SECTOR_SIZE/2	-	PageAddressOffset;															//页内剩余存储空间(16位字计算)
;;;111    
;;;112    	//---------------------考虑跨页写情况
;;;113    	while(TotalHaveWritten<NumToWrite)
;;;114    	{
;;;115    		if(RemainderSpace	>=	NumToWrite)		//不需要跨页
;;;116    		{
;;;117    			NumWaitToWrite	=	NumToWrite;			//全部数据写入
;;;118    		}
;;;119    		else
;;;120    		{
;;;121    			NumWaitToWrite	=	STM_SECTOR_SIZE/2	-	PageAddressOffset;
;;;122    		}
;;;123    		
;;;124    		//检查页是否需要擦除
;;;125    		STM32_FLASH_Read(PageAddress,STM32_FLASH_BUF,STM_SECTOR_SIZE/2);	//读出整个扇区的内容
;;;126    		for(i=0;i<NumWaitToWrite;i++)		//校验数据----检查需要写入的存储空间是否为空
;;;127    		{
;;;128    			if(STM32_FLASH_BUF[PageAddressOffset+i]	!=	0XFFFF)			//检查偏移后的地址是否为空
;;;129    				break;				//需要擦除
;;;130    		}
;;;131    		//需要擦除----注意保存原始不应该擦除的数据
;;;132    		if(i<NumWaitToWrite)
;;;133    		{
;;;134    			//擦除整个页---闪存擦除操作可以按页面擦除或完全擦除(全擦除)
;;;135    			//FLASH_ErasePage(PageAddress);			//擦除这个扇区
;;;136    			FLASH_ErasePage(PageAddress);				//擦除这个扇区
;;;137    			//将待写入数据及原扇区保留数据放入写入缓冲区
;;;138    			memcpy(&STM32_FLASH_BUF[PageAddressOffset],pBuffer,NumWaitToWrite);												//复制数据
;;;139    			STM32_FLASH_Write_NoCheck(PageAddress,STM32_FLASH_BUF,PageAddressOffset+NumWaitToWrite);		//将原保留数据和新增加数据写入扇区
;;;140    		}
;;;141    		else		//不需要擦除
;;;142    		{
;;;143    			STM32_FLASH_Write_NoCheck(PageAddress+PageAddressOffset,pBuffer,NumWaitToWrite);					//写已经擦除了的,直接写入扇区剩余区间.
;;;144    		}
;;;145    		
;;;146    		TotalHaveWritten	+=	NumWaitToWrite;			//已写入计数
;;;147    		
;;;148    		//如果需要跨页时需要用到
;;;149    		PageAddressOffset	=		0;									//新页起始地址0，不需要偏移
;;;150    		PageAddress				+=	STM_SECTOR_SIZE;		//增加一个页地址
;;;151    		RemainderSpace		+=	STM_SECTOR_SIZE/2;	//新页起始地址0，剩余页空间为页大小
;;;152    	}
;;;153    	FLASH_Lock();		//上锁
;;;154    }
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L4.28|
00001c  f7fffffe          BL       FLASH_Unlock
000020  f1b46f00          CMP      r4,#0x8000000         ;103
000024  d903              BLS      |L4.46|
000026  f3c40009          UBFX     r0,r4,#0,#10          ;105
00002a  eba40800          SUB      r8,r4,r0              ;105
                  |L4.46|
00002e  f3c40548          UBFX     r5,r4,#1,#9           ;109
000032  f5c57900          RSB      r9,r5,#0x200          ;110
000036  e044              B        |L4.194|
                  |L4.56|
000038  45b9              CMP      r9,r7                 ;115
00003a  db01              BLT      |L4.64|
00003c  463e              MOV      r6,r7                 ;117
00003e  e002              B        |L4.70|
                  |L4.64|
000040  f5c57000          RSB      r0,r5,#0x200          ;121
000044  b286              UXTH     r6,r0                 ;121
                  |L4.70|
000046  f44f7200          MOV      r2,#0x200             ;125
00004a  4922              LDR      r1,|L4.212|
00004c  4640              MOV      r0,r8                 ;125
00004e  f7fffffe          BL       STM32_FLASH_Read
000052  f04f0a00          MOV      r10,#0                ;126
000056  e00d              B        |L4.116|
                  |L4.88|
000058  eb05000a          ADD      r0,r5,r10             ;128
00005c  491d              LDR      r1,|L4.212|
00005e  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;128
000062  f64f71ff          MOV      r1,#0xffff            ;128
000066  4288              CMP      r0,r1                 ;128
000068  d000              BEQ      |L4.108|
00006a  e005              B        |L4.120|
                  |L4.108|
00006c  f10a0001          ADD      r0,r10,#1             ;126
000070  fa1ffa80          UXTH     r10,r0                ;126
                  |L4.116|
000074  45b2              CMP      r10,r6                ;126
000076  dbef              BLT      |L4.88|
                  |L4.120|
000078  bf00              NOP                            ;129
00007a  45b2              CMP      r10,r6                ;132
00007c  da10              BGE      |L4.160|
00007e  4640              MOV      r0,r8                 ;136
000080  f7fffffe          BL       FLASH_ErasePage
000084  4913              LDR      r1,|L4.212|
000086  eb010045          ADD      r0,r1,r5,LSL #1       ;138
00008a  4632              MOV      r2,r6                 ;138
00008c  9901              LDR      r1,[sp,#4]            ;138
00008e  f7fffffe          BL       __aeabi_memcpy
000092  19a8              ADDS     r0,r5,r6              ;139
000094  b282              UXTH     r2,r0                 ;139
000096  490f              LDR      r1,|L4.212|
000098  4640              MOV      r0,r8                 ;139
00009a  f7fffffe          BL       STM32_FLASH_Write_NoCheck
00009e  e005              B        |L4.172|
                  |L4.160|
0000a0  eb080005          ADD      r0,r8,r5              ;143
0000a4  4632              MOV      r2,r6                 ;143
0000a6  9901              LDR      r1,[sp,#4]            ;143
0000a8  f7fffffe          BL       STM32_FLASH_Write_NoCheck
                  |L4.172|
0000ac  eb0b0006          ADD      r0,r11,r6             ;146
0000b0  fa1ffb80          UXTH     r11,r0                ;146
0000b4  2500              MOVS     r5,#0                 ;149
0000b6  f5086880          ADD      r8,r8,#0x400          ;150
0000ba  f5097000          ADD      r0,r9,#0x200          ;151
0000be  fa1ff980          UXTH     r9,r0                 ;151
                  |L4.194|
0000c2  45bb              CMP      r11,r7                ;113
0000c4  dbb8              BLT      |L4.56|
0000c6  f7fffffe          BL       FLASH_Lock
0000ca  bf00              NOP      
0000cc  e7a4              B        |L4.24|
;;;155    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L4.208|
                          DCD      0x08020000
                  |L4.212|
                          DCD      STM32_FLASH_BUF

                          AREA ||i.STM32_FLASH_WriteBac||, CODE, READONLY, ALIGN=2

                  STM32_FLASH_WriteBac PROC
;;;155    
;;;156    void STM32_FLASH_WriteBac(u32 StartAddr,u16 *pBuffer,u16 NumToWrite)		//从指定地址写入指定长度的数据
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;157    {
000004  4607              MOV      r7,r0
000006  468b              MOV      r11,r1
000008  4616              MOV      r6,r2
;;;158    	u32 secpos;	   //扇区地址
;;;159    	u16 secoff;	   //扇区内偏移地址(16位字计算)
;;;160    	u16 secremain; //扇区内剩余地址(16位字计算)   
;;;161     	u16 i;    
;;;162    	u32 offaddr;   //去掉0X08000000后的地址
;;;163    	if(StartAddr<STM32_FLASH_BASE||(StartAddr>=(STM32_FLASH_BASE+1024*STM32_FLASH_SIZE)))		//地址不在合法范围内
00000a  f1b76f00          CMP      r7,#0x8000000
00000e  d302              BCC      |L5.22|
000010  4831              LDR      r0,|L5.216|
000012  4287              CMP      r7,r0
000014  d301              BCC      |L5.26|
                  |L5.22|
;;;164    		return;			//非法地址	
;;;165    	
;;;166    	FLASH_Unlock();		//解锁
;;;167    	
;;;168    	offaddr	=	StartAddr	-	STM32_FLASH_BASE;		//实际偏移地址.
;;;169    	secpos	=	offaddr		/	STM_SECTOR_SIZE;		//扇区地址  0~127 for STM32F103RBT6---计算起始扇区地址
;;;170    	//---------------------考虑跨页写情况
;;;171    	secoff	=	(offaddr%STM_SECTOR_SIZE)/2;		//在扇区内的偏移(2个字节为基本单位.)----计算在扇区内的起始地址
;;;172    	//1，不跨页情况	
;;;173    	secremain	=	STM_SECTOR_SIZE/2	-	secoff;		//扇区剩余空间大小
;;;174    	//2，跨页情况
;;;175    	if(NumToWrite	+	secoff	>	STM_SECTOR_SIZE/2)		//跨页
;;;176    	{
;;;177    		//......
;;;178    	}	
;;;179    	
;;;180    	if(NumToWrite<=secremain)			//不跨页
;;;181    		secremain	=	NumToWrite;			//不大于该扇区范围
;;;182    	while(1)
;;;183    	{	
;;;184    		STM32_FLASH_Read(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE,STM32_FLASH_BUF,STM_SECTOR_SIZE/2);	//读出整个扇区的内容
;;;185    		for(i=0;i<secremain;i++)		//校验数据----检查需要写入的存储空间是否为空
;;;186    		{
;;;187    			if(STM32_FLASH_BUF[secoff+i]	!=	0XFFFF)			//检查偏移后的地址是否为空
;;;188    				break;				//需要擦除  	  
;;;189    		}
;;;190    		if(i<secremain)		//需要擦除----注意保存原始不应该擦除的数据
;;;191    		{
;;;192    			FLASH_ErasePage(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE);			//擦除这个扇区
;;;193    //			for(i=0;i<secremain;i++)			//复制---将待写入数据拷贝并且保留偏移前的原始数据
;;;194    //			{
;;;195    //				STM32_FLASH_BUF[i+secoff]=pBuffer[i];		//未跨页+偏移前数据	  
;;;196    //			}
;;;197    			memcpy(&STM32_FLASH_BUF[secoff],pBuffer,secremain);			//复制数据
;;;198    //			STM32_FLASH_Write_NoCheck(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE,STM32_FLASH_BUF,STM_SECTOR_SIZE/2);	//写入整个扇区
;;;199    			STM32_FLASH_Write_NoCheck(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE,STM32_FLASH_BUF,STM_SECTOR_SIZE/2);	//写入整个扇区 
;;;200    		}									//不需要擦除，直接写入数据
;;;201    		else
;;;202    			STM32_FLASH_Write_NoCheck(StartAddr,pBuffer,secremain);				//写已经擦除了的,直接写入扇区剩余区间.
;;;203    		
;;;204    		if(NumToWrite	==	secremain)
;;;205    			break;		//写入结束了
;;;206    		else				//写入未结束
;;;207    		{
;;;208    			secpos			++;				//扇区地址增1
;;;209    			secoff			=	0;			//偏移位置为0 	 
;;;210    			pBuffer			+=	secremain;  	//指针偏移
;;;211    			StartAddr		+=	secremain;		//写地址偏移	   
;;;212    			NumToWrite	-=	secremain;		//字节(16位)数递减
;;;213    			if(NumToWrite	>	(STM_SECTOR_SIZE/2))
;;;214    				secremain	=	STM_SECTOR_SIZE/2;		//下一个扇区还是写不完
;;;215    			else
;;;216    				secremain	=	NumToWrite;						//下一个扇区可以写完了
;;;217    		}	 
;;;218    	};	
;;;219    	FLASH_Lock();		//上锁
;;;220    }
000016  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.26|
00001a  f7fffffe          BL       FLASH_Unlock
00001e  f1a76a00          SUB      r10,r7,#0x8000000     ;168
000022  ea4f259a          LSR      r5,r10,#10            ;169
000026  f3ca0848          UBFX     r8,r10,#1,#9          ;171
00002a  f5c87400          RSB      r4,r8,#0x200          ;173
00002e  42a6              CMP      r6,r4                 ;180
000030  dc00              BGT      |L5.52|
000032  4634              MOV      r4,r6                 ;181
                  |L5.52|
000034  e04a              B        |L5.204|
                  |L5.54|
000036  f04f6100          MOV      r1,#0x8000000         ;184
00003a  eb012085          ADD      r0,r1,r5,LSL #10      ;184
00003e  148a              ASRS     r2,r1,#18             ;184
000040  4926              LDR      r1,|L5.220|
000042  f7fffffe          BL       STM32_FLASH_Read
000046  f04f0900          MOV      r9,#0                 ;185
00004a  e00d              B        |L5.104|
                  |L5.76|
00004c  eb080009          ADD      r0,r8,r9              ;187
000050  4922              LDR      r1,|L5.220|
000052  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;187
000056  f64f71ff          MOV      r1,#0xffff            ;187
00005a  4288              CMP      r0,r1                 ;187
00005c  d000              BEQ      |L5.96|
00005e  e005              B        |L5.108|
                  |L5.96|
000060  f1090001          ADD      r0,r9,#1              ;185
000064  fa1ff980          UXTH     r9,r0                 ;185
                  |L5.104|
000068  45a1              CMP      r9,r4                 ;185
00006a  dbef              BLT      |L5.76|
                  |L5.108|
00006c  bf00              NOP                            ;188
00006e  45a1              CMP      r9,r4                 ;190
000070  da15              BGE      |L5.158|
000072  f04f6100          MOV      r1,#0x8000000         ;192
000076  eb012085          ADD      r0,r1,r5,LSL #10      ;192
00007a  f7fffffe          BL       FLASH_ErasePage
00007e  4917              LDR      r1,|L5.220|
000080  eb010048          ADD      r0,r1,r8,LSL #1       ;197
000084  4622              MOV      r2,r4                 ;197
000086  4659              MOV      r1,r11                ;197
000088  f7fffffe          BL       __aeabi_memcpy
00008c  f04f6100          MOV      r1,#0x8000000         ;199
000090  eb012085          ADD      r0,r1,r5,LSL #10      ;199
000094  148a              ASRS     r2,r1,#18             ;199
000096  4911              LDR      r1,|L5.220|
000098  f7fffffe          BL       STM32_FLASH_Write_NoCheck
00009c  e004              B        |L5.168|
                  |L5.158|
00009e  4622              MOV      r2,r4                 ;202
0000a0  4659              MOV      r1,r11                ;202
0000a2  4638              MOV      r0,r7                 ;202
0000a4  f7fffffe          BL       STM32_FLASH_Write_NoCheck
                  |L5.168|
0000a8  42a6              CMP      r6,r4                 ;204
0000aa  d100              BNE      |L5.174|
0000ac  e00f              B        |L5.206|
                  |L5.174|
0000ae  1c6d              ADDS     r5,r5,#1              ;208
0000b0  f04f0800          MOV      r8,#0                 ;209
0000b4  eb0b0b44          ADD      r11,r11,r4,LSL #1     ;210
0000b8  4427              ADD      r7,r7,r4              ;211
0000ba  1b30              SUBS     r0,r6,r4              ;212
0000bc  b286              UXTH     r6,r0                 ;212
0000be  f5b67f00          CMP      r6,#0x200             ;213
0000c2  dd02              BLE      |L5.202|
0000c4  f44f7400          MOV      r4,#0x200             ;214
0000c8  e000              B        |L5.204|
                  |L5.202|
0000ca  4634              MOV      r4,r6                 ;216
                  |L5.204|
0000cc  e7b3              B        |L5.54|
                  |L5.206|
0000ce  bf00              NOP                            ;205
0000d0  f7fffffe          BL       FLASH_Lock
0000d4  bf00              NOP      
0000d6  e79e              B        |L5.22|
;;;221    /*******************************************************************************
                          ENDP

                  |L5.216|
                          DCD      0x08020000
                  |L5.220|
                          DCD      STM32_FLASH_BUF

                          AREA ||i.STM32_FLASH_Write_NoCheck||, CODE, READONLY, ALIGN=1

                  STM32_FLASH_Write_NoCheck PROC
;;;68     *******************************************************************************/
;;;69     void STM32_FLASH_Write_NoCheck(u32 StartAddr,u16 *pBuffer,u16 NumToWrite) 	//不检查的写入半字数据  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70     { 			 		 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;71     	u16 i;
;;;72     	for(i=0;i<NumToWrite;i++)
00000a  2400              MOVS     r4,#0
00000c  e007              B        |L6.30|
                  |L6.14|
;;;73     	{
;;;74     		FLASH_ProgramHalfWord(StartAddr,pBuffer[i]);		//在指定地址编写半字
00000e  f8361014          LDRH     r1,[r6,r4,LSL #1]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       FLASH_ProgramHalfWord
;;;75     		StartAddr	+=	2;	//地址增加2.
000018  1cad              ADDS     r5,r5,#2
00001a  1c60              ADDS     r0,r4,#1              ;72
00001c  b284              UXTH     r4,r0                 ;72
                  |L6.30|
00001e  42bc              CMP      r4,r7                 ;72
000020  dbf5              BLT      |L6.14|
;;;76     	}  
;;;77     }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;78     /*******************************************************************************
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  STM32_FLASH_BUF
                          %        1024
