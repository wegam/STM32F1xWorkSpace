; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\amp_lay.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\amp_lay.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\amp_lay.crf ..\..\Examples\WOW\AMP_LAY.C]
                          THUMB

                          AREA ||i.AMPLAYCOMM_Configuration||, CODE, READONLY, ALIGN=2

                  AMPLAYCOMM_Configuration PROC
;;;229    *******************************************************************************/
;;;230    void AMPLAYCOMM_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;231    { 
;;;232      //-----------------------------层板接口USART1 PA11-RE,PA12-TE
;;;233      stLayRS485.USARTx  = USART1;
000002  480c              LDR      r0,|L1.52|
000004  490c              LDR      r1,|L1.56|
000006  6008              STR      r0,[r1,#0]  ; stLayRS485
;;;234      stLayRS485.RS485_CTL_PORT  = GPIOA;
000008  480c              LDR      r0,|L1.60|
00000a  6048              STR      r0,[r1,#4]  ; stLayRS485
;;;235      stLayRS485.RS485_CTL_Pin   = GPIO_Pin_12;
00000c  1480              ASRS     r0,r0,#18
00000e  8108              STRH     r0,[r1,#8]
;;;236      RS485_DMA_ConfigurationNR			(&stLayRS485,19200,gDatasize);	//USART_DMA配置--查询方式，不开中断,配置完默认为接收状态
000010  2280              MOVS     r2,#0x80
000012  f44f4196          MOV      r1,#0x4b00
000016  4808              LDR      r0,|L1.56|
000018  f7fffffe          BL       RS485_DMA_ConfigurationNR
;;;237      GPIO_Configuration_OPP50	(GPIOA,GPIO_Pin_11);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00001c  f44f6100          MOV      r1,#0x800
000020  4806              LDR      r0,|L1.60|
000022  f7fffffe          BL       GPIO_Configuration_OPP50
;;;238      GPIO_ResetBits(GPIOA,GPIO_Pin_11);
000026  f44f6100          MOV      r1,#0x800
00002a  4804              LDR      r0,|L1.60|
00002c  f7fffffe          BL       GPIO_ResetBits
;;;239    }
000030  bd10              POP      {r4,pc}
;;;240    /*******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x40013800
                  |L1.56|
                          DCD      stLayRS485
                  |L1.60|
                          DCD      0x40010800

                          AREA ||i.AMPLAYSwitchID_Configuration||, CODE, READONLY, ALIGN=2

                  AMPLAYSwitchID_Configuration PROC
;;;159    *******************************************************************************/
;;;160    void AMPLAYSwitchID_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;161    {
;;;162      stLaySwitch.NumOfSW	=	8;
000002  2008              MOVS     r0,#8
000004  491a              LDR      r1,|L2.112|
000006  f881007e          STRB     r0,[r1,#0x7e]
;;;163      
;;;164      stLaySwitch.SW1_PORT	=	GPIOA;
00000a  481a              LDR      r0,|L2.116|
00000c  6008              STR      r0,[r1,#0]  ; stLaySwitch
;;;165      stLaySwitch.SW1_Pin	=	GPIO_Pin_7;
00000e  2080              MOVS     r0,#0x80
000010  8088              STRH     r0,[r1,#4]
;;;166      
;;;167      stLaySwitch.SW2_PORT	=	GPIOA;
000012  4818              LDR      r0,|L2.116|
000014  6088              STR      r0,[r1,#8]  ; stLaySwitch
;;;168      stLaySwitch.SW2_Pin	=	GPIO_Pin_6;
000016  2040              MOVS     r0,#0x40
000018  8188              STRH     r0,[r1,#0xc]
;;;169      
;;;170      stLaySwitch.SW3_PORT	=	GPIOA;
00001a  4816              LDR      r0,|L2.116|
00001c  6108              STR      r0,[r1,#0x10]  ; stLaySwitch
;;;171      stLaySwitch.SW3_Pin	=	GPIO_Pin_5;
00001e  2020              MOVS     r0,#0x20
000020  8288              STRH     r0,[r1,#0x14]
;;;172      
;;;173      stLaySwitch.SW4_PORT	=	GPIOA;
000022  4814              LDR      r0,|L2.116|
000024  6188              STR      r0,[r1,#0x18]  ; stLaySwitch
;;;174      stLaySwitch.SW4_Pin	=	GPIO_Pin_4;
000026  2010              MOVS     r0,#0x10
000028  8388              STRH     r0,[r1,#0x1c]
;;;175      
;;;176      stLaySwitch.SW5_PORT	=	GPIOB;
00002a  4813              LDR      r0,|L2.120|
00002c  6208              STR      r0,[r1,#0x20]  ; stLaySwitch
;;;177      stLaySwitch.SW5_Pin	=	GPIO_Pin_11;
00002e  14c0              ASRS     r0,r0,#19
000030  8488              STRH     r0,[r1,#0x24]
;;;178      
;;;179      stLaySwitch.SW6_PORT	=	GPIOB;
000032  4811              LDR      r0,|L2.120|
000034  6288              STR      r0,[r1,#0x28]  ; stLaySwitch
;;;180      stLaySwitch.SW6_Pin	=	GPIO_Pin_10;
000036  1500              ASRS     r0,r0,#20
000038  8588              STRH     r0,[r1,#0x2c]
;;;181      
;;;182      stLaySwitch.SW7_PORT	=	GPIOB;
00003a  480f              LDR      r0,|L2.120|
00003c  6308              STR      r0,[r1,#0x30]  ; stLaySwitch
;;;183      stLaySwitch.SW7_Pin	=	GPIO_Pin_2;
00003e  2004              MOVS     r0,#4
000040  8688              STRH     r0,[r1,#0x34]
;;;184      
;;;185      stLaySwitch.SW8_PORT	=	GPIOB;
000042  480d              LDR      r0,|L2.120|
000044  6388              STR      r0,[r1,#0x38]  ; stLaySwitch
;;;186      stLaySwitch.SW8_Pin	=	GPIO_Pin_1;
000046  2002              MOVS     r0,#2
000048  8788              STRH     r0,[r1,#0x3c]
;;;187    
;;;188    	SwitchIdInitialize(&stLaySwitch);						//
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       SwitchIdInitialize
;;;189    
;;;190    
;;;191      LayAddr=(SWITCHID_ReadLeft(&stLaySwitch)>>4)&0X0F;  //层地址
000050  4807              LDR      r0,|L2.112|
000052  f7fffffe          BL       SWITCHID_ReadLeft
000056  f3c01003          UBFX     r0,r0,#4,#4
00005a  4908              LDR      r1,|L2.124|
00005c  7008              STRB     r0,[r1,#0]
;;;192      SegAddr=SWITCHID_ReadLeft(&stLaySwitch)&0x0F;        //位地址
00005e  4804              LDR      r0,|L2.112|
000060  f7fffffe          BL       SWITCHID_ReadLeft
000064  f000000f          AND      r0,r0,#0xf
000068  4905              LDR      r1,|L2.128|
00006a  7008              STRB     r0,[r1,#0]
;;;193    
;;;194    }
00006c  bd10              POP      {r4,pc}
;;;195    /*******************************************************************************
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      stLaySwitch
                  |L2.116|
                          DCD      0x40010800
                  |L2.120|
                          DCD      0x40010c00
                  |L2.124|
                          DCD      LayAddr
                  |L2.128|
                          DCD      SegAddr

                          AREA ||i.AMPLAY_Configuration||, CODE, READONLY, ALIGN=1

                  AMPLAY_Configuration PROC
;;;34     *******************************************************************************/
;;;35     void AMPLAY_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;36     {	
;;;37     	SYS_Configuration();					//系统配置---打开系统时钟 STM32_SYS.H	
000002  f7fffffe          BL       SYS_Configuration
;;;38       
;;;39       AMPLAYSwitchID_Configuration();
000006  f7fffffe          BL       AMPLAYSwitchID_Configuration
;;;40       
;;;41       AMPLAY_GenyConfiguration();   //常规接口配置，背光，锁，电源控制
00000a  f7fffffe          BL       AMPLAY_GenyConfiguration
;;;42         
;;;43       AMPLAYCOMM_Configuration();  
00000e  f7fffffe          BL       AMPLAYCOMM_Configuration
;;;44      
;;;45     //	PWM_OUT(TIM2,PWM_OUTChannel1,1000,950);	  //PWM设定-20161127版本  
;;;46     //  IWDG_Configuration(1000);								  //独立看门狗配置---参数单位ms
;;;47     //  SysTick_Configuration(1000);              //系统嘀嗒时钟配置72MHz,单位为uS
;;;48     }
000012  bd10              POP      {r4,pc}
;;;49     /*******************************************************************************
                          ENDP


                          AREA ||i.AMPLAY_GenyConfiguration||, CODE, READONLY, ALIGN=2

                  AMPLAY_GenyConfiguration PROC
;;;203    *******************************************************************************/
;;;204    void AMPLAY_GenyConfiguration(void)
000000  b508              PUSH     {r3,lr}
;;;205    {
;;;206      //--------------------------已拨码
;;;207      if(LayAddr&&SegAddr)  
000002  481f              LDR      r0,|L4.128|
000004  7800              LDRB     r0,[r0,#0]  ; LayAddr
000006  b1f0              CBZ      r0,|L4.70|
000008  481e              LDR      r0,|L4.132|
00000a  7800              LDRB     r0,[r0,#0]  ; SegAddr
00000c  b1d8              CBZ      r0,|L4.70|
;;;208      {
;;;209        PWM_OUT(TIM2,PWM_OUTChannel2,1000,1000);						//PWM设定-20161127版本---红色
00000e  f44f707a          MOV      r0,#0x3e8
000012  2200              MOVS     r2,#0
000014  4b1c              LDR      r3,|L4.136|
000016  2101              MOVS     r1,#1
000018  9000              STR      r0,[sp,#0]
00001a  06c0              LSLS     r0,r0,#27
00001c  f7fffffe          BL       PWM_OUT
;;;210        PWM_OUT(TIM2,PWM_OUTChannel4,1000,1000);						//PWM设定-20161127版本---黄色
000020  f44f707a          MOV      r0,#0x3e8
000024  2200              MOVS     r2,#0
000026  4b18              LDR      r3,|L4.136|
000028  2103              MOVS     r1,#3
00002a  9000              STR      r0,[sp,#0]
00002c  06c0              LSLS     r0,r0,#27
00002e  f7fffffe          BL       PWM_OUT
;;;211        PWM_OUT(TIM2,PWM_OUTChannel3,1000,1000);						//PWM设定-20161127版本---蓝色
000032  f44f707a          MOV      r0,#0x3e8
000036  2200              MOVS     r2,#0
000038  4b13              LDR      r3,|L4.136|
00003a  2102              MOVS     r1,#2
00003c  9000              STR      r0,[sp,#0]
00003e  06c0              LSLS     r0,r0,#27
000040  f7fffffe          BL       PWM_OUT
000044  e01a              B        |L4.124|
                  |L4.70|
;;;212      }
;;;213      //--------------------------未拨码
;;;214      else
;;;215      {
;;;216        PWM_OUT(TIM2,PWM_OUTChannel2,2,900);						//PWM设定-20161127版本---红色
000046  f44f7061          MOV      r0,#0x384
00004a  2200              MOVS     r2,#0
00004c  0703              LSLS     r3,r0,#28
00004e  2101              MOVS     r1,#1
000050  9000              STR      r0,[sp,#0]
000052  4618              MOV      r0,r3
000054  f7fffffe          BL       PWM_OUT
;;;217        PWM_OUT(TIM2,PWM_OUTChannel4,2,600);						//PWM设定-20161127版本---黄色
000058  f44f7016          MOV      r0,#0x258
00005c  2200              MOVS     r2,#0
00005e  f04f4380          MOV      r3,#0x40000000
000062  2103              MOVS     r1,#3
000064  9000              STR      r0,[sp,#0]
000066  4618              MOV      r0,r3
000068  f7fffffe          BL       PWM_OUT
;;;218        PWM_OUT(TIM2,PWM_OUTChannel3,2,200);						//PWM设定-20161127版本---蓝色
00006c  20c8              MOVS     r0,#0xc8
00006e  2200              MOVS     r2,#0
000070  06c3              LSLS     r3,r0,#27
000072  2102              MOVS     r1,#2
000074  9000              STR      r0,[sp,#0]
000076  4618              MOV      r0,r3
000078  f7fffffe          BL       PWM_OUT
                  |L4.124|
;;;219      }
;;;220    }
00007c  bd08              POP      {r3,pc}
;;;221    /*******************************************************************************
                          ENDP

00007e  0000              DCW      0x0000
                  |L4.128|
                          DCD      LayAddr
                  |L4.132|
                          DCD      SegAddr
                  |L4.136|
                          DCD      0x408f4000

                          AREA ||i.AMPLAY_Loop||, CODE, READONLY, ALIGN=2

                  AMPLAY_Loop PROC
;;;71     *******************************************************************************/
;;;72     void AMPLAY_Loop(void)
000000  b510              PUSH     {r4,lr}
;;;73     {  
;;;74       AMPLAY_Receive();
000002  f7fffffe          BL       AMPLAY_Receive
;;;75       //----------------层发送
;;;76       if(0  ==  AMPPro.Time.LaySendTime)
000006  4803              LDR      r0,|L5.20|
000008  8980              LDRH     r0,[r0,#0xc]  ; AMPPro
00000a  b910              CBNZ     r0,|L5.18|
;;;77       {
;;;78         Check_SendBuff(LayPort);
00000c  2003              MOVS     r0,#3
00000e  f7fffffe          BL       Check_SendBuff
                  |L5.18|
;;;79       }
;;;80     }
000012  bd10              POP      {r4,pc}
;;;81     //=================================硬件接口ST==============================================================
                          ENDP

                  |L5.20|
                          DCD      AMPPro

                          AREA ||i.AMPLAY_Receive||, CODE, READONLY, ALIGN=2

                  AMPLAY_Receive PROC
;;;90     *******************************************************************************/
;;;91     void AMPLAY_Receive(void)
000000  b510              PUSH     {r4,lr}
;;;92     {
000002  b0c0              SUB      sp,sp,#0x100
;;;93       unsigned short RxNum  = 0;
000004  2400              MOVS     r4,#0
;;;94       unsigned char rxd[256]={0};
000006  f44f7180          MOV      r1,#0x100
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memclr4
;;;95       //==========================================================接收查询
;;;96       //---------------------层板接口 USART2
;;;97       RxNum = RS485_ReadBufferIDLE(&stLayRS485,rxd);
000010  4669              MOV      r1,sp
000012  4806              LDR      r0,|L6.44|
000014  f7fffffe          BL       RS485_ReadBufferIDLE
000018  4604              MOV      r4,r0
;;;98       if(RxNum)
00001a  b124              CBZ      r4,|L6.38|
;;;99       {
;;;100        Msg_ProcessLY(LayPort,rxd,RxNum);              //柜消息处理
00001c  4622              MOV      r2,r4
00001e  4669              MOV      r1,sp
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       Msg_ProcessLY
                  |L6.38|
;;;101      }
;;;102      
;;;103    }
000026  b040              ADD      sp,sp,#0x100
000028  bd10              POP      {r4,pc}
;;;104    /*******************************************************************************
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      stLayRS485

                          AREA ||i.AMPLAY_SYSLED||, CODE, READONLY, ALIGN=2

                  AMPLAY_SYSLED PROC
;;;135    *******************************************************************************/
;;;136    void AMPLAY_SYSLED(void)
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138      if(0==AMPPro.Time.SYSLEDTime)
000002  480b              LDR      r0,|L7.48|
000004  8880              LDRH     r0,[r0,#4]  ; AMPPro
000006  b988              CBNZ     r0,|L7.44|
;;;139      {    
;;;140        GPIO_Toggle	(SYSLEDPort,SYSLEDPin);		//将GPIO相应管脚输出翻转----V20170605
000008  2101              MOVS     r1,#1
00000a  480a              LDR      r0,|L7.52|
00000c  f7fffffe          BL       GPIO_Toggle
;;;141        if(LayAddr&SegAddr)   //已拨码，频率1Hz
000010  4809              LDR      r0,|L7.56|
000012  7800              LDRB     r0,[r0,#0]  ; LayAddr
000014  4909              LDR      r1,|L7.60|
000016  7809              LDRB     r1,[r1,#0]  ; SegAddr
000018  4008              ANDS     r0,r0,r1
00001a  b120              CBZ      r0,|L7.38|
;;;142        {
;;;143          AMPPro.Time.SYSLEDTime=500;
00001c  f44f70fa          MOV      r0,#0x1f4
000020  4903              LDR      r1,|L7.48|
000022  8088              STRH     r0,[r1,#4]
000024  e002              B        |L7.44|
                  |L7.38|
;;;144        }
;;;145        else          //未拨码，频率5Hz
;;;146        {
;;;147          AMPPro.Time.SYSLEDTime=100;
000026  2064              MOVS     r0,#0x64
000028  4901              LDR      r1,|L7.48|
00002a  8088              STRH     r0,[r1,#4]
                  |L7.44|
;;;148        }
;;;149      }
;;;150    }
00002c  bd10              POP      {r4,pc}
;;;151    /*******************************************************************************
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      AMPPro
                  |L7.52|
                          DCD      0x40010800
                  |L7.56|
                          DCD      LayAddr
                  |L7.60|
                          DCD      SegAddr

                          AREA ||i.AMPLAY_Send||, CODE, READONLY, ALIGN=1

                  AMPLAY_Send PROC
;;;345    *******************************************************************************/
;;;346    unsigned short AMPLAY_Send(unsigned char* pBuffer,unsigned short length)
000000  b570              PUSH     {r4-r6,lr}
;;;347    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;348      return(AddSendBuffer(LayPort,pBuffer,length));
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2003              MOVS     r0,#3
00000c  f7fffffe          BL       AddSendBuffer
;;;349    }
000010  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP


                          AREA ||i.AMPLAY_SendBuff||, CODE, READONLY, ALIGN=2

                  AMPLAY_SendBuff PROC
;;;330    *******************************************************************************/
;;;331    unsigned short AMPLAY_SendBuff(enCCPortDef Port,unsigned char* pBuffer,unsigned short length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;332    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;333      unsigned  short   sendedlen = 0;
00000a  2600              MOVS     r6,#0
;;;334      sendedlen = RS485_DMASend(&stLayRS485,pBuffer,length);	//RS485-DMA发送程序
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  4803              LDR      r0,|L9.32|
000012  f7fffffe          BL       RS485_DMASend
000016  4606              MOV      r6,r0
;;;335      return  sendedlen;
000018  4630              MOV      r0,r6
;;;336    }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;337    /*******************************************************************************
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      stLayRS485

                          AREA ||i.AMPLAY_Server||, CODE, READONLY, ALIGN=1

                  AMPLAY_Server PROC
;;;57     *******************************************************************************/
;;;58     void AMPLAY_Server(void)
000000  b510              PUSH     {r4,lr}
;;;59     {  
;;;60       AMPLAY_SwitchIDServer();
000002  f7fffffe          BL       AMPLAY_SwitchIDServer
;;;61       AMPLAY_SYSLED();
000006  f7fffffe          BL       AMPLAY_SYSLED
;;;62     }
00000a  bd10              POP      {r4,pc}
;;;63     /*******************************************************************************
                          ENDP


                          AREA ||i.AMPLAY_SwitchIDServer||, CODE, READONLY, ALIGN=2

                  AMPLAY_SwitchIDServer PROC
;;;112    *******************************************************************************/
;;;113    void AMPLAY_SwitchIDServer(void)
000000  b570              PUSH     {r4-r6,lr}
;;;114    {
;;;115      unsigned char Lbac=LayAddr,Sbac=SegAddr;
000002  4813              LDR      r0,|L11.80|
000004  7804              LDRB     r4,[r0,#0]  ; LayAddr
000006  4813              LDR      r0,|L11.84|
000008  7805              LDRB     r5,[r0,#0]  ; SegAddr
;;;116      if(0==AMPPro.Time.swicthidtime)
00000a  4813              LDR      r0,|L11.88|
00000c  8840              LDRH     r0,[r0,#2]  ; AMPPro
00000e  b9e8              CBNZ     r0,|L11.76|
;;;117      {
;;;118        LayAddr = SWITCHID_ReadLeft(&stLaySwitch);
000010  4812              LDR      r0,|L11.92|
000012  f7fffffe          BL       SWITCHID_ReadLeft
000016  490e              LDR      r1,|L11.80|
000018  7008              STRB     r0,[r1,#0]
;;;119        SegAddr = LayAddr;
00001a  4608              MOV      r0,r1
00001c  7800              LDRB     r0,[r0,#0]  ; LayAddr
00001e  490d              LDR      r1,|L11.84|
000020  7008              STRB     r0,[r1,#0]
;;;120        LayAddr =(LayAddr>>4)&0x0F;
000022  480b              LDR      r0,|L11.80|
000024  7800              LDRB     r0,[r0,#0]  ; LayAddr
000026  0900              LSRS     r0,r0,#4
000028  4909              LDR      r1,|L11.80|
00002a  7008              STRB     r0,[r1,#0]
;;;121        SegAddr = SegAddr&0x0F;
00002c  4809              LDR      r0,|L11.84|
00002e  7800              LDRB     r0,[r0,#0]  ; SegAddr
000030  f000000f          AND      r0,r0,#0xf
000034  4907              LDR      r1,|L11.84|
000036  7008              STRB     r0,[r1,#0]
;;;122        
;;;123        if((Lbac!=LayAddr)||(Sbac!=SegAddr))
000038  4805              LDR      r0,|L11.80|
00003a  7800              LDRB     r0,[r0,#0]  ; LayAddr
00003c  4284              CMP      r4,r0
00003e  d103              BNE      |L11.72|
000040  4608              MOV      r0,r1
000042  7800              LDRB     r0,[r0,#0]  ; SegAddr
000044  4285              CMP      r5,r0
000046  d001              BEQ      |L11.76|
                  |L11.72|
;;;124          AMPLAY_GenyConfiguration();
000048  f7fffffe          BL       AMPLAY_GenyConfiguration
                  |L11.76|
;;;125      }
;;;126    }
00004c  bd70              POP      {r4-r6,pc}
;;;127    /*******************************************************************************
                          ENDP

00004e  0000              DCW      0x0000
                  |L11.80|
                          DCD      LayAddr
                  |L11.84|
                          DCD      SegAddr
                  |L11.88|
                          DCD      AMPPro
                  |L11.92|
                          DCD      stLaySwitch

                          AREA ||i.Msg_ProcessLY||, CODE, READONLY, ALIGN=2

                  Msg_ProcessLY PROC
;;;248    *******************************************************************************/
;;;249    void Msg_ProcessLY(enCCPortDef Port,unsigned char* pBuffer,unsigned short length)
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;250    {  
000004  b081              SUB      sp,sp,#4
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;251      unsigned  char result       = 0; 
00000a  2700              MOVS     r7,#0
;;;252      //unsigned  char address      = 0;  
;;;253      unsigned  short framlength  = 0; 
00000c  46b8              MOV      r8,r7
;;;254      unsigned  char  Cmd         = 0;  
00000e  46b9              MOV      r9,r7
;;;255      unsigned  char* paddrbac    = pBuffer;         //备份数据缓存起始地址
000010  46a2              MOV      r10,r4
;;;256      
;;;257      stampphydef* ampframe=NULL;
000012  2500              MOVS     r5,#0
;;;258      //-------------------------检查端口是否为层接口及缓存地址是否为空
;;;259      if(LayPort!=Port||NULL==pBuffer)
000014  2e03              CMP      r6,#3
000016  d100              BNE      |L12.26|
000018  b90c              CBNZ     r4,|L12.30|
                  |L12.26|
;;;260      {
;;;261        return;
;;;262      }
;;;263      //-------------------------协议检查
;;;264      framlength	=	getframe(pBuffer,&length);    //判断帧消息内容是否符合协议
;;;265      if(0== framlength)
;;;266      {
;;;267        memset(paddrbac,0x00,gDatasize);             //清除数据
;;;268        return;
;;;269      }
;;;270      //-------------------------检查是否为应答帧
;;;271      result  = ackcheck(pBuffer);                //检查是否为应答消息,应答消息返回1
;;;272      if(1==result)
;;;273      {
;;;274        if(AMPPro.buffer.WaitAck.Lay)
;;;275        {
;;;276          AMPPro.buffer.WaitAck.Lay=0;
;;;277          Releas_OneBuffer(LayPort);        //释放一个发送缓存
;;;278        }
;;;279        return;
;;;280      }
;;;281      //-------------------------地址检查
;;;282    
;;;283      if(0==addr2check(pBuffer,LayAddr))
;;;284        return;
;;;285      if(0==addr3check(pBuffer,SegAddr))
;;;286        return;
;;;287    
;;;288      
;;;289      //-------------------------根据地址转发数据：广播数据发送到副柜和本柜层板
;;;290      ampframe  = (stampphydef*)pBuffer;
;;;291      Cmd = ampframe->msg.cmd.cmd;
;;;292      
;;;293      //-------------------------下发数据
;;;294      if(0  ==  ampframe->msg.cmd.dir)
;;;295      {
;;;296        //CMD_Process((unsigned char*)ampframe,framlength);
;;;297        ackFrame(LayPort,1); //向上应答
;;;298        //---------------------------开背光灯命令
;;;299        if(AmpCmdLed ==  Cmd) //最高位为0表示上往下发
;;;300        {
;;;301          if(LayAddr&&SegAddr)
;;;302          {
;;;303            PWM_OUT(TIM2,PWM_OUTChannel2,2,1000);						//PWM设定-20161127版本---红色
;;;304            PWM_OUT(TIM2,PWM_OUTChannel4,2,1000);						//PWM设定-20161127版本---黄色
;;;305            PWM_OUT(TIM2,PWM_OUTChannel3,2,1000);						//PWM设定-20161127版本---蓝色
;;;306            
;;;307            if(ampframe->msg.data[0]) //红灯
;;;308              PWM_OUT(TIM2,PWM_OUTChannel2,2,500);						//PWM设定-20161127版本---红色
;;;309            if(ampframe->msg.data[1]) //黄色
;;;310              PWM_OUT(TIM2,PWM_OUTChannel4,2,500);						//PWM设定-20161127版本---黄色
;;;311            if(ampframe->msg.data[2]) //蓝色
;;;312              PWM_OUT(TIM2,PWM_OUTChannel3,2,500);						//PWM设定-20161127版本---蓝色
;;;313          }
;;;314        }
;;;315      }
;;;316      //-------------------------上传数据
;;;317      else
;;;318      {    
;;;319        return;   //层板端口只接收下发数据，如有上发数据，则为其它层上传，其它层板不处理
;;;320      }
;;;321    }
00001a  e8bd87ff          POP      {r0-r10,pc}
                  |L12.30|
00001e  a903              ADD      r1,sp,#0xc            ;264
000020  4620              MOV      r0,r4                 ;264
000022  f7fffffe          BL       getframe
000026  4680              MOV      r8,r0                 ;264
000028  f1b80f00          CMP      r8,#0                 ;265
00002c  d104              BNE      |L12.56|
00002e  2180              MOVS     r1,#0x80              ;267
000030  4650              MOV      r0,r10                ;267
000032  f7fffffe          BL       __aeabi_memclr
000036  e7f0              B        |L12.26|
                  |L12.56|
000038  4620              MOV      r0,r4                 ;271
00003a  f7fffffe          BL       ackcheck
00003e  4607              MOV      r7,r0                 ;271
000040  2f01              CMP      r7,#1                 ;272
000042  d10e              BNE      |L12.98|
000044  4839              LDR      r0,|L12.300|
000046  7dc0              LDRB     r0,[r0,#0x17]         ;274  ; AMPPro
000048  f3c00080          UBFX     r0,r0,#2,#1           ;274
00004c  b140              CBZ      r0,|L12.96|
00004e  4837              LDR      r0,|L12.300|
000050  7dc0              LDRB     r0,[r0,#0x17]         ;276  ; AMPPro
000052  f0200004          BIC      r0,r0,#4              ;276
000056  4935              LDR      r1,|L12.300|
000058  75c8              STRB     r0,[r1,#0x17]         ;276
00005a  2003              MOVS     r0,#3                 ;277
00005c  f7fffffe          BL       Releas_OneBuffer
                  |L12.96|
000060  e7db              B        |L12.26|
                  |L12.98|
000062  4833              LDR      r0,|L12.304|
000064  7801              LDRB     r1,[r0,#0]            ;283  ; LayAddr
000066  4620              MOV      r0,r4                 ;283
000068  f7fffffe          BL       addr2check
00006c  b900              CBNZ     r0,|L12.112|
00006e  e7d4              B        |L12.26|
                  |L12.112|
000070  4830              LDR      r0,|L12.308|
000072  7801              LDRB     r1,[r0,#0]            ;285  ; SegAddr
000074  4620              MOV      r0,r4                 ;285
000076  f7fffffe          BL       addr3check
00007a  b900              CBNZ     r0,|L12.126|
00007c  e7cd              B        |L12.26|
                  |L12.126|
00007e  4625              MOV      r5,r4                 ;290
000080  78a8              LDRB     r0,[r5,#2]            ;291
000082  f000093f          AND      r9,r0,#0x3f           ;291
000086  78a8              LDRB     r0,[r5,#2]            ;294
000088  09c0              LSRS     r0,r0,#7              ;294
00008a  2800              CMP      r0,#0                 ;294
00008c  d14b              BNE      |L12.294|
00008e  2101              MOVS     r1,#1                 ;297
000090  2003              MOVS     r0,#3                 ;297
000092  f7fffffe          BL       ackFrame
000096  f1b90f02          CMP      r9,#2                 ;299
00009a  d145              BNE      |L12.296|
00009c  4824              LDR      r0,|L12.304|
00009e  7800              LDRB     r0,[r0,#0]            ;301  ; LayAddr
0000a0  b3e8              CBZ      r0,|L12.286|
0000a2  4824              LDR      r0,|L12.308|
0000a4  7800              LDRB     r0,[r0,#0]            ;301  ; SegAddr
0000a6  b3d0              CBZ      r0,|L12.286|
0000a8  f44f707a          MOV      r0,#0x3e8             ;303
0000ac  2200              MOVS     r2,#0                 ;303
0000ae  06c3              LSLS     r3,r0,#27             ;303
0000b0  2101              MOVS     r1,#1                 ;303
0000b2  9000              STR      r0,[sp,#0]            ;303
0000b4  4618              MOV      r0,r3                 ;303
0000b6  f7fffffe          BL       PWM_OUT
0000ba  f44f707a          MOV      r0,#0x3e8             ;304
0000be  2200              MOVS     r2,#0                 ;304
0000c0  06c3              LSLS     r3,r0,#27             ;304
0000c2  2103              MOVS     r1,#3                 ;304
0000c4  9000              STR      r0,[sp,#0]            ;304
0000c6  4618              MOV      r0,r3                 ;304
0000c8  f7fffffe          BL       PWM_OUT
0000cc  f44f707a          MOV      r0,#0x3e8             ;305
0000d0  2200              MOVS     r2,#0                 ;305
0000d2  06c3              LSLS     r3,r0,#27             ;305
0000d4  2102              MOVS     r1,#2                 ;305
0000d6  9000              STR      r0,[sp,#0]            ;305
0000d8  4618              MOV      r0,r3                 ;305
0000da  f7fffffe          BL       PWM_OUT
0000de  79a8              LDRB     r0,[r5,#6]            ;307
0000e0  b140              CBZ      r0,|L12.244|
0000e2  f44f70fa          MOV      r0,#0x1f4             ;308
0000e6  2200              MOVS     r2,#0                 ;308
0000e8  0703              LSLS     r3,r0,#28             ;308
0000ea  2101              MOVS     r1,#1                 ;308
0000ec  9000              STR      r0,[sp,#0]            ;308
0000ee  4618              MOV      r0,r3                 ;308
0000f0  f7fffffe          BL       PWM_OUT
                  |L12.244|
0000f4  79e8              LDRB     r0,[r5,#7]            ;309
0000f6  b140              CBZ      r0,|L12.266|
0000f8  f44f70fa          MOV      r0,#0x1f4             ;310
0000fc  2200              MOVS     r2,#0                 ;310
0000fe  0703              LSLS     r3,r0,#28             ;310
000100  2103              MOVS     r1,#3                 ;310
000102  9000              STR      r0,[sp,#0]            ;310
000104  4618              MOV      r0,r3                 ;310
000106  f7fffffe          BL       PWM_OUT
                  |L12.266|
00010a  7a28              LDRB     r0,[r5,#8]            ;311
00010c  b138              CBZ      r0,|L12.286|
00010e  f44f70fa          MOV      r0,#0x1f4             ;312
000112  2200              MOVS     r2,#0                 ;312
000114  0703              LSLS     r3,r0,#28             ;312
000116  2102              MOVS     r1,#2                 ;312
000118  9000              STR      r0,[sp,#0]            ;312
00011a  4618              MOV      r0,r3                 ;312
00011c  e000              B        |L12.288|
                  |L12.286|
00011e  e003              B        |L12.296|
                  |L12.288|
000120  f7fffffe          BL       PWM_OUT
000124  e000              B        |L12.296|
                  |L12.294|
000126  e778              B        |L12.26|
                  |L12.296|
000128  bf00              NOP      
00012a  e776              B        |L12.26|
;;;322    /*******************************************************************************
                          ENDP

                  |L12.300|
                          DCD      AMPPro
                  |L12.304|
                          DCD      LayAddr
                  |L12.308|
                          DCD      SegAddr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  stLayRS485
                          %        12
                  stLaySwitch
                          %        132

                          AREA ||.data||, DATA, ALIGN=0

                  LayAddr
000000  00                DCB      0x00
                  SegAddr
000001  00                DCB      0x00
