; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\ds2401.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\ds2401.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\ds2401.crf ..\..\Driver\Components\SCR\DS2401.c]
                          THUMB

                          AREA ||i.CRC8_Calculate||, CODE, READONLY, ALIGN=2

                  CRC8_Calculate PROC
;;;52     //查表计算方法
;;;53     uint8_t CRC8_Calculate(uint8_t *pBuf, uint8_t len)
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  4602              MOV      r2,r0
;;;55     	uint8_t crc8=0;	//CRC8字节初始化
000004  2000              MOVS     r0,#0
;;;56     	
;;;57     	//进行CRC8位校验
;;;58     	while(len)
000006  e006              B        |L1.22|
                  |L1.8|
;;;59     	{
;;;60     		crc8 = g_CRC8Tab[*pBuf^crc8];
000008  7813              LDRB     r3,[r2,#0]
00000a  4043              EORS     r3,r3,r0
00000c  4c03              LDR      r4,|L1.28|
00000e  5ce0              LDRB     r0,[r4,r3]
;;;61     		pBuf++;
000010  1c52              ADDS     r2,r2,#1
;;;62     		len--;
000012  1e4b              SUBS     r3,r1,#1
000014  b2d9              UXTB     r1,r3
                  |L1.22|
000016  2900              CMP      r1,#0                 ;58
000018  d1f6              BNE      |L1.8|
;;;63     	}
;;;64     
;;;65     	return(crc8);	//返回CRC8校验数据
;;;66     }  
00001a  bd10              POP      {r4,pc}
;;;67     /*******************************************************************************
                          ENDP

                  |L1.28|
                          DCD      g_CRC8Tab

                          AREA ||i.DS2401_Configuration||, CODE, READONLY, ALIGN=2

                  DS2401_Configuration PROC
;;;72     *******************************************************************************/
;;;73     void DS2401_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;74     {
;;;75     	GPIO_Configuration_OPP50	(Port_Dallas,	Pin_Dallas);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000002  f44f4180          MOV      r1,#0x4000
000006  4802              LDR      r0,|L2.16|
000008  f7fffffe          BL       GPIO_Configuration_OPP50
;;;76     }
00000c  bd10              POP      {r4,pc}
;;;77     /*******************************************************************************
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40010c00

                          AREA ||i.Dallas_GetID||, CODE, READONLY, ALIGN=1

                  Dallas_GetID PROC
;;;249    *******************************************************************************/
;;;250    uint8_t Dallas_GetID(uint8_t *pBuf)
000000  b57c              PUSH     {r2-r6,lr}
;;;251    {
000002  4605              MOV      r5,r0
;;;252    	uint8_t i;
;;;253    	uint8_t buf[8];
;;;254    
;;;255    	Dallas_Rest();						//复位总线
000004  f7fffffe          BL       Dallas_Rest
;;;256    
;;;257    	Dallas_WriteByte(0x33);		//read romid
000008  2033              MOVS     r0,#0x33
00000a  f7fffffe          BL       Dallas_WriteByte
;;;258    	for(i=0; i<8; i++)
00000e  2400              MOVS     r4,#0
000010  e005              B        |L3.30|
                  |L3.18|
;;;259    		buf[i] = Dallas_ReadByte();
000012  f7fffffe          BL       Dallas_ReadByte
000016  f80d0004          STRB     r0,[sp,r4]
00001a  1c60              ADDS     r0,r4,#1              ;258
00001c  b2c4              UXTB     r4,r0                 ;258
                  |L3.30|
00001e  2c08              CMP      r4,#8                 ;258
000020  dbf7              BLT      |L3.18|
;;;260    	
;;;261    	if(buf[0] != 0x01)
000022  f89d0000          LDRB     r0,[sp,#0]
000026  2801              CMP      r0,#1
000028  d001              BEQ      |L3.46|
;;;262    		return 1;
00002a  2001              MOVS     r0,#1
                  |L3.44|
;;;263    	if(CRC8_Calculate(buf, 7) != buf[7])
;;;264    		return 1;
;;;265    
;;;266    	for(i=0; i<8; i++)
;;;267    		pBuf[i] = buf[i];
;;;268    	
;;;269    	return 0;
;;;270    }
00002c  bd7c              POP      {r2-r6,pc}
                  |L3.46|
00002e  2107              MOVS     r1,#7                 ;263
000030  4668              MOV      r0,sp                 ;263
000032  f7fffffe          BL       CRC8_Calculate
000036  f89d1007          LDRB     r1,[sp,#7]            ;263
00003a  4288              CMP      r0,r1                 ;263
00003c  d001              BEQ      |L3.66|
00003e  2001              MOVS     r0,#1                 ;264
000040  e7f4              B        |L3.44|
                  |L3.66|
000042  2400              MOVS     r4,#0                 ;266
000044  e004              B        |L3.80|
                  |L3.70|
000046  f81d0004          LDRB     r0,[sp,r4]            ;267
00004a  5528              STRB     r0,[r5,r4]            ;267
00004c  1c60              ADDS     r0,r4,#1              ;266
00004e  b2c4              UXTB     r4,r0                 ;266
                  |L3.80|
000050  2c08              CMP      r4,#8                 ;266
000052  dbf8              BLT      |L3.70|
000054  2000              MOVS     r0,#0                 ;269
000056  e7e9              B        |L3.44|
;;;271    
                          ENDP


                          AREA ||i.Dallas_Init||, CODE, READONLY, ALIGN=2

                  Dallas_Init PROC
;;;231    *******************************************************************************/
;;;232    uint8_t Dallas_Init(void)
000000  b510              PUSH     {r4,lr}
;;;233    {
;;;234    	uint8_t Result	=	0;
000002  2400              MOVS     r4,#0
;;;235    	GPIO_Configuration_OPP50	(Port_Dallas,	Pin_Dallas);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000004  f44f4180          MOV      r1,#0x4000
000008  4802              LDR      r0,|L4.20|
00000a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;236    
;;;237    //	Result	=	Dallas_Rest();
;;;238    
;;;239    	return Result;
00000e  4620              MOV      r0,r4
;;;240    }
000010  bd10              POP      {r4,pc}
;;;241    /*******************************************************************************
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40010c00

                          AREA ||i.Dallas_ReadBit||, CODE, READONLY, ALIGN=2

                  Dallas_ReadBit PROC
;;;126    *******************************************************************************/
;;;127    uint8_t Dallas_ReadBit(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	uint8_t data;
;;;130    	
;;;131    	Dallas_SetOut;				//设为输出模式
000002  f44f4180          MOV      r1,#0x4000
000006  4810              LDR      r0,|L5.72|
000008  f7fffffe          BL       GPIO_Configuration_OPP50
;;;132    	Dallas_L; 						//拉低总线
00000c  f44f4080          MOV      r0,#0x4000
000010  490d              LDR      r1,|L5.72|
000012  3114              ADDS     r1,r1,#0x14
000014  6008              STR      r0,[r1,#0]
;;;133    	SysTick_DeleyuS(5);		//至少1us时间
000016  2005              MOVS     r0,#5
000018  f7fffffe          BL       SysTick_DeleyuS
;;;134    //	Dallas_H; 						//释放总线
;;;135    	Dallas_SetIn;					//设置为输入模式
00001c  f44f4180          MOV      r1,#0x4000
000020  4809              LDR      r0,|L5.72|
000022  f7fffffe          BL       GPIO_Configuration_IPU
;;;136    	SysTick_DeleyuS(12);	//等待从机响应
000026  200c              MOVS     r0,#0xc
000028  f7fffffe          BL       SysTick_DeleyuS
;;;137    	if(Dallas_Read)				//读取总线状态
00002c  4806              LDR      r0,|L5.72|
00002e  3008              ADDS     r0,r0,#8
000030  6800              LDR      r0,[r0,#0]
000032  f4004080          AND      r0,r0,#0x4000
000036  b108              CBZ      r0,|L5.60|
;;;138    		data = 1;
000038  2401              MOVS     r4,#1
00003a  e000              B        |L5.62|
                  |L5.60|
;;;139    	else
;;;140    		data = 0;	 
00003c  2400              MOVS     r4,#0
                  |L5.62|
;;;141    	SysTick_DeleyuS(50);
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       SysTick_DeleyuS
;;;142    	
;;;143    	return data;
000044  4620              MOV      r0,r4
;;;144    }
000046  bd10              POP      {r4,pc}
;;;145    /*******************************************************************************
                          ENDP

                  |L5.72|
                          DCD      0x40010c00

                          AREA ||i.Dallas_ReadByte||, CODE, READONLY, ALIGN=1

                  Dallas_ReadByte PROC
;;;153    *******************************************************************************/
;;;154    uint8_t Dallas_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;155    {        
;;;156    	uint8_t i,j,dat;
;;;157    	
;;;158    	dat = 0;
000002  2600              MOVS     r6,#0
;;;159    	for (i=1; i<=8; i++)
000004  2501              MOVS     r5,#1
000006  e008              B        |L6.26|
                  |L6.8|
;;;160    	{
;;;161    		j = Dallas_ReadBit();		//读取一位数据
000008  f7fffffe          BL       Dallas_ReadBit
00000c  4604              MOV      r4,r0
;;;162    		dat = (j<<7)|(dat>>1);	//从低位开始保存数据
00000e  01e0              LSLS     r0,r4,#7
000010  ea400066          ORR      r0,r0,r6,ASR #1
000014  b2c6              UXTB     r6,r0
000016  1c68              ADDS     r0,r5,#1              ;159
000018  b2c5              UXTB     r5,r0                 ;159
                  |L6.26|
00001a  2d08              CMP      r5,#8                 ;159
00001c  ddf4              BLE      |L6.8|
;;;163    	}	
;;;164    	return dat;
00001e  4630              MOV      r0,r6
;;;165    }
000020  bd70              POP      {r4-r6,pc}
;;;166    /*******************************************************************************
                          ENDP


                          AREA ||i.Dallas_Rest||, CODE, READONLY, ALIGN=2

                  Dallas_Rest PROC
;;;83     *******************************************************************************/
;;;84     uint8_t Dallas_Rest(void)		//复位Dallas,返回结果
000000  b510              PUSH     {r4,lr}
;;;85     {
;;;86     	uint16_t retry=0;
000002  2400              MOVS     r4,#0
;;;87     	//----------------------复位时间：拉低信号大于480us
;;;88     	Dallas_SetOut;					//SET PG11 OUTPUT
000004  f44f4180          MOV      r1,#0x4000
000008  4815              LDR      r0,|L7.96|
00000a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;89     	Dallas_L;								//拉低DQ
00000e  f44f4080          MOV      r0,#0x4000
000012  4913              LDR      r1,|L7.96|
000014  3114              ADDS     r1,r1,#0x14
000016  6008              STR      r0,[r1,#0]
;;;90     	SysTick_DeleyuS(750);		//拉低750us（大于480uS)
000018  f24020ee          MOV      r0,#0x2ee
00001c  f7fffffe          BL       SysTick_DeleyuS
;;;91     //	Dallas_H;								//DQ=1 
;;;92     //	SysTick_DeleyuS(15);		//15US---检测响应需要在15uS后
;;;93     	
;;;94     	//----------------------检测响应：总时间需要大于480us
;;;95     	//1释放总线
;;;96     	//2等待15us~60uS
;;;97     	//3从机拉低总线60uS~240uS
;;;98     	//4从机释放/拉高总线
;;;99     	Dallas_SetIn;				//SET PG11 INPUT		//输入模式
000020  f44f4180          MOV      r1,#0x4000
000024  480e              LDR      r0,|L7.96|
000026  f7fffffe          BL       GPIO_Configuration_IPU
;;;100    	SysTick_DeleyuS(15);		//15US---检测响应需要在15uS后
00002a  200f              MOVS     r0,#0xf
00002c  f7fffffe          BL       SysTick_DeleyuS
;;;101    	while(Dallas_Read	&& (retry < 500))			//响应检测时间不超过240uS
000030  e001              B        |L7.54|
                  |L7.50|
;;;102    	{
;;;103    		retry++;
000032  1c60              ADDS     r0,r4,#1
000034  b284              UXTH     r4,r0
                  |L7.54|
000036  480a              LDR      r0,|L7.96|
000038  3008              ADDS     r0,r0,#8              ;101
00003a  6800              LDR      r0,[r0,#0]            ;101
00003c  f4004080          AND      r0,r0,#0x4000         ;101
000040  b110              CBZ      r0,|L7.72|
000042  f5b47ffa          CMP      r4,#0x1f4             ;101
000046  dbf4              BLT      |L7.50|
                  |L7.72|
;;;104    //		SysTick_DeleyuS(1);
;;;105    	}
;;;106    	if(retry >= 500)	//超时
000048  f5b47ffa          CMP      r4,#0x1f4
00004c  db01              BLT      |L7.82|
;;;107    		return 1;
00004e  2001              MOVS     r0,#1
                  |L7.80|
;;;108    	else
;;;109    		retry=0;
;;;110    	//增加延时--为了满足总的检测时间480uS
;;;111    	SysTick_DeleyuS(480);		//总的检测响应时间需要大于480uS
;;;112    	return 0;
;;;113    }
000050  bd10              POP      {r4,pc}
                  |L7.82|
000052  2400              MOVS     r4,#0                 ;109
000054  f44f70f0          MOV      r0,#0x1e0             ;111
000058  f7fffffe          BL       SysTick_DeleyuS
00005c  2000              MOVS     r0,#0                 ;112
00005e  e7f7              B        |L7.80|
;;;114    
                          ENDP

                  |L7.96|
                          DCD      0x40010c00

                          AREA ||i.Dallas_WriteBit||, CODE, READONLY, ALIGN=2

                  Dallas_WriteBit PROC
;;;179    *******************************************************************************/
;;;180    void Dallas_WriteBit(unsigned char bit)		//1-wire 一位（1bit）写操作-写0&写1
000000  b510              PUSH     {r4,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182    		// =============Write 1
;;;183    		if (bit&0x01)		
000004  f0040001          AND      r0,r4,#1
000008  b178              CBZ      r0,|L8.42|
;;;184    		{
;;;185    			Dallas_L;					//拉低总线
00000a  f44f4080          MOV      r0,#0x4000
00000e  490f              LDR      r1,|L8.76|
000010  6008              STR      r0,[r1,#0]
;;;186    			SysTick_DeleyuS(2);		//至少维持了1us,表示写时序(包括写0时序或写1时序)开始 
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       SysTick_DeleyuS
;;;187    			Dallas_H;					//拉高总线
000018  f44f4080          MOV      r0,#0x4000
00001c  490b              LDR      r1,|L8.76|
00001e  1f09              SUBS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;188    			SysTick_DeleyuS(60);	//等待从机采样完成
000022  203c              MOVS     r0,#0x3c
000024  f7fffffe          BL       SysTick_DeleyuS
000028  e00e              B        |L8.72|
                  |L8.42|
;;;189    		}
;;;190    		// =============Write 0
;;;191    		else						
;;;192    		{
;;;193    			Dallas_L;					//拉低总线
00002a  f44f4080          MOV      r0,#0x4000
00002e  4907              LDR      r1,|L8.76|
000030  6008              STR      r0,[r1,#0]
;;;194    			SysTick_DeleyuS(60);	//保持60us，等待从机采样
000032  203c              MOVS     r0,#0x3c
000034  f7fffffe          BL       SysTick_DeleyuS
;;;195    			Dallas_H;					//释放总线
000038  f44f4080          MOV      r0,#0x4000
00003c  4903              LDR      r1,|L8.76|
00003e  1f09              SUBS     r1,r1,#4
000040  6008              STR      r0,[r1,#0]
;;;196    			SysTick_DeleyuS(2);
000042  2002              MOVS     r0,#2
000044  f7fffffe          BL       SysTick_DeleyuS
                  |L8.72|
;;;197    		}
;;;198    }
000048  bd10              POP      {r4,pc}
;;;199    /*******************************************************************************
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      0x40010c14

                          AREA ||i.Dallas_WriteByte||, CODE, READONLY, ALIGN=2

                  Dallas_WriteByte PROC
;;;207    *******************************************************************************/
;;;208    void Dallas_WriteByte(uint8_t dat)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {             
000002  4604              MOV      r4,r0
;;;210    	uint8_t j;
;;;211    	uint8_t testb;
;;;212    	
;;;213    	Dallas_SetOut;							//SET PG11 OUTPUT;
000004  f44f4180          MOV      r1,#0x4000
000008  4807              LDR      r0,|L9.40|
00000a  f7fffffe          BL       GPIO_Configuration_OPP50
;;;214    	
;;;215    	for (j=1; j<=8; j++)
00000e  2601              MOVS     r6,#1
000010  e007              B        |L9.34|
                  |L9.18|
;;;216    	{
;;;217    		testb = dat&0x01;
000012  f0040501          AND      r5,r4,#1
;;;218    		dat = dat>>1;
000016  1064              ASRS     r4,r4,#1
;;;219    		Dallas_WriteBit(testb);		//1-wire 一位（1bit）写操作-写0&写1
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       Dallas_WriteBit
00001e  1c70              ADDS     r0,r6,#1              ;215
000020  b2c6              UXTB     r6,r0                 ;215
                  |L9.34|
000022  2e08              CMP      r6,#8                 ;215
000024  ddf5              BLE      |L9.18|
;;;220    	}
;;;221    }
000026  bd70              POP      {r4-r6,pc}
;;;222    /*******************************************************************************
                          ENDP

                  |L9.40|
                          DCD      0x40010c00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  g_CRC8Tab
000000  005ebce2          DCB      0x00,0x5e,0xbc,0xe2
000004  613fdd83          DCB      0x61,0x3f,0xdd,0x83
000008  c29c7e20          DCB      0xc2,0x9c,0x7e,0x20
00000c  a3fd1f41          DCB      0xa3,0xfd,0x1f,0x41
000010  9dc3217f          DCB      0x9d,0xc3,0x21,0x7f
000014  fca2401e          DCB      0xfc,0xa2,0x40,0x1e
000018  5f01e3bd          DCB      0x5f,0x01,0xe3,0xbd
00001c  3e6082dc          DCB      0x3e,0x60,0x82,0xdc
000020  237d9fc1          DCB      0x23,0x7d,0x9f,0xc1
000024  421cfea0          DCB      0x42,0x1c,0xfe,0xa0
000028  e1bf5d03          DCB      0xe1,0xbf,0x5d,0x03
00002c  80de3c62          DCB      0x80,0xde,0x3c,0x62
000030  bee0025c          DCB      0xbe,0xe0,0x02,0x5c
000034  df81633d          DCB      0xdf,0x81,0x63,0x3d
000038  7c22c09e          DCB      0x7c,0x22,0xc0,0x9e
00003c  1d43a1ff          DCB      0x1d,0x43,0xa1,0xff
000040  4618faa4          DCB      0x46,0x18,0xfa,0xa4
000044  27799bc5          DCB      0x27,0x79,0x9b,0xc5
000048  84da3866          DCB      0x84,0xda,0x38,0x66
00004c  e5bb5907          DCB      0xe5,0xbb,0x59,0x07
000050  db856739          DCB      0xdb,0x85,0x67,0x39
000054  bae40658          DCB      0xba,0xe4,0x06,0x58
000058  1947a5fb          DCB      0x19,0x47,0xa5,0xfb
00005c  7826c49a          DCB      0x78,0x26,0xc4,0x9a
000060  653bd987          DCB      0x65,0x3b,0xd9,0x87
000064  045ab8e6          DCB      0x04,0x5a,0xb8,0xe6
000068  a7f91b45          DCB      0xa7,0xf9,0x1b,0x45
00006c  c6987a24          DCB      0xc6,0x98,0x7a,0x24
000070  f8a6441a          DCB      0xf8,0xa6,0x44,0x1a
000074  99c7257b          DCB      0x99,0xc7,0x25,0x7b
000078  3a6486d8          DCB      0x3a,0x64,0x86,0xd8
00007c  5b05e7b9          DCB      0x5b,0x05,0xe7,0xb9
000080  8cd2306e          DCB      0x8c,0xd2,0x30,0x6e
000084  edb3510f          DCB      0xed,0xb3,0x51,0x0f
000088  4e10f2ac          DCB      0x4e,0x10,0xf2,0xac
00008c  2f7193cd          DCB      0x2f,0x71,0x93,0xcd
000090  114fadf3          DCB      0x11,0x4f,0xad,0xf3
000094  702ecc92          DCB      0x70,0x2e,0xcc,0x92
000098  d38d6f31          DCB      0xd3,0x8d,0x6f,0x31
00009c  b2ec0e50          DCB      0xb2,0xec,0x0e,0x50
0000a0  aff1134d          DCB      0xaf,0xf1,0x13,0x4d
0000a4  ce90722c          DCB      0xce,0x90,0x72,0x2c
0000a8  6d33d18f          DCB      0x6d,0x33,0xd1,0x8f
0000ac  0c52b0ee          DCB      0x0c,0x52,0xb0,0xee
0000b0  326c8ed0          DCB      0x32,0x6c,0x8e,0xd0
0000b4  530defb1          DCB      0x53,0x0d,0xef,0xb1
0000b8  f0ae4c12          DCB      0xf0,0xae,0x4c,0x12
0000bc  91cf2d73          DCB      0x91,0xcf,0x2d,0x73
0000c0  ca947628          DCB      0xca,0x94,0x76,0x28
0000c4  abf51749          DCB      0xab,0xf5,0x17,0x49
0000c8  0856b4ea          DCB      0x08,0x56,0xb4,0xea
0000cc  6937d58b          DCB      0x69,0x37,0xd5,0x8b
0000d0  5709ebb5          DCB      0x57,0x09,0xeb,0xb5
0000d4  36688ad4          DCB      0x36,0x68,0x8a,0xd4
0000d8  95cb2977          DCB      0x95,0xcb,0x29,0x77
0000dc  f4aa4816          DCB      0xf4,0xaa,0x48,0x16
0000e0  e9b7550b          DCB      0xe9,0xb7,0x55,0x0b
0000e4  88d6346a          DCB      0x88,0xd6,0x34,0x6a
0000e8  2b7597c9          DCB      0x2b,0x75,0x97,0xc9
0000ec  4a14f6a8          DCB      0x4a,0x14,0xf6,0xa8
0000f0  742ac896          DCB      0x74,0x2a,0xc8,0x96
0000f4  154ba9f7          DCB      0x15,0x4b,0xa9,0xf7
0000f8  b6e80a54          DCB      0xb6,0xe8,0x0a,0x54
0000fc  d7896b35          DCB      0xd7,0x89,0x6b,0x35
