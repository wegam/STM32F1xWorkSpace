; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\linkedlist.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\linkedlist.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\linkedlist.crf ..\..\Driver\Tool\LinkedList.C]
                          THUMB

                          AREA ||i.AddNode||, CODE, READONLY, ALIGN=1

                  AddNode PROC
;;;101    //===============================================================================
;;;102    static LINK_NODE *AddNode(LINK_NODE* EndNODEx,LINK_NODE* NewNODEx)
000000  4602              MOV      r2,r0
;;;103    {
;;;104    	if(EndNODEx==NULL)						//头结点为空结点----新链表
000002  b92a              CBNZ     r2,|L1.16|
;;;105    	{
;;;106    		NewNODEx->PrevNode	=	NULL;	//第一个结点的上结点为空结点
000004  2000              MOVS     r0,#0
000006  6088              STR      r0,[r1,#8]
;;;107    		NewNODEx->NextNode	=	NULL;	//新建立的链表的下一结点为空结点
000008  60c8              STR      r0,[r1,#0xc]
;;;108    		EndNODEx	=	NewNODEx;				//
00000a  460a              MOV      r2,r1
;;;109    		return	NewNODEx;
00000c  4608              MOV      r0,r1
                  |L1.14|
;;;110    	}
;;;111    	//==================非空结点
;;;112    	else													//头结点非空结点
;;;113    	{
;;;114        LINK_NODE* TempNODEx  = EndNODEx;   //备份新结点
;;;115        TempNODEx->NextNode   = NewNODEx;   //尾结点的下结点连接到新结点
;;;116        NewNODEx ->PrevNode   = EndNODEx;   //新结点的上结点指向尾结点
;;;117        
;;;118        NewNODEx->NextNode    = NULL;       //新结点的尾结点为空
;;;119        EndNODEx =  NewNODEx;               //更新尾结点
;;;120    		return	EndNODEx;
;;;121    	}
;;;122    }
00000e  4770              BX       lr
                  |L1.16|
000010  4613              MOV      r3,r2                 ;114
000012  60d9              STR      r1,[r3,#0xc]          ;115
000014  608a              STR      r2,[r1,#8]            ;116
000016  2000              MOVS     r0,#0                 ;118
000018  60c8              STR      r0,[r1,#0xc]          ;118
00001a  460a              MOV      r2,r1                 ;119
00001c  4610              MOV      r0,r2                 ;120
00001e  e7f6              B        |L1.14|
;;;123    //===============================================================================
                          ENDP


                          AREA ||i.CreateNode||, CODE, READONLY, ALIGN=1

                  CreateNode PROC
;;;31     //===============================================================================
;;;32     static LINK_NODE *CreateNode(char* DataAddr,unsigned long DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;33     {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;34     	LINK_NODE *NewNode; 		//NewNode保存创建的新结点的地址
;;;35       char *Addr;
;;;36     	if(DataLength==0	||	DataAddr==NULL)				//数据长度为0,不执行
000008  b105              CBZ      r5,|L2.12|
00000a  b917              CBNZ     r7,|L2.18|
                  |L2.12|
;;;37     	{
;;;38     		return	NULL;
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;39     	}
;;;40     	//==================为此结点申请动态空间
;;;41     	NewNode = (LINK_NODE *) malloc (sizeof(LINK_NODE)); 	//开辟一个新结点(申请动态存储空间)
;;;42     
;;;43     	if (NULL == NewNode)	//申请失败
;;;44     	{
;;;45     		return NULL;				//返回空地址
;;;46     	}
;;;47     	else									//申请成功:下一步申请数据空间
;;;48     	{
;;;49     		//==================为此结点申请数据存储空间----使用动态存储空间方式
;;;50     		Addr	= (char *) malloc (DataLength);			//申请数据存储动态存储空间
;;;51     		if(NULL	== Addr)	//数据空间申请失败:释放结点,返回NULL
;;;52     		{
;;;53     			free(NewNode);								//释放建立的新结点
;;;54     			return NULL;									//返回空地址
;;;55     		}
;;;56         NewNode->DataAddr = Addr;
;;;57     		NewNode->NextNode = NULL;
;;;58     		NewNode->DataLen  = DataLength;											//此结点存储的数据大小
;;;59     		memcpy(NewNode->DataAddr,DataAddr,DataLength);		//复制数据		
;;;60     	}
;;;61     	return	NewNode;					//返回尾结点的地址:准备结尾结点添加数据
;;;62     }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L2.18|
000012  2010              MOVS     r0,#0x10              ;41
000014  f7fffffe          BL       malloc
000018  4604              MOV      r4,r0                 ;41
00001a  b90c              CBNZ     r4,|L2.32|
00001c  2000              MOVS     r0,#0                 ;45
00001e  e7f6              B        |L2.14|
                  |L2.32|
000020  4628              MOV      r0,r5                 ;50
000022  f7fffffe          BL       malloc
000026  4606              MOV      r6,r0                 ;50
000028  b926              CBNZ     r6,|L2.52|
00002a  4620              MOV      r0,r4                 ;53
00002c  f7fffffe          BL       free
000030  2000              MOVS     r0,#0                 ;54
000032  e7ec              B        |L2.14|
                  |L2.52|
000034  6066              STR      r6,[r4,#4]            ;56
000036  2000              MOVS     r0,#0                 ;57
000038  60e0              STR      r0,[r4,#0xc]          ;57
00003a  8025              STRH     r5,[r4,#0]            ;58
00003c  462a              MOV      r2,r5                 ;59
00003e  4639              MOV      r1,r7                 ;59
000040  6860              LDR      r0,[r4,#4]            ;59
000042  f7fffffe          BL       __aeabi_memcpy
000046  4620              MOV      r0,r4                 ;61
000048  e7e1              B        |L2.14|
;;;63     //===============================================================================
                          ENDP


                          AREA ||i.DeleteNode||, CODE, READONLY, ALIGN=1

                  DeleteNode PROC
;;;128    //===============================================================================
;;;129    static LINK_NODE *DeleteNode(LINK_NODE* DelNODEx)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4604              MOV      r4,r0
;;;131    	LINK_NODE* pNODE;
;;;132    	
;;;133    	pNODE = DelNODEx;
000004  4625              MOV      r5,r4
;;;134    	//==================判断结点是否为空
;;;135    	if(pNODE	==	NULL)
000006  b90d              CBNZ     r5,|L3.12|
;;;136    	{
;;;137    		return NULL;
000008  2000              MOVS     r0,#0
                  |L3.10|
;;;138    	}
;;;139    //	//==================动态数据方式:需要释放数据空间
;;;140    //	free(pNODE->DataAddr);										//释放数据空间
;;;141    	//==================结点头尾判断
;;;142    	if(DelNODEx->PrevNode==NULL)			//----------------上一个结点为空
;;;143    	{
;;;144    		if(DelNODEx->NextNode==NULL)										//上一个结点为空,下一个结点为空
;;;145    		{
;;;146          free(DelNODEx->DataAddr);									  //释放结点内数据缓存
;;;147    			free(DelNODEx);															//释放已删除结点
;;;148    			DelNODEx	=	NULL;													//删除地址
;;;149    		}
;;;150    		else																				//上一个结点为空,下一个结点非空
;;;151    		{
;;;152    			DelNODEx	=	DelNODEx->NextNode;				    //待删除结点地址更新为下一结点地址
;;;153    			DelNODEx->PrevNode		=	NULL;	            //下一结点的头结点更改为空结点
;;;154          free(pNODE->DataAddr);									  //释放结点内数据缓存
;;;155    			free(pNODE);															//释放已删除结点
;;;156    		}
;;;157    	}
;;;158    	else													//----------------上一个结点非空
;;;159    	{
;;;160    		if(DelNODEx->NextNode==NULL)										//上一个结点非空,下一个结点为空
;;;161    		{
;;;162    			DelNODEx->PrevNode->NextNode	=	NULL;		//上结点的尾结点设置为空
;;;163    			DelNODEx	=	DelNODEx->PrevNode;			//此结点地址更新为上一结点地址
;;;164          free(pNODE->DataAddr);									  //释放结点内数据缓存
;;;165    			free(pNODE);															//释放已删除结点
;;;166    		}
;;;167    		else											//----------------上一个结点非空,下一个结点非空
;;;168    		{
;;;169          DelNODEx->PrevNode->NextNode=DelNODEx->NextNode;	//上结点尾结点连接到此结点的下结点
;;;170    			DelNODEx->NextNode->PrevNode=DelNODEx->PrevNode;	//些结点的下结点的头结点连接到些结点的上结点
;;;171          DelNODEx  = DelNODEx->PrevNode;			              //此结点地址更新为上一结点地址
;;;172          free(pNODE->DataAddr);									  //释放结点内数据缓存
;;;173    			free(pNODE);															//释放已删除结点
;;;174    		}
;;;175    	}
;;;176    	return DelNODEx;						//返回新结点地址
;;;177    }
00000a  bd70              POP      {r4-r6,pc}
                  |L3.12|
00000c  68a0              LDR      r0,[r4,#8]            ;142
00000e  b998              CBNZ     r0,|L3.56|
000010  68e0              LDR      r0,[r4,#0xc]          ;144
000012  b938              CBNZ     r0,|L3.36|
000014  6860              LDR      r0,[r4,#4]            ;146
000016  f7fffffe          BL       free
00001a  4620              MOV      r0,r4                 ;147
00001c  f7fffffe          BL       free
000020  2400              MOVS     r4,#0                 ;148
000022  e023              B        |L3.108|
                  |L3.36|
000024  68e4              LDR      r4,[r4,#0xc]          ;152
000026  2000              MOVS     r0,#0                 ;153
000028  60a0              STR      r0,[r4,#8]            ;153
00002a  6868              LDR      r0,[r5,#4]            ;154
00002c  f7fffffe          BL       free
000030  4628              MOV      r0,r5                 ;155
000032  f7fffffe          BL       free
000036  e019              B        |L3.108|
                  |L3.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;160
00003a  b950              CBNZ     r0,|L3.82|
00003c  2000              MOVS     r0,#0                 ;162
00003e  68a1              LDR      r1,[r4,#8]            ;162
000040  60c8              STR      r0,[r1,#0xc]          ;162
000042  68a4              LDR      r4,[r4,#8]            ;163
000044  6868              LDR      r0,[r5,#4]            ;164
000046  f7fffffe          BL       free
00004a  4628              MOV      r0,r5                 ;165
00004c  f7fffffe          BL       free
000050  e00c              B        |L3.108|
                  |L3.82|
000052  e9d41002          LDRD     r1,r0,[r4,#8]         ;169
000056  60c8              STR      r0,[r1,#0xc]          ;169
000058  e9d40102          LDRD     r0,r1,[r4,#8]         ;170
00005c  6088              STR      r0,[r1,#8]            ;170
00005e  68a4              LDR      r4,[r4,#8]            ;171
000060  6868              LDR      r0,[r5,#4]            ;172
000062  f7fffffe          BL       free
000066  4628              MOV      r0,r5                 ;173
000068  f7fffffe          BL       free
                  |L3.108|
00006c  4620              MOV      r0,r4                 ;176
00006e  e7cc              B        |L3.10|
;;;178    //===============================================================================
                          ENDP


                          AREA ||i.FIFO_DEL||, CODE, READONLY, ALIGN=1

                  FIFO_DEL PROC
;;;365    //===============================================================================
;;;366    LINK_NODE* FIFO_DEL(LINK_NODE	*DelNode)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
000002  4604              MOV      r4,r0
;;;368    	if(NULL ==  DelNode)
000004  b90c              CBNZ     r4,|L4.10|
;;;369    	{
;;;370    		return 0;
000006  2000              MOVS     r0,#0
                  |L4.8|
;;;371    	}
;;;372      if(NULL ==  DelNode->PrevNode)    //头结点为空
;;;373      {
;;;374        if(NULL ==  DelNode->NextNode)  //尾结点为空
;;;375        {
;;;376          free(DelNode->DataAddr);      //释放结点内数据缓存
;;;377          free(DelNode);                //释放已删除结点
;;;378          DelNode = NULL;
;;;379        }
;;;380        else
;;;381        {
;;;382          LINK_NODE* pNODE	=	DelNode;
;;;383          DelNode = DelNode->NextNode;
;;;384          free(pNODE->DataAddr);        //释放结点内数据缓存
;;;385          free(pNODE);                  //释放已删除结点
;;;386        }
;;;387      }
;;;388      
;;;389      else                              //头结点非空
;;;390      {
;;;391        if(NULL ==  DelNode->NextNode)  //尾结点为空
;;;392        {
;;;393          LINK_NODE* pNODE	=	DelNode;
;;;394          DelNode = DelNode->NextNode;
;;;395          DelNode->PrevNode = NULL;
;;;396          free(pNODE->DataAddr);        //释放结点内数据缓存
;;;397          free(pNODE);                  //释放已删除结点
;;;398        }
;;;399        else
;;;400        {
;;;401          LINK_NODE* pNODE	=	DelNode;
;;;402          DelNode->PrevNode->NextNode = DelNode->NextNode;
;;;403          DelNode->NextNode->PrevNode = DelNode->PrevNode;
;;;404          DelNode = DelNode->PrevNode;
;;;405          free(pNODE->DataAddr);        //释放结点内数据缓存
;;;406          free(pNODE);                  //释放已删除结点
;;;407        }
;;;408      }
;;;409    	return DelNode;	
;;;410    }
000008  bd70              POP      {r4-r6,pc}
                  |L4.10|
00000a  68a0              LDR      r0,[r4,#8]            ;372
00000c  b990              CBNZ     r0,|L4.52|
00000e  68e0              LDR      r0,[r4,#0xc]          ;374
000010  b938              CBNZ     r0,|L4.34|
000012  6860              LDR      r0,[r4,#4]            ;376
000014  f7fffffe          BL       free
000018  4620              MOV      r0,r4                 ;377
00001a  f7fffffe          BL       free
00001e  2400              MOVS     r4,#0                 ;378
000020  e024              B        |L4.108|
                  |L4.34|
000022  4625              MOV      r5,r4                 ;382
000024  68e4              LDR      r4,[r4,#0xc]          ;383
000026  6868              LDR      r0,[r5,#4]            ;384
000028  f7fffffe          BL       free
00002c  4628              MOV      r0,r5                 ;385
00002e  f7fffffe          BL       free
000032  e01b              B        |L4.108|
                  |L4.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;391
000036  b950              CBNZ     r0,|L4.78|
000038  4625              MOV      r5,r4                 ;393
00003a  68e4              LDR      r4,[r4,#0xc]          ;394
00003c  2000              MOVS     r0,#0                 ;395
00003e  60a0              STR      r0,[r4,#8]            ;395
000040  6868              LDR      r0,[r5,#4]            ;396
000042  f7fffffe          BL       free
000046  4628              MOV      r0,r5                 ;397
000048  f7fffffe          BL       free
00004c  e00e              B        |L4.108|
                  |L4.78|
00004e  4625              MOV      r5,r4                 ;401
000050  e9d41002          LDRD     r1,r0,[r4,#8]         ;402
000054  60c8              STR      r0,[r1,#0xc]          ;402
000056  e9d40102          LDRD     r0,r1,[r4,#8]         ;403
00005a  6088              STR      r0,[r1,#8]            ;403
00005c  68a4              LDR      r4,[r4,#8]            ;404
00005e  6868              LDR      r0,[r5,#4]            ;405
000060  f7fffffe          BL       free
000064  4628              MOV      r0,r5                 ;406
000066  f7fffffe          BL       free
00006a  bf00              NOP                            ;407
                  |L4.108|
00006c  4620              MOV      r0,r4                 ;409
00006e  e7cb              B        |L4.8|
;;;411    //===============================================================================
                          ENDP


                          AREA ||i.FIFO_IN||, CODE, READONLY, ALIGN=1

                  FIFO_IN PROC
;;;256    //===============================================================================
;;;257    unsigned short  FIFO_IN(LINK_NODE	**EndNode,char* SaveAddr,unsigned short SaveLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;259    	//==================临时变量
;;;260    	LINK_NODE *NewNode = NULL; 											//新建临时结点
00000a  2400              MOVS     r4,#0
;;;261      LINK_NODE *TempNode = *EndNode; 							  //临时结点
00000c  f8d58000          LDR      r8,[r5,#0]
;;;262    	//==================创建结点:返回结点地址
;;;263    	NewNode	=	CreateNode(SaveAddr,SaveLength);			//得到新申请的结点地址
000010  4631              MOV      r1,r6
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       CreateNode
000018  4604              MOV      r4,r0
;;;264    	//==================判断申请结点结果			
;;;265    	if(NewNode==NULL)		//申请失败
00001a  b914              CBNZ     r4,|L5.34|
;;;266    	{
;;;267    		return 0;	        //退出,返回0
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;268    	}
;;;269      //==================空链表
;;;270      if(NULL ==  TempNode)
;;;271      {
;;;272        NewNode->NextNode = NULL;
;;;273        NewNode->PrevNode = NULL;
;;;274        *EndNode = NewNode;
;;;275        return  SaveLength;
;;;276      }
;;;277      else
;;;278      {
;;;279        //===================查找尾结点并且在尾结点添加新结点
;;;280        LINK_NODE*  TempNode  = *EndNode;
;;;281        unsigned char i=0;
;;;282        for(i=0;i<0xFF;i++)
;;;283        {
;;;284          if(NULL ==  TempNode->NextNode)
;;;285          {
;;;286            break;
;;;287          }
;;;288          TempNode  = TempNode->NextNode;
;;;289        }
;;;290        TempNode->NextNode  = NewNode;
;;;291        NewNode->PrevNode   = TempNode;
;;;292        NewNode->NextNode   = NULL;
;;;293        *EndNode = NewNode;
;;;294      }
;;;295    	//==================判断此链表是否为空链表(头结点是否为空)
;;;296    	
;;;297    	return	SaveLength;
;;;298    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.34|
000022  f1b80f00          CMP      r8,#0                 ;270
000026  d105              BNE      |L5.52|
000028  2000              MOVS     r0,#0                 ;272
00002a  60e0              STR      r0,[r4,#0xc]          ;272
00002c  60a0              STR      r0,[r4,#8]            ;273
00002e  602c              STR      r4,[r5,#0]            ;274
000030  4630              MOV      r0,r6                 ;275
000032  e7f4              B        |L5.30|
                  |L5.52|
000034  6828              LDR      r0,[r5,#0]            ;280
000036  2100              MOVS     r1,#0                 ;281
000038  bf00              NOP                            ;282
00003a  e005              B        |L5.72|
                  |L5.60|
00003c  68c2              LDR      r2,[r0,#0xc]          ;284
00003e  b902              CBNZ     r2,|L5.66|
000040  e004              B        |L5.76|
                  |L5.66|
000042  68c0              LDR      r0,[r0,#0xc]          ;288
000044  1c4a              ADDS     r2,r1,#1              ;282
000046  b2d1              UXTB     r1,r2                 ;282
                  |L5.72|
000048  29ff              CMP      r1,#0xff              ;282
00004a  dbf7              BLT      |L5.60|
                  |L5.76|
00004c  bf00              NOP                            ;286
00004e  60c4              STR      r4,[r0,#0xc]          ;290
000050  60a0              STR      r0,[r4,#8]            ;291
000052  2200              MOVS     r2,#0                 ;292
000054  60e2              STR      r2,[r4,#0xc]          ;292
000056  602c              STR      r4,[r5,#0]            ;293
000058  bf00              NOP                            ;294
00005a  4630              MOV      r0,r6                 ;297
00005c  e7df              B        |L5.30|
;;;299    
                          ENDP


                          AREA ||i.FIFO_OUT||, CODE, READONLY, ALIGN=1

                  FIFO_OUT PROC
;;;305    //===============================================================================
;;;306    unsigned short FIFO_OUT(LINK_NODE	**HeadNode,char* ReadAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;307    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;308      LINK_NODE *TempNode = *HeadNode; 							  //临时结点
000008  682c              LDR      r4,[r5,#0]
;;;309      unsigned short DataLen = 0;			//存储的数据长度
00000a  2700              MOVS     r7,#0
;;;310    	//==================空结点
;;;311    	if(TempNode==NULL)							//链表头结点为空---空链表
00000c  b914              CBNZ     r4,|L6.20|
;;;312    	{
;;;313    		return NULL;												  //退出
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;314    	}
;;;315    	//==================非空结点
;;;316    	else		
;;;317    	{
;;;318        //===================查找头结点并且复制头结点内存数据，然后重新修改头结点地址，释放原头结点内存
;;;319        unsigned char i = 0;
;;;320        for(i=0;i<0xFF;i++)
;;;321        {
;;;322          if(NULL ==  TempNode->PrevNode) //此结点上结点为空表示此为头结点
;;;323          {
;;;324            break;
;;;325          }
;;;326          TempNode  = TempNode->PrevNode;
;;;327        }
;;;328    		//==================复制数据
;;;329        DataLen = TempNode->DataLen;
;;;330        if(DataLen)
;;;331        {
;;;332          if(NULL !=  ReadAddr)
;;;333          {
;;;334            free(ReadAddr);        
;;;335          }
;;;336          ReadAddr  = (char*)malloc((unsigned int)DataLen);
;;;337          if(NULL ==  ReadAddr)   //动态内存申请失败
;;;338          {
;;;339            return 0;
;;;340          }
;;;341          memcpy(ReadAddr,TempNode->DataAddr,TempNode->DataLen);	          //复制结点内数据到链表缓存
;;;342        }
;;;343        //===================重新更新链表头地址，释放链表空间，如果是最后一个链表，删除链表
;;;344        if(NULL !=  TempNode->NextNode)                           //链表还有结点
;;;345        {
;;;346          TempNode ->NextNode->PrevNode = NULL;
;;;347          *HeadNode  = TempNode  ->NextNode;
;;;348          free(TempNode->DataAddr);                               //释放结点内数据缓存
;;;349          free(TempNode);                                         //释放已删除结点
;;;350        }
;;;351        else
;;;352        {
;;;353          free(TempNode->DataAddr);                               //释放结点内数据缓存
;;;354          free(TempNode);                                         //释放已删除结点
;;;355          *HeadNode  = NULL;
;;;356        }
;;;357    		return DataLen;					//返回数据宽度
;;;358    	}
;;;359    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L6.20|
000014  f04f0800          MOV      r8,#0                 ;319
000018  bf00              NOP                            ;320
00001a  e007              B        |L6.44|
                  |L6.28|
00001c  68a0              LDR      r0,[r4,#8]            ;322
00001e  b900              CBNZ     r0,|L6.34|
000020  e007              B        |L6.50|
                  |L6.34|
000022  68a4              LDR      r4,[r4,#8]            ;326
000024  f1080001          ADD      r0,r8,#1              ;320
000028  f00008ff          AND      r8,r0,#0xff           ;320
                  |L6.44|
00002c  f1b80fff          CMP      r8,#0xff              ;320
000030  dbf4              BLT      |L6.28|
                  |L6.50|
000032  bf00              NOP                            ;324
000034  8827              LDRH     r7,[r4,#0]            ;329
000036  b17f              CBZ      r7,|L6.88|
000038  b116              CBZ      r6,|L6.64|
00003a  4630              MOV      r0,r6                 ;334
00003c  f7fffffe          BL       free
                  |L6.64|
000040  4638              MOV      r0,r7                 ;336
000042  f7fffffe          BL       malloc
000046  4606              MOV      r6,r0                 ;336
000048  b90e              CBNZ     r6,|L6.78|
00004a  2000              MOVS     r0,#0                 ;339
00004c  e7e0              B        |L6.16|
                  |L6.78|
00004e  8822              LDRH     r2,[r4,#0]            ;341
000050  4630              MOV      r0,r6                 ;341
000052  6861              LDR      r1,[r4,#4]            ;341
000054  f7fffffe          BL       __aeabi_memcpy
                  |L6.88|
000058  68e0              LDR      r0,[r4,#0xc]          ;344
00005a  b158              CBZ      r0,|L6.116|
00005c  2000              MOVS     r0,#0                 ;346
00005e  68e1              LDR      r1,[r4,#0xc]          ;346
000060  6088              STR      r0,[r1,#8]            ;346
000062  68e0              LDR      r0,[r4,#0xc]          ;347
000064  6028              STR      r0,[r5,#0]            ;347
000066  6860              LDR      r0,[r4,#4]            ;348
000068  f7fffffe          BL       free
00006c  4620              MOV      r0,r4                 ;349
00006e  f7fffffe          BL       free
000072  e007              B        |L6.132|
                  |L6.116|
000074  6860              LDR      r0,[r4,#4]            ;353
000076  f7fffffe          BL       free
00007a  4620              MOV      r0,r4                 ;354
00007c  f7fffffe          BL       free
000080  2000              MOVS     r0,#0                 ;355
000082  6028              STR      r0,[r5,#0]            ;355
                  |L6.132|
000084  4638              MOV      r0,r7                 ;357
000086  e7c3              B        |L6.16|
;;;360    //===============================================================================
                          ENDP


                          AREA ||i.FindData||, CODE, READONLY, ALIGN=1

                  FindData PROC
;;;207    //===============================================================================
;;;208    LINK_NODE *FindData(LINK_NODE	*HeadNODE,char* DataAddr,unsigned long DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;209    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;210    	unsigned short i	=0;
00000a  2600              MOVS     r6,#0
;;;211    	LINK_NODE* TempNODEx	=	NULL;
00000c  2400              MOVS     r4,#0
;;;212    	
;;;213    	if(HeadNODE	==	NULL)   //空结点
00000e  b915              CBNZ     r5,|L7.22|
;;;214    	{
;;;215    		return NULL;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;216    	}
;;;217    	TempNODEx	=	HeadNODE;
;;;218    	for(i=0;i<0xFF;i++)
;;;219    	{
;;;220    		if(TempNODEx  ==	NULL)
;;;221    		{
;;;222    			return NULL;
;;;223    		}
;;;224    		else if(memcmp(TempNODEx->DataAddr,DataAddr,DataLength)	==	0)				//查找到数据//比较内存数据相等
;;;225    		{
;;;226    			return	TempNODEx;
;;;227    		}
;;;228    		else
;;;229    		{
;;;230    			TempNODEx	=	TempNODEx->NextNode;
;;;231    		}
;;;232    	}
;;;233    	return NULL;
;;;234    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L7.22|
000016  462c              MOV      r4,r5                 ;217
000018  2600              MOVS     r6,#0                 ;218
00001a  e00d              B        |L7.56|
                  |L7.28|
00001c  b90c              CBNZ     r4,|L7.34|
00001e  2000              MOVS     r0,#0                 ;222
000020  e7f7              B        |L7.18|
                  |L7.34|
000022  4642              MOV      r2,r8                 ;224
000024  4639              MOV      r1,r7                 ;224
000026  6860              LDR      r0,[r4,#4]            ;224
000028  f7fffffe          BL       memcmp
00002c  b908              CBNZ     r0,|L7.50|
00002e  4620              MOV      r0,r4                 ;226
000030  e7ef              B        |L7.18|
                  |L7.50|
000032  68e4              LDR      r4,[r4,#0xc]          ;230
000034  1c70              ADDS     r0,r6,#1              ;218
000036  b286              UXTH     r6,r0                 ;218
                  |L7.56|
000038  2eff              CMP      r6,#0xff              ;218
00003a  dbef              BLT      |L7.28|
00003c  2000              MOVS     r0,#0                 ;233
00003e  e7e8              B        |L7.18|
;;;235    //===============================================================================
                          ENDP


                          AREA ||i.GetEndNode||, CODE, READONLY, ALIGN=1

                  GetEndNode PROC
;;;183    //===============================================================================
;;;184    static LINK_NODE *GetEndNode(LINK_NODE* DelNODEx)
000000  b530              PUSH     {r4,r5,lr}
;;;185    {
000002  4605              MOV      r5,r0
;;;186    	LINK_NODE* pNODE;
;;;187    	pNODE	=	DelNODEx;
000004  462c              MOV      r4,r5
;;;188    	if(pNODE	==	NULL)
000006  b90c              CBNZ     r4,|L8.12|
;;;189    	{
;;;190    		return NULL;
000008  2000              MOVS     r0,#0
                  |L8.10|
;;;191    	}
;;;192    	if(pNODE->NextNode	==NULL)
;;;193    	{
;;;194    		return pNODE;
;;;195    	}
;;;196    	else
;;;197    	{
;;;198    		GetEndNode(pNODE->NextNode);
;;;199    	}
;;;200    	return pNODE;
;;;201    }
00000a  bd30              POP      {r4,r5,pc}
                  |L8.12|
00000c  68e0              LDR      r0,[r4,#0xc]          ;192
00000e  b908              CBNZ     r0,|L8.20|
000010  4620              MOV      r0,r4                 ;194
000012  e7fa              B        |L8.10|
                  |L8.20|
000014  68e0              LDR      r0,[r4,#0xc]          ;198
000016  f7fffffe          BL       GetEndNode
00001a  4620              MOV      r0,r4                 ;200
00001c  e7f5              B        |L8.10|
;;;202    //===============================================================================
                          ENDP


                          AREA ||i.GetListLength||, CODE, READONLY, ALIGN=1

                  GetListLength PROC
;;;240    //===============================================================================
;;;241    unsigned long GetListLength(LINK_NODE* HeadNODEx)
000000  b510              PUSH     {r4,lr}
;;;242    {
000002  4604              MOV      r4,r0
;;;243    	if(HeadNODEx==NULL)			//结点为空
000004  b90c              CBNZ     r4,|L9.10|
;;;244    	{
;;;245    		return 0;					//
000006  2000              MOVS     r0,#0
                  |L9.8|
;;;246    	}
;;;247    	return	1+GetListLength(HeadNODEx->NextNode);
;;;248    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  68e0              LDR      r0,[r4,#0xc]          ;247
00000c  f7fffffe          BL       GetListLength
000010  1c40              ADDS     r0,r0,#1              ;247
000012  e7f9              B        |L9.8|
;;;249    //===============================================================================
                          ENDP


                          AREA ||i.InsertNode||, CODE, READONLY, ALIGN=1

                  InsertNode PROC
;;;68     //===============================================================================
;;;69     static LINK_NODE *InsertNode(LINK_NODE* HeadNODEx,LINK_NODE* NewNODEx)
000000  4602              MOV      r2,r0
;;;70     {
;;;71     	if(HeadNODEx==NULL)						//头结点为空结点----新链表
000002  b922              CBNZ     r2,|L10.14|
;;;72     	{
;;;73     		NewNODEx->PrevNode	=	NULL;	//第一个结点的上结点为空结点
000004  2000              MOVS     r0,#0
000006  6088              STR      r0,[r1,#8]
;;;74     		NewNODEx->NextNode	=	NULL;	//新建立的链表的下一结点为空结点
000008  60c8              STR      r0,[r1,#0xc]
;;;75     		return	NewNODEx;
00000a  4608              MOV      r0,r1
                  |L10.12|
;;;76     	}
;;;77     	//==================非空结点
;;;78     	else													//头结点非空结点
;;;79     	{		
;;;80     		if(HeadNODEx->PrevNode	==NULL)			//头结点的上结点为空
;;;81     		{
;;;82     			NewNODEx->PrevNode	=	NULL;				//新结点的上结点为空
;;;83     			NewNODEx->NextNode	=	HeadNODEx;	//新结点的下结点到头结点
;;;84     			HeadNODEx->PrevNode	=	NewNODEx;		//头结点的上结点连接到新结点
;;;85     		}
;;;86     		else																											//头结点的上结点非空
;;;87     		{
;;;88     			NewNODEx->PrevNode	=	HeadNODEx->PrevNode->NextNode;		//新结点	的上结点连接到头结点的上结点
;;;89     			NewNODEx->NextNode	=	HeadNODEx;												//新结点的下结点连接到头结点
;;;90     			HeadNODEx->PrevNode->NextNode=NewNODEx;									//头结点的上结点的下结点连接到新结点
;;;91     			HeadNODEx->PrevNode=NewNODEx;														//头结点的上结点连接到新结点
;;;92     		}
;;;93     		return	NewNODEx;
;;;94     	}
;;;95     }
00000c  4770              BX       lr
                  |L10.14|
00000e  6890              LDR      r0,[r2,#8]            ;80
000010  b920              CBNZ     r0,|L10.28|
000012  2000              MOVS     r0,#0                 ;82
000014  6088              STR      r0,[r1,#8]            ;82
000016  60ca              STR      r2,[r1,#0xc]          ;83
000018  6091              STR      r1,[r2,#8]            ;84
00001a  e006              B        |L10.42|
                  |L10.28|
00001c  6890              LDR      r0,[r2,#8]            ;88
00001e  68c0              LDR      r0,[r0,#0xc]          ;88
000020  6088              STR      r0,[r1,#8]            ;88
000022  60ca              STR      r2,[r1,#0xc]          ;89
000024  6890              LDR      r0,[r2,#8]            ;90
000026  60c1              STR      r1,[r0,#0xc]          ;90
000028  6091              STR      r1,[r2,#8]            ;91
                  |L10.42|
00002a  4608              MOV      r0,r1                 ;93
00002c  e7ee              B        |L10.12|
;;;96     //===============================================================================
                          ENDP


                          AREA ||i.LIFO_IN||, CODE, READONLY, ALIGN=1

                  LIFO_IN PROC
;;;417    //===============================================================================
;;;418    unsigned long LIFO_IN(LINK_NODE	*HeadNode,char* SaveAddr,unsigned long SaveLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;419    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;420    	LINK_NODE *NewNode = NULL; 											//临时数据
00000a  2400              MOVS     r4,#0
;;;421    //	HeadNode->DataLen	=	SaveLength;							    //保存待存储的数据大小
;;;422    	NewNode	=	CreateNode(SaveAddr,SaveLength);		  //得到新申请的结点地址
00000c  4631              MOV      r1,r6
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       CreateNode
000014  4604              MOV      r4,r0
;;;423    						
;;;424    	if(NewNode==NULL)		//申请失败
000016  b914              CBNZ     r4,|L11.30|
;;;425    	{
;;;426    		return 0;					//
000018  2000              MOVS     r0,#0
                  |L11.26|
;;;427    	}
;;;428      //在头结点前插入新结点
;;;429      if(NULL ==  HeadNode)                     //头结点为空结点
;;;430      {
;;;431        NewNode->NextNode = NULL;
;;;432        NewNode->PrevNode = NULL;
;;;433        HeadNode  = NewNode;
;;;434      }
;;;435      else
;;;436      {
;;;437        LINK_NODE*  TempNode  = HeadNode;
;;;438        unsigned char i=0;
;;;439        for(i=0;i<0xFF;i++)
;;;440        {
;;;441          if(NULL ==  TempNode->PrevNode)
;;;442          {
;;;443            break;
;;;444          }
;;;445          TempNode  = TempNode->PrevNode;
;;;446        }
;;;447        NewNode->NextNode = TempNode;
;;;448        NewNode->PrevNode = NULL;
;;;449        HeadNode  = NewNode;                    //更新头结点
;;;450        
;;;451      }
;;;452    	return	SaveLength;
;;;453    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L11.30|
00001e  b925              CBNZ     r5,|L11.42|
000020  2000              MOVS     r0,#0                 ;431
000022  60e0              STR      r0,[r4,#0xc]          ;431
000024  60a0              STR      r0,[r4,#8]            ;432
000026  4625              MOV      r5,r4                 ;433
000028  e011              B        |L11.78|
                  |L11.42|
00002a  4628              MOV      r0,r5                 ;437
00002c  2100              MOVS     r1,#0                 ;438
00002e  bf00              NOP                            ;439
000030  e005              B        |L11.62|
                  |L11.50|
000032  6882              LDR      r2,[r0,#8]            ;441
000034  b902              CBNZ     r2,|L11.56|
000036  e004              B        |L11.66|
                  |L11.56|
000038  6880              LDR      r0,[r0,#8]            ;445
00003a  1c4a              ADDS     r2,r1,#1              ;439
00003c  b2d1              UXTB     r1,r2                 ;439
                  |L11.62|
00003e  29ff              CMP      r1,#0xff              ;439
000040  dbf7              BLT      |L11.50|
                  |L11.66|
000042  bf00              NOP                            ;443
000044  60e0              STR      r0,[r4,#0xc]          ;447
000046  2200              MOVS     r2,#0                 ;448
000048  60a2              STR      r2,[r4,#8]            ;448
00004a  4625              MOV      r5,r4                 ;449
00004c  bf00              NOP                            ;451
                  |L11.78|
00004e  4630              MOV      r0,r6                 ;452
000050  e7e3              B        |L11.26|
;;;454    
                          ENDP


                          AREA ||i.LIFO_OUT||, CODE, READONLY, ALIGN=1

                  LIFO_OUT PROC
;;;460    //===============================================================================
;;;461    LINK_NODE* LIFO_OUT(LINK_NODE	*EndNode,char* ReadAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;463    	//==================空结点
;;;464    	if(EndNode==NULL)							//链表头结点为空---空链表
000006  b90d              CBNZ     r5,|L12.12|
;;;465    	{
;;;466    		return 0;														//退出
000008  2000              MOVS     r0,#0
                  |L12.10|
;;;467    	}
;;;468    	//==================非空结点
;;;469    	else		
;;;470    	{
;;;471        LINK_NODE*  TempNode  = EndNode;
;;;472        do
;;;473        {
;;;474          TempNode  = TempNode->NextNode;
;;;475        }
;;;476        while(NULL ==  TempNode->NextNode);
;;;477        TempNode->PrevNode->NextNode  = NULL;
;;;478        EndNode = TempNode->PrevNode;
;;;479        memcpy(ReadAddr,TempNode->DataAddr,TempNode->DataLen);                //复制数据
;;;480        free(TempNode->DataAddr);                               //释放结点内数据缓存
;;;481        free(TempNode);                                         //释放已删除结点
;;;482        
;;;483    		return EndNode;																			    //返回新的尾结点地址
;;;484    	}
;;;485    }
00000a  bd70              POP      {r4-r6,pc}
                  |L12.12|
00000c  462c              MOV      r4,r5                 ;471
00000e  bf00              NOP                            ;472
                  |L12.16|
000010  68e4              LDR      r4,[r4,#0xc]          ;474
000012  68e0              LDR      r0,[r4,#0xc]          ;476
000014  2800              CMP      r0,#0                 ;476
000016  d0fb              BEQ      |L12.16|
000018  2000              MOVS     r0,#0                 ;477
00001a  68a1              LDR      r1,[r4,#8]            ;477
00001c  60c8              STR      r0,[r1,#0xc]          ;477
00001e  68a5              LDR      r5,[r4,#8]            ;478
000020  8822              LDRH     r2,[r4,#0]            ;479
000022  4630              MOV      r0,r6                 ;479
000024  6861              LDR      r1,[r4,#4]            ;479
000026  f7fffffe          BL       __aeabi_memcpy
00002a  6860              LDR      r0,[r4,#4]            ;480
00002c  f7fffffe          BL       free
000030  4620              MOV      r0,r4                 ;481
000032  f7fffffe          BL       free
000036  4628              MOV      r0,r5                 ;483
000038  e7e7              B        |L12.10|
;;;486    //===============================================================================
                          ENDP


                          AREA ||i.LinkListTest||, CODE, READONLY, ALIGN=1

                  LinkListTest PROC
;;;491    //===============================================================================
;;;492    unsigned long LinkListTest(LINK_NODE	*LISTx,char* DataAddr,unsigned long SaveLength,unsigned char CMD)
000000  b530              PUSH     {r4,r5,lr}
;;;493    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;494    	unsigned long	RevLength	=	0;
000006  2000              MOVS     r0,#0
000008  4601              MOV      r1,r0
;;;495    //	//===========================FIFO测试
;;;496    //	//--------------------入列			----命令0x01;
;;;497    //	if(CMD	==	0x01)
;;;498    //	{
;;;499    //		RevLength	=	FIFO_IN(LISTx,DataAddr,SaveLength);		//FIFO存储数据---First in, First out
;;;500    //	}
;;;501    //	//--------------------出列			----命令0x02
;;;502    //	else if(CMD	==	0x02)
;;;503    //	{
;;;504    //		RevLength	=	FIFO_OUT(LISTx,DataAddr);							//FIFO输出数据---First in, First out
;;;505    //	}	
;;;506    //	//--------------------删除结点		----命令0x03
;;;507    //	else if(CMD	==	0x03)
;;;508    //	{
;;;509    //		RevLength	=	FIFO_DEL(LISTx,DataAddr,SaveLength);	//FIFO删除相应数据的结点
;;;510    //	}
;;;511    //	//--------------------查找数据		----命令0x04
;;;512    //	else if(CMD	==	0x04)
;;;513    //	{
;;;514    //	}
;;;515    //	//--------------------清空链表		----命令0x05
;;;516    //	else if(CMD	==	0x05)
;;;517    //	{
;;;518    //	}
;;;519    //	
;;;520    //	
;;;521    //	//===========================LIFO测试
;;;522    //	//--------------------入列			----命令0x11
;;;523    //	else if(CMD	==	0x11)
;;;524    //	{
;;;525    //	}
;;;526    //	//--------------------出列			----命令0x12
;;;527    //	else if(CMD	==	0x11)
;;;528    //	{
;;;529    //	}
;;;530    //	//--------------------删除结点		----命令0x13
;;;531    //	else if(CMD	==	0x11)
;;;532    //	{
;;;533    //	}
;;;534    //	//--------------------查找数据		----命令0x14
;;;535    //	else if(CMD	==	0x11)
;;;536    //	{
;;;537    //	}
;;;538    //	//--------------------清空链表		----命令0x15
;;;539    //	else if(CMD	==	0x11)
;;;540    //	{
;;;541    //	}
;;;542    //	return RevLength;
;;;543    }
00000a  bd30              POP      {r4,r5,pc}
;;;544    
                          ENDP

