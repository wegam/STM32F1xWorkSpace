; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32_adc.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32_adc.crf ..\..\Driver\WOW\SCR\STM32_ADC.C]
                          THUMB

                          AREA ||i.ADC1_Cmd||, CODE, READONLY, ALIGN=2

                  ADC1_Cmd PROC
;;;353    *******************************************************************************/
;;;354    void ADC1_Cmd(FunctionalState NewState)		//开启ADC1转换
000000  b510              PUSH     {r4,lr}
;;;355    {
000002  4604              MOV      r4,r0
;;;356    //	assert_param(IS_FUNCTIONAL_STATE(ENABLE));
;;;357    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;358      if (NewState != DISABLE)
000004  b314              CBZ      r4,|L1.76|
;;;359      {		
;;;360        ADC_DMACmd(ADC1, ENABLE); 									//开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数）ADC_DMACmd(ADC1, ENABLE);
000006  2101              MOVS     r1,#1
000008  4817              LDR      r0,|L1.104|
00000a  f7fffffe          BL       ADC_DMACmd
;;;361    		DMA_Cmd(DMA1_Channel1,ENABLE);
00000e  2101              MOVS     r1,#1
000010  4816              LDR      r0,|L1.108|
000012  f7fffffe          BL       DMA_Cmd
;;;362    		ADC_Cmd(ADC1, ENABLE); 											//使能指定的ADC1
000016  2101              MOVS     r1,#1
000018  4813              LDR      r0,|L1.104|
00001a  f7fffffe          BL       ADC_Cmd
;;;363    		ADC_SoftwareStartConvCmd(ADC1,ENABLE);
00001e  2101              MOVS     r1,#1
000020  4811              LDR      r0,|L1.104|
000022  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;364    		ADC_ResetCalibration(ADC1); 								//复位指定的ADC1的校准寄存器
000026  4810              LDR      r0,|L1.104|
000028  f7fffffe          BL       ADC_ResetCalibration
;;;365    		
;;;366    		while(ADC_GetResetCalibrationStatus(ADC1)); //获取ADC1复位校准寄存器的状态,设置状态则等待
00002c  bf00              NOP      
                  |L1.46|
00002e  480e              LDR      r0,|L1.104|
000030  f7fffffe          BL       ADC_GetResetCalibrationStatus
000034  2800              CMP      r0,#0
000036  d1fa              BNE      |L1.46|
;;;367    		ADC_StartCalibration(ADC1); 								//开始指定ADC1的校准状态
000038  480b              LDR      r0,|L1.104|
00003a  f7fffffe          BL       ADC_StartCalibration
;;;368    		while(ADC_GetCalibrationStatus(ADC1)); 			//获取指定ADC1的校准程序,设置状态则等待	
00003e  bf00              NOP      
                  |L1.64|
000040  4809              LDR      r0,|L1.104|
000042  f7fffffe          BL       ADC_GetCalibrationStatus
000046  2800              CMP      r0,#0
000048  d1fa              BNE      |L1.64|
00004a  e00b              B        |L1.100|
                  |L1.76|
;;;369      }
;;;370      else
;;;371      {
;;;372        ADC_SoftwareStartConvCmd(ADC1,DISABLE);
00004c  2100              MOVS     r1,#0
00004e  4806              LDR      r0,|L1.104|
000050  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;373        ADC_DMACmd(ADC1, DISABLE); 	//开启ADC的DMA支持（要实现DMA功能，还需独立配置DMA通道等参数）ADC_DMACmd(ADC1, ENABLE);
000054  2100              MOVS     r1,#0
000056  4804              LDR      r0,|L1.104|
000058  f7fffffe          BL       ADC_DMACmd
;;;374    		ADC_Cmd(ADC1, DISABLE); 		//使能指定的ADC1	
00005c  2100              MOVS     r1,#0
00005e  4802              LDR      r0,|L1.104|
000060  f7fffffe          BL       ADC_Cmd
                  |L1.100|
;;;375      }
;;;376    }
000064  bd10              POP      {r4,pc}
;;;377    
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
                          DCD      0x40012400
                  |L1.108|
                          DCD      0x40020008

                          AREA ||i.ADC1_DMAConfiguration||, CODE, READONLY, ALIGN=2

                  ADC1_DMAConfiguration PROC
;;;326    *******************************************************************************/
;;;327    void ADC1_DMAConfiguration(u32 *ADCDataBuffer,u32 DMA_BufferSize) 		//ADC1 DMA配置
000000  b530              PUSH     {r4,r5,lr}
;;;328    {  
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;329    	DMA_InitTypeDef DMA_InitStructure; 																					//DMA结构体
;;;330    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); 		//使能DMA传输
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;331      
;;;332    	DMA_DeInit(DMA1_Channel1); 																									  //将DMA的通道1寄存器重设为缺省值
000010  480f              LDR      r0,|L2.80|
000012  f7fffffe          BL       DMA_DeInit
;;;333    	DMA_InitStructure.DMA_PeripheralBaseAddr  = (u32)&ADC1->DR; 									//DMA外设基地址---ADC
000016  480f              LDR      r0,|L2.84|
000018  9000              STR      r0,[sp,#0]
;;;334    	DMA_InitStructure.DMA_MemoryBaseAddr      = (u32)ADCDataBuffer; 						  //DMA内存基地址---ADC存储变量地址
00001a  9501              STR      r5,[sp,#4]
;;;335    	DMA_InitStructure.DMA_DIR                 = DMA_DIR_PeripheralSRC; 					  //设置源端---外设作为数据传输的来源
00001c  2000              MOVS     r0,#0
00001e  9002              STR      r0,[sp,#8]
;;;336    	DMA_InitStructure.DMA_BufferSize          = DMA_BufferSize; 								  //DMA通道的DMA缓存的大小
000020  9403              STR      r4,[sp,#0xc]
;;;337    	DMA_InitStructure.DMA_PeripheralInc       = DMA_PeripheralInc_Disable; 			  //外设地址寄存器不变
000022  9004              STR      r0,[sp,#0x10]
;;;338    	DMA_InitStructure.DMA_MemoryInc           = DMA_MemoryInc_Enable; 					  //内存地址寄存器递增：多通道转换时数据存储地址需要增加
000024  2080              MOVS     r0,#0x80
000026  9005              STR      r0,[sp,#0x14]
;;;339    	DMA_InitStructure.DMA_PeripheralDataSize  = DMA_PeripheralDataSize_HalfWord;  //外设数据宽度为16位
000028  0040              LSLS     r0,r0,#1
00002a  9006              STR      r0,[sp,#0x18]
;;;340    	DMA_InitStructure.DMA_MemoryDataSize      = DMA_MemoryDataSize_HalfWord;		  //内存数据宽度为16位
00002c  0080              LSLS     r0,r0,#2
00002e  9007              STR      r0,[sp,#0x1c]
;;;341    	DMA_InitStructure.DMA_Mode                = DMA_Mode_Circular; 							  //工作在循环缓存模式---不停地采集数据
000030  2020              MOVS     r0,#0x20
000032  9008              STR      r0,[sp,#0x20]
;;;342    	DMA_InitStructure.DMA_Priority            = DMA_Priority_High; 							  //DMA通道x拥有高优先级
000034  0200              LSLS     r0,r0,#8
000036  9009              STR      r0,[sp,#0x24]
;;;343    	DMA_InitStructure.DMA_M2M                 = DMA_M2M_Disable; 								  //DMA通道x没有设置为内存到内存传输
000038  2000              MOVS     r0,#0
00003a  900a              STR      r0,[sp,#0x28]
;;;344    	DMA_Init(DMA1_Channel1, &DMA_InitStructure); 																  //根据DMA_InitStruct中指定的参数初始化DMA的通道
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L2.80|
000040  f7fffffe          BL       DMA_Init
;;;345    	DMA_Cmd(DMA1_Channel1,ENABLE);																							  //使能DMA通道
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L2.80|
000048  f7fffffe          BL       DMA_Cmd
;;;346    }
00004c  b00b              ADD      sp,sp,#0x2c
00004e  bd30              POP      {r4,r5,pc}
;;;347    /*******************************************************************************
                          ENDP

                  |L2.80|
                          DCD      0x40020008
                  |L2.84|
                          DCD      0x4001244c

                          AREA ||i.ADC1_DiscConfigurationDMANR||, CODE, READONLY, ALIGN=2

                  ADC1_DiscConfigurationDMANR PROC
;;;89     *******************************************************************************/
;;;90     unsigned char ADC1_DiscConfigurationDMANR(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;91                                   unsigned char Rank,               //转换顺序
;;;92     															unsigned char	ADC_Channel_x,			//通道号
;;;93     															unsigned char	ADC_SampleTime			//采样时间周期
;;;94     															)												//ADC1规则通道组配置
;;;95     {	
000004  b087              SUB      sp,sp,#0x1c
000006  4680              MOV      r8,r0
000008  460c              MOV      r4,r1
00000a  4691              MOV      r9,r2
;;;96     	ADC_InitTypeDef 	ADC_InitStructure; 						//ADC结构体
;;;97     	GPIO_InitTypeDef 	GPIO_InitStructure;						//GPIO结构体
;;;98     	GPIO_TypeDef* GPIOx=0;
00000c  f04f0a00          MOV      r10,#0
;;;99     	u16 GPIO_Pin_x=0;  
000010  46d3              MOV      r11,r10
;;;100      unsigned char i = 0;
000012  2700              MOVS     r7,#0
;;;101      ADCList  *ADCDiscTemp = NULL;
000014  2500              MOVS     r5,#0
;;;102      ADCList  *ADCDiscNew  = (ADCList*)malloc(sizeof(ADCList));
000016  2008              MOVS     r0,#8
000018  f7fffffe          BL       malloc
00001c  4606              MOV      r6,r0
;;;103      if(NULL ==  ADCDiscNew)
00001e  b946              CBNZ     r6,|L3.50|
;;;104      {
;;;105        ADCDiscNew  = (ADCList*)malloc(sizeof(ADCList));
000020  2008              MOVS     r0,#8
000022  f7fffffe          BL       malloc
000026  4606              MOV      r6,r0
;;;106        if(NULL ==  ADCDiscNew)
000028  b91e              CBNZ     r6,|L3.50|
;;;107        {
;;;108          return 0;
00002a  2000              MOVS     r0,#0
                  |L3.44|
;;;109        }
;;;110      }
;;;111      ADCDiscNew->Rank = Rank;
;;;112      ADCDiscNew->ADC_Channel_x  = ADC_Channel_x;
;;;113      ADCDiscNew->ADC_SampleTime = ADC_SampleTime;
;;;114      ADCDiscNew->Next  = NULL;
;;;115    
;;;116      if(NULL ==  ADCDisc)
;;;117      {
;;;118        ADCDisc = ADCDiscNew;
;;;119        ChannelCount=1;
;;;120      }
;;;121      else
;;;122      {    
;;;123        ADCDiscTemp = ADCDisc;
;;;124        for(i=1;i<=ADC_Channel_17;i++)
;;;125        {
;;;126          if(NULL ==  ADCDiscTemp->Next)
;;;127          {
;;;128            ADCDiscTemp->Next = ADCDiscNew;
;;;129            ChannelCount  = i+1;
;;;130            break;
;;;131          }
;;;132          else
;;;133          {
;;;134            ADCDiscTemp = ADCDiscTemp->Next;
;;;135          }
;;;136        }    
;;;137      }
;;;138    	//由时钟控制器提供的ADCCLK时钟和PCLK2(APB2时钟)同步。
;;;139    	//RCC控制器为ADC时钟提供一个专用的可编程预分频器。
;;;140    	//1)==============================================打开ADC时钟，并设置分频因子	
;;;141    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);	//使能ADC时钟
;;;142    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);										//6分频12MHz
;;;143    	//2)==============================================根据所选的通道，打开相应GPIO时钟，配置相应GPIO为模拟输入（依据STM32F107VC引脚分布)
;;;144    	//2.1)--------------------------------------------打开相应时钟
;;;145    	if(ADC_Channel_x<=ADC_Channel_7)
;;;146    	{
;;;147    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);		//使能GPIOA时钟
;;;148    	}
;;;149    	else if(ADC_Channel_x>ADC_Channel_7&&ADC_Channel_x<=ADC_Channel_9)
;;;150    	{
;;;151    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);		//使能GPIOB时钟
;;;152    	}
;;;153    	else if(ADC_Channel_x>ADC_Channel_9&&ADC_Channel_x<=ADC_Channel_15)
;;;154    	{
;;;155    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);		//使能GPIOC时钟
;;;156    	}
;;;157    	else
;;;158    	{
;;;159    	}
;;;160    	//2.2)--------------------------------------------选择相应GPIO
;;;161    	switch (ADC_Channel_x)
;;;162    	{
;;;163    		case	ADC_Channel_0:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_0;	break;
;;;164    		case	ADC_Channel_1:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_1;	break;
;;;165    		case	ADC_Channel_2:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_2;	break;
;;;166    		case	ADC_Channel_3:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_3;	break;
;;;167    		case	ADC_Channel_4:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_4;	break;
;;;168    		case	ADC_Channel_5:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_5;	break;
;;;169    		case	ADC_Channel_6:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_6;	break;
;;;170    		case	ADC_Channel_7:	GPIOx=GPIOA;	GPIO_Pin_x=GPIO_Pin_7;	break;
;;;171    		case	ADC_Channel_8:	GPIOx=GPIOB;	GPIO_Pin_x=GPIO_Pin_0;	break;
;;;172    		case	ADC_Channel_9:	GPIOx=GPIOB;	GPIO_Pin_x=GPIO_Pin_1;	break;
;;;173    		case	ADC_Channel_10:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_0;	break;
;;;174    		case	ADC_Channel_11:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_1;	break;
;;;175    		case	ADC_Channel_12:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_2;	break;
;;;176    		case	ADC_Channel_13:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_3;	break;
;;;177    		case	ADC_Channel_14:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_4;	break;
;;;178    		case	ADC_Channel_15:	GPIOx=GPIOC;	GPIO_Pin_x=GPIO_Pin_5;	break;
;;;179    		
;;;180    		default :break;					
;;;181    	}
;;;182    	//2.3)--------------------------------------------配置GPIO
;;;183    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_x;							//GPIO_Pin_x
;;;184    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;					//模拟输入
;;;185    	GPIO_Init(GPIOx,&GPIO_InitStructure);									//GPIO初始化
;;;186    	
;;;187    	//3)==============================================设置ADC的工作模式
;;;188      ADC1_Cmd(DISABLE);
;;;189      ADC_DeInit(ADC1);
;;;190    	ADC_InitStructure.ADC_Mode 								= ADC_Mode_Independent; 			//ADC工作模式:ADC1和ADC2工作在独立模式
;;;191    	ADC_InitStructure.ADC_ScanConvMode 				=	ENABLE; 										//模数转换工作在扫描模式
;;;192    	ADC_InitStructure.ADC_ContinuousConvMode 	= ENABLE; 										//模数转换工作在连续转换模式
;;;193    	ADC_InitStructure.ADC_ExternalTrigConv 		= ADC_ExternalTrigConv_None; 	//转换由软件而不是外部触发启动--外部触发转换关闭
;;;194    	ADC_InitStructure.ADC_DataAlign 					= ADC_DataAlign_Right; 				//ADC数据右对齐(左边补充0）
;;;195    	ADC_InitStructure.ADC_NbrOfChannel 				= ChannelCount; 			        //顺序进行规则转换的ADC通道的数目
;;;196    	ADC_Init(ADC1, &ADC_InitStructure); 																		//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
;;;197    	
;;;198    	//4)==============================================设置ADC的规则系列相关信息---通道选择
;;;199      ADC1_Cmd(DISABLE);
;;;200      ADCDiscTemp = ADCDisc;
;;;201      for(i=0;i<ChannelCount;i++)
;;;202      {
;;;203        ADC_RegularChannelConfig(ADC1, ADCDiscTemp->ADC_Channel_x, ADCDiscTemp->Rank,ADCDiscTemp->ADC_SampleTime);
;;;204        if(NULL ==  ADCDiscTemp->Next)
;;;205        {
;;;206          break;
;;;207        }
;;;208        else
;;;209        {
;;;210          ADCDiscTemp = ADCDiscTemp->Next;
;;;211        }
;;;212      }
;;;213      //5)==============================================设置ADC的规则系列相关信息---通道选择
;;;214    	ADC1_DMAConfiguration((u32*)ADCBuffer,ChannelCount);  //ADC1 DMA配置	
;;;215    
;;;216      //6)==========开启ADC转换并校准
;;;217    	ADC1_Cmd(ENABLE);																		//开启ADC1转换
;;;218      return ChannelCount;     //返回通道总数
;;;219    }
00002c  b007              ADD      sp,sp,#0x1c
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.50|
000032  f8868000          STRB     r8,[r6,#0]            ;111
000036  7074              STRB     r4,[r6,#1]            ;112
000038  f8869002          STRB     r9,[r6,#2]            ;113
00003c  2000              MOVS     r0,#0                 ;114
00003e  6070              STR      r0,[r6,#4]            ;114
000040  486e              LDR      r0,|L3.508|
000042  6800              LDR      r0,[r0,#0]            ;116  ; ADCDisc
000044  b928              CBNZ     r0,|L3.82|
000046  486d              LDR      r0,|L3.508|
000048  6006              STR      r6,[r0,#0]            ;118  ; ADCDisc
00004a  2001              MOVS     r0,#1                 ;119
00004c  496c              LDR      r1,|L3.512|
00004e  7008              STRB     r0,[r1,#0]            ;119
000050  e010              B        |L3.116|
                  |L3.82|
000052  486a              LDR      r0,|L3.508|
000054  6805              LDR      r5,[r0,#0]            ;123  ; ADCDisc
000056  2701              MOVS     r7,#1                 ;124
000058  e009              B        |L3.110|
                  |L3.90|
00005a  6868              LDR      r0,[r5,#4]            ;126
00005c  b920              CBNZ     r0,|L3.104|
00005e  606e              STR      r6,[r5,#4]            ;128
000060  1c78              ADDS     r0,r7,#1              ;129
000062  4967              LDR      r1,|L3.512|
000064  7008              STRB     r0,[r1,#0]            ;129
000066  e004              B        |L3.114|
                  |L3.104|
000068  686d              LDR      r5,[r5,#4]            ;134
00006a  1c78              ADDS     r0,r7,#1              ;124
00006c  b2c7              UXTB     r7,r0                 ;124
                  |L3.110|
00006e  2f11              CMP      r7,#0x11              ;124
000070  ddf3              BLE      |L3.90|
                  |L3.114|
000072  bf00              NOP                            ;130
                  |L3.116|
000074  2101              MOVS     r1,#1                 ;141
000076  0248              LSLS     r0,r1,#9              ;141
000078  f7fffffe          BL       RCC_APB2PeriphClockCmd
00007c  f44f4000          MOV      r0,#0x8000            ;142
000080  f7fffffe          BL       RCC_ADCCLKConfig
000084  2c07              CMP      r4,#7                 ;145
000086  dc04              BGT      |L3.146|
000088  2101              MOVS     r1,#1                 ;147
00008a  2004              MOVS     r0,#4                 ;147
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
000090  e010              B        |L3.180|
                  |L3.146|
000092  2c07              CMP      r4,#7                 ;149
000094  dd06              BLE      |L3.164|
000096  2c09              CMP      r4,#9                 ;149
000098  dc04              BGT      |L3.164|
00009a  2101              MOVS     r1,#1                 ;151
00009c  2008              MOVS     r0,#8                 ;151
00009e  f7fffffe          BL       RCC_APB2PeriphClockCmd
0000a2  e007              B        |L3.180|
                  |L3.164|
0000a4  2c09              CMP      r4,#9                 ;153
0000a6  dd05              BLE      |L3.180|
0000a8  2c0f              CMP      r4,#0xf               ;153
0000aa  dc03              BGT      |L3.180|
0000ac  2101              MOVS     r1,#1                 ;155
0000ae  2010              MOVS     r0,#0x10              ;155
0000b0  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L3.180|
0000b4  2c10              CMP      r4,#0x10              ;161
0000b6  d259              BCS      |L3.364|
0000b8  e8dff004          TBB      [pc,r4]               ;161
0000bc  080d1217          DCB      0x08,0x0d,0x12,0x17
0000c0  1c21262b          DCB      0x1c,0x21,0x26,0x2b
0000c4  30353a3f          DCB      0x30,0x35,0x3a,0x3f
0000c8  44494e53          DCB      0x44,0x49,0x4e,0x53
0000cc  f8dfa134          LDR      r10,|L3.516|
0000d0  f04f0b01          MOV      r11,#1                ;163
0000d4  e04b              B        |L3.366|
0000d6  f8dfa12c          LDR      r10,|L3.516|
0000da  f04f0b02          MOV      r11,#2                ;164
0000de  e046              B        |L3.366|
0000e0  f8dfa120          LDR      r10,|L3.516|
0000e4  f04f0b04          MOV      r11,#4                ;165
0000e8  e041              B        |L3.366|
0000ea  f8dfa118          LDR      r10,|L3.516|
0000ee  f04f0b08          MOV      r11,#8                ;166
0000f2  e03c              B        |L3.366|
0000f4  f8dfa10c          LDR      r10,|L3.516|
0000f8  f04f0b10          MOV      r11,#0x10             ;167
0000fc  e037              B        |L3.366|
0000fe  f8dfa104          LDR      r10,|L3.516|
000102  f04f0b20          MOV      r11,#0x20             ;168
000106  e032              B        |L3.366|
000108  f8dfa0f8          LDR      r10,|L3.516|
00010c  f04f0b40          MOV      r11,#0x40             ;169
000110  e02d              B        |L3.366|
000112  f8dfa0f0          LDR      r10,|L3.516|
000116  f04f0b80          MOV      r11,#0x80             ;170
00011a  e028              B        |L3.366|
00011c  f8dfa0e8          LDR      r10,|L3.520|
000120  f04f0b01          MOV      r11,#1                ;171
000124  e023              B        |L3.366|
000126  f8dfa0e0          LDR      r10,|L3.520|
00012a  f04f0b02          MOV      r11,#2                ;172
00012e  e01e              B        |L3.366|
000130  f8dfa0d8          LDR      r10,|L3.524|
000134  f04f0b01          MOV      r11,#1                ;173
000138  e019              B        |L3.366|
00013a  f8dfa0d0          LDR      r10,|L3.524|
00013e  f04f0b02          MOV      r11,#2                ;174
000142  e014              B        |L3.366|
000144  f8dfa0c4          LDR      r10,|L3.524|
000148  f04f0b04          MOV      r11,#4                ;175
00014c  e00f              B        |L3.366|
00014e  f8dfa0bc          LDR      r10,|L3.524|
000152  f04f0b08          MOV      r11,#8                ;176
000156  e00a              B        |L3.366|
000158  f8dfa0b0          LDR      r10,|L3.524|
00015c  f04f0b10          MOV      r11,#0x10             ;177
000160  e005              B        |L3.366|
000162  f8dfa0a8          LDR      r10,|L3.524|
000166  f04f0b20          MOV      r11,#0x20             ;178
00016a  e000              B        |L3.366|
                  |L3.364|
00016c  bf00              NOP                            ;180
                  |L3.366|
00016e  bf00              NOP                            ;163
000170  f8adb004          STRH     r11,[sp,#4]           ;183
000174  2000              MOVS     r0,#0                 ;184
000176  f88d0007          STRB     r0,[sp,#7]            ;184
00017a  a901              ADD      r1,sp,#4              ;185
00017c  4650              MOV      r0,r10                ;185
00017e  f7fffffe          BL       GPIO_Init
000182  2000              MOVS     r0,#0                 ;188
000184  f7fffffe          BL       ADC1_Cmd
000188  4821              LDR      r0,|L3.528|
00018a  f7fffffe          BL       ADC_DeInit
00018e  2000              MOVS     r0,#0                 ;190
000190  9002              STR      r0,[sp,#8]            ;190
000192  2001              MOVS     r0,#1                 ;191
000194  f88d000c          STRB     r0,[sp,#0xc]          ;191
000198  f88d000d          STRB     r0,[sp,#0xd]          ;192
00019c  f44f2060          MOV      r0,#0xe0000           ;193
0001a0  9004              STR      r0,[sp,#0x10]         ;193
0001a2  2000              MOVS     r0,#0                 ;194
0001a4  9005              STR      r0,[sp,#0x14]         ;194
0001a6  4816              LDR      r0,|L3.512|
0001a8  7800              LDRB     r0,[r0,#0]            ;195  ; ChannelCount
0001aa  f88d0018          STRB     r0,[sp,#0x18]         ;195
0001ae  a902              ADD      r1,sp,#8              ;196
0001b0  4817              LDR      r0,|L3.528|
0001b2  f7fffffe          BL       ADC_Init
0001b6  2000              MOVS     r0,#0                 ;199
0001b8  f7fffffe          BL       ADC1_Cmd
0001bc  480f              LDR      r0,|L3.508|
0001be  6805              LDR      r5,[r0,#0]            ;200  ; ADCDisc
0001c0  2700              MOVS     r7,#0                 ;201
0001c2  e00b              B        |L3.476|
                  |L3.452|
0001c4  78ab              LDRB     r3,[r5,#2]            ;203
0001c6  782a              LDRB     r2,[r5,#0]            ;203
0001c8  7869              LDRB     r1,[r5,#1]            ;203
0001ca  4811              LDR      r0,|L3.528|
0001cc  f7fffffe          BL       ADC_RegularChannelConfig
0001d0  6868              LDR      r0,[r5,#4]            ;204
0001d2  b900              CBNZ     r0,|L3.470|
0001d4  e006              B        |L3.484|
                  |L3.470|
0001d6  686d              LDR      r5,[r5,#4]            ;210
0001d8  1c78              ADDS     r0,r7,#1              ;201
0001da  b2c7              UXTB     r7,r0                 ;201
                  |L3.476|
0001dc  4808              LDR      r0,|L3.512|
0001de  7800              LDRB     r0,[r0,#0]            ;201  ; ChannelCount
0001e0  4287              CMP      r7,r0                 ;201
0001e2  dbef              BLT      |L3.452|
                  |L3.484|
0001e4  bf00              NOP                            ;206
0001e6  4806              LDR      r0,|L3.512|
0001e8  7801              LDRB     r1,[r0,#0]            ;214  ; ChannelCount
0001ea  480a              LDR      r0,|L3.532|
0001ec  f7fffffe          BL       ADC1_DMAConfiguration
0001f0  2001              MOVS     r0,#1                 ;217
0001f2  f7fffffe          BL       ADC1_Cmd
0001f6  4802              LDR      r0,|L3.512|
0001f8  7800              LDRB     r0,[r0,#0]            ;218  ; ChannelCount
0001fa  e717              B        |L3.44|
;;;220    /*******************************************************************************
                          ENDP

                  |L3.508|
                          DCD      ADCDisc
                  |L3.512|
                          DCD      ChannelCount
                  |L3.516|
                          DCD      0x40010800
                  |L3.520|
                          DCD      0x40010c00
                  |L3.524|
                          DCD      0x40011000
                  |L3.528|
                          DCD      0x40012400
                  |L3.532|
                          DCD      ADCBuffer

                          AREA ||i.ADC1_DiscGetData||, CODE, READONLY, ALIGN=2

                  ADC1_DiscGetData PROC
;;;228    *******************************************************************************/
;;;229    unsigned char ADC1_DiscGetData(unsigned short* DataBuffer)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231      if(NULL !=  ADCBuffer)
;;;232      {
;;;233        memcpy(DataBuffer,ADCBuffer,ChannelCount*2);
000004  4804              LDR      r0,|L4.24|
000006  7800              LDRB     r0,[r0,#0]  ; ChannelCount
000008  0042              LSLS     r2,r0,#1
00000a  4904              LDR      r1,|L4.28|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       __aeabi_memcpy
;;;234        return ChannelCount;
000012  4801              LDR      r0,|L4.24|
000014  7800              LDRB     r0,[r0,#0]  ; ChannelCount
;;;235      }
;;;236      else
;;;237      {
;;;238        return 0;
;;;239      }
;;;240    }
000016  bd10              POP      {r4,pc}
;;;241    
                          ENDP

                  |L4.24|
                          DCD      ChannelCount
                  |L4.28|
                          DCD      ADCBuffer

                          AREA ||i.ADC1_InitStructure||, CODE, READONLY, ALIGN=2

                  ADC1_InitStructure PROC
;;;307    *******************************************************************************/
;;;308    void ADC1_InitStructure(u8 ADC_NbrOfChannel)				//ADC初始化
000000  b510              PUSH     {r4,lr}
;;;309    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;310    	ADC_InitTypeDef ADC_InitStructure; 						//ADC结构体
;;;311    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; 													//ADC工作模式:ADC1和ADC2工作在独立模式
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;312    	ADC_InitStructure.ADC_ScanConvMode =ENABLE; 																//模数转换工作在扫描模式
00000a  2001              MOVS     r0,#1
00000c  f88d0008          STRB     r0,[sp,#8]
;;;313    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; 													//模数转换工作在连续转换模式
000010  f88d0009          STRB     r0,[sp,#9]
;;;314    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; 				//转换由软件而不是外部触发启动--外部触发转换关闭
000014  f44f2060          MOV      r0,#0xe0000
000018  9003              STR      r0,[sp,#0xc]
;;;315    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; 											//ADC数据右对齐(左边补充0）
00001a  2000              MOVS     r0,#0
00001c  9004              STR      r0,[sp,#0x10]
;;;316    	ADC_InitStructure.ADC_NbrOfChannel = ADC_NbrOfChannel; 											//顺序进行规则转换的ADC通道的数目
00001e  f88d4014          STRB     r4,[sp,#0x14]
;;;317    	ADC_Init(ADC1, &ADC_InitStructure); 																				//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
000022  a901              ADD      r1,sp,#4
000024  4802              LDR      r0,|L5.48|
000026  f7fffffe          BL       ADC_Init
;;;318    }
00002a  b006              ADD      sp,sp,#0x18
00002c  bd10              POP      {r4,pc}
;;;319    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      0x40012400

                          AREA ||i.ADC1_InjectedConfiguration||, CODE, READONLY, ALIGN=1

                  ADC1_InjectedConfiguration PROC
;;;77     *******************************************************************************/
;;;78     void ADC1_InjectedConfiguration(void)			//ADC1注入通道组配置
000000  4770              BX       lr
;;;79     {	
;;;80     }
;;;81     /*******************************************************************************
                          ENDP


                          AREA ||i.ADC_TempSensorConfiguration||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorConfiguration PROC
;;;249    *******************************************************************************/
;;;250    void ADC_TempSensorConfiguration(u32 *ADC_DATA)
000000  b510              PUSH     {r4,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);			//使能ADC时钟
000004  2101              MOVS     r1,#1
000006  0248              LSLS     r0,r1,#9
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;253    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   										//分频因子6时钟为72M/6=12MHz
00000c  f44f4000          MOV      r0,#0x8000
000010  f7fffffe          BL       RCC_ADCCLKConfig
;;;254    	ADC1_InitStructure(1);																	//ADC初始化
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       ADC1_InitStructure
;;;255    	ADC_RegularChannelConfig(ADC1, ADC_Channel_16, 1,ADC_SampleTime_239Cycles5);	//选择ADC，通道，顺序及转换周期
00001a  2307              MOVS     r3,#7
00001c  2201              MOVS     r2,#1
00001e  2110              MOVS     r1,#0x10
000020  4813              LDR      r0,|L7.112|
000022  f7fffffe          BL       ADC_RegularChannelConfig
;;;256    	ADC1_DMAConfiguration(ADC_DATA,1); 											//ADC1_DMA配置
000026  2101              MOVS     r1,#1
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       ADC1_DMAConfiguration
;;;257    	ADC_DMACmd(ADC1, ENABLE);   														//ADC命令，使能DMA的ADC转换
00002e  2101              MOVS     r1,#1
000030  480f              LDR      r0,|L7.112|
000032  f7fffffe          BL       ADC_DMACmd
;;;258    	ADC_TempSensorVrefintCmd(ENABLE);												//使能温度传感器和内部参考电压通道	
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       ADC_TempSensorVrefintCmd
;;;259    	ADC1_Cmd(ENABLE);																				//开启ADC1转换
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       ADC1_Cmd
;;;260    	
;;;261    	ADC_ResetCalibration(ADC1);   													//重新校准
000042  480b              LDR      r0,|L7.112|
000044  f7fffffe          BL       ADC_ResetCalibration
;;;262    	while(ADC_GetResetCalibrationStatus(ADC1)); 	 					//等待重新校准完成
000048  bf00              NOP      
                  |L7.74|
00004a  4809              LDR      r0,|L7.112|
00004c  f7fffffe          BL       ADC_GetResetCalibrationStatus
000050  2800              CMP      r0,#0
000052  d1fa              BNE      |L7.74|
;;;263    	ADC_StartCalibration(ADC1); 														//开始校准
000054  4806              LDR      r0,|L7.112|
000056  f7fffffe          BL       ADC_StartCalibration
;;;264    	while(ADC_GetCalibrationStatus(ADC1));    							//等待校准完成
00005a  bf00              NOP      
                  |L7.92|
00005c  4804              LDR      r0,|L7.112|
00005e  f7fffffe          BL       ADC_GetCalibrationStatus
000062  2800              CMP      r0,#0
000064  d1fa              BNE      |L7.92|
;;;265    	ADC_SoftwareStartConvCmd(ADC1, ENABLE); 								//连续转换开始，ADC通过DMA方式不断的更新RAM区。
000066  2101              MOVS     r1,#1
000068  4801              LDR      r0,|L7.112|
00006a  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;266    	
;;;267    //	ADC_InitTypeDef ADC_InitStructure; 
;;;268    //	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1    , ENABLE );   //使能GPIOA,ADC1通道时钟
;;;269    //	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   //分频因子6时钟为72M/6=12MHz
;;;270    //	ADC_DeInit(ADC1);  //将外设 ADC1 的全部寄存器重设为缺省值
;;;271    //	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  //ADC工作模式:ADC1和ADC2工作在独立模式
;;;272    //	ADC_InitStructure.ADC_ScanConvMode = DISABLE;   //模数转换工作在单通道模式
;;;273    //	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式
;;;274    //	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动
;;;275    //	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;  //ADC数据右对齐
;;;276    //	ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目
;;;277    //	ADC_Init(ADC1, &ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
;;;278    //	ADC_TempSensorVrefintCmd(ENABLE); //开启内部温度传感器
;;;279    //	ADC_Cmd(ADC1, ENABLE);  //使能指定的ADC1
;;;280    //	ADC_ResetCalibration(ADC1); //重置指定的ADC1的复位寄存器
;;;281    //	while(ADC_GetResetCalibrationStatus(ADC1)); //获取ADC1重置校准寄存器的状态,设置状态则等待
;;;282    //	ADC_StartCalibration(ADC1);
;;;283    //	while(ADC_GetCalibrationStatus(ADC1));      //获取指定ADC1的校准程序,设置状态则等待
;;;284    }
00006e  bd10              POP      {r4,pc}
;;;285    /*******************************************************************************
                          ENDP

                  |L7.112|
                          DCD      0x40012400

                          AREA ||i.Get_ADC_Temperature||, CODE, READONLY, ALIGN=2

                  Get_ADC_Temperature PROC
;;;292    *******************************************************************************/
;;;293    float Get_ADC_Temperature(u32 ADC_DATA)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;294    {
000004  b088              SUB      sp,sp,#0x20
;;;295    	float Result=0.0;
000006  2000              MOVS     r0,#0
000008  9006              STR      r0,[sp,#0x18]
;;;296    	Result=(1.43-(ADC_DATA*3.3)/4096)*1000/4.35 + 25;
00000a  9808              LDR      r0,[sp,#0x20]
00000c  f7fffffe          BL       __aeabi_ui2d
000010  4680              MOV      r8,r0
000012  f04f3266          MOV      r2,#0x66666666
000016  4b14              LDR      r3,|L8.104|
000018  f7fffffe          BL       __aeabi_dmul
00001c  4606              MOV      r6,r0
00001e  2200              MOVS     r2,#0
000020  4b12              LDR      r3,|L8.108|
000022  f7fffffe          BL       __aeabi_ddiv
000026  4a12              LDR      r2,|L8.112|
000028  4b12              LDR      r3,|L8.116|
00002a  e9cd0100          STRD     r0,r1,[sp,#0]
00002e  f7fffffe          BL       __aeabi_drsub
000032  2200              MOVS     r2,#0
000034  4b10              LDR      r3,|L8.120|
000036  e9cd0102          STRD     r0,r1,[sp,#8]
00003a  f7fffffe          BL       __aeabi_dmul
00003e  f04f3266          MOV      r2,#0x66666666
000042  4b0e              LDR      r3,|L8.124|
000044  e9cd0104          STRD     r0,r1,[sp,#0x10]
000048  f7fffffe          BL       __aeabi_ddiv
00004c  4604              MOV      r4,r0
00004e  2200              MOVS     r2,#0
000050  4b0b              LDR      r3,|L8.128|
000052  f7fffffe          BL       __aeabi_dadd
000056  4682              MOV      r10,r0
000058  f7fffffe          BL       __aeabi_d2f
00005c  9006              STR      r0,[sp,#0x18]
;;;297    	return (float)Result;
00005e  9806              LDR      r0,[sp,#0x18]
;;;298    
;;;299    }
000060  b009              ADD      sp,sp,#0x24
000062  e8bd8ff0          POP      {r4-r11,pc}
;;;300    
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      0x400a6666
                  |L8.108|
                          DCD      0x40b00000
                  |L8.112|
                          DCD      0xae147ae1
                  |L8.116|
                          DCD      0x3ff6e147
                  |L8.120|
                          DCD      0x408f4000
                  |L8.124|
                          DCD      0x40116666
                  |L8.128|
                          DCD      0x40390000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ADCBuffer
                          %        36

                          AREA ||.data||, DATA, ALIGN=2

                  ADCDisc
                          DCD      0x00000000
                  ChannelCount
000004  00                DCB      0x00
