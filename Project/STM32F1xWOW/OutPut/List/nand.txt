; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\nand.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\nand.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\nand.crf ..\..\Driver\Components\SCR\NAND.C]
                          THUMB

                          AREA ||i.NAND_Initialize||, CODE, READONLY, ALIGN=2

                  NAND_Initialize PROC
;;;79     *******************************************************************************/
;;;80     void NAND_Initialize(void)
000000  2101              MOVS     r1,#1
;;;81     {
;;;82     //  mysysinit();//RCC初始化，系统时钟设置72MHZ
;;;83       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);//使能APB2的GPIO_D时钟
000002  2020              MOVS     r0,#0x20
000004  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;84       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG, ENABLE);//使能APB2的GPIO_D时钟
000008  2101              MOVS     r1,#1
00000a  0208              LSLS     r0,r1,#8
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;85       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);//使能APB2的GPIO_B时钟
000010  2101              MOVS     r1,#1
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;86       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);//使能APB2的GPIO_E时钟
000018  2101              MOVS     r1,#1
00001a  2040              MOVS     r0,#0x40
00001c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;87       RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);//使能APB2的GPIO_E时钟
000020  2101              MOVS     r1,#1
000022  4608              MOV      r0,r1
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;88       RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//使能APB1的USART2时钟
000028  2101              MOVS     r1,#1
00002a  0388              LSLS     r0,r1,#14
00002c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;89       /* led*/
;;;90     //  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9| GPIO_Pin_10| GPIO_Pin_11;
;;;91     //  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;92     //  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;93     //  GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;94       /* 设置PB.5用于控制NAND的为上拉输入 RB */
;;;95       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000030  2040              MOVS     r0,#0x40
000032  4916              LDR      r1,|L1.140|
000034  8008              STRH     r0,[r1,#0]
;;;96       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000036  2003              MOVS     r0,#3
000038  7088              STRB     r0,[r1,#2]
;;;97       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00003a  2048              MOVS     r0,#0x48
00003c  70c8              STRB     r0,[r1,#3]
;;;98       GPIO_Init(GPIOD, &GPIO_InitStructure);
00003e  4814              LDR      r0,|L1.144|
000040  f7fffffe          BL       GPIO_Init
;;;99       /* 设置PD口用于控制NAND的为输出 */
;;;100      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6| GPIO_Pin_7| GPIO_Pin_14| GPIO_Pin_15;
000044  f24c00e0          MOV      r0,#0xc0e0
000048  4910              LDR      r1,|L1.140|
00004a  8008              STRH     r0,[r1,#0]
;;;101      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00004c  2003              MOVS     r0,#3
00004e  7088              STRB     r0,[r1,#2]
;;;102      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000050  2010              MOVS     r0,#0x10
000052  70c8              STRB     r0,[r1,#3]
;;;103      GPIO_Init(GPIOD, &GPIO_InitStructure);
000054  480e              LDR      r0,|L1.144|
000056  f7fffffe          BL       GPIO_Init
;;;104    //  my_USART_init();  
;;;105           
;;;106    
;;;107      wait_NAND_readay();//忙则等待；
00005a  f7fffffe          BL       wait_NAND_readay
;;;108    
;;;109      my_send_byte(0);
00005e  2000              MOVS     r0,#0
000060  f7fffffe          BL       my_send_byte
;;;110      my_send_byte(1);
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       my_send_byte
;;;111      my_send_byte(2);
00006a  2002              MOVS     r0,#2
00006c  f7fffffe          BL       my_send_byte
;;;112      my_send_byte(3);
000070  2003              MOVS     r0,#3
000072  f7fffffe          BL       my_send_byte
;;;113      
;;;114      READ_NAND_ID(); //读闪存ID
000076  f7fffffe          BL       READ_NAND_ID
;;;115      erase_NAND_BLOK();//擦除闪存的一个块
00007a  f7fffffe          BL       erase_NAND_BLOK
;;;116      write_NAND_PAGE();//写一个页
00007e  f7fffffe          BL       write_NAND_PAGE
;;;117    
;;;118      read_NAND_PAGE();//读一个页
000082  f7fffffe          BL       read_NAND_PAGE
;;;119      while(1);
000086  bf00              NOP      
                  |L1.136|
000088  e7fe              B        |L1.136|
;;;120    
;;;121    
;;;122    }
;;;123    /*擦除一个块*/
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      GPIO_InitStructure
                  |L1.144|
                          DCD      0x40011400

                          AREA ||i.READ_NAND_ID||, CODE, READONLY, ALIGN=2

                  READ_NAND_ID PROC
;;;326    /*读取NAND闪存的ID序列号串口发送*/
;;;327    void READ_NAND_ID()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;328    {
;;;329    
;;;330      uint8_t a=0,b=0,c=0,d=0;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;331    
;;;332      
;;;333       /* 设置PD口用于控制NAND的为输出 */
;;;334      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6| GPIO_Pin_7| GPIO_Pin_14| GPIO_Pin_15;
00000c  f24c00e0          MOV      r0,#0xc0e0
000010  494c              LDR      r1,|L2.324|
000012  8008              STRH     r0,[r1,#0]
;;;335      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  7088              STRB     r0,[r1,#2]
;;;336      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  70c8              STRB     r0,[r1,#3]
;;;337      GPIO_Init(GPIOD, &GPIO_InitStructure);
00001c  484a              LDR      r0,|L2.328|
00001e  f7fffffe          BL       GPIO_Init
;;;338    /*设置PE口得低八位为输出*/
;;;339      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2| GPIO_Pin_3| GPIO_Pin_4|GPIO_Pin_5 | GPIO_Pin_6| GPIO_Pin_7;
000022  20ff              MOVS     r0,#0xff
000024  4947              LDR      r1,|L2.324|
000026  8008              STRH     r0,[r1,#0]
;;;340      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000028  2003              MOVS     r0,#3
00002a  7088              STRB     r0,[r1,#2]
;;;341      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00002c  2010              MOVS     r0,#0x10
00002e  70c8              STRB     r0,[r1,#3]
;;;342      GPIO_Init(GPIOE, &GPIO_InitStructure);
000030  4846              LDR      r0,|L2.332|
000032  f7fffffe          BL       GPIO_Init
;;;343    
;;;344    
;;;345      CLR_CE;//开启片选
000036  f44f6180          MOV      r1,#0x400
00003a  4845              LDR      r0,|L2.336|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;346    
;;;347    
;;;348      SET_CLE;//命令锁存开启
000040  f44f6100          MOV      r1,#0x800
000044  4840              LDR      r0,|L2.328|
000046  f7fffffe          BL       GPIO_SetBits
;;;349      CLR_WE;//写使能
00004a  2120              MOVS     r1,#0x20
00004c  483e              LDR      r0,|L2.328|
00004e  f7fffffe          BL       GPIO_ResetBits
;;;350      CLR_ALE;//地址锁存关闭
000052  f44f5180          MOV      r1,#0x1000
000056  483c              LDR      r0,|L2.328|
000058  f7fffffe          BL       GPIO_ResetBits
;;;351      SET_RE;//读关闭
00005c  2110              MOVS     r1,#0x10
00005e  483a              LDR      r0,|L2.328|
000060  f7fffffe          BL       GPIO_SetBits
;;;352      GPIO_Write(GPIOE, 0x90); //读ID命令
000064  2190              MOVS     r1,#0x90
000066  4839              LDR      r0,|L2.332|
000068  f7fffffe          BL       GPIO_Write
;;;353      SET_WE;//关闭写
00006c  2120              MOVS     r1,#0x20
00006e  4836              LDR      r0,|L2.328|
000070  f7fffffe          BL       GPIO_SetBits
;;;354    
;;;355      CLR_CLE;
000074  f44f6100          MOV      r1,#0x800
000078  4833              LDR      r0,|L2.328|
00007a  f7fffffe          BL       GPIO_ResetBits
;;;356      SET_ALE;
00007e  f44f5180          MOV      r1,#0x1000
000082  4831              LDR      r0,|L2.328|
000084  f7fffffe          BL       GPIO_SetBits
;;;357      CLR_WE;
000088  2120              MOVS     r1,#0x20
00008a  482f              LDR      r0,|L2.328|
00008c  f7fffffe          BL       GPIO_ResetBits
;;;358      GPIO_Write(GPIOE, 0x00); //地址00
000090  2100              MOVS     r1,#0
000092  482e              LDR      r0,|L2.332|
000094  f7fffffe          BL       GPIO_Write
;;;359      SET_WE;
000098  2120              MOVS     r1,#0x20
00009a  482b              LDR      r0,|L2.328|
00009c  f7fffffe          BL       GPIO_SetBits
;;;360    
;;;361    
;;;362    
;;;363    
;;;364      /*设置PE口得低八位为输入*/
;;;365      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2| GPIO_Pin_3| GPIO_Pin_4|GPIO_Pin_7 | GPIO_Pin_6| GPIO_Pin_7;
0000a0  20df              MOVS     r0,#0xdf
0000a2  4928              LDR      r1,|L2.324|
0000a4  8008              STRH     r0,[r1,#0]
;;;366      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a6  2003              MOVS     r0,#3
0000a8  7088              STRB     r0,[r1,#2]
;;;367      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
0000aa  2048              MOVS     r0,#0x48
0000ac  70c8              STRB     r0,[r1,#3]
;;;368      GPIO_Init(GPIOE, &GPIO_InitStructure);
0000ae  4827              LDR      r0,|L2.332|
0000b0  f7fffffe          BL       GPIO_Init
;;;369    
;;;370      CLR_ALE; //注意啊，这里一定把他放在下面应为是有时间要求的；时序图TAR=15纳秒之后才是RE的操作；
0000b4  f44f5180          MOV      r1,#0x1000
0000b8  4823              LDR      r0,|L2.328|
0000ba  f7fffffe          BL       GPIO_ResetBits
;;;371           //读出的结果是AD F1 80 1D ，2011年8月26日，与天津第四项目部宿舍
;;;372         //AD F1,不用关心，80 1D代表本闪存为8位组织结构，页面大小为2KB，快大小为128KB，备用区为每512字节有16字节
;;;373      CLR_RE;
0000be  2110              MOVS     r1,#0x10
0000c0  4821              LDR      r0,|L2.328|
0000c2  f7fffffe          BL       GPIO_ResetBits
;;;374    
;;;375      a=(GPIOE->IDR);//读出数据
0000c6  4821              LDR      r0,|L2.332|
0000c8  3008              ADDS     r0,r0,#8
0000ca  6800              LDR      r0,[r0,#0]
0000cc  b2c4              UXTB     r4,r0
;;;376      SET_RE;
0000ce  2110              MOVS     r1,#0x10
0000d0  481d              LDR      r0,|L2.328|
0000d2  f7fffffe          BL       GPIO_SetBits
;;;377    
;;;378      CLR_RE;
0000d6  2110              MOVS     r1,#0x10
0000d8  481b              LDR      r0,|L2.328|
0000da  f7fffffe          BL       GPIO_ResetBits
;;;379      b=(GPIOE->IDR);
0000de  481b              LDR      r0,|L2.332|
0000e0  3008              ADDS     r0,r0,#8
0000e2  6800              LDR      r0,[r0,#0]
0000e4  b2c5              UXTB     r5,r0
;;;380      SET_RE;
0000e6  2110              MOVS     r1,#0x10
0000e8  4817              LDR      r0,|L2.328|
0000ea  f7fffffe          BL       GPIO_SetBits
;;;381    
;;;382      CLR_RE;
0000ee  2110              MOVS     r1,#0x10
0000f0  4815              LDR      r0,|L2.328|
0000f2  f7fffffe          BL       GPIO_ResetBits
;;;383      c=(GPIOE->IDR);
0000f6  4815              LDR      r0,|L2.332|
0000f8  3008              ADDS     r0,r0,#8
0000fa  6800              LDR      r0,[r0,#0]
0000fc  b2c6              UXTB     r6,r0
;;;384      SET_RE;
0000fe  2110              MOVS     r1,#0x10
000100  4811              LDR      r0,|L2.328|
000102  f7fffffe          BL       GPIO_SetBits
;;;385    
;;;386      CLR_RE;
000106  2110              MOVS     r1,#0x10
000108  480f              LDR      r0,|L2.328|
00010a  f7fffffe          BL       GPIO_ResetBits
;;;387      d=(GPIOE->IDR);//delay_1us(1);
00010e  480f              LDR      r0,|L2.332|
000110  3008              ADDS     r0,r0,#8
000112  6800              LDR      r0,[r0,#0]
000114  b2c7              UXTB     r7,r0
;;;388      SET_RE;
000116  2110              MOVS     r1,#0x10
000118  480b              LDR      r0,|L2.328|
00011a  f7fffffe          BL       GPIO_SetBits
;;;389    
;;;390    
;;;391      SET_CE;//关闭片选
00011e  f44f6180          MOV      r1,#0x400
000122  480b              LDR      r0,|L2.336|
000124  f7fffffe          BL       GPIO_SetBits
;;;392    
;;;393      my_send_byte(a);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       my_send_byte
;;;394      my_send_byte(b);
00012e  4628              MOV      r0,r5
000130  f7fffffe          BL       my_send_byte
;;;395      my_send_byte(c);
000134  4630              MOV      r0,r6
000136  f7fffffe          BL       my_send_byte
;;;396      my_send_byte(d);
00013a  4638              MOV      r0,r7
00013c  f7fffffe          BL       my_send_byte
;;;397    }
000140  e8bd81f0          POP      {r4-r8,pc}
;;;398    /*写一个命令*/
                          ENDP

                  |L2.324|
                          DCD      GPIO_InitStructure
                  |L2.328|
                          DCD      0x40011400
                  |L2.332|
                          DCD      0x40011800
                  |L2.336|
                          DCD      0x40012000

                          AREA ||i.delay_1us||, CODE, READONLY, ALIGN=1

                  delay_1us PROC
;;;457    *********************/
;;;458    void delay_1us(uint32_t time)
000000  4601              MOV      r1,r0
;;;459    {   
;;;460      uint32_t b,c;
;;;461      for(c=time;c;c--) //定时=time*3*333.6=time*1000.8ns
000002  e005              B        |L3.16|
                  |L3.4|
;;;462      {     
;;;463        for(b=8;b;b--); //8*13.9*3= 333.6     
000004  2208              MOVS     r2,#8
000006  e000              B        |L3.10|
                  |L3.8|
000008  1e52              SUBS     r2,r2,#1
                  |L3.10|
00000a  2a00              CMP      r2,#0
00000c  d1fc              BNE      |L3.8|
00000e  1e49              SUBS     r1,r1,#1              ;461
                  |L3.16|
000010  2900              CMP      r1,#0                 ;461
000012  d1f7              BNE      |L3.4|
;;;464      }
;;;465    }
000014  4770              BX       lr
;;;466    /***********************************
                          ENDP


                          AREA ||i.erase_NAND_BLOK||, CODE, READONLY, ALIGN=2

                  erase_NAND_BLOK PROC
;;;123    /*擦除一个块*/
;;;124    void erase_NAND_BLOK()
000000  b570              PUSH     {r4-r6,lr}
;;;125    { uint8_t e,m;
;;;126    
;;;127    
;;;128    
;;;129    /*设置PE口得低八位为输出*/
;;;130      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2| GPIO_Pin_3| GPIO_Pin_4|GPIO_Pin_5 | GPIO_Pin_6| GPIO_Pin_7;
000002  20ff              MOVS     r0,#0xff
000004  4954              LDR      r1,|L4.344|
000006  8008              STRH     r0,[r1,#0]
;;;131      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000008  2003              MOVS     r0,#3
00000a  7088              STRB     r0,[r1,#2]
;;;132      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000c  2010              MOVS     r0,#0x10
00000e  70c8              STRB     r0,[r1,#3]
;;;133      GPIO_Init(GPIOE, &GPIO_InitStructure);
000010  4852              LDR      r0,|L4.348|
000012  f7fffffe          BL       GPIO_Init
;;;134      
;;;135      SET_WE;
000016  2120              MOVS     r1,#0x20
000018  4851              LDR      r0,|L4.352|
00001a  f7fffffe          BL       GPIO_SetBits
;;;136      SET_RE;
00001e  2110              MOVS     r1,#0x10
000020  484f              LDR      r0,|L4.352|
000022  f7fffffe          BL       GPIO_SetBits
;;;137      CLR_ALE;  //初始化
000026  f44f5180          MOV      r1,#0x1000
00002a  484d              LDR      r0,|L4.352|
00002c  f7fffffe          BL       GPIO_ResetBits
;;;138      CLR_CLE;
000030  f44f6100          MOV      r1,#0x800
000034  484a              LDR      r0,|L4.352|
000036  f7fffffe          BL       GPIO_ResetBits
;;;139    
;;;140      CLR_CE;
00003a  f44f6180          MOV      r1,#0x400
00003e  4849              LDR      r0,|L4.356|
000040  f7fffffe          BL       GPIO_ResetBits
;;;141      SET_CLE;
000044  f44f6100          MOV      r1,#0x800
000048  4845              LDR      r0,|L4.352|
00004a  f7fffffe          BL       GPIO_SetBits
;;;142      CLR_ALE;
00004e  f44f5180          MOV      r1,#0x1000
000052  4843              LDR      r0,|L4.352|
000054  f7fffffe          BL       GPIO_ResetBits
;;;143      CLR_WE;
000058  2120              MOVS     r1,#0x20
00005a  4841              LDR      r0,|L4.352|
00005c  f7fffffe          BL       GPIO_ResetBits
;;;144      GPIO_Write(GPIOE, 0x60); //命令
000060  2160              MOVS     r1,#0x60
000062  483e              LDR      r0,|L4.348|
000064  f7fffffe          BL       GPIO_Write
;;;145      SET_WE;
000068  2120              MOVS     r1,#0x20
00006a  483d              LDR      r0,|L4.352|
00006c  f7fffffe          BL       GPIO_SetBits
;;;146      CLR_CLE;
000070  f44f6100          MOV      r1,#0x800
000074  483a              LDR      r0,|L4.352|
000076  f7fffffe          BL       GPIO_ResetBits
;;;147      SET_ALE;
00007a  f44f5180          MOV      r1,#0x1000
00007e  4838              LDR      r0,|L4.352|
000080  f7fffffe          BL       GPIO_SetBits
;;;148      CLR_WE;
000084  2120              MOVS     r1,#0x20
000086  4836              LDR      r0,|L4.352|
000088  f7fffffe          BL       GPIO_ResetBits
;;;149      GPIO_Write(GPIOE, 0x00); //快地址0
00008c  2100              MOVS     r1,#0
00008e  4833              LDR      r0,|L4.348|
000090  f7fffffe          BL       GPIO_Write
;;;150      SET_WE;
000094  2120              MOVS     r1,#0x20
000096  4832              LDR      r0,|L4.352|
000098  f7fffffe          BL       GPIO_SetBits
;;;151      CLR_WE;
00009c  2120              MOVS     r1,#0x20
00009e  4830              LDR      r0,|L4.352|
0000a0  f7fffffe          BL       GPIO_ResetBits
;;;152      GPIO_Write(GPIOE, 0x00); //块地址1
0000a4  2100              MOVS     r1,#0
0000a6  482d              LDR      r0,|L4.348|
0000a8  f7fffffe          BL       GPIO_Write
;;;153      SET_WE;
0000ac  2120              MOVS     r1,#0x20
0000ae  482c              LDR      r0,|L4.352|
0000b0  f7fffffe          BL       GPIO_SetBits
;;;154      CLR_ALE;
0000b4  f44f5180          MOV      r1,#0x1000
0000b8  4829              LDR      r0,|L4.352|
0000ba  f7fffffe          BL       GPIO_ResetBits
;;;155      SET_CLE;
0000be  f44f6100          MOV      r1,#0x800
0000c2  4827              LDR      r0,|L4.352|
0000c4  f7fffffe          BL       GPIO_SetBits
;;;156      CLR_WE;
0000c8  2120              MOVS     r1,#0x20
0000ca  4825              LDR      r0,|L4.352|
0000cc  f7fffffe          BL       GPIO_ResetBits
;;;157      GPIO_Write(GPIOE, 0xd0); //开始擦除
0000d0  21d0              MOVS     r1,#0xd0
0000d2  4822              LDR      r0,|L4.348|
0000d4  f7fffffe          BL       GPIO_Write
;;;158      SET_WE;
0000d8  2120              MOVS     r1,#0x20
0000da  4821              LDR      r0,|L4.352|
0000dc  f7fffffe          BL       GPIO_SetBits
;;;159      CLR_CLE;
0000e0  f44f6100          MOV      r1,#0x800
0000e4  481e              LDR      r0,|L4.352|
0000e6  f7fffffe          BL       GPIO_ResetBits
;;;160      for(m=5;m;m--);//延时满足时序
0000ea  2505              MOVS     r5,#5
0000ec  e001              B        |L4.242|
                  |L4.238|
0000ee  1e68              SUBS     r0,r5,#1
0000f0  b2c5              UXTB     r5,r0
                  |L4.242|
0000f2  2d00              CMP      r5,#0
0000f4  d1fb              BNE      |L4.238|
;;;161      wait_NAND_readay();
0000f6  f7fffffe          BL       wait_NAND_readay
;;;162      delay_1us(3000); //等待擦完
0000fa  f64030b8          MOV      r0,#0xbb8
0000fe  f7fffffe          BL       delay_1us
;;;163      SET_CLE;
000102  f44f6100          MOV      r1,#0x800
000106  4816              LDR      r0,|L4.352|
000108  f7fffffe          BL       GPIO_SetBits
;;;164      CLR_WE;
00010c  2120              MOVS     r1,#0x20
00010e  4814              LDR      r0,|L4.352|
000110  f7fffffe          BL       GPIO_ResetBits
;;;165      GPIO_Write(GPIOE, 0x70); // 读状态码状态读 //这个状态要为E0才表示操作完成可以进行下一步操作
000114  2170              MOVS     r1,#0x70
000116  4811              LDR      r0,|L4.348|
000118  f7fffffe          BL       GPIO_Write
;;;166      SET_WE;
00011c  2120              MOVS     r1,#0x20
00011e  4810              LDR      r0,|L4.352|
000120  f7fffffe          BL       GPIO_SetBits
;;;167      CLR_CLE;
000124  f44f6100          MOV      r1,#0x800
000128  480d              LDR      r0,|L4.352|
00012a  f7fffffe          BL       GPIO_ResetBits
;;;168      GPIOE->CRL=0x88888888; //数据口转换成输入
00012e  f04f3088          MOV      r0,#0x88888888
000132  490a              LDR      r1,|L4.348|
000134  6008              STR      r0,[r1,#0]
;;;169      CLR_RE;
000136  2110              MOVS     r1,#0x10
000138  4809              LDR      r0,|L4.352|
00013a  f7fffffe          BL       GPIO_ResetBits
;;;170      e=(GPIOE->IDR);//读出数据
00013e  4807              LDR      r0,|L4.348|
000140  3008              ADDS     r0,r0,#8
000142  6800              LDR      r0,[r0,#0]
000144  b2c4              UXTB     r4,r0
;;;171      SET_RE;
000146  2110              MOVS     r1,#0x10
000148  4805              LDR      r0,|L4.352|
00014a  f7fffffe          BL       GPIO_SetBits
;;;172      my_send_byte(e);  //穿行发送
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       my_send_byte
;;;173    
;;;174    }
000154  bd70              POP      {r4-r6,pc}
;;;175    /*读闪存一页*/
                          ENDP

000156  0000              DCW      0x0000
                  |L4.344|
                          DCD      GPIO_InitStructure
                  |L4.348|
                          DCD      0x40011800
                  |L4.352|
                          DCD      0x40011400
                  |L4.356|
                          DCD      0x40012000

                          AREA ||i.my_USART_init||, CODE, READONLY, ALIGN=2

                  my_USART_init PROC
;;;482    **********************************/
;;;483    void my_USART_init()
000000  2105              MOVS     r1,#5
;;;484    {
;;;485    
;;;486    /*USART2的优先级设为5*/
;;;487    NVIC->IPR[37]=5;
000002  480d              LDR      r0,|L5.56|
000004  6001              STR      r1,[r0,#0]
;;;488    /*开启38号中断即USART2，关闭其他所有外部的中断*/
;;;489    NVIC->ISER[1]=0x00000020;    
000006  2020              MOVS     r0,#0x20
000008  490c              LDR      r1,|L5.60|
00000a  6008              STR      r0,[r1,#0]
;;;490    /*设置复用模式下的引脚模式为全双工：TX输出推挽复用，RX为输入上拉模式，速度50MHZ*/
;;;491                GPIOA->CRH=0x000008b0; 
00000c  f44f600b          MOV      r0,#0x8b0
000010  490b              LDR      r1,|L5.64|
000012  6008              STR      r0,[r1,#0]
;;;492      /* 1.开启USART，
;;;493    * 
;;;494    */
;;;495    USART1->CR1=0x2000;
000014  1448              ASRS     r0,r1,#17
000016  490b              LDR      r1,|L5.68|
000018  8008              STRH     r0,[r1,#0]
;;;496    /* 1.关闭局域网模式
;;;497    * 2.1个停止位
;;;498    * 3.CK引脚禁能
;;;499    */
;;;500    USART1->CR2=0;
00001a  2000              MOVS     r0,#0
00001c  1d09              ADDS     r1,r1,#4
00001e  8008              STRH     r0,[r1,#0]
;;;501    /* 1.关闭调制解调模式
;;;502    * 2.关闭DMA模式
;;;503    * 3.关闭智能卡、红外模式
;;;504    *   4.关闭错误中断
;;;505    
;;;506    */
;;;507    USART1->CR3=0;
000020  1d09              ADDS     r1,r1,#4
000022  8008              STRH     r0,[r1,#0]
;;;508    /*     波特率设置
;;;509    
;;;510         2011年8月11日
;;;511            王均伟
;;;512             天津第四项目部宿舍
;;;513    
;;;514        BRR中的第四位（DIV_Fraction）作为小数，高12位(DIV_MANtissa)作为整数部分，
;;;515      
;;;516        1，根据公式：波特率=fck/16*usardiv,其中usardivBRR寄存器的值，所以变形得：USARDIV=fck/16*波特率
;;;517        2.算出来BRR寄存器的值后就要把这个值变成16进制数据写入BRR寄存器中，
;;;518          遵循以下规则：
;;;519          小数部分*16=DIV_Fraction或者取近似的值
;;;520          整数部分直接=DIV_MANtissa
;;;521        3.把这个16进制值写入BRR寄存器
;;;522        例如我要算波特率设成9600bps的BRR寄存器值，
;;;523        1.先求USARDIV=36000000/16*9600=234.375
;;;524        2.换成十六进制：DIV_Fraction=16*0.375=0x6
;;;525                        DIV_MANtissa=234=0xea
;;;526        3.组合并写入寄存器
;;;527                         USART2->BRR=0x0ea6;值得注意的是这里是16位半字操作，所以不要以为是32位。
;;;528    
;;;529    */
;;;530    USART1->BRR=0x0ea6;
000024  f64060a6          MOV      r0,#0xea6
000028  4906              LDR      r1,|L5.68|
00002a  1f09              SUBS     r1,r1,#4
00002c  8008              STRH     r0,[r1,#0]
;;;531    
;;;532    /* 1.开启USART
;;;533    * 2.开启接收完毕中断
;;;534    * 3.开启发送功能
;;;535    *   4.开启接收功能
;;;536    */
;;;537    USART1->CR1=0x202c;
00002e  f242002c          MOV      r0,#0x202c
000032  1d09              ADDS     r1,r1,#4
000034  8008              STRH     r0,[r1,#0]
;;;538    
;;;539    
;;;540    }
000036  4770              BX       lr
;;;541    
                          ENDP

                  |L5.56|
                          DCD      0xe000e494
                  |L5.60|
                          DCD      0xe000e104
                  |L5.64|
                          DCD      0x40010804
                  |L5.68|
                          DCD      0x4001380c

                          AREA ||i.my_send_byte||, CODE, READONLY, ALIGN=2

                  my_send_byte PROC
;;;470    ************************************/ 
;;;471    void my_send_byte(unsigned char send_date )
000000  bf00              NOP      
                  |L6.2|
;;;472    {
;;;473    
;;;474      while( (USART1->SR&0x00000080)!=0x80);//发送寄存器为空
000002  4905              LDR      r1,|L6.24|
000004  8809              LDRH     r1,[r1,#0]
000006  f0010180          AND      r1,r1,#0x80
00000a  2980              CMP      r1,#0x80
00000c  d1f9              BNE      |L6.2|
;;;475       USART1->DR=send_date; 
00000e  4902              LDR      r1,|L6.24|
000010  1d09              ADDS     r1,r1,#4
000012  8008              STRH     r0,[r1,#0]
;;;476    
;;;477    
;;;478    }
000014  4770              BX       lr
;;;479    /**********************************
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40013800

                          AREA ||i.mysysinit||, CODE, READONLY, ALIGN=1

                  mysysinit PROC
;;;542    
;;;543    void mysysinit()//系统初始化程序
000000  b510              PUSH     {r4,lr}
;;;544    {
;;;545    ErrorStatus HSEStartUpStatus;//说明标志位
;;;546    RCC_DeInit();//所有外设全部缺省设置
000002  f7fffffe          BL       RCC_DeInit
;;;547    
;;;548    /* Enable HSE */
;;;549    RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;550    /* Wait till HSE is ready and if Time out is reached exit */
;;;551    HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4604              MOV      r4,r0
;;;552    if(HSEStartUpStatus == SUCCESS)//启动成功
000014  2c01              CMP      r4,#1
000016  d13c              BNE      |L7.146|
;;;553    {
;;;554    /*这两条FLASH指令必须加上，不知为啥？不加上就运行几秒后出错，参照系统初始化*/
;;;555    /* Enable The Prefetch Buffer */
;;;556    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);//FLASH缓存开启
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;557    /* Configure the Latency cycle: Set 2 Latency cycles */
;;;558      FLASH_SetLatency(FLASH_Latency_2);  //设置FLASH这些位表示SYSCLK(系统时钟)周期与闪存访问时间的比例,为010：两个等待状态，当 48MHz < SYSCLK ≤ 72MHz
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       FLASH_SetLatency
;;;559    /* Set PLL clock output to 72MHz using HSE (8MHz) as entry clock */
;;;560    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);//外部时钟为8M，PLL的输入时钟=8MHZ，倍频系数9，
000024  f44f11e0          MOV      r1,#0x1c0000
000028  0420              LSLS     r0,r4,#16
00002a  f7fffffe          BL       RCC_PLLConfig
;;;561    
;;;562    /* Configure HCLK such as HCLK = SYSCLK */
;;;563    RCC_HCLKConfig(RCC_SYSCLK_Div1);//设置了啦AHB分频器的分频系数=1，即HCLK=SYSCLK=72MHZ
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       RCC_HCLKConfig
;;;564    /* Configure PCLK1 such as PCLK1 = HCLK/2 */
;;;565    RCC_PCLK1Config(RCC_HCLK_Div2);//设置了APB1外设的时钟频率最大是36M这里是APB1的分频器设为2,PCLK1=HCLK/2=72/2=36MHZ正好是最大值
000034  02a0              LSLS     r0,r4,#10
000036  f7fffffe          BL       RCC_PCLK1Config
;;;566    /* Configure PCLK2 such as PCLK2 = HCLK */
;;;567    RCC_PCLK2Config(RCC_HCLK_Div1);//设置PLCK2=HCLK=72MHZ，的APB2分频器=1
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       RCC_PCLK2Config
;;;568    /* Select the PLL as system clock source */
;;;569    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);//设置了SYSCLK的提供者为PLL，频率由上面算出=72MHZ
000040  2002              MOVS     r0,#2
000042  f7fffffe          BL       RCC_SYSCLKConfig
;;;570    /* disable PLL Ready interrupt */
;;;571    RCC_ITConfig(RCC_IT_PLLRDY, DISABLE);//PLL中断关闭
000046  2100              MOVS     r1,#0
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       RCC_ITConfig
;;;572    /* disable PLL Ready interrupt */
;;;573    RCC_ITConfig(RCC_IT_HSERDY,DISABLE);//HSE中断关闭
00004e  2100              MOVS     r1,#0
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       RCC_ITConfig
;;;574    /* disable PLL Ready interrupt */
;;;575    RCC_ITConfig(RCC_IT_HSIRDY, DISABLE); //HSI中断关闭
000056  2100              MOVS     r1,#0
000058  2004              MOVS     r0,#4
00005a  f7fffffe          BL       RCC_ITConfig
;;;576    /* disable PLL Ready interrupt */
;;;577    RCC_ITConfig(RCC_IT_LSERDY, DISABLE); //LSE中断关闭
00005e  2100              MOVS     r1,#0
000060  2002              MOVS     r0,#2
000062  f7fffffe          BL       RCC_ITConfig
;;;578    /* disable PLL Ready interrupt */
;;;579    RCC_ITConfig(RCC_IT_LSIRDY, DISABLE); //LSI中断关闭
000066  2100              MOVS     r1,#0
000068  2001              MOVS     r0,#1
00006a  f7fffffe          BL       RCC_ITConfig
;;;580    
;;;581    /* PLL clock divided by 1.5 used as USB clock source */
;;;582    RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);//设置USB的时钟为=72、1.5=48mhz
00006e  2000              MOVS     r0,#0
000070  f7fffffe          BL       RCC_USBCLKConfig
;;;583    /* Configure ADCCLK such as ADCCLK = PCLK2/2 */
;;;584    RCC_ADCCLKConfig(RCC_PCLK2_Div2);//设置ADC时钟=PCLK2/2= 36MHZ
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       RCC_ADCCLKConfig
;;;585    /* disable the LSE */
;;;586    RCC_LSEConfig(RCC_LSE_OFF);//外部低速晶振关闭
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       RCC_LSEConfig
;;;587    
;;;588    /*DISable the RTC clock */
;;;589    RCC_RTCCLKCmd(DISABLE);
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       RCC_RTCCLKCmd
;;;590    /* DISable the Clock Security System */
;;;591    RCC_ClockSecuritySystemCmd(DISABLE);
000086  2000              MOVS     r0,#0
000088  f7fffffe          BL       RCC_ClockSecuritySystemCmd
;;;592    /* Enable the PLL */
;;;593    RCC_PLLCmd(ENABLE);//使能PLL
00008c  2001              MOVS     r0,#1
00008e  f7fffffe          BL       RCC_PLLCmd
                  |L7.146|
;;;594    
;;;595    
;;;596    
;;;597    
;;;598    
;;;599    
;;;600    
;;;601    /* PLL ans system clock config */
;;;602    }
;;;603    else
;;;604    {
;;;605    /* Add here some code to deal with this error */
;;;606    }
;;;607    }
000092  bd10              POP      {r4,pc}
;;;608    /************************************** The End Of FILE **************************************/
                          ENDP


                          AREA ||i.read_NAND_PAGE||, CODE, READONLY, ALIGN=2

                  read_NAND_PAGE PROC
;;;175    /*读闪存一页*/
;;;176    void read_NAND_PAGE()
000000  b570              PUSH     {r4-r6,lr}
;;;177    {
;;;178      uint32_t n;
;;;179      uint8_t sd;
;;;180    
;;;181      /*设置PE口得低八位为输出*/
;;;182      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2| GPIO_Pin_3| GPIO_Pin_4|GPIO_Pin_5 | GPIO_Pin_6| GPIO_Pin_7;
000002  20ff              MOVS     r0,#0xff
000004  4968              LDR      r1,|L8.424|
000006  8008              STRH     r0,[r1,#0]
;;;183      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000008  2003              MOVS     r0,#3
00000a  7088              STRB     r0,[r1,#2]
;;;184      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000c  2010              MOVS     r0,#0x10
00000e  70c8              STRB     r0,[r1,#3]
;;;185      GPIO_Init(GPIOE, &GPIO_InitStructure);
000010  4866              LDR      r0,|L8.428|
000012  f7fffffe          BL       GPIO_Init
;;;186      SET_WE;
000016  2120              MOVS     r1,#0x20
000018  4865              LDR      r0,|L8.432|
00001a  f7fffffe          BL       GPIO_SetBits
;;;187      SET_RE;
00001e  2110              MOVS     r1,#0x10
000020  4863              LDR      r0,|L8.432|
000022  f7fffffe          BL       GPIO_SetBits
;;;188      CLR_ALE;
000026  f44f5180          MOV      r1,#0x1000
00002a  4861              LDR      r0,|L8.432|
00002c  f7fffffe          BL       GPIO_ResetBits
;;;189      CLR_CLE;
000030  f44f6100          MOV      r1,#0x800
000034  485e              LDR      r0,|L8.432|
000036  f7fffffe          BL       GPIO_ResetBits
;;;190    
;;;191      CLR_CE;//片选开启
00003a  f44f6180          MOV      r1,#0x400
00003e  485d              LDR      r0,|L8.436|
000040  f7fffffe          BL       GPIO_ResetBits
;;;192      SET_CLE;
000044  f44f6100          MOV      r1,#0x800
000048  4859              LDR      r0,|L8.432|
00004a  f7fffffe          BL       GPIO_SetBits
;;;193      CLR_ALE;
00004e  f44f5180          MOV      r1,#0x1000
000052  4857              LDR      r0,|L8.432|
000054  f7fffffe          BL       GPIO_ResetBits
;;;194      SET_RE;
000058  2110              MOVS     r1,#0x10
00005a  4855              LDR      r0,|L8.432|
00005c  f7fffffe          BL       GPIO_SetBits
;;;195      CLR_WE;
000060  2120              MOVS     r1,#0x20
000062  4853              LDR      r0,|L8.432|
000064  f7fffffe          BL       GPIO_ResetBits
;;;196      GPIO_Write(GPIOE, 0x00); //  读命令
000068  2100              MOVS     r1,#0
00006a  4850              LDR      r0,|L8.428|
00006c  f7fffffe          BL       GPIO_Write
;;;197      SET_WE;
000070  2120              MOVS     r1,#0x20
000072  484f              LDR      r0,|L8.432|
000074  f7fffffe          BL       GPIO_SetBits
;;;198      CLR_CLE;
000078  f44f6100          MOV      r1,#0x800
00007c  484c              LDR      r0,|L8.432|
00007e  f7fffffe          BL       GPIO_ResetBits
;;;199      SET_ALE;
000082  f44f5180          MOV      r1,#0x1000
000086  484a              LDR      r0,|L8.432|
000088  f7fffffe          BL       GPIO_SetBits
;;;200      SET_RE;
00008c  2110              MOVS     r1,#0x10
00008e  4848              LDR      r0,|L8.432|
000090  f7fffffe          BL       GPIO_SetBits
;;;201      CLR_WE;
000094  2120              MOVS     r1,#0x20
000096  4846              LDR      r0,|L8.432|
000098  f7fffffe          BL       GPIO_ResetBits
;;;202      GPIO_Write(GPIOE, 0x00); //页地址
00009c  2100              MOVS     r1,#0
00009e  4843              LDR      r0,|L8.428|
0000a0  f7fffffe          BL       GPIO_Write
;;;203      SET_WE;
0000a4  2120              MOVS     r1,#0x20
0000a6  4842              LDR      r0,|L8.432|
0000a8  f7fffffe          BL       GPIO_SetBits
;;;204      CLR_WE;
0000ac  2120              MOVS     r1,#0x20
0000ae  4840              LDR      r0,|L8.432|
0000b0  f7fffffe          BL       GPIO_ResetBits
;;;205      GPIO_Write(GPIOE, 0x00);//页地址
0000b4  2100              MOVS     r1,#0
0000b6  483d              LDR      r0,|L8.428|
0000b8  f7fffffe          BL       GPIO_Write
;;;206      SET_WE;
0000bc  2120              MOVS     r1,#0x20
0000be  483c              LDR      r0,|L8.432|
0000c0  f7fffffe          BL       GPIO_SetBits
;;;207      CLR_WE;
0000c4  2120              MOVS     r1,#0x20
0000c6  483a              LDR      r0,|L8.432|
0000c8  f7fffffe          BL       GPIO_ResetBits
;;;208      GPIO_Write(GPIOE, 0x00); //快地址
0000cc  2100              MOVS     r1,#0
0000ce  4837              LDR      r0,|L8.428|
0000d0  f7fffffe          BL       GPIO_Write
;;;209      SET_WE;
0000d4  2120              MOVS     r1,#0x20
0000d6  4836              LDR      r0,|L8.432|
0000d8  f7fffffe          BL       GPIO_SetBits
;;;210      CLR_WE;
0000dc  2120              MOVS     r1,#0x20
0000de  4834              LDR      r0,|L8.432|
0000e0  f7fffffe          BL       GPIO_ResetBits
;;;211      GPIO_Write(GPIOE, 0x00);//快地址
0000e4  2100              MOVS     r1,#0
0000e6  4831              LDR      r0,|L8.428|
0000e8  f7fffffe          BL       GPIO_Write
;;;212      SET_WE;
0000ec  2120              MOVS     r1,#0x20
0000ee  4830              LDR      r0,|L8.432|
0000f0  f7fffffe          BL       GPIO_SetBits
;;;213    
;;;214      CLR_ALE;
0000f4  f44f5180          MOV      r1,#0x1000
0000f8  482d              LDR      r0,|L8.432|
0000fa  f7fffffe          BL       GPIO_ResetBits
;;;215      SET_CLE;
0000fe  f44f6100          MOV      r1,#0x800
000102  482b              LDR      r0,|L8.432|
000104  f7fffffe          BL       GPIO_SetBits
;;;216      SET_RE;
000108  2110              MOVS     r1,#0x10
00010a  4829              LDR      r0,|L8.432|
00010c  f7fffffe          BL       GPIO_SetBits
;;;217      CLR_WE;
000110  2120              MOVS     r1,#0x20
000112  4827              LDR      r0,|L8.432|
000114  f7fffffe          BL       GPIO_ResetBits
;;;218      GPIO_Write(GPIOE, 0x30); //开始读出命令
000118  2130              MOVS     r1,#0x30
00011a  4824              LDR      r0,|L8.428|
00011c  f7fffffe          BL       GPIO_Write
;;;219      SET_WE;
000120  2120              MOVS     r1,#0x20
000122  4823              LDR      r0,|L8.432|
000124  f7fffffe          BL       GPIO_SetBits
;;;220      CLR_CLE;
000128  f44f6100          MOV      r1,#0x800
00012c  4820              LDR      r0,|L8.432|
00012e  f7fffffe          BL       GPIO_ResetBits
;;;221      GPIOE->CRL=0x88888888; //接口转换
000132  f04f3088          MOV      r0,#0x88888888
000136  491d              LDR      r1,|L8.428|
000138  6008              STR      r0,[r1,#0]
;;;222      for(n=30;n;n--);//满足时序
00013a  241e              MOVS     r4,#0x1e
00013c  e000              B        |L8.320|
                  |L8.318|
00013e  1e64              SUBS     r4,r4,#1
                  |L8.320|
000140  2c00              CMP      r4,#0
000142  d1fc              BNE      |L8.318|
;;;223        delay_1us(20); //等待
000144  2014              MOVS     r0,#0x14
000146  f7fffffe          BL       delay_1us
;;;224      wait_NAND_readay();
00014a  f7fffffe          BL       wait_NAND_readay
;;;225      for(n=2112;n;n--)
00014e  f44f6404          MOV      r4,#0x840
000152  e00f              B        |L8.372|
                  |L8.340|
;;;226      {
;;;227        CLR_RE;
000154  2110              MOVS     r1,#0x10
000156  4816              LDR      r0,|L8.432|
000158  f7fffffe          BL       GPIO_ResetBits
;;;228        sd=(GPIOE->IDR);//读出数据
00015c  4813              LDR      r0,|L8.428|
00015e  3008              ADDS     r0,r0,#8
000160  6800              LDR      r0,[r0,#0]
000162  b2c5              UXTB     r5,r0
;;;229        SET_RE;
000164  2110              MOVS     r1,#0x10
000166  4812              LDR      r0,|L8.432|
000168  f7fffffe          BL       GPIO_SetBits
;;;230        my_send_byte(sd);//发送到计算机
00016c  4628              MOV      r0,r5
00016e  f7fffffe          BL       my_send_byte
000172  1e64              SUBS     r4,r4,#1              ;225
                  |L8.372|
000174  2c00              CMP      r4,#0                 ;225
000176  d1ed              BNE      |L8.340|
;;;231      }
;;;232    
;;;233      SET_CE;
000178  f44f6180          MOV      r1,#0x400
00017c  480d              LDR      r0,|L8.436|
00017e  f7fffffe          BL       GPIO_SetBits
;;;234      SET_WE;
000182  2120              MOVS     r1,#0x20
000184  480a              LDR      r0,|L8.432|
000186  f7fffffe          BL       GPIO_SetBits
;;;235      SET_RE;
00018a  2110              MOVS     r1,#0x10
00018c  4808              LDR      r0,|L8.432|
00018e  f7fffffe          BL       GPIO_SetBits
;;;236      CLR_ALE;
000192  f44f5180          MOV      r1,#0x1000
000196  4806              LDR      r0,|L8.432|
000198  f7fffffe          BL       GPIO_ResetBits
;;;237      CLR_CLE;
00019c  f44f6100          MOV      r1,#0x800
0001a0  4803              LDR      r0,|L8.432|
0001a2  f7fffffe          BL       GPIO_ResetBits
;;;238    }
0001a6  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  |L8.424|
                          DCD      GPIO_InitStructure
                  |L8.428|
                          DCD      0x40011800
                  |L8.432|
                          DCD      0x40011400
                  |L8.436|
                          DCD      0x40012000

                          AREA ||i.read_nand_date||, CODE, READONLY, ALIGN=2

                  read_nand_date PROC
;;;439    /*读一个数据*/
;;;440    uint8_t read_nand_date()
000000  b510              PUSH     {r4,lr}
;;;441    {
;;;442      uint8_t a;
;;;443      CLR_CE;
000002  f44f6180          MOV      r1,#0x400
000006  480e              LDR      r0,|L9.64|
000008  f7fffffe          BL       GPIO_ResetBits
;;;444      SET_WE;
00000c  2120              MOVS     r1,#0x20
00000e  480d              LDR      r0,|L9.68|
000010  f7fffffe          BL       GPIO_SetBits
;;;445      SET_RE;
000014  2110              MOVS     r1,#0x10
000016  480b              LDR      r0,|L9.68|
000018  f7fffffe          BL       GPIO_SetBits
;;;446      CLR_RE;;;; 
00001c  2110              MOVS     r1,#0x10
00001e  4809              LDR      r0,|L9.68|
000020  f7fffffe          BL       GPIO_ResetBits
;;;447      a=(GPIOE->IDR);//读出数据
000024  4808              LDR      r0,|L9.72|
000026  6800              LDR      r0,[r0,#0]
000028  b2c4              UXTB     r4,r0
;;;448      SET_RE;
00002a  2110              MOVS     r1,#0x10
00002c  4805              LDR      r0,|L9.68|
00002e  f7fffffe          BL       GPIO_SetBits
;;;449      SET_CE;
000032  f44f6180          MOV      r1,#0x400
000036  4802              LDR      r0,|L9.64|
000038  f7fffffe          BL       GPIO_SetBits
;;;450      return a;
00003c  4620              MOV      r0,r4
;;;451    }
00003e  bd10              POP      {r4,pc}
;;;452    /********************
                          ENDP

                  |L9.64|
                          DCD      0x40012000
                  |L9.68|
                          DCD      0x40011400
                  |L9.72|
                          DCD      0x40011808

                          AREA ||i.wait_NAND_readay||, CODE, READONLY, ALIGN=2

                  wait_NAND_readay PROC
;;;315    /*等待芯片不忙*/
;;;316    void wait_NAND_readay()
000000  b510              PUSH     {r4,lr}
;;;317    {
;;;318      uint8_t wait=0;//忙闲信号
000002  2400              MOVS     r4,#0
;;;319      //等待芯片不忙
;;;320      do
000004  bf00              NOP      
                  |L10.6|
;;;321      {
;;;322        wait=GPIO_ReadOutputDataBit(GPIOD, GPIO_Pin_6);//读取忙闲引脚
000006  2140              MOVS     r1,#0x40
000008  4803              LDR      r0,|L10.24|
00000a  f7fffffe          BL       GPIO_ReadOutputDataBit
00000e  4604              MOV      r4,r0
;;;323      }
;;;324      while(0x00==wait);
000010  2c00              CMP      r4,#0
000012  d0f8              BEQ      |L10.6|
;;;325    }
000014  bd10              POP      {r4,pc}
;;;326    /*读取NAND闪存的ID序列号串口发送*/
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40011400

                          AREA ||i.write_NAND_PAGE||, CODE, READONLY, ALIGN=2

                  write_NAND_PAGE PROC
;;;241    /*写闪存的一页，数据=2112字节=2kb*/
;;;242    void write_NAND_PAGE()
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244      uint8_t send_date=0;
000002  2500              MOVS     r5,#0
;;;245      uint32_t numb;
;;;246       /*设置PE口得低八位为输出*/
;;;247      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1| GPIO_Pin_2| GPIO_Pin_3| GPIO_Pin_4|GPIO_Pin_5 | GPIO_Pin_6| GPIO_Pin_7;
000004  20ff              MOVS     r0,#0xff
000006  4975              LDR      r1,|L11.476|
000008  8008              STRH     r0,[r1,#0]
;;;248      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  7088              STRB     r0,[r1,#2]
;;;249      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000e  2010              MOVS     r0,#0x10
000010  70c8              STRB     r0,[r1,#3]
;;;250      GPIO_Init(GPIOE, &GPIO_InitStructure);
000012  4873              LDR      r0,|L11.480|
000014  f7fffffe          BL       GPIO_Init
;;;251      SET_WE;
000018  2120              MOVS     r1,#0x20
00001a  4872              LDR      r0,|L11.484|
00001c  f7fffffe          BL       GPIO_SetBits
;;;252      SET_RE;
000020  2110              MOVS     r1,#0x10
000022  4870              LDR      r0,|L11.484|
000024  f7fffffe          BL       GPIO_SetBits
;;;253      CLR_ALE;
000028  f44f5180          MOV      r1,#0x1000
00002c  486d              LDR      r0,|L11.484|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;254      CLR_CLE;
000032  f44f6100          MOV      r1,#0x800
000036  486b              LDR      r0,|L11.484|
000038  f7fffffe          BL       GPIO_ResetBits
;;;255    
;;;256      CLR_CE;//片选开启
00003c  f44f6180          MOV      r1,#0x400
000040  4869              LDR      r0,|L11.488|
000042  f7fffffe          BL       GPIO_ResetBits
;;;257      SET_CLE;//命令
000046  f44f6100          MOV      r1,#0x800
00004a  4866              LDR      r0,|L11.484|
00004c  f7fffffe          BL       GPIO_SetBits
;;;258      CLR_ALE;
000050  f44f5180          MOV      r1,#0x1000
000054  4863              LDR      r0,|L11.484|
000056  f7fffffe          BL       GPIO_ResetBits
;;;259      SET_WE;
00005a  2120              MOVS     r1,#0x20
00005c  4861              LDR      r0,|L11.484|
00005e  f7fffffe          BL       GPIO_SetBits
;;;260      SET_RE;
000062  2110              MOVS     r1,#0x10
000064  485f              LDR      r0,|L11.484|
000066  f7fffffe          BL       GPIO_SetBits
;;;261    
;;;262      CLR_WE;
00006a  2120              MOVS     r1,#0x20
00006c  485d              LDR      r0,|L11.484|
00006e  f7fffffe          BL       GPIO_ResetBits
;;;263      GPIO_Write(GPIOE, 0x80); //写一页命令
000072  2180              MOVS     r1,#0x80
000074  485a              LDR      r0,|L11.480|
000076  f7fffffe          BL       GPIO_Write
;;;264      SET_WE;
00007a  2120              MOVS     r1,#0x20
00007c  4859              LDR      r0,|L11.484|
00007e  f7fffffe          BL       GPIO_SetBits
;;;265      CLR_CLE;//释放命令总线
000082  f44f6100          MOV      r1,#0x800
000086  4857              LDR      r0,|L11.484|
000088  f7fffffe          BL       GPIO_ResetBits
;;;266    
;;;267    
;;;268      SET_ALE;//地址写入允许
00008c  f44f5180          MOV      r1,#0x1000
000090  4854              LDR      r0,|L11.484|
000092  f7fffffe          BL       GPIO_SetBits
;;;269      CLR_WE;
000096  2120              MOVS     r1,#0x20
000098  4852              LDR      r0,|L11.484|
00009a  f7fffffe          BL       GPIO_ResetBits
;;;270      GPIO_Write(GPIOE, 0x00); //页地址0
00009e  2100              MOVS     r1,#0
0000a0  484f              LDR      r0,|L11.480|
0000a2  f7fffffe          BL       GPIO_Write
;;;271      SET_WE;
0000a6  2120              MOVS     r1,#0x20
0000a8  484e              LDR      r0,|L11.484|
0000aa  f7fffffe          BL       GPIO_SetBits
;;;272      CLR_WE;
0000ae  2120              MOVS     r1,#0x20
0000b0  484c              LDR      r0,|L11.484|
0000b2  f7fffffe          BL       GPIO_ResetBits
;;;273      GPIO_Write(GPIOE, 0x00); //页地址
0000b6  2100              MOVS     r1,#0
0000b8  4849              LDR      r0,|L11.480|
0000ba  f7fffffe          BL       GPIO_Write
;;;274      SET_WE;
0000be  2120              MOVS     r1,#0x20
0000c0  4848              LDR      r0,|L11.484|
0000c2  f7fffffe          BL       GPIO_SetBits
;;;275      CLR_WE;
0000c6  2120              MOVS     r1,#0x20
0000c8  4846              LDR      r0,|L11.484|
0000ca  f7fffffe          BL       GPIO_ResetBits
;;;276      GPIO_Write(GPIOE, 0x00); //快递至
0000ce  2100              MOVS     r1,#0
0000d0  4843              LDR      r0,|L11.480|
0000d2  f7fffffe          BL       GPIO_Write
;;;277      SET_WE;
0000d6  2120              MOVS     r1,#0x20
0000d8  4842              LDR      r0,|L11.484|
0000da  f7fffffe          BL       GPIO_SetBits
;;;278      CLR_WE;
0000de  2120              MOVS     r1,#0x20
0000e0  4840              LDR      r0,|L11.484|
0000e2  f7fffffe          BL       GPIO_ResetBits
;;;279      GPIO_Write(GPIOE, 0x00); //快递至
0000e6  2100              MOVS     r1,#0
0000e8  483d              LDR      r0,|L11.480|
0000ea  f7fffffe          BL       GPIO_Write
;;;280      SET_WE;
0000ee  2120              MOVS     r1,#0x20
0000f0  483c              LDR      r0,|L11.484|
0000f2  f7fffffe          BL       GPIO_SetBits
;;;281      CLR_ALE;//释放地址总线
0000f6  f44f5180          MOV      r1,#0x1000
0000fa  483a              LDR      r0,|L11.484|
0000fc  f7fffffe          BL       GPIO_ResetBits
;;;282    
;;;283      for(numb=5;numb;numb--);//延时
000100  2405              MOVS     r4,#5
000102  e000              B        |L11.262|
                  |L11.260|
000104  1e64              SUBS     r4,r4,#1
                  |L11.262|
000106  2c00              CMP      r4,#0
000108  d1fc              BNE      |L11.260|
;;;284      for(numb=2112;numb;numb--)
00010a  f44f6404          MOV      r4,#0x840
00010e  e00c              B        |L11.298|
                  |L11.272|
;;;285      {
;;;286         CLR_WE;
000110  2120              MOVS     r1,#0x20
000112  4834              LDR      r0,|L11.484|
000114  f7fffffe          BL       GPIO_ResetBits
;;;287         GPIO_Write(GPIOE, 0x89);  //写入数据89
000118  2189              MOVS     r1,#0x89
00011a  4831              LDR      r0,|L11.480|
00011c  f7fffffe          BL       GPIO_Write
;;;288         SET_WE;
000120  2120              MOVS     r1,#0x20
000122  4830              LDR      r0,|L11.484|
000124  f7fffffe          BL       GPIO_SetBits
000128  1e64              SUBS     r4,r4,#1              ;284
                  |L11.298|
00012a  2c00              CMP      r4,#0                 ;284
00012c  d1f0              BNE      |L11.272|
;;;289    
;;;290      }
;;;291      SET_CLE;//开启命令总线
00012e  f44f6100          MOV      r1,#0x800
000132  482c              LDR      r0,|L11.484|
000134  f7fffffe          BL       GPIO_SetBits
;;;292      CLR_WE;
000138  2120              MOVS     r1,#0x20
00013a  482a              LDR      r0,|L11.484|
00013c  f7fffffe          BL       GPIO_ResetBits
;;;293      GPIO_Write(GPIOE, 0x10);//页编程
000140  2110              MOVS     r1,#0x10
000142  4827              LDR      r0,|L11.480|
000144  f7fffffe          BL       GPIO_Write
;;;294      SET_WE;
000148  2120              MOVS     r1,#0x20
00014a  4826              LDR      r0,|L11.484|
00014c  f7fffffe          BL       GPIO_SetBits
;;;295      for(numb=3;numb;numb--);//略微延时
000150  2403              MOVS     r4,#3
000152  e000              B        |L11.342|
                  |L11.340|
000154  1e64              SUBS     r4,r4,#1
                  |L11.342|
000156  2c00              CMP      r4,#0
000158  d1fc              BNE      |L11.340|
;;;296      wait_NAND_readay();
00015a  f7fffffe          BL       wait_NAND_readay
;;;297      delay_1us(500);
00015e  f44f70fa          MOV      r0,#0x1f4
000162  f7fffffe          BL       delay_1us
;;;298      CLR_WE;
000166  2120              MOVS     r1,#0x20
000168  481e              LDR      r0,|L11.484|
00016a  f7fffffe          BL       GPIO_ResetBits
;;;299      GPIO_Write(GPIOE, 0x70);//状态读 //这个状态要为E0才表示操作完成可以进行下一步操作
00016e  2170              MOVS     r1,#0x70
000170  481b              LDR      r0,|L11.480|
000172  f7fffffe          BL       GPIO_Write
;;;300      SET_WE;
000176  2120              MOVS     r1,#0x20
000178  481a              LDR      r0,|L11.484|
00017a  f7fffffe          BL       GPIO_SetBits
;;;301      GPIOE->CRL=0x88888888;
00017e  f04f3088          MOV      r0,#0x88888888
000182  4917              LDR      r1,|L11.480|
000184  6008              STR      r0,[r1,#0]
;;;302      SET_WE;
000186  2120              MOVS     r1,#0x20
000188  4816              LDR      r0,|L11.484|
00018a  f7fffffe          BL       GPIO_SetBits
;;;303      SET_RE;
00018e  2110              MOVS     r1,#0x10
000190  4814              LDR      r0,|L11.484|
000192  f7fffffe          BL       GPIO_SetBits
;;;304      CLR_RE;
000196  2110              MOVS     r1,#0x10
000198  4812              LDR      r0,|L11.484|
00019a  f7fffffe          BL       GPIO_ResetBits
;;;305      send_date=(GPIOE->IDR);//读出数据
00019e  4810              LDR      r0,|L11.480|
0001a0  3008              ADDS     r0,r0,#8
0001a2  6800              LDR      r0,[r0,#0]
0001a4  b2c5              UXTB     r5,r0
;;;306      SET_CE;
0001a6  f44f6180          MOV      r1,#0x400
0001aa  480f              LDR      r0,|L11.488|
0001ac  f7fffffe          BL       GPIO_SetBits
;;;307      my_send_byte(send_date);
0001b0  4628              MOV      r0,r5
0001b2  f7fffffe          BL       my_send_byte
;;;308      SET_WE;
0001b6  2120              MOVS     r1,#0x20
0001b8  480a              LDR      r0,|L11.484|
0001ba  f7fffffe          BL       GPIO_SetBits
;;;309      SET_RE;
0001be  2110              MOVS     r1,#0x10
0001c0  4808              LDR      r0,|L11.484|
0001c2  f7fffffe          BL       GPIO_SetBits
;;;310      CLR_ALE;
0001c6  f44f5180          MOV      r1,#0x1000
0001ca  4806              LDR      r0,|L11.484|
0001cc  f7fffffe          BL       GPIO_ResetBits
;;;311      CLR_CLE;
0001d0  f44f6100          MOV      r1,#0x800
0001d4  4803              LDR      r0,|L11.484|
0001d6  f7fffffe          BL       GPIO_ResetBits
;;;312    
;;;313    }
0001da  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

                  |L11.476|
                          DCD      GPIO_InitStructure
                  |L11.480|
                          DCD      0x40011800
                  |L11.484|
                          DCD      0x40011400
                  |L11.488|
                          DCD      0x40012000

                          AREA ||i.write_nand_addrrs||, CODE, READONLY, ALIGN=2

                  write_nand_addrrs PROC
;;;412    /*写一个地址*/
;;;413    void write_nand_addrrs(uint8_t a)
000000  b510              PUSH     {r4,lr}
;;;414    {
000002  4604              MOV      r4,r0
;;;415      CLR_CE;
000004  f44f6180          MOV      r1,#0x400
000008  4813              LDR      r0,|L12.88|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;416      SET_RE;
00000e  2110              MOVS     r1,#0x10
000010  4812              LDR      r0,|L12.92|
000012  f7fffffe          BL       GPIO_SetBits
;;;417      CLR_CLE;
000016  f44f6100          MOV      r1,#0x800
00001a  4810              LDR      r0,|L12.92|
00001c  f7fffffe          BL       GPIO_ResetBits
;;;418      SET_ALE;
000020  f44f5180          MOV      r1,#0x1000
000024  480d              LDR      r0,|L12.92|
000026  f7fffffe          BL       GPIO_SetBits
;;;419      CLR_WE;;;
00002a  2120              MOVS     r1,#0x20
00002c  480b              LDR      r0,|L12.92|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;420      GPIO_Write(GPIOE, a); //地址
000032  4621              MOV      r1,r4
000034  480a              LDR      r0,|L12.96|
000036  f7fffffe          BL       GPIO_Write
;;;421      SET_WE;
00003a  2120              MOVS     r1,#0x20
00003c  4807              LDR      r0,|L12.92|
00003e  f7fffffe          BL       GPIO_SetBits
;;;422      CLR_ALE;
000042  f44f5180          MOV      r1,#0x1000
000046  4805              LDR      r0,|L12.92|
000048  f7fffffe          BL       GPIO_ResetBits
;;;423      SET_CE;
00004c  f44f6180          MOV      r1,#0x400
000050  4801              LDR      r0,|L12.88|
000052  f7fffffe          BL       GPIO_SetBits
;;;424    
;;;425    
;;;426    }
000056  bd10              POP      {r4,pc}
;;;427    //写一个数据
                          ENDP

                  |L12.88|
                          DCD      0x40012000
                  |L12.92|
                          DCD      0x40011400
                  |L12.96|
                          DCD      0x40011800

                          AREA ||i.write_nand_commond||, CODE, READONLY, ALIGN=2

                  write_nand_commond PROC
;;;398    /*写一个命令*/
;;;399    void write_nand_commond(uint8_t comm)
000000  b510              PUSH     {r4,lr}
;;;400    {
000002  4604              MOV      r4,r0
;;;401      CLR_CE;
000004  f44f6180          MOV      r1,#0x400
000008  4813              LDR      r0,|L13.88|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;402      SET_RE;
00000e  2110              MOVS     r1,#0x10
000010  4812              LDR      r0,|L13.92|
000012  f7fffffe          BL       GPIO_SetBits
;;;403      SET_CLE;//命令锁存开启
000016  f44f6100          MOV      r1,#0x800
00001a  4810              LDR      r0,|L13.92|
00001c  f7fffffe          BL       GPIO_SetBits
;;;404      CLR_ALE;//地址锁存关闭
000020  f44f5180          MOV      r1,#0x1000
000024  480d              LDR      r0,|L13.92|
000026  f7fffffe          BL       GPIO_ResetBits
;;;405      CLR_WE;//写使能
00002a  2120              MOVS     r1,#0x20
00002c  480b              LDR      r0,|L13.92|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;406      GPIO_Write(GPIOE, comm); //命令
000032  4621              MOV      r1,r4
000034  480a              LDR      r0,|L13.96|
000036  f7fffffe          BL       GPIO_Write
;;;407      SET_WE;//关闭写
00003a  2120              MOVS     r1,#0x20
00003c  4807              LDR      r0,|L13.92|
00003e  f7fffffe          BL       GPIO_SetBits
;;;408      CLR_CLE;
000042  f44f6100          MOV      r1,#0x800
000046  4805              LDR      r0,|L13.92|
000048  f7fffffe          BL       GPIO_ResetBits
;;;409      SET_CE;
00004c  f44f6180          MOV      r1,#0x400
000050  4801              LDR      r0,|L13.88|
000052  f7fffffe          BL       GPIO_SetBits
;;;410    
;;;411    }
000056  bd10              POP      {r4,pc}
;;;412    /*写一个地址*/
                          ENDP

                  |L13.88|
                          DCD      0x40012000
                  |L13.92|
                          DCD      0x40011400
                  |L13.96|
                          DCD      0x40011800

                          AREA ||i.write_nand_date||, CODE, READONLY, ALIGN=2

                  write_nand_date PROC
;;;427    //写一个数据
;;;428    void write_nand_date(uint8_t da)
000000  b510              PUSH     {r4,lr}
;;;429    { 
000002  4604              MOV      r4,r0
;;;430      CLR_CE;
000004  f44f6180          MOV      r1,#0x400
000008  4810              LDR      r0,|L14.76|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;431      CLR_ALE;
00000e  f44f5180          MOV      r1,#0x1000
000012  480f              LDR      r0,|L14.80|
000014  f7fffffe          BL       GPIO_ResetBits
;;;432      CLR_CLE;
000018  f44f6100          MOV      r1,#0x800
00001c  480c              LDR      r0,|L14.80|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;433      SET_RE;
000022  2110              MOVS     r1,#0x10
000024  480a              LDR      r0,|L14.80|
000026  f7fffffe          BL       GPIO_SetBits
;;;434      CLR_WE;
00002a  2120              MOVS     r1,#0x20
00002c  4808              LDR      r0,|L14.80|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;435      GPIOE->ODR=da;//GPIO_Write(GPIOE, da); //数据
000032  4808              LDR      r0,|L14.84|
000034  6004              STR      r4,[r0,#0]
;;;436      SET_WE;
000036  2120              MOVS     r1,#0x20
000038  4805              LDR      r0,|L14.80|
00003a  f7fffffe          BL       GPIO_SetBits
;;;437      SET_CE;
00003e  f44f6180          MOV      r1,#0x400
000042  4802              LDR      r0,|L14.76|
000044  f7fffffe          BL       GPIO_SetBits
;;;438    }
000048  bd10              POP      {r4,pc}
;;;439    /*读一个数据*/
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      0x40012000
                  |L14.80|
                          DCD      0x40011400
                  |L14.84|
                          DCD      0x4001180c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  tabel
                          %        2111

                          AREA ||.data||, DATA, ALIGN=1

                  GPIO_InitStructure
                          DCDU     0x00000000
