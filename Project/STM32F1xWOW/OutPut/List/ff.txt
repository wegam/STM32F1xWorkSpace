; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\ff.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\ff.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\ff.crf ..\..\Driver\FatFs\source\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;4123   *******************************************************************************/
;;;4124   static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;4125   	FATFS* fs,			/* Filesystem object */
;;;4126   	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
;;;4127   )
;;;4128   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4129   	fs->wflag   = 0;            //文件是否改动的标志，为1时要回写。
000006  2000              MOVS     r0,#0
000008  70e0              STRB     r0,[r4,#3]
;;;4130     fs->winsect = 0xFFFFFFFF;		//窗口中出现的扇区  /* Invaidate window */
00000a  1e40              SUBS     r0,r0,#1
00000c  62e0              STR      r0,[r4,#0x2c]
;;;4131     //改变文件系统的当前工作扇区，如果想要操作的扇区就是当前扇区，什么事不做；如果不是，则将原扇区写回；如果是FAT表，还得写入备份区。
;;;4132     //这个函数内部使用，外部无法引用。
;;;4133   	if (move_window(fs, sect) != FR_OK)   //检查读写数据功能并读取数据
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       move_window
000016  b108              CBZ      r0,|L1.28|
;;;4134       return 4;	/* Load boot record */    //加载引导记录
000018  2004              MOVS     r0,#4
                  |L1.26|
;;;4135   
;;;4136   	if (ld_word(fs->win + BS_55AA) != 0xAA55) 	/* Check boot record signature (always here regardless of the sector size) */ //检查引导记录签名（总是在这里不考虑扇区大小）
;;;4137       return 3;
;;;4138   
;;;4139   #if FF_FS_EXFAT
;;;4140   	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) 	/* Check if exFAT VBR */
;;;4141       return 1;
;;;4142   #endif
;;;4143   	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) 
;;;4144     {	/* Valid JumpBoot code? */
;;;4145   		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
;;;4146   		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
;;;4147   	}
;;;4148   	return 2;	/* Valid BS but not FAT */    //有效Bs但不是FAT
;;;4149   }
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  f204202e          ADD      r0,r4,#0x22e          ;4136
000020  f7fffffe          BL       ld_word
000024  f64a2155          MOV      r1,#0xaa55            ;4136
000028  4288              CMP      r0,r1                 ;4136
00002a  d001              BEQ      |L1.48|
00002c  2003              MOVS     r0,#3                 ;4137
00002e  e7f4              B        |L1.26|
                  |L1.48|
000030  f8940030          LDRB     r0,[r4,#0x30]         ;4143
000034  28e9              CMP      r0,#0xe9              ;4143
000036  d007              BEQ      |L1.72|
000038  f8940030          LDRB     r0,[r4,#0x30]         ;4143
00003c  28eb              CMP      r0,#0xeb              ;4143
00003e  d003              BEQ      |L1.72|
000040  f8940030          LDRB     r0,[r4,#0x30]         ;4143
000044  28e8              CMP      r0,#0xe8              ;4143
000046  d111              BNE      |L1.108|
                  |L1.72|
000048  2203              MOVS     r2,#3                 ;4145
00004a  a109              ADR      r1,|L1.112|
00004c  f1040066          ADD      r0,r4,#0x66           ;4145
000050  f7fffffe          BL       mem_cmp
000054  b908              CBNZ     r0,|L1.90|
000056  2000              MOVS     r0,#0                 ;4145
000058  e7df              B        |L1.26|
                  |L1.90|
00005a  2205              MOVS     r2,#5                 ;4146
00005c  a105              ADR      r1,|L1.116|
00005e  f1040082          ADD      r0,r4,#0x82           ;4146
000062  f7fffffe          BL       mem_cmp
000066  b908              CBNZ     r0,|L1.108|
000068  2000              MOVS     r0,#0                 ;4146
00006a  e7d6              B        |L1.26|
                  |L1.108|
00006c  2002              MOVS     r0,#2                 ;4148
00006e  e7d4              B        |L1.26|
;;;4150   
                          ENDP

                  |L1.112|
000070  46415400          DCB      "FAT",0
                  |L1.116|
000074  46415433          DCB      "FAT32",0
000078  3200    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;678    /* Check if chr is contained in the string *//*内存查找关键字符memchr*/
;;;679    static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
000000  4602              MOV      r2,r0
;;;680    {
;;;681    	while (*str && *str != chr)
000002  e000              B        |L2.6|
                  |L2.4|
;;;682        str++;
000004  1c52              ADDS     r2,r2,#1
                  |L2.6|
000006  7810              LDRB     r0,[r2,#0]            ;681
000008  b110              CBZ      r0,|L2.16|
00000a  7810              LDRB     r0,[r2,#0]            ;681
00000c  4288              CMP      r0,r1                 ;681
00000e  d1f9              BNE      |L2.4|
                  |L2.16|
;;;683    	return *str;
000010  7810              LDRB     r0,[r2,#0]
;;;684    }
000012  4770              BX       lr
;;;685    /* Test if the character is DBC 1st byte *//**/
                          ENDP


                          AREA ||i.clst2sect||, CODE, READONLY, ALIGN=1

                  clst2sect PROC
;;;1282   *******************************************************************************/
;;;1283   static DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
000000  4602              MOV      r2,r0
;;;1284   	FATFS* fs,		/* Filesystem object */
;;;1285   	DWORD clst		/* Cluster# to be converted */
;;;1286   )
;;;1287   {
;;;1288   	clst -= 2;		/* Cluster number is origin from 2 */   //簇号对齐
000002  1e89              SUBS     r1,r1,#2
;;;1289   	if (clst >= fs->n_fatent - 2)             /* Is it invalid cluster number? */ //无效簇编号
000004  6950              LDR      r0,[r2,#0x14]
000006  1e80              SUBS     r0,r0,#2
000008  4288              CMP      r0,r1
00000a  d801              BHI      |L3.16|
;;;1290       return 0;	
00000c  2000              MOVS     r0,#0
                  |L3.14|
;;;1291     //============================返回起始扇区号
;;;1292   	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
;;;1293   }
00000e  4770              BX       lr
                  |L3.16|
000010  8953              LDRH     r3,[r2,#0xa]          ;1292
000012  6a90              LDR      r0,[r2,#0x28]         ;1292
000014  fb030001          MLA      r0,r3,r1,r0           ;1292
000018  e7f9              B        |L3.14|
;;;1294   
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;1806   *******************************************************************************/
;;;1807   static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1808   	FFOBJID* obj,		/* Corresponding object */
;;;1809   	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
;;;1810   )
;;;1811   {
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
;;;1812   	DWORD cs, ncl, scl;
;;;1813   	FRESULT res;    //文件函数执行结果返回码
;;;1814   	FATFS *fs = obj->fs;
000008  f8da4000          LDR      r4,[r10,#0]
;;;1815   
;;;1816   
;;;1817   	if (clst == 0)  /* Create a new chain */
00000c  f1b80f00          CMP      r8,#0
000010  d106              BNE      |L4.32|
;;;1818     {	
;;;1819   		scl = fs->last_clst;				/* Suggested cluster to start to find */
000012  68e7              LDR      r7,[r4,#0xc]
;;;1820   		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
000014  b117              CBZ      r7,|L4.28|
000016  6960              LDR      r0,[r4,#0x14]
000018  42b8              CMP      r0,r7
00001a  d815              BHI      |L4.72|
                  |L4.28|
00001c  2701              MOVS     r7,#1
00001e  e013              B        |L4.72|
                  |L4.32|
;;;1821   	}
;;;1822   	else  /* Stretch a chain */
;;;1823     {				
;;;1824   		cs = get_fat(obj, clst);			/* Check the cluster status */
000020  4641              MOV      r1,r8
000022  4650              MOV      r0,r10
000024  f7fffffe          BL       get_fat
000028  4605              MOV      r5,r0
;;;1825   		if (cs < 2)             /* Test for insanity */
00002a  2d02              CMP      r5,#2
00002c  d202              BCS      |L4.52|
;;;1826         return 1;				
00002e  2001              MOVS     r0,#1
                  |L4.48|
;;;1827   		if (cs == 0xFFFFFFFF)   /* Test for disk error */
;;;1828         return cs;	
;;;1829   		if (cs < fs->n_fatent)  /* It is already followed by next cluster */
;;;1830         return cs;	
;;;1831   		scl = clst;							/* Cluster to start to find */
;;;1832   	}
;;;1833   	if (fs->free_clst == 0)   /* No free cluster */
;;;1834       return 0;		
;;;1835   
;;;1836   #if FF_FS_EXFAT
;;;1837   	if (fs->fs_type == FS_EXFAT)  /* On the exFAT volume */
;;;1838     {	
;;;1839   		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
;;;1840   		if (ncl == 0 || ncl == 0xFFFFFFFF)    /* No free cluster or hard error? */
;;;1841         return ncl;	
;;;1842   		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
;;;1843   		if (res == FR_INT_ERR)
;;;1844         return 1;
;;;1845   		if (res == FR_DISK_ERR)
;;;1846         return 0xFFFFFFFF;
;;;1847   		if (clst == 0)  /* Is it a new chain? */
;;;1848       {							
;;;1849   			obj->stat = 2;							/* Set status 'contiguous' */
;;;1850   		}
;;;1851       else            /* It is a stretched chain */
;;;1852       {									
;;;1853   			if (obj->stat == 2 && ncl != scl + 1)   /* Is the chain got fragmented? */
;;;1854         {	
;;;1855   				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
;;;1856   				obj->stat = 3;						/* Change status 'just fragmented' */
;;;1857   			}
;;;1858   		}
;;;1859   		if (obj->stat != 2)     /* Is the file non-contiguous? */
;;;1860       {	
;;;1861   			if (ncl == clst + 1)  /* Is the cluster next to previous one? */
;;;1862         {	
;;;1863   				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
;;;1864   			}
;;;1865         else    /* New fragment */
;;;1866         {				
;;;1867   				if (obj->n_frag == 0)
;;;1868             obj->n_frag = 1;
;;;1869   				res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
;;;1870   				if (res == FR_OK)
;;;1871             obj->n_frag = 1;
;;;1872   			}
;;;1873   		}
;;;1874   	} else
;;;1875   #endif
;;;1876   	{	/* On the FAT/FAT32 volume */
;;;1877   		ncl = 0;
;;;1878   		if (scl == clst)  /* Stretching an existing chain? */
;;;1879       {						
;;;1880   			ncl = scl + 1;						/* Test if next cluster is free */
;;;1881   			if (ncl >= fs->n_fatent)
;;;1882           ncl = 2;
;;;1883   			cs = get_fat(obj, ncl);				/* Get next cluster status */
;;;1884   			if (cs == 1 || cs == 0xFFFFFFFF)  /* Test for error */
;;;1885           return cs;	
;;;1886   			if (cs != 0)  /* Not free? */
;;;1887         {						
;;;1888   				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
;;;1889   				if (cs >= 2 && cs < fs->n_fatent)
;;;1890             scl = cs;
;;;1891   				ncl = 0;
;;;1892   			}
;;;1893   		}
;;;1894   		if(ncl == 0)  /* The new cluster cannot be contiguous and find another fragment */
;;;1895       {	
;;;1896   			ncl = scl;	/* Start cluster */
;;;1897   			for (;;)
;;;1898         {
;;;1899   				ncl++;							      /* Next cluster */
;;;1900   				if (ncl >= fs->n_fatent)  /* Check wrap-around */
;;;1901           {		
;;;1902   					ncl = 2;
;;;1903   					if (ncl > scl)    /* No free cluster found? */
;;;1904               return 0;	
;;;1905   				}
;;;1906   				cs = get_fat(obj, ncl); /* Get the cluster status */
;;;1907   				if (cs == 0)    /* Found a free cluster? */
;;;1908             break;				
;;;1909   				if (cs == 1 || cs == 0xFFFFFFFF)  /* Test for error */
;;;1910             return cs;	
;;;1911   				if (ncl == scl) /* No free cluster found? */
;;;1912             return 0;		
;;;1913   			}
;;;1914   		}
;;;1915   		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
;;;1916   		if (res == FR_OK && clst != 0)
;;;1917       {
;;;1918   			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
;;;1919   		}
;;;1920   	}
;;;1921   
;;;1922   	if (res == FR_OK) /* Update FSINFO if function succeeded. */
;;;1923     {			
;;;1924   		fs->last_clst = ncl;
;;;1925   		if (fs->free_clst <= fs->n_fatent - 2)
;;;1926         fs->free_clst--;
;;;1927   		fs->fsi_flag |= 1;
;;;1928   	}
;;;1929     else
;;;1930     {
;;;1931   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
;;;1932   	}
;;;1933   	return ncl;		/* Return new cluster number or error status */
;;;1934   }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L4.52|
000034  1c68              ADDS     r0,r5,#1              ;1827
000036  b908              CBNZ     r0,|L4.60|
000038  4628              MOV      r0,r5                 ;1828
00003a  e7f9              B        |L4.48|
                  |L4.60|
00003c  6960              LDR      r0,[r4,#0x14]         ;1829
00003e  42a8              CMP      r0,r5                 ;1829
000040  d901              BLS      |L4.70|
000042  4628              MOV      r0,r5                 ;1830
000044  e7f4              B        |L4.48|
                  |L4.70|
000046  4647              MOV      r7,r8                 ;1831
                  |L4.72|
000048  6920              LDR      r0,[r4,#0x10]         ;1833
00004a  b908              CBNZ     r0,|L4.80|
00004c  2000              MOVS     r0,#0                 ;1834
00004e  e7ef              B        |L4.48|
                  |L4.80|
000050  2600              MOVS     r6,#0                 ;1877
000052  4547              CMP      r7,r8                 ;1878
000054  d118              BNE      |L4.136|
000056  1c7e              ADDS     r6,r7,#1              ;1880
000058  6960              LDR      r0,[r4,#0x14]         ;1881
00005a  42b0              CMP      r0,r6                 ;1881
00005c  d800              BHI      |L4.96|
00005e  2602              MOVS     r6,#2                 ;1882
                  |L4.96|
000060  4631              MOV      r1,r6                 ;1883
000062  4650              MOV      r0,r10                ;1883
000064  f7fffffe          BL       get_fat
000068  4605              MOV      r5,r0                 ;1883
00006a  2d01              CMP      r5,#1                 ;1884
00006c  d001              BEQ      |L4.114|
00006e  1c68              ADDS     r0,r5,#1              ;1884
000070  b908              CBNZ     r0,|L4.118|
                  |L4.114|
000072  4628              MOV      r0,r5                 ;1885
000074  e7dc              B        |L4.48|
                  |L4.118|
000076  b13d              CBZ      r5,|L4.136|
000078  68e5              LDR      r5,[r4,#0xc]          ;1888
00007a  2d02              CMP      r5,#2                 ;1889
00007c  d303              BCC      |L4.134|
00007e  6960              LDR      r0,[r4,#0x14]         ;1889
000080  42a8              CMP      r0,r5                 ;1889
000082  d900              BLS      |L4.134|
000084  462f              MOV      r7,r5                 ;1890
                  |L4.134|
000086  2600              MOVS     r6,#0                 ;1891
                  |L4.136|
000088  b9e6              CBNZ     r6,|L4.196|
00008a  463e              MOV      r6,r7                 ;1896
00008c  bf00              NOP                            ;1897
                  |L4.142|
00008e  1c76              ADDS     r6,r6,#1              ;1899
000090  6960              LDR      r0,[r4,#0x14]         ;1900
000092  42b0              CMP      r0,r6                 ;1900
000094  d804              BHI      |L4.160|
000096  2602              MOVS     r6,#2                 ;1902
000098  42be              CMP      r6,r7                 ;1903
00009a  d901              BLS      |L4.160|
00009c  2000              MOVS     r0,#0                 ;1904
00009e  e7c7              B        |L4.48|
                  |L4.160|
0000a0  4631              MOV      r1,r6                 ;1906
0000a2  4650              MOV      r0,r10                ;1906
0000a4  f7fffffe          BL       get_fat
0000a8  4605              MOV      r5,r0                 ;1906
0000aa  b905              CBNZ     r5,|L4.174|
0000ac  e009              B        |L4.194|
                  |L4.174|
0000ae  2d01              CMP      r5,#1                 ;1909
0000b0  d001              BEQ      |L4.182|
0000b2  1c68              ADDS     r0,r5,#1              ;1909
0000b4  b908              CBNZ     r0,|L4.186|
                  |L4.182|
0000b6  4628              MOV      r0,r5                 ;1910
0000b8  e7ba              B        |L4.48|
                  |L4.186|
0000ba  42be              CMP      r6,r7                 ;1911
0000bc  d1e7              BNE      |L4.142|
0000be  2000              MOVS     r0,#0                 ;1912
0000c0  e7b6              B        |L4.48|
                  |L4.194|
0000c2  bf00              NOP                            ;1908
                  |L4.196|
0000c4  f04f32ff          MOV      r2,#0xffffffff        ;1915
0000c8  4631              MOV      r1,r6                 ;1915
0000ca  4620              MOV      r0,r4                 ;1915
0000cc  f7fffffe          BL       put_fat
0000d0  4681              MOV      r9,r0                 ;1915
0000d2  f1b90f00          CMP      r9,#0                 ;1916
0000d6  d108              BNE      |L4.234|
0000d8  f1b80f00          CMP      r8,#0                 ;1916
0000dc  d005              BEQ      |L4.234|
0000de  4632              MOV      r2,r6                 ;1918
0000e0  4641              MOV      r1,r8                 ;1918
0000e2  4620              MOV      r0,r4                 ;1918
0000e4  f7fffffe          BL       put_fat
0000e8  4681              MOV      r9,r0                 ;1918
                  |L4.234|
0000ea  f1b90f00          CMP      r9,#0                 ;1922
0000ee  d10d              BNE      |L4.268|
0000f0  60e6              STR      r6,[r4,#0xc]          ;1924
0000f2  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;1925
0000f6  1e80              SUBS     r0,r0,#2              ;1925
0000f8  4281              CMP      r1,r0                 ;1925
0000fa  d802              BHI      |L4.258|
0000fc  6920              LDR      r0,[r4,#0x10]         ;1926
0000fe  1e40              SUBS     r0,r0,#1              ;1926
000100  6120              STR      r0,[r4,#0x10]         ;1926
                  |L4.258|
000102  7920              LDRB     r0,[r4,#4]            ;1927
000104  f0400001          ORR      r0,r0,#1              ;1927
000108  7120              STRB     r0,[r4,#4]            ;1927
00010a  e007              B        |L4.284|
                  |L4.268|
00010c  f1b90f01          CMP      r9,#1                 ;1931
000110  d102              BNE      |L4.280|
000112  f04f30ff          MOV      r0,#0xffffffff        ;1931
000116  e000              B        |L4.282|
                  |L4.280|
000118  2001              MOVS     r0,#1                 ;1931
                  |L4.282|
00011a  4606              MOV      r6,r0                 ;1931
                  |L4.284|
00011c  4630              MOV      r0,r6                 ;1933
00011e  e787              B        |L4.48|
;;;1935   
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;3644   *******************************************************************************/
;;;3645   static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
000000  e92d5ff3          PUSH     {r0,r1,r4-r12,lr}
;;;3646   	DIR* dp,					/* Pointer to the directory object */
;;;3647   	const TCHAR** path			/* Pointer to pointer to the segment in the path string */
;;;3648   )
;;;3649   {
000004  4689              MOV      r9,r1
;;;3650   #if FF_USE_LFN		/* LFN configuration */
;;;3651   	BYTE b, cf;
;;;3652   	WCHAR wc, *lfn;
;;;3653   	DWORD uc;
;;;3654   	UINT i, ni, si, di;
;;;3655   	const TCHAR *p;
;;;3656   
;;;3657   
;;;3658   	/* Create LFN into LFN working buffer */
;;;3659   	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
;;;3660   	for (;;) 
;;;3661     {
;;;3662   		uc = tchar2uni(&p);			/* Get a character */
;;;3663   		if (uc == 0xFFFFFFFF) 
;;;3664         return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
;;;3665   		if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
;;;3666         wc = (WCHAR)uc;
;;;3667   		if (wc < ' ' || wc == '/' || wc == '\\') 
;;;3668         break;	/* Break if end of the path or a separator is found */
;;;3669   		if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) 
;;;3670         return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
;;;3671   		if (di >= FF_MAX_LFN) 
;;;3672         return FR_INVALID_NAME;	/* Reject too long name */
;;;3673   		lfn[di++] = wc;					/* Store the Unicode character */
;;;3674   	}
;;;3675   	while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
;;;3676   	*path = p;							/* Return pointer to the next segment */
;;;3677   	cf = (wc < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
;;;3678   
;;;3679   #if FF_FS_RPATH != 0
;;;3680   	if ((di == 1 && lfn[di - 1] == '.')
;;;3681       ||(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) 
;;;3682     {	/* Is this segment a dot name? */
;;;3683   		lfn[di] = 0;
;;;3684   		for (i = 0; i < 11; i++) 
;;;3685       {		/* Create dot name for SFN entry */
;;;3686   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;3687   		}
;;;3688   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;3689   		return FR_OK;
;;;3690   	}
;;;3691   #endif
;;;3692   	while (di)
;;;3693     {						/* Snip off trailing spaces and dots if exist */
;;;3694   		wc = lfn[di - 1];
;;;3695   		if (wc != ' ' && wc != '.')
;;;3696         break;
;;;3697   		di--;
;;;3698   	}
;;;3699   	lfn[di] = 0;							/* LFN is created into the working buffer */
;;;3700   	if (di == 0) 
;;;3701       return FR_INVALID_NAME;	/* Reject null name */
;;;3702   	/* Create SFN in directory form */
;;;3703   	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
;;;3704   	if (si > 0 || lfn[si] == '.')
;;;3705       cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
;;;3706   	while (di > 0 && lfn[di - 1] != '.')
;;;3707       di--;	/* Find last dot (di<=si: no extension) */
;;;3708   
;;;3709   	mem_set(dp->fn, ' ', 11);
;;;3710   	i = b = 0; ni = 8;
;;;3711   	for (;;)
;;;3712     {
;;;3713   		wc = lfn[si++];					/* Get an LFN character */
;;;3714   		if (wc == 0) 
;;;3715         break;				/* Break on end of the LFN */
;;;3716   		if (wc == ' ' || (wc == '.' && si != di))
;;;3717       {	/* Remove embedded spaces and dots */
;;;3718   			cf |= NS_LOSS | NS_LFN;
;;;3719   			continue;
;;;3720   		}
;;;3721   
;;;3722   		if (i >= ni || si == di)
;;;3723       {		/* End of field? */
;;;3724   			if (ni == 11)
;;;3725         {				/* Name extension overflow? */
;;;3726   				cf |= NS_LOSS | NS_LFN;
;;;3727   				break;
;;;3728   			}
;;;3729   			if (si != di)
;;;3730           cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
;;;3731   			if (si > di)
;;;3732           break;						/* No name extension? */
;;;3733   			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
;;;3734   			continue;
;;;3735   		}
;;;3736   		if (wc >= 0x80)
;;;3737       {	/* Is this a non-ASCII character? */
;;;3738   			cf |= NS_LFN;	/* LFN entry needs to be created */
;;;3739   #if FF_CODE_PAGE == 0
;;;3740   			if (ExCvt)
;;;3741         {	/* At SBCS */
;;;3742   				wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
;;;3743   				if (wc & 0x80) 
;;;3744             wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
;;;3745   			}
;;;3746         else
;;;3747         {		/* At DBCS */
;;;3748   				wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
;;;3749   			}
;;;3750   #elif FF_CODE_PAGE < 900	/* SBCS cfg */
;;;3751   			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
;;;3752   			if (wc & 0x80) 
;;;3753           wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
;;;3754   #else						/* DBCS cfg */  //DBCS为双位元组字元系统 Double Byte Char Systems 
;;;3755   			wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
;;;3756   #endif
;;;3757   		}
;;;3758   
;;;3759   		if (wc >= 0x100) 
;;;3760       {				/* Is this a DBC? */
;;;3761   			if (i >= ni - 1) 
;;;3762         {			/* Field overflow? */
;;;3763   				cf |= NS_LOSS | NS_LFN;
;;;3764   				i = ni; 
;;;3765           continue;		/* Next field */
;;;3766   			}
;;;3767   			dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
;;;3768   		}
;;;3769       else
;;;3770       {						/* SBC */
;;;3771   			if (wc == 0 || chk_chr("+,;=[]", wc))
;;;3772         {	/* Replace illegal characters for SFN if needed */
;;;3773   				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;3774   			}
;;;3775         else
;;;3776         {
;;;3777   				if (IsUpper(wc))
;;;3778           {		/* ASCII upper case? */
;;;3779   					b |= 2;
;;;3780   				}
;;;3781   				if (IsLower(wc))
;;;3782           {		/* ASCII lower case? */
;;;3783   					b |= 1; wc -= 0x20;
;;;3784   				}
;;;3785   			}
;;;3786   		}
;;;3787   		dp->fn[i++] = (BYTE)wc;
;;;3788   	}
;;;3789   
;;;3790   	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;3791   
;;;3792   	if (ni == 8)
;;;3793       b <<= 2;				/* Shift capital flags if no extension */
;;;3794   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)
;;;3795       cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
;;;3796   	if (!(cf & NS_LFN))
;;;3797     {				/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;3798   		if (b & 0x01)
;;;3799         cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
;;;3800   		if (b & 0x04)
;;;3801         cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
;;;3802   	}
;;;3803   
;;;3804   	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
;;;3805   
;;;3806   	return FR_OK;
;;;3807   
;;;3808   
;;;3809   #else	/* FF_USE_LFN : Non-LFN configuration */
;;;3810   	BYTE c, d, *sfn;
;;;3811   	UINT ni, si, i;
;;;3812   	const char *p;
;;;3813   
;;;3814   	/* Create file name in directory form */
;;;3815   	p = *path; sfn = dp->fn;
000006  f8d98000          LDR      r8,[r9,#0]
00000a  9800              LDR      r0,[sp,#0]
00000c  f1000520          ADD      r5,r0,#0x20
;;;3816   	mem_set(sfn, ' ', 11);
000010  220b              MOVS     r2,#0xb
000012  2120              MOVS     r1,#0x20
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       mem_set
;;;3817   	si = i = 0; ni = 8;
00001a  2000              MOVS     r0,#0
00001c  4607              MOV      r7,r0
00001e  4606              MOV      r6,r0
000020  f04f0b08          MOV      r11,#8
;;;3818   #if FF_FS_RPATH != 0
;;;3819   	if (p[si] == '.') { /* Is this a dot entry? */
;;;3820   		for (;;) {
;;;3821   			c = (BYTE)p[si++];
;;;3822   			if (c != '.' || si >= 3) break;
;;;3823   			sfn[i++] = c;
;;;3824   		}
;;;3825   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;3826   		*path = p + si;								/* Return pointer to the next segment */
;;;3827   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
;;;3828   		return FR_OK;
;;;3829   	}
;;;3830   #endif
;;;3831   	for (;;)
000024  bf00              NOP      
                  |L5.38|
;;;3832    {
;;;3833   		c = (BYTE)p[si++];				/* Get a byte */
000026  4630              MOV      r0,r6
000028  1c76              ADDS     r6,r6,#1
00002a  f8184000          LDRB     r4,[r8,r0]
;;;3834   		if (c <= ' ') break; 			/* Break if end of the path name */
00002e  2c20              CMP      r4,#0x20
000030  dc00              BGT      |L5.52|
000032  e04a              B        |L5.202|
                  |L5.52|
;;;3835   		if (c == '/' || c == '\\')
000034  2c2f              CMP      r4,#0x2f
000036  d001              BEQ      |L5.60|
000038  2c5c              CMP      r4,#0x5c
00003a  d10a              BNE      |L5.82|
                  |L5.60|
;;;3836       {	/* Break if a separator is found */
;;;3837   			while (p[si] == '/' || p[si] == '\\') 
00003c  e000              B        |L5.64|
                  |L5.62|
;;;3838           si++;	/* Skip duplicated separator if exist */
00003e  1c76              ADDS     r6,r6,#1
                  |L5.64|
000040  f8180006          LDRB     r0,[r8,r6]            ;3837
000044  282f              CMP      r0,#0x2f              ;3837
000046  d0fa              BEQ      |L5.62|
000048  f8180006          LDRB     r0,[r8,r6]            ;3837
00004c  285c              CMP      r0,#0x5c              ;3837
00004e  d0f6              BEQ      |L5.62|
;;;3839   			break;
000050  e03b              B        |L5.202|
                  |L5.82|
;;;3840   		}
;;;3841   		if (c == '.' || i >= ni) 
000052  2c2e              CMP      r4,#0x2e
000054  d001              BEQ      |L5.90|
000056  455f              CMP      r7,r11
000058  d30b              BCC      |L5.114|
                  |L5.90|
;;;3842       {		/* End of body or field overflow? */
;;;3843   			if (ni == 11 || c != '.')
00005a  f1bb0f0b          CMP      r11,#0xb
00005e  d001              BEQ      |L5.100|
000060  2c2e              CMP      r4,#0x2e
000062  d002              BEQ      |L5.106|
                  |L5.100|
;;;3844           return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
000064  2006              MOVS     r0,#6
                  |L5.102|
;;;3845   			i = 8; ni = 11;				/* Enter file extension field */
;;;3846   			continue;
;;;3847   		}
;;;3848   #if FF_CODE_PAGE == 0
;;;3849   		if (ExCvt && c >= 0x80)
;;;3850       {		/* Is SBC extended character? */
;;;3851   			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
;;;3852   		}
;;;3853   #elif FF_CODE_PAGE < 900
;;;3854   		if (c >= 0x80)
;;;3855       {				/* Is SBC extended character? */
;;;3856   			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
;;;3857   		}
;;;3858   #endif
;;;3859   		if (dbc_1st(c))
;;;3860       {				/* Check if it is a DBC 1st byte */
;;;3861   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;3862   			if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
;;;3863   			sfn[i++] = c;
;;;3864   			sfn[i++] = d;
;;;3865   		}
;;;3866       else
;;;3867       {						/* SBC */
;;;3868   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) 
;;;3869           return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
;;;3870   			if (IsLower(c)) 
;;;3871           c -= 0x20;	/* To upper */
;;;3872   			sfn[i++] = c;
;;;3873   		}
;;;3874   	}
;;;3875   	*path = p + si;						/* Return pointer to the next segment */
;;;3876   	if (i == 0) 
;;;3877       return FR_INVALID_NAME;	/* Reject nul string */
;;;3878   
;;;3879   	if (sfn[0] == DDEM)
;;;3880       sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;3881   	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
;;;3882   
;;;3883   	return FR_OK;
;;;3884   #endif /* FF_USE_LFN */
;;;3885   }
000066  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.106|
00006a  2708              MOVS     r7,#8                 ;3845
00006c  f04f0b0b          MOV      r11,#0xb              ;3845
000070  e7d9              B        |L5.38|
                  |L5.114|
000072  4620              MOV      r0,r4                 ;3859
000074  f7fffffe          BL       dbc_1st
000078  b1a8              CBZ      r0,|L5.166|
00007a  4630              MOV      r0,r6                 ;3861
00007c  1c76              ADDS     r6,r6,#1              ;3861
00007e  f818a000          LDRB     r10,[r8,r0]           ;3861
000082  4650              MOV      r0,r10                ;3862
000084  f7fffffe          BL       dbc_2nd
000088  b118              CBZ      r0,|L5.146|
00008a  f1ab0001          SUB      r0,r11,#1             ;3862
00008e  42b8              CMP      r0,r7                 ;3862
000090  d801              BHI      |L5.150|
                  |L5.146|
000092  2006              MOVS     r0,#6                 ;3862
000094  e7e7              B        |L5.102|
                  |L5.150|
000096  4638              MOV      r0,r7                 ;3863
000098  1c7f              ADDS     r7,r7,#1              ;3863
00009a  542c              STRB     r4,[r5,r0]            ;3863
00009c  4638              MOV      r0,r7                 ;3864
00009e  1c7f              ADDS     r7,r7,#1              ;3864
0000a0  f805a000          STRB     r10,[r5,r0]           ;3864
0000a4  e010              B        |L5.200|
                  |L5.166|
0000a6  4621              MOV      r1,r4                 ;3868
0000a8  a012              ADR      r0,|L5.244|
0000aa  f7fffffe          BL       chk_chr
0000ae  b108              CBZ      r0,|L5.180|
0000b0  2006              MOVS     r0,#6                 ;3869
0000b2  e7d8              B        |L5.102|
                  |L5.180|
0000b4  2c61              CMP      r4,#0x61              ;3870
0000b6  db04              BLT      |L5.194|
0000b8  2c7a              CMP      r4,#0x7a              ;3870
0000ba  dc02              BGT      |L5.194|
0000bc  f1a40020          SUB      r0,r4,#0x20           ;3871
0000c0  b2c4              UXTB     r4,r0                 ;3871
                  |L5.194|
0000c2  4638              MOV      r0,r7                 ;3872
0000c4  1c7f              ADDS     r7,r7,#1              ;3872
0000c6  542c              STRB     r4,[r5,r0]            ;3872
                  |L5.200|
0000c8  e7ad              B        |L5.38|
                  |L5.202|
0000ca  bf00              NOP                            ;3834
0000cc  eb080006          ADD      r0,r8,r6              ;3875
0000d0  f8c90000          STR      r0,[r9,#0]            ;3875
0000d4  b90f              CBNZ     r7,|L5.218|
0000d6  2006              MOVS     r0,#6                 ;3877
0000d8  e7c5              B        |L5.102|
                  |L5.218|
0000da  7828              LDRB     r0,[r5,#0]            ;3879
0000dc  28e5              CMP      r0,#0xe5              ;3879
0000de  d101              BNE      |L5.228|
0000e0  2005              MOVS     r0,#5                 ;3880
0000e2  7028              STRB     r0,[r5,#0]            ;3880
                  |L5.228|
0000e4  2c20              CMP      r4,#0x20              ;3881
0000e6  dc01              BGT      |L5.236|
0000e8  2004              MOVS     r0,#4                 ;3881
0000ea  e000              B        |L5.238|
                  |L5.236|
0000ec  2000              MOVS     r0,#0                 ;3881
                  |L5.238|
0000ee  72e8              STRB     r0,[r5,#0xb]          ;3881
0000f0  2000              MOVS     r0,#0                 ;3883
0000f2  e7b8              B        |L5.102|
;;;3886   
                          ENDP

                  |L5.244|
0000f4  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
0000f8  3a3b3c3d
0000fc  3e3f5b5d
000100  7c7f00  
000103  00                DCB      0

                          AREA ||i.dbc_1st||, CODE, READONLY, ALIGN=2

                  dbc_1st PROC
;;;685    /* Test if the character is DBC 1st byte *//**/
;;;686    static int dbc_1st (BYTE c)
000000  4601              MOV      r1,r0
;;;687    {
;;;688    #if FF_CODE_PAGE == 0		/* Variable code page */
;;;689    	if (DbcTbl && c >= DbcTbl[0])
;;;690      {
;;;691    		if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
;;;692    		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
;;;693    	}
;;;694    #elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
;;;695    	if (c >= DbcTbl[0])
000002  480b              LDR      r0,|L6.48|
000004  7800              LDRB     r0,[r0,#0]  ; DbcTbl
000006  4288              CMP      r0,r1
000008  dc0f              BGT      |L6.42|
;;;696      {
;;;697    		if (c <= DbcTbl[1]) return 1;
00000a  4809              LDR      r0,|L6.48|
00000c  7840              LDRB     r0,[r0,#1]  ; DbcTbl
00000e  4288              CMP      r0,r1
000010  db01              BLT      |L6.22|
000012  2001              MOVS     r0,#1
                  |L6.20|
;;;698    		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
;;;699    	}
;;;700    #else						/* SBCS fixed code page */
;;;701    	if (c != 0) return 0;	/* Always false */
;;;702    #endif
;;;703    	return 0;
;;;704    }
000014  4770              BX       lr
                  |L6.22|
000016  4806              LDR      r0,|L6.48|
000018  7880              LDRB     r0,[r0,#2]            ;698  ; DbcTbl
00001a  4288              CMP      r0,r1                 ;698
00001c  dc05              BGT      |L6.42|
00001e  4804              LDR      r0,|L6.48|
000020  78c0              LDRB     r0,[r0,#3]            ;698  ; DbcTbl
000022  4288              CMP      r0,r1                 ;698
000024  db01              BLT      |L6.42|
000026  2001              MOVS     r0,#1                 ;698
000028  e7f4              B        |L6.20|
                  |L6.42|
00002a  2000              MOVS     r0,#0                 ;703
00002c  e7f2              B        |L6.20|
;;;705    /* Test if the character is DBC 2nd byte */
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      DbcTbl

                          AREA ||i.dbc_2nd||, CODE, READONLY, ALIGN=2

                  dbc_2nd PROC
;;;705    /* Test if the character is DBC 2nd byte */
;;;706    static int dbc_2nd (BYTE c)
000000  4601              MOV      r1,r0
;;;707    {
;;;708    #if FF_CODE_PAGE == 0		/* Variable code page */
;;;709    	if (DbcTbl && c >= DbcTbl[4])
;;;710      {
;;;711    		if (c <= DbcTbl[5]) return 1;					/* 2nd byte range 1 */
;;;712    		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
;;;713    		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
;;;714    	}
;;;715    #elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
;;;716    	if (c >= DbcTbl[4]) {
000002  4810              LDR      r0,|L7.68|
000004  7900              LDRB     r0,[r0,#4]  ; DbcTbl
000006  4288              CMP      r0,r1
000008  dc19              BGT      |L7.62|
;;;717    		if (c <= DbcTbl[5]) return 1;
00000a  480e              LDR      r0,|L7.68|
00000c  7940              LDRB     r0,[r0,#5]  ; DbcTbl
00000e  4288              CMP      r0,r1
000010  db01              BLT      |L7.22|
000012  2001              MOVS     r0,#1
                  |L7.20|
;;;718    		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
;;;719    		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
;;;720    	}
;;;721    #else						/* SBCS fixed code page */
;;;722    	if (c != 0) return 0;	/* Always false */
;;;723    #endif
;;;724    	return 0;
;;;725    }
000014  4770              BX       lr
                  |L7.22|
000016  480b              LDR      r0,|L7.68|
000018  7980              LDRB     r0,[r0,#6]            ;718  ; DbcTbl
00001a  4288              CMP      r0,r1                 ;718
00001c  dc05              BGT      |L7.42|
00001e  4809              LDR      r0,|L7.68|
000020  79c0              LDRB     r0,[r0,#7]            ;718  ; DbcTbl
000022  4288              CMP      r0,r1                 ;718
000024  db01              BLT      |L7.42|
000026  2001              MOVS     r0,#1                 ;718
000028  e7f4              B        |L7.20|
                  |L7.42|
00002a  4806              LDR      r0,|L7.68|
00002c  7a00              LDRB     r0,[r0,#8]            ;719  ; DbcTbl
00002e  4288              CMP      r0,r1                 ;719
000030  dc05              BGT      |L7.62|
000032  4804              LDR      r0,|L7.68|
000034  7a40              LDRB     r0,[r0,#9]            ;719  ; DbcTbl
000036  4288              CMP      r0,r1                 ;719
000038  db01              BLT      |L7.62|
00003a  2001              MOVS     r0,#1                 ;719
00003c  e7ea              B        |L7.20|
                  |L7.62|
00003e  2000              MOVS     r0,#0                 ;724
000040  e7e8              B        |L7.20|
;;;726    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      DbcTbl

                          AREA ||i.dir_alloc||, CODE, READONLY, ALIGN=1

                  dir_alloc PROC
;;;2197   *******************************************************************************/
;;;2198   static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2199   	DIR* dp,				/* Pointer to the directory object */
;;;2200   	UINT nent				/* Number of contiguous entries to allocate */
;;;2201   )
;;;2202   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;2203   	FRESULT res;    //文件函数执行结果返回码
;;;2204   	UINT n;
;;;2205   	FATFS *fs = dp->obj.fs;   //目录中包含的文件系统对象结构体地址
000008  f8d48000          LDR      r8,[r4,#0]
;;;2206   
;;;2207   
;;;2208   	res = dir_sdi(dp, 0);   //目录处理-设置目录索引--从0开始查找
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       dir_sdi
000014  4605              MOV      r5,r0
;;;2209   	if (res == FR_OK)
000016  b9ed              CBNZ     r5,|L8.84|
;;;2210     {
;;;2211   		n = 0;
000018  2700              MOVS     r7,#0
;;;2212   		do
00001a  bf00              NOP      
                  |L8.28|
;;;2213       {
;;;2214   			res = move_window(fs, dp->sect);
00001c  4640              MOV      r0,r8
00001e  69a1              LDR      r1,[r4,#0x18]
000020  f7fffffe          BL       move_window
000024  4605              MOV      r5,r0
;;;2215   			if (res != FR_OK)
000026  b105              CBZ      r5,|L8.42|
;;;2216           break;
000028  e013              B        |L8.82|
                  |L8.42|
;;;2217   #if FF_FS_EXFAT
;;;2218   			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0))
;;;2219         {
;;;2220   #else
;;;2221   			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)
00002a  69e0              LDR      r0,[r4,#0x1c]
00002c  7800              LDRB     r0,[r0,#0]
00002e  28e5              CMP      r0,#0xe5
000030  d002              BEQ      |L8.56|
000032  69e0              LDR      r0,[r4,#0x1c]
000034  7800              LDRB     r0,[r0,#0]
000036  b920              CBNZ     r0,|L8.66|
                  |L8.56|
;;;2222         {
;;;2223   #endif
;;;2224   				if (++n == nent)
000038  1c78              ADDS     r0,r7,#1
00003a  4607              MOV      r7,r0
00003c  42b0              CMP      r0,r6
00003e  d101              BNE      |L8.68|
;;;2225             break;	/* A block of contiguous free entries is found */
000040  e007              B        |L8.82|
                  |L8.66|
;;;2226   			}
;;;2227         else
;;;2228         {
;;;2229   				n = 0;					/* Not a blank entry. Restart to search */
000042  2700              MOVS     r7,#0
                  |L8.68|
;;;2230   			}
;;;2231   			res = dir_next(dp, 1);  //目录处理-下一步移动目录表索引
000044  2101              MOVS     r1,#1
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       dir_next
00004c  4605              MOV      r5,r0
;;;2232   		}while (res == FR_OK);	/* Next entry with table stretch enabled */
00004e  2d00              CMP      r5,#0
000050  d0e4              BEQ      |L8.28|
                  |L8.82|
000052  bf00              NOP                            ;2216
                  |L8.84|
;;;2233   	}
;;;2234   
;;;2235   	if (res == FR_NO_FILE)
000054  2d04              CMP      r5,#4
000056  d100              BNE      |L8.90|
;;;2236       res = FR_DENIED;	/* No directory entry to allocate */
000058  2507              MOVS     r5,#7
                  |L8.90|
;;;2237   	return res;
00005a  4628              MOV      r0,r5
;;;2238   }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;2239   
                          ENDP


                          AREA ||i.dir_clear||, CODE, READONLY, ALIGN=1

                  dir_clear PROC
;;;1997   #if !FF_FS_READONLY
;;;1998   static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1999   	FATFS *fs,		/* Filesystem object */
;;;2000   	DWORD clst		/* Directory table to clear */
;;;2001   )
;;;2002   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;2003   	DWORD sect;
;;;2004   	UINT n, szb;
;;;2005   	BYTE *ibuf;
;;;2006   
;;;2007   
;;;2008   	if (sync_window(fs) != FR_OK) /* Flush disk access window */
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       sync_window
00000e  b110              CBZ      r0,|L9.22|
;;;2009       return FR_DISK_ERR;	
000010  2001              MOVS     r0,#1
                  |L9.18|
;;;2010   	sect = clst2sect(fs, clst);		/* Top of the cluster */
;;;2011   	fs->winsect = sect;				/* Set window to top of the cluster */
;;;2012   	mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
;;;2013   #if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
;;;2014   	/* Allocate a temporary buffer */
;;;2015   	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
;;;2016   	if (szb > SS(fs)) /* Buffer allocated? */
;;;2017     {		
;;;2018   		mem_set(ibuf, 0, szb);
;;;2019   		szb /= SS(fs);		/* Bytes -> Sectors */
;;;2020   		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
;;;2021   		ff_memfree(ibuf);
;;;2022   	}
;;;2023     else
;;;2024   #endif
;;;2025   	{
;;;2026   		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
;;;2027   		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
;;;2028   	}
;;;2029   	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
;;;2030   }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L9.22|
000016  4649              MOV      r1,r9                 ;2010
000018  4620              MOV      r0,r4                 ;2010
00001a  f7fffffe          BL       clst2sect
00001e  4606              MOV      r6,r0                 ;2010
000020  62e6              STR      r6,[r4,#0x2c]         ;2011
000022  f44f7200          MOV      r2,#0x200             ;2012
000026  2100              MOVS     r1,#0                 ;2012
000028  f1040030          ADD      r0,r4,#0x30           ;2012
00002c  f7fffffe          BL       mem_set
000030  f1040830          ADD      r8,r4,#0x30           ;2026
000034  2701              MOVS     r7,#1                 ;2026
000036  2500              MOVS     r5,#0                 ;2027
000038  e000              B        |L9.60|
                  |L9.58|
00003a  443d              ADD      r5,r5,r7              ;2027
                  |L9.60|
00003c  8960              LDRH     r0,[r4,#0xa]          ;2027
00003e  42a8              CMP      r0,r5                 ;2027
000040  d907              BLS      |L9.82|
000042  1972              ADDS     r2,r6,r5              ;2027
000044  7860              LDRB     r0,[r4,#1]            ;2027
000046  463b              MOV      r3,r7                 ;2027
000048  4641              MOV      r1,r8                 ;2027
00004a  f7fffffe          BL       disk_write
00004e  2800              CMP      r0,#0                 ;2027
000050  d0f3              BEQ      |L9.58|
                  |L9.82|
000052  8960              LDRH     r0,[r4,#0xa]          ;2029
000054  42a8              CMP      r0,r5                 ;2029
000056  d001              BEQ      |L9.92|
000058  2001              MOVS     r0,#1                 ;2029
00005a  e7da              B        |L9.18|
                  |L9.92|
00005c  2000              MOVS     r0,#0                 ;2029
00005e  e7d8              B        |L9.18|
;;;2031   #endif	/* !FF_FS_READONLY */
                          ENDP


                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;3092   *******************************************************************************/
;;;3093   static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3094   	DIR* dp					/* Pointer to the directory object with the file name */
;;;3095   )
;;;3096   {
000004  4604              MOV      r4,r0
;;;3097   	FRESULT res;            //文件函数执行结果返回码
;;;3098   	FATFS *fs = dp->obj.fs; //目录中包含的文件系统对象结构体地址
000006  6827              LDR      r7,[r4,#0]
;;;3099   	BYTE c;
;;;3100   #if FF_USE_LFN
;;;3101   	BYTE a, ord, sum;
;;;3102   #endif
;;;3103   
;;;3104   	res = dir_sdi(dp, 0);			/* Rewind directory object */   //目录处理-设置目录索引--从0开始查找
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       dir_sdi
000010  4605              MOV      r5,r0
;;;3105   	if (res != FR_OK) return res;
000012  b115              CBZ      r5,|L10.26|
000014  4628              MOV      r0,r5
                  |L10.22|
;;;3106   #if FF_FS_EXFAT
;;;3107   	if (fs->fs_type == FS_EXFAT) 
;;;3108     {	/* On the exFAT volume */
;;;3109   		BYTE nc;
;;;3110   		UINT di, ni;
;;;3111   		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
;;;3112   
;;;3113   		while ((res = dir_read_file(dp)) == FR_OK) 
;;;3114       {	/* Read an item */
;;;3115   #if FF_MAX_LFN < 255
;;;3116   			if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) 
;;;3117           continue;			/* Skip comparison if inaccessible object name */
;;;3118   #endif
;;;3119   			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) 
;;;3120           continue;	/* Skip comparison if hash mismatched */
;;;3121   			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++)
;;;3122         {	/* Compare the name */
;;;3123   				if ((di % SZDIRE) == 0)
;;;3124             di += 2;
;;;3125   				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni]))
;;;3126             break;
;;;3127   			}
;;;3128   			if (nc == 0 && !fs->lfnbuf[ni])
;;;3129           break;	/* Name matched? */
;;;3130   		}
;;;3131   		return res;
;;;3132   	}
;;;3133   #endif
;;;3134   	/* On the FAT/FAT32 volume */
;;;3135   #if FF_USE_LFN
;;;3136   	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;3137   #endif
;;;3138   	do
;;;3139     {
;;;3140   		res = move_window(fs, dp->sect);
;;;3141   		if (res != FR_OK) 
;;;3142         break;
;;;3143   		c = dp->dir[DIR_Name];
;;;3144   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;;;3145   #if FF_USE_LFN		/* LFN configuration */
;;;3146   		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
;;;3147   		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) 
;;;3148       {	/* An entry without valid data */
;;;3149   			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;3150   		} 
;;;3151       else 
;;;3152       {
;;;3153   			if (a == AM_LFN)
;;;3154         {			/* An LFN entry is found */
;;;3155   				if (!(dp->fn[NSFLAG] & NS_NOLFN))
;;;3156           {
;;;3157   					if (c & LLEF)
;;;3158             {		/* Is it start of LFN sequence? */
;;;3159   						sum = dp->dir[LDIR_Chksum];
;;;3160   						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
;;;3161   						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
;;;3162   					}
;;;3163   					/* Check validity of the LFN entry and compare it with given name */
;;;3164   					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
;;;3165   				}
;;;3166   			}
;;;3167         else
;;;3168         {					/* An SFN entry is found */
;;;3169   				if (ord == 0 && sum == sum_sfn(dp->dir)) 
;;;3170             break;	/* LFN matched? */
;;;3171   				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) 
;;;3172             break;	/* SFN matched? */
;;;3173   				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;3174   			}
;;;3175   		}
;;;3176   #else		/* Non LFN configuration */
;;;3177   		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
;;;3178   		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) 
;;;3179         break;	/* Is it a valid entry? */
;;;3180   #endif
;;;3181   		res = dir_next(dp, 0);	/* Next entry */  //目录处理-下一步移动目录表索引
;;;3182   	} while (res == FR_OK);
;;;3183   	return res;
;;;3184   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L10.26|
00001a  bf00              NOP                            ;3138
                  |L10.28|
00001c  4638              MOV      r0,r7                 ;3140
00001e  69a1              LDR      r1,[r4,#0x18]         ;3140
000020  f7fffffe          BL       move_window
000024  4605              MOV      r5,r0                 ;3140
000026  b105              CBZ      r5,|L10.42|
000028  e01d              B        |L10.102|
                  |L10.42|
00002a  69e0              LDR      r0,[r4,#0x1c]         ;3143
00002c  7806              LDRB     r6,[r0,#0]            ;3143
00002e  b90e              CBNZ     r6,|L10.52|
000030  2504              MOVS     r5,#4                 ;3144
000032  e018              B        |L10.102|
                  |L10.52|
000034  69e0              LDR      r0,[r4,#0x1c]         ;3177
000036  7ac0              LDRB     r0,[r0,#0xb]          ;3177
000038  f000003f          AND      r0,r0,#0x3f           ;3177
00003c  71a0              STRB     r0,[r4,#6]            ;3177
00003e  69e0              LDR      r0,[r4,#0x1c]         ;3178
000040  7ac0              LDRB     r0,[r0,#0xb]          ;3178
000042  f0000008          AND      r0,r0,#8              ;3178
000046  b938              CBNZ     r0,|L10.88|
000048  220b              MOVS     r2,#0xb               ;3178
00004a  f1040120          ADD      r1,r4,#0x20           ;3178
00004e  69e0              LDR      r0,[r4,#0x1c]         ;3178
000050  f7fffffe          BL       mem_cmp
000054  b900              CBNZ     r0,|L10.88|
000056  e006              B        |L10.102|
                  |L10.88|
000058  2100              MOVS     r1,#0                 ;3181
00005a  4620              MOV      r0,r4                 ;3181
00005c  f7fffffe          BL       dir_next
000060  4605              MOV      r5,r0                 ;3181
000062  2d00              CMP      r5,#0                 ;3182
000064  d0da              BEQ      |L10.28|
                  |L10.102|
000066  bf00              NOP                            ;3142
000068  4628              MOV      r0,r5                 ;3183
00006a  e7d4              B        |L10.22|
;;;3185   
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;2111   *******************************************************************************/
;;;2112   static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2113                     DIR* dp,				/* Pointer to the directory object */
;;;2114                     int stretch		  /* 0: Do not stretch table, 1: Stretch table if needed */
;;;2115   )
;;;2116   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;2117   	DWORD ofs, clst;
;;;2118   	FATFS *fs = dp->obj.fs;   //目录中包含的文件系统对象结构体地址
000008  6827              LDR      r7,[r4,#0]
;;;2119   
;;;2120   	ofs = dp->dptr + SZDIRE;	/* Next entry */
00000a  6920              LDR      r0,[r4,#0x10]
00000c  f1000620          ADD      r6,r0,#0x20
;;;2121   	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) /* Report EOT when offset has reached max value */
000010  69a0              LDR      r0,[r4,#0x18]
000012  b110              CBZ      r0,|L11.26|
000014  f5b61f00          CMP      r6,#0x200000
000018  d302              BCC      |L11.32|
                  |L11.26|
;;;2122       return FR_NO_FILE;	
00001a  2004              MOVS     r0,#4
                  |L11.28|
;;;2123   
;;;2124   	if (ofs % SS(fs) == 0)  /* Sector changed? */
;;;2125     {	
;;;2126   		dp->sect++;				/* Next sector */
;;;2127   
;;;2128   		if (dp->clust == 0) /* Static table */
;;;2129       {	
;;;2130   			if (ofs / SZDIRE >= fs->n_rootdir)  /* Report EOT if it reached end of static table */
;;;2131         {	
;;;2132   				dp->sect = 0; return FR_NO_FILE;
;;;2133   			}
;;;2134   		}
;;;2135   		else  /* Dynamic table */
;;;2136       {					
;;;2137   			if ((ofs / SS(fs) & (fs->csize - 1)) == 0)  /* Cluster changed? */
;;;2138         {	
;;;2139   				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
;;;2140   				if (clst <= 1)  /* Internal error */
;;;2141             return FR_INT_ERR;			
;;;2142   				if (clst == 0xFFFFFFFF)   /* Disk error */
;;;2143             return FR_DISK_ERR;	
;;;2144   				if (clst >= fs->n_fatent) /* It reached end of dynamic table */
;;;2145           {					
;;;2146   #if !FF_FS_READONLY
;;;2147   					if (!stretch) /* If no stretch, report EOT */
;;;2148             {								
;;;2149   						dp->sect = 0;
;;;2150               return FR_NO_FILE;
;;;2151   					}
;;;2152   					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
;;;2153   					if (clst == 0)
;;;2154               return FR_DENIED;			  /* No free cluster */
;;;2155   					if (clst == 1)
;;;2156               return FR_INT_ERR;			/* Internal error */
;;;2157   					if (clst == 0xFFFFFFFF)
;;;2158               return FR_DISK_ERR;	/* Disk error */
;;;2159   					if (dir_clear(fs, clst) != FR_OK)
;;;2160               return FR_DISK_ERR;	/* Clean up the stretched table */
;;;2161   					if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
;;;2162   #else
;;;2163   					if (!stretch)
;;;2164               dp->sect = 0;					  /* (this line is to suppress compiler warning) */
;;;2165               dp->sect = 0; 
;;;2166               return FR_NO_FILE;			/* Report EOT */
;;;2167   #endif
;;;2168   				}
;;;2169   				dp->clust = clst;		/* Initialize data for new cluster */
;;;2170   				dp->sect = clst2sect(fs, clst);
;;;2171   			}
;;;2172   		}
;;;2173   	}
;;;2174   	dp->dptr = ofs;						        /* Current entry */     //更新当前读写地址
;;;2175   	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */   //偏移到下一个目录信息地址
;;;2176   
;;;2177   	return FR_OK;
;;;2178   }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L11.32|
000020  f3c60008          UBFX     r0,r6,#0,#9           ;2124
000024  2800              CMP      r0,#0                 ;2124
000026  d145              BNE      |L11.180|
000028  69a0              LDR      r0,[r4,#0x18]         ;2126
00002a  1c40              ADDS     r0,r0,#1              ;2126
00002c  61a0              STR      r0,[r4,#0x18]         ;2126
00002e  6960              LDR      r0,[r4,#0x14]         ;2128
000030  b938              CBNZ     r0,|L11.66|
000032  8938              LDRH     r0,[r7,#8]            ;2130
000034  ebb01f56          CMP      r0,r6,LSR #5          ;2130
000038  d83c              BHI      |L11.180|
00003a  2000              MOVS     r0,#0                 ;2132
00003c  61a0              STR      r0,[r4,#0x18]         ;2132
00003e  2004              MOVS     r0,#4                 ;2132
000040  e7ec              B        |L11.28|
                  |L11.66|
000042  8978              LDRH     r0,[r7,#0xa]          ;2137
000044  1e40              SUBS     r0,r0,#1              ;2137
000046  ea002056          AND      r0,r0,r6,LSR #9       ;2137
00004a  bb98              CBNZ     r0,|L11.180|
00004c  4620              MOV      r0,r4                 ;2139
00004e  6961              LDR      r1,[r4,#0x14]         ;2139
000050  f7fffffe          BL       get_fat
000054  4605              MOV      r5,r0                 ;2139
000056  2d01              CMP      r5,#1                 ;2140
000058  d801              BHI      |L11.94|
00005a  2002              MOVS     r0,#2                 ;2141
00005c  e7de              B        |L11.28|
                  |L11.94|
00005e  1c68              ADDS     r0,r5,#1              ;2142
000060  b908              CBNZ     r0,|L11.102|
000062  2001              MOVS     r0,#1                 ;2143
000064  e7da              B        |L11.28|
                  |L11.102|
000066  6978              LDR      r0,[r7,#0x14]         ;2144
000068  42a8              CMP      r0,r5                 ;2144
00006a  d81d              BHI      |L11.168|
00006c  f1b80f00          CMP      r8,#0                 ;2147
000070  d103              BNE      |L11.122|
000072  2000              MOVS     r0,#0                 ;2149
000074  61a0              STR      r0,[r4,#0x18]         ;2149
000076  2004              MOVS     r0,#4                 ;2150
000078  e7d0              B        |L11.28|
                  |L11.122|
00007a  4620              MOV      r0,r4                 ;2152
00007c  6961              LDR      r1,[r4,#0x14]         ;2152
00007e  f7fffffe          BL       create_chain
000082  4605              MOV      r5,r0                 ;2152
000084  b90d              CBNZ     r5,|L11.138|
000086  2007              MOVS     r0,#7                 ;2154
000088  e7c8              B        |L11.28|
                  |L11.138|
00008a  2d01              CMP      r5,#1                 ;2155
00008c  d101              BNE      |L11.146|
00008e  2002              MOVS     r0,#2                 ;2156
000090  e7c4              B        |L11.28|
                  |L11.146|
000092  1c68              ADDS     r0,r5,#1              ;2157
000094  b908              CBNZ     r0,|L11.154|
000096  2001              MOVS     r0,#1                 ;2158
000098  e7c0              B        |L11.28|
                  |L11.154|
00009a  4629              MOV      r1,r5                 ;2159
00009c  4638              MOV      r0,r7                 ;2159
00009e  f7fffffe          BL       dir_clear
0000a2  b108              CBZ      r0,|L11.168|
0000a4  2001              MOVS     r0,#1                 ;2160
0000a6  e7b9              B        |L11.28|
                  |L11.168|
0000a8  6165              STR      r5,[r4,#0x14]         ;2169
0000aa  4629              MOV      r1,r5                 ;2170
0000ac  4638              MOV      r0,r7                 ;2170
0000ae  f7fffffe          BL       clst2sect
0000b2  61a0              STR      r0,[r4,#0x18]         ;2170
                  |L11.180|
0000b4  6126              STR      r6,[r4,#0x10]         ;2174
0000b6  f3c60108          UBFX     r1,r6,#0,#9           ;2175
0000ba  f1070030          ADD      r0,r7,#0x30           ;2175
0000be  4408              ADD      r0,r0,r1              ;2175
0000c0  61e0              STR      r0,[r4,#0x1c]         ;2175
0000c2  2000              MOVS     r0,#0                 ;2177
0000c4  e7aa              B        |L11.28|
;;;2179   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;2982   *******************************************************************************/
;;;2983   static FRESULT dir_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2984   	DIR* dp,		/* Pointer to the directory object */
;;;2985   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;2986   )
;;;2987   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;2988   	FRESULT res = FR_NO_FILE;   //文件函数执行结果返回码
000008  2504              MOVS     r5,#4
;;;2989   	FATFS   *fs = dp->obj.fs;   //目录中包含的文件系统对象结构体地址
00000a  f8d49000          LDR      r9,[r4,#0]
;;;2990   	BYTE    a, c;
;;;2991   #if FF_USE_LFN
;;;2992   	BYTE ord = 0xFF, sum = 0xFF;
;;;2993   #endif
;;;2994   
;;;2995   	while (dp->sect) 
00000e  e027              B        |L12.96|
                  |L12.16|
;;;2996      {
;;;2997   		res = move_window(fs, dp->sect);    //检查当前扇区是否可用，如果可用，刚在文件系统中将当前工作扇区修改为此扇区地址
000010  4648              MOV      r0,r9
000012  69a1              LDR      r1,[r4,#0x18]
000014  f7fffffe          BL       move_window
000018  4605              MOV      r5,r0
;;;2998   		if (res != FR_OK) 
00001a  b105              CBZ      r5,|L12.30|
;;;2999         break;
00001c  e023              B        |L12.102|
                  |L12.30|
;;;3000   		c = dp->dir[DIR_Name];	            /* Test for the entry type */ //检查首字节数据类型
00001e  69e0              LDR      r0,[r4,#0x1c]
000020  7806              LDRB     r6,[r0,#0]
;;;3001   		if (c == 0)     //空数据----已经读取完目录
000022  b90e              CBNZ     r6,|L12.40|
;;;3002       {
;;;3003   			res = FR_NO_FILE; 
000024  2504              MOVS     r5,#4
;;;3004         break; /* Reached to end of the directory */
000026  e01e              B        |L12.102|
                  |L12.40|
;;;3005   		}
;;;3006   #if FF_FS_EXFAT
;;;3007   		if (fs->fs_type == FS_EXFAT) 
;;;3008       {	/* On the exFAT volume */
;;;3009   			if (FF_USE_LABEL && vol) 
;;;3010         {
;;;3011   				if (c == 0x83) 
;;;3012             break;	/* Volume label entry? */
;;;3013   			}
;;;3014         else 
;;;3015        {
;;;3016   				if (c == 0x85) 
;;;3017           {		/* Start of the file entry block? */
;;;3018   					dp->blk_ofs = dp->dptr;	/* Get location of the block */
;;;3019   					res = load_xdir(dp);	/* Load the entry block */
;;;3020   					if (res == FR_OK) 
;;;3021             {
;;;3022   						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
;;;3023   					}
;;;3024   					break;
;;;3025   				}
;;;3026   			}
;;;3027   		} else
;;;3028   #endif
;;;3029   		{	/* On the FAT/FAT32 volume */
;;;3030   			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
000028  69e0              LDR      r0,[r4,#0x1c]
00002a  7ac0              LDRB     r0,[r0,#0xb]
00002c  f000073f          AND      r7,r0,#0x3f
000030  71a7              STRB     r7,[r4,#6]
;;;3031   #if FF_USE_LFN		/* LFN configuration */
;;;3032   			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) 
;;;3033         {	/* An entry without valid data */
;;;3034   				ord = 0xFF;
;;;3035   			}
;;;3036         else
;;;3037         {
;;;3038   				if (a == AM_LFN) 
;;;3039           {			/* An LFN entry is found */
;;;3040   					if (c & LLEF) 
;;;3041             {			/* Is it start of an LFN sequence? */
;;;3042   						sum = dp->dir[LDIR_Chksum];
;;;3043   						c &= (BYTE)~LLEF; ord = c;
;;;3044   						dp->blk_ofs = dp->dptr;
;;;3045   					}
;;;3046   					/* Check LFN validity and capture it */
;;;3047   					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
;;;3048   				}
;;;3049           else
;;;3050           {					/* An SFN entry is found */
;;;3051   					if (ord != 0 || sum != sum_sfn(dp->dir))
;;;3052             {	/* Is there a valid LFN? */
;;;3053   						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
;;;3054   					}
;;;3055   					break;
;;;3056   				}
;;;3057   			}
;;;3058   #else		/* Non LFN configuration */
;;;3059   			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) 
000032  2ee5              CMP      r6,#0xe5
000034  d00d              BEQ      |L12.82|
000036  2e2e              CMP      r6,#0x2e
000038  d00b              BEQ      |L12.82|
00003a  2f0f              CMP      r7,#0xf
00003c  d009              BEQ      |L12.82|
00003e  f0270020          BIC      r0,r7,#0x20
000042  2808              CMP      r0,#8
000044  d101              BNE      |L12.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L12.76|
                  |L12.74|
00004a  2000              MOVS     r0,#0
                  |L12.76|
00004c  4540              CMP      r0,r8
00004e  d100              BNE      |L12.82|
;;;3060         {	/* Is it a valid entry? */
;;;3061   				break;
000050  e009              B        |L12.102|
                  |L12.82|
;;;3062   			}
;;;3063   #endif
;;;3064   		}
;;;3065   		res = dir_next(dp, 0);		/* Next entry *///目录处理-下一步移动目录表索引
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       dir_next
00005a  4605              MOV      r5,r0
;;;3066   		if (res != FR_OK) 
00005c  b105              CBZ      r5,|L12.96|
;;;3067         break;
00005e  e002              B        |L12.102|
                  |L12.96|
000060  69a0              LDR      r0,[r4,#0x18]         ;2995
000062  2800              CMP      r0,#0                 ;2995
000064  d1d4              BNE      |L12.16|
                  |L12.102|
000066  bf00              NOP                            ;2999
;;;3068   	}
;;;3069   
;;;3070   	if (res != FR_OK) 
000068  b10d              CBZ      r5,|L12.110|
;;;3071       dp->sect = 0;		/* Terminate the read operation on error or EOT */
00006a  2000              MOVS     r0,#0
00006c  61a0              STR      r0,[r4,#0x18]
                  |L12.110|
;;;3072   	return res;
00006e  4628              MOV      r0,r5
;;;3073   }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;3074   
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;3203   *******************************************************************************/
;;;3204   static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;3205   	DIR* dp						/* Target directory with object name to be created */
;;;3206   )
;;;3207   {
000002  4604              MOV      r4,r0
;;;3208   	FRESULT res;              //文件函数执行结果返回码
;;;3209   	FATFS *fs = dp->obj.fs;   //目录中包含的文件系统对象结构体地址
000004  6826              LDR      r6,[r4,#0]
;;;3210   #if FF_USE_LFN		/* LFN configuration */
;;;3211   	UINT n, nlen, nent;
;;;3212   	BYTE sn[12], sum;
;;;3213   
;;;3214   
;;;3215   	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) 
;;;3216       return FR_INVALID_NAME;	/* Check name validity */
;;;3217   	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
;;;3218   
;;;3219   #if FF_FS_EXFAT
;;;3220   	if (fs->fs_type == FS_EXFAT) 
;;;3221     {	/* On the exFAT volume */
;;;3222   		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
;;;3223   		res = dir_alloc(dp, nent);		/* Allocate entries */
;;;3224   		if (res != FR_OK) 
;;;3225         return res;
;;;3226   		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);	/* Set the allocated entry block offset */
;;;3227   
;;;3228   		if (dp->obj.stat & 4) 
;;;3229       {			/* Has the directory been stretched? */
;;;3230   			dp->obj.stat &= ~4;
;;;3231   			res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
;;;3232   			if (res != FR_OK) 
;;;3233           return res;
;;;3234   			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
;;;3235   			if (res != FR_OK) 
;;;3236           return res;
;;;3237   			if (dp->obj.sclust != 0)
;;;3238         {		/* Is it a sub directory? */
;;;3239   				DIR dj;
;;;3240   				res = load_obj_xdir(&dj, &dp->obj);	/* Load the object status */
;;;3241   				if (res != FR_OK) 
;;;3242             return res;
;;;3243   				dp->obj.objsize += (DWORD)fs->csize * SS(fs);			/* Increase the directory size by cluster size */
;;;3244   				st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);	/* Update the allocation status */
;;;3245   				st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
;;;3246   				fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
;;;3247   				res = store_xdir(&dj);				/* Store the object status */
;;;3248   				if (res != FR_OK) 
;;;3249             return res;
;;;3250   			}
;;;3251   		}
;;;3252   		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
;;;3253   		return FR_OK;
;;;3254   	}
;;;3255   #endif
;;;3256   	/* On the FAT/FAT32 volume */
;;;3257   	mem_cpy(sn, dp->fn, 12);
;;;3258   	if (sn[NSFLAG] & NS_LOSS) 
;;;3259     {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;3260   		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
;;;3261   		for (n = 1; n < 100; n++) 
;;;3262       {
;;;3263   			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
;;;3264   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;3265   			if (res != FR_OK) 
;;;3266           break;
;;;3267   		}
;;;3268   		if (n == 100) 
;;;3269         return FR_DENIED;		/* Abort if too many collisions */
;;;3270   		if (res != FR_NO_FILE) 
;;;3271         return res;	/* Abort if the result is other than 'not collided' */
;;;3272   		dp->fn[NSFLAG] = sn[NSFLAG];
;;;3273   	}
;;;3274   
;;;3275   	/* Create an SFN with/without LFNs. */
;;;3276   	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
;;;3277   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;3278   	if (res == FR_OK && --nent) 
;;;3279     {	/* Set LFN entry if needed */
;;;3280   		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
;;;3281   		if (res == FR_OK)
;;;3282       {
;;;3283   			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
;;;3284   			do 
;;;3285         {					/* Store LFN entries in bottom first */
;;;3286   				res = move_window(fs, dp->sect);
;;;3287   				if (res != FR_OK) 
;;;3288             break;
;;;3289   				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
;;;3290   				fs->wflag = 1;
;;;3291   				res = dir_next(dp, 0);	/* Next entry */  //目录处理-下一步移动目录表索引
;;;3292   			} while (res == FR_OK && --nent);
;;;3293   		}
;;;3294   	}
;;;3295   
;;;3296   #else	/* Non LFN configuration */
;;;3297   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dir_alloc
00000e  4605              MOV      r5,r0
;;;3298   
;;;3299   #endif
;;;3300   
;;;3301   	/* Set SFN entry */
;;;3302   	if (res == FR_OK) 
000010  b995              CBNZ     r5,|L13.56|
;;;3303     {
;;;3304   		res = move_window(fs, dp->sect);
000012  4630              MOV      r0,r6
000014  69a1              LDR      r1,[r4,#0x18]
000016  f7fffffe          BL       move_window
00001a  4605              MOV      r5,r0
;;;3305   		if (res == FR_OK) 
00001c  b965              CBNZ     r5,|L13.56|
;;;3306       {
;;;3307   			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
00001e  2220              MOVS     r2,#0x20
000020  2100              MOVS     r1,#0
000022  69e0              LDR      r0,[r4,#0x1c]
000024  f7fffffe          BL       mem_set
;;;3308   			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
000028  220b              MOVS     r2,#0xb
00002a  f1040120          ADD      r1,r4,#0x20
00002e  69e0              LDR      r0,[r4,#0x1c]
000030  f7fffffe          BL       mem_cpy
;;;3309   #if FF_USE_LFN
;;;3310   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;3311   #endif
;;;3312   			fs->wflag = 1;
000034  2001              MOVS     r0,#1
000036  70f0              STRB     r0,[r6,#3]
                  |L13.56|
;;;3313   		}
;;;3314   	}
;;;3315   
;;;3316   	return res;
000038  4628              MOV      r0,r5
;;;3317   }
00003a  bd70              POP      {r4-r6,pc}
;;;3318   
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;3337   *******************************************************************************/
;;;3338   static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;3339   	DIR* dp					/* Directory object pointing the entry to be removed */
;;;3340   )
;;;3341   {
000002  4604              MOV      r4,r0
;;;3342   	FRESULT res;            //文件函数执行结果返回码
;;;3343   	FATFS *fs = dp->obj.fs; //目录中包含的文件系统对象结构体地址
000004  6826              LDR      r6,[r4,#0]
;;;3344   #if FF_USE_LFN		/* LFN configuration */
;;;3345   	DWORD last = dp->dptr;
;;;3346   
;;;3347   	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
;;;3348   	if (res == FR_OK) 
;;;3349     {
;;;3350   		do 
;;;3351       {
;;;3352   			res = move_window(fs, dp->sect);
;;;3353   			if (res != FR_OK) 
;;;3354           break;
;;;3355   			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT)
;;;3356         {	/* On the exFAT volume */
;;;3357   				dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
;;;3358   			}
;;;3359         else
;;;3360         {									/* On the FAT/FAT32 volume */
;;;3361   				dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'. */
;;;3362   			}
;;;3363   			fs->wflag = 1;
;;;3364   			if (dp->dptr >= last) 
;;;3365           break;	/* If reached last entry then all entries of the object has been deleted. */
;;;3366   			res = dir_next(dp, 0);	/* Next entry */    //目录处理-下一步移动目录表索引
;;;3367   		} while (res == FR_OK);
;;;3368   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;3369   	}
;;;3370   #else			/* Non LFN configuration */
;;;3371   
;;;3372   	res = move_window(fs, dp->sect);
000006  4630              MOV      r0,r6
000008  69a1              LDR      r1,[r4,#0x18]
00000a  f7fffffe          BL       move_window
00000e  4605              MOV      r5,r0
;;;3373   	if (res == FR_OK) 
000010  b925              CBNZ     r5,|L14.28|
;;;3374     {
;;;3375   		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
000012  20e5              MOVS     r0,#0xe5
000014  69e1              LDR      r1,[r4,#0x1c]
000016  7008              STRB     r0,[r1,#0]
;;;3376   		fs->wflag = 1;
000018  2001              MOVS     r0,#1
00001a  70f0              STRB     r0,[r6,#3]
                  |L14.28|
;;;3377   	}
;;;3378   #endif
;;;3379   	return res;
00001c  4628              MOV      r0,r5
;;;3380   }
00001e  bd70              POP      {r4-r6,pc}
;;;3381   
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;2046   *******************************************************************************/
;;;2047   static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2048                   DIR*  dp, /* Pointer to directory object */
;;;2049                   DWORD ofs /* Offset of directory table */
;;;2050   )
;;;2051   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2052   	DWORD csz;    //簇容量（每个簇包含的字节数）
;;;2053     DWORD clst;   //根目录起始扇区/簇
;;;2054   	FATFS *fs = dp->obj.fs;   //目录中包含的文件系统对象结构体地址
000008  6826              LDR      r6,[r4,#0]
;;;2055   
;;;2056     //================================Check range of offset and alignment偏移和对准检查范围
;;;2057   	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE)  /* Check range of offset and alignment */
00000a  f5b51f00          CMP      r5,#0x200000
00000e  d202              BCS      |L15.22|
000010  f005001f          AND      r0,r5,#0x1f
000014  b110              CBZ      r0,|L15.28|
                  |L15.22|
;;;2058     {	
;;;2059   		return FR_INT_ERR;
000016  2002              MOVS     r0,#2
                  |L15.24|
;;;2060   	}
;;;2061   	dp->dptr = ofs;				    /* Set current offset */              //设置偏移量
;;;2062   	clst = dp->obj.sclust;		/* Table start cluster (0:root) */    //读取对象数据起始簇（0：没有集群或根目录）
;;;2063   	if (clst == 0 && fs->fs_type >= FS_FAT32) /* Replace cluster# 0 with root cluster# */
;;;2064     {	
;;;2065   		clst = fs->dirbase;     //读取根目录起始扇区(FAT32:Cluster#)
;;;2066   		if (FF_FS_EXFAT)
;;;2067         dp->obj.stat = 0;	    /* exFAT: Root dir has an FAT chain */
;;;2068   	}
;;;2069     //=================================
;;;2070   	if (clst == 0)  /* Static table (root-directory on the FAT volume) */ //静态表（FAT卷上的根目录）
;;;2071     {	
;;;2072   		if (ofs / SZDIRE >= fs->n_rootdir)  /* Is index out of range? */
;;;2073         return FR_INT_ERR;	
;;;2074   		dp->sect = fs->dirbase;
;;;2075   
;;;2076   	}
;;;2077     //=================================
;;;2078     else    /* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */ //动态表（FAT32／EXFAT卷上的子目录或根目录）
;;;2079     {			
;;;2080   		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */   //获取每个簇的容量（单个簇包含的扇区数*单个扇区的字节数
;;;2081       //===============================扫描簇内容
;;;2082   		while (ofs >= csz)                /* Follow cluster chain */
;;;2083       {				
;;;2084   			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
;;;2085   			if (clst == 0xFFFFFFFF)   /* Disk error */
;;;2086           return FR_DISK_ERR;	
;;;2087   			if (clst < 2 || clst >= fs->n_fatent) /* Reached to end of table or internal error */
;;;2088           return FR_INT_ERR;	
;;;2089   			ofs -= csz;
;;;2090   		}
;;;2091   		dp->sect = clst2sect(fs, clst);     //根据簇号获取数据起始扇地址
;;;2092   	}
;;;2093   	dp->clust = clst;					    /* Current cluster# */
;;;2094   	if (dp->sect == 0)
;;;2095       return FR_INT_ERR;
;;;2096   	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
;;;2097   	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */ //指向目录数据地址
;;;2098   	return FR_OK;
;;;2099   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L15.28|
00001c  6125              STR      r5,[r4,#0x10]         ;2061
00001e  68a7              LDR      r7,[r4,#8]            ;2062
000020  b91f              CBNZ     r7,|L15.42|
000022  7830              LDRB     r0,[r6,#0]            ;2063
000024  2803              CMP      r0,#3                 ;2063
000026  db00              BLT      |L15.42|
000028  6a77              LDR      r7,[r6,#0x24]         ;2065
                  |L15.42|
00002a  b947              CBNZ     r7,|L15.62|
00002c  8930              LDRH     r0,[r6,#8]            ;2072
00002e  ebb01f55          CMP      r0,r5,LSR #5          ;2072
000032  d801              BHI      |L15.56|
000034  2002              MOVS     r0,#2                 ;2073
000036  e7ef              B        |L15.24|
                  |L15.56|
000038  6a70              LDR      r0,[r6,#0x24]         ;2074
00003a  61a0              STR      r0,[r4,#0x18]         ;2074
00003c  e01c              B        |L15.120|
                  |L15.62|
00003e  8970              LDRH     r0,[r6,#0xa]          ;2080
000040  ea4f2840          LSL      r8,r0,#9              ;2080
000044  e011              B        |L15.106|
                  |L15.70|
000046  4639              MOV      r1,r7                 ;2084
000048  4620              MOV      r0,r4                 ;2084
00004a  f7fffffe          BL       get_fat
00004e  4607              MOV      r7,r0                 ;2084
000050  1c78              ADDS     r0,r7,#1              ;2085
000052  b908              CBNZ     r0,|L15.88|
000054  2001              MOVS     r0,#1                 ;2086
000056  e7df              B        |L15.24|
                  |L15.88|
000058  2f02              CMP      r7,#2                 ;2087
00005a  d302              BCC      |L15.98|
00005c  6970              LDR      r0,[r6,#0x14]         ;2087
00005e  42b8              CMP      r0,r7                 ;2087
000060  d801              BHI      |L15.102|
                  |L15.98|
000062  2002              MOVS     r0,#2                 ;2088
000064  e7d8              B        |L15.24|
                  |L15.102|
000066  eba50508          SUB      r5,r5,r8              ;2089
                  |L15.106|
00006a  4545              CMP      r5,r8                 ;2082
00006c  d2eb              BCS      |L15.70|
00006e  4639              MOV      r1,r7                 ;2091
000070  4630              MOV      r0,r6                 ;2091
000072  f7fffffe          BL       clst2sect
000076  61a0              STR      r0,[r4,#0x18]         ;2091
                  |L15.120|
000078  6167              STR      r7,[r4,#0x14]         ;2093
00007a  69a0              LDR      r0,[r4,#0x18]         ;2094
00007c  b908              CBNZ     r0,|L15.130|
00007e  2002              MOVS     r0,#2                 ;2095
000080  e7ca              B        |L15.24|
                  |L15.130|
000082  69a0              LDR      r0,[r4,#0x18]         ;2096
000084  eb002055          ADD      r0,r0,r5,LSR #9       ;2096
000088  61a0              STR      r0,[r4,#0x18]         ;2096
00008a  f3c50108          UBFX     r1,r5,#0,#9           ;2097
00008e  f1060030          ADD      r0,r6,#0x30           ;2097
000092  4408              ADD      r0,r0,r1              ;2097
000094  61e0              STR      r0,[r4,#0x1c]         ;2097
000096  2000              MOVS     r0,#0                 ;2098
000098  e7be              B        |L15.24|
;;;2100   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;5218   *******************************************************************************/
;;;5219   FRESULT f_close (
000000  b538              PUSH     {r3-r5,lr}
;;;5220           FIL* fp		/* Pointer to the file object to be closed */   //要关闭的文件对象结构体指针
;;;5221   )
;;;5222   {
000002  4605              MOV      r5,r0
;;;5223   	FRESULT res;    //文件函数执行结果返回码
;;;5224   	FATFS   *fs;    //文件系统对象
;;;5225   
;;;5226   #if !FF_FS_READONLY
;;;5227   	res = f_sync(fp);					/* Flush cached data */
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       f_sync
00000a  4604              MOV      r4,r0
;;;5228   	if (res == FR_OK)
00000c  b93c              CBNZ     r4,|L16.30|
;;;5229   #endif
;;;5230   	{
;;;5231   		res = validate(&fp->obj, &fs);	/* Lock volume */
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       validate
000016  4604              MOV      r4,r0
;;;5232   		if (res == FR_OK) 
000018  b90c              CBNZ     r4,|L16.30|
;;;5233       {
;;;5234   #if FF_FS_LOCK != 0
;;;5235   			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
;;;5236   			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
;;;5237   #else
;;;5238   			fp->obj.fs = 0;	/* Invalidate file object */
00001a  2000              MOVS     r0,#0
00001c  6028              STR      r0,[r5,#0]
                  |L16.30|
;;;5239   #endif
;;;5240   #if FF_FS_REENTRANT
;;;5241   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;5242   #endif
;;;5243   		}
;;;5244   	}
;;;5245   	return res;
00001e  4620              MOV      r0,r4
;;;5246   }
000020  bd38              POP      {r3-r5,pc}
;;;5247   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;5804   *******************************************************************************/
;;;5805   FRESULT f_closedir (
000000  b538              PUSH     {r3-r5,lr}
;;;5806   	DIR *dp		/* Pointer to the directory object to be closed */
;;;5807   )
;;;5808   {
000002  4604              MOV      r4,r0
;;;5809   	FRESULT res;  //文件函数执行结果返回码
;;;5810   	FATFS   *fs;  //文件系统对象
;;;5811   
;;;5812   
;;;5813   	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4605              MOV      r5,r0
;;;5814   	if (res == FR_OK) 
00000e  b90d              CBNZ     r5,|L17.20|
;;;5815     {
;;;5816   #if FF_FS_LOCK != 0
;;;5817   		if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
;;;5818   		if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
;;;5819   #else
;;;5820   		dp->obj.fs = 0;	/* Invalidate directory object */   //目录中包含的文件系统对象结构体地址--清除
000010  2000              MOVS     r0,#0
000012  6020              STR      r0,[r4,#0]
                  |L17.20|
;;;5821   #endif
;;;5822   #if FF_FS_REENTRANT
;;;5823   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;5824   #endif
;;;5825   	}
;;;5826   	return res;
000014  4628              MOV      r0,r5
;;;5827   }
000016  bd38              POP      {r3-r5,pc}
;;;5828   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;6049   *******************************************************************************/
;;;6050   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;6051   	const TCHAR* path,	/* Logical drive number */  /* 驱动器的根目录 */
;;;6052   	DWORD* nclst,		    /* Pointer to a variable to return number of free clusters */       /* 存储空闲簇数目变量的指针 */
;;;6053   	FATFS** fatfs		    /* Pointer to return pointer to corresponding filesystem object */  /* 文件系统对象指针的指针 */
;;;6054   )
;;;6055   {
000004  b086              SUB      sp,sp,#0x18
000006  4688              MOV      r8,r1
000008  4692              MOV      r10,r2
;;;6056   	FRESULT res;  //文件函数执行结果返回码
;;;6057   	FATFS   *fs;  //文件系统对象
;;;6058   	DWORD   nfree, clst, sect, stat;
;;;6059   	UINT    i;
;;;6060   	FFOBJID obj;
;;;6061   
;;;6062   
;;;6063   	/* Get logical drive */
;;;6064   	res = find_volume(&path, &fs, 0);   //确定逻辑驱动器号并在需要时装入卷及初始化驱动器及获取磁盘相关信息
00000a  2200              MOVS     r2,#0
00000c  a905              ADD      r1,sp,#0x14
00000e  a806              ADD      r0,sp,#0x18
000010  f7fffffe          BL       find_volume
000014  4681              MOV      r9,r0
;;;6065   	if (res == FR_OK)
000016  f1b90f00          CMP      r9,#0
00001a  d168              BNE      |L18.238|
;;;6066     {
;;;6067   		*fatfs = fs;				/* Return ptr to the fs object */
00001c  9805              LDR      r0,[sp,#0x14]
00001e  f8ca0000          STR      r0,[r10,#0]
;;;6068   		//========================/* If free_clst is valid, return it without full FAT scan */
;;;6069   		if (fs->free_clst <= fs->n_fatent - 2)
000022  9805              LDR      r0,[sp,#0x14]
000024  e9d01004          LDRD     r1,r0,[r0,#0x10]
000028  1e80              SUBS     r0,r0,#2
00002a  4281              CMP      r1,r0
00002c  d804              BHI      |L18.56|
;;;6070       {
;;;6071   			*nclst = fs->free_clst;
00002e  9805              LDR      r0,[sp,#0x14]
000030  6900              LDR      r0,[r0,#0x10]
000032  f8c80000          STR      r0,[r8,#0]
000036  e05a              B        |L18.238|
                  |L18.56|
;;;6072   		}
;;;6073       else
;;;6074      {
;;;6075   			//========================/* Scan FAT to obtain number of free clusters */
;;;6076   			nfree = 0;
000038  2500              MOVS     r5,#0
;;;6077   			if (fs->fs_type == FS_FAT12)  /* FAT12: Scan bit field FAT entries */
00003a  9805              LDR      r0,[sp,#0x14]
00003c  7800              LDRB     r0,[r0,#0]
00003e  2801              CMP      r0,#1
000040  d11b              BNE      |L18.122|
;;;6078         {	
;;;6079   				clst = 2; obj.fs = fs;
000042  2602              MOVS     r6,#2
000044  9805              LDR      r0,[sp,#0x14]
000046  9001              STR      r0,[sp,#4]
;;;6080   				do
000048  bf00              NOP      
                  |L18.74|
;;;6081           {
;;;6082   					stat = get_fat(&obj, clst);
00004a  4631              MOV      r1,r6
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       get_fat
000052  4607              MOV      r7,r0
;;;6083   					if (stat == 0xFFFFFFFF)
000054  1c78              ADDS     r0,r7,#1
000056  b910              CBNZ     r0,|L18.94|
;;;6084             {
;;;6085               res = FR_DISK_ERR;
000058  f04f0901          MOV      r9,#1
;;;6086               break;
00005c  e00c              B        |L18.120|
                  |L18.94|
;;;6087             }
;;;6088   					if (stat == 1)
00005e  2f01              CMP      r7,#1
000060  d102              BNE      |L18.104|
;;;6089             {
;;;6090               res = FR_INT_ERR;
000062  f04f0902          MOV      r9,#2
;;;6091               break;
000066  e007              B        |L18.120|
                  |L18.104|
;;;6092             }
;;;6093   					if (stat == 0)
000068  b907              CBNZ     r7,|L18.108|
;;;6094               nfree++;
00006a  1c6d              ADDS     r5,r5,#1
                  |L18.108|
;;;6095   				}while (++clst < fs->n_fatent);
00006c  1c70              ADDS     r0,r6,#1
00006e  4606              MOV      r6,r0
000070  9905              LDR      r1,[sp,#0x14]
000072  6949              LDR      r1,[r1,#0x14]
000074  4288              CMP      r0,r1
000076  d3e8              BCC      |L18.74|
                  |L18.120|
000078  e02f              B        |L18.218|
                  |L18.122|
;;;6096   			}
;;;6097         else
;;;6098         {
;;;6099   #if FF_FS_EXFAT
;;;6100           //========================/* exFAT: Scan allocation bitmap */
;;;6101   				if (fs->fs_type == FS_EXFAT)  
;;;6102           {	
;;;6103   					BYTE bm;
;;;6104   					UINT b;
;;;6105   
;;;6106   					clst = fs->n_fatent - 2;	/* Number of clusters */
;;;6107   					sect = fs->database;		  /* Assuming bitmap starts at cluster 2 */
;;;6108   					i = 0;						        /* Offset in the sector */
;;;6109             //========================/* Counts numbuer of bits with zero in the bitmap */
;;;6110   					do
;;;6111             {	
;;;6112   						if (i == 0)
;;;6113               {
;;;6114   							res = move_window(fs, sect++);
;;;6115   							if (res != FR_OK)
;;;6116                   break;
;;;6117   						}
;;;6118   						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--)
;;;6119               {
;;;6120   							if (!(bm & 1))
;;;6121                   nfree++;
;;;6122   							bm >>= 1;
;;;6123   						}
;;;6124   						i = (i + 1) % SS(fs);
;;;6125   					} while (clst);
;;;6126   				}
;;;6127           else
;;;6128   #endif
;;;6129           //========================/* FAT16/32: Scan WORD/DWORD FAT entries */
;;;6130   				{	
;;;6131   					clst = fs->n_fatent;	/* Number of entries */
00007a  9805              LDR      r0,[sp,#0x14]
00007c  6946              LDR      r6,[r0,#0x14]
;;;6132   					sect = fs->fatbase;		/* Top of the FAT */
00007e  9805              LDR      r0,[sp,#0x14]
000080  f8d0b020          LDR      r11,[r0,#0x20]
;;;6133   					i = 0;					/* Offset in the sector */
000084  2400              MOVS     r4,#0
;;;6134   					do {	/* Counts numbuer of entries with zero in the FAT */
000086  bf00              NOP      
                  |L18.136|
;;;6135   						if (i == 0) {
000088  b954              CBNZ     r4,|L18.160|
;;;6136   							res = move_window(fs, sect++);
00008a  4659              MOV      r1,r11
00008c  f10b0b01          ADD      r11,r11,#1
000090  9805              LDR      r0,[sp,#0x14]
000092  f7fffffe          BL       move_window
000096  4681              MOV      r9,r0
;;;6137   							if (res != FR_OK) break;
000098  f1b90f00          CMP      r9,#0
00009c  d000              BEQ      |L18.160|
00009e  e01b              B        |L18.216|
                  |L18.160|
;;;6138   						}
;;;6139   						if (fs->fs_type == FS_FAT16)
0000a0  9805              LDR      r0,[sp,#0x14]
0000a2  7800              LDRB     r0,[r0,#0]
0000a4  2802              CMP      r0,#2
0000a6  d108              BNE      |L18.186|
;;;6140               {
;;;6141   							if (ld_word(fs->win + i) == 0) nfree++;
0000a8  9905              LDR      r1,[sp,#0x14]
0000aa  3130              ADDS     r1,r1,#0x30
0000ac  1908              ADDS     r0,r1,r4
0000ae  f7fffffe          BL       ld_word
0000b2  b900              CBNZ     r0,|L18.182|
0000b4  1c6d              ADDS     r5,r5,#1
                  |L18.182|
;;;6142   							i += 2;
0000b6  1ca4              ADDS     r4,r4,#2
0000b8  e009              B        |L18.206|
                  |L18.186|
;;;6143   						}
;;;6144               else
;;;6145               {
;;;6146   							if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0)
0000ba  9905              LDR      r1,[sp,#0x14]
0000bc  3130              ADDS     r1,r1,#0x30
0000be  1908              ADDS     r0,r1,r4
0000c0  f7fffffe          BL       ld_dword
0000c4  f0204070          BIC      r0,r0,#0xf0000000
0000c8  b900              CBNZ     r0,|L18.204|
;;;6147                   nfree++;
0000ca  1c6d              ADDS     r5,r5,#1
                  |L18.204|
;;;6148   							i += 4;
0000cc  1d24              ADDS     r4,r4,#4
                  |L18.206|
;;;6149   						}
;;;6150   						i %= SS(fs);
0000ce  f3c40408          UBFX     r4,r4,#0,#9
;;;6151   					} while (--clst);
0000d2  1e70              SUBS     r0,r6,#1
0000d4  1e06              SUBS     r6,r0,#0
0000d6  d1d7              BNE      |L18.136|
                  |L18.216|
0000d8  bf00              NOP                            ;6137
                  |L18.218|
;;;6152   				}
;;;6153   			}
;;;6154   			*nclst = nfree;			    /* Return the free clusters */
0000da  f8c85000          STR      r5,[r8,#0]
;;;6155   			fs->free_clst = nfree;	/* Now free_clst is valid */
0000de  9805              LDR      r0,[sp,#0x14]
0000e0  6105              STR      r5,[r0,#0x10]
;;;6156   			fs->fsi_flag |= 1;		  /* FAT32: FSInfo is to be updated */
0000e2  9805              LDR      r0,[sp,#0x14]
0000e4  7900              LDRB     r0,[r0,#4]
0000e6  f0400001          ORR      r0,r0,#1
0000ea  9905              LDR      r1,[sp,#0x14]
0000ec  7108              STRB     r0,[r1,#4]
                  |L18.238|
;;;6157   		}
;;;6158   	}
;;;6159   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
0000ee  4648              MOV      r0,r9
;;;6160   }
0000f0  b009              ADD      sp,sp,#0x24
0000f2  e8bd8ff0          POP      {r4-r11,pc}
;;;6161   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;5496   *******************************************************************************/
;;;5497   FRESULT f_lseek (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;5498   	FIL* fp,		  /* Pointer to the file object */
;;;5499   	FSIZE_t ofs		/* File pointer from top of file */
;;;5500   )
;;;5501   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;5502   	FRESULT res;
;;;5503   	FATFS   *fs;  //文件系统对象
;;;5504   	DWORD   clst, bcs, nsect;
;;;5505   	FSIZE_t ifptr;
;;;5506   #if FF_USE_FASTSEEK
;;;5507   	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;5508   #endif
;;;5509   
;;;5510   	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
000008  4669              MOV      r1,sp
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       validate
000010  4682              MOV      r10,r0
;;;5511   	if (res == FR_OK) 
000012  f1ba0f00          CMP      r10,#0
000016  d101              BNE      |L19.28|
;;;5512       res = (FRESULT)fp->err;
000018  f894a011          LDRB     r10,[r4,#0x11]
                  |L19.28|
;;;5513   #if FF_FS_EXFAT && !FF_FS_READONLY
;;;5514   	if (res == FR_OK && fs->fs_type == FS_EXFAT) 
;;;5515     {
;;;5516   		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
;;;5517   	}
;;;5518   #endif
;;;5519   	if (res != FR_OK) 
00001c  f1ba0f00          CMP      r10,#0
000020  d002              BEQ      |L19.40|
;;;5520       LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
000022  4650              MOV      r0,r10
                  |L19.36|
;;;5521   
;;;5522   #if FF_USE_FASTSEEK
;;;5523   	if (fp->cltbl) /* Fast seek */
;;;5524     {	
;;;5525   		if (ofs == CREATE_LINKMAP) /* Create CLMT */
;;;5526       {	
;;;5527   			tbl = fp->cltbl;
;;;5528   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;5529   			cl = fp->obj.sclust;		/* Origin of the chain */
;;;5530   			if (cl != 0) 
;;;5531         {
;;;5532   				do          
;;;5533           {
;;;5534   					/* Get a fragment */
;;;5535   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;5536   					do 
;;;5537             {
;;;5538   						pcl = cl; ncl++;
;;;5539   						cl = get_fat(&fp->obj, cl);
;;;5540   						if (cl <= 1) ABORT(fs, FR_INT_ERR);
;;;5541   						if (cl == 0xFFFFFFFF) 
;;;5542                 ABORT(fs, FR_DISK_ERR);
;;;5543   					}while (cl == pcl + 1);
;;;5544   					if (ulen <= tlen) /* Store the length and top of the fragment */
;;;5545             {		
;;;5546   						*tbl++ = ncl; *tbl++ = tcl;
;;;5547   					}
;;;5548   				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
;;;5549   			}
;;;5550   			*fp->cltbl = ulen;	/* Number of items used */
;;;5551   			if (ulen <= tlen) 
;;;5552         {
;;;5553   				*tbl = 0;		/* Terminate table */
;;;5554   			} 
;;;5555         else 
;;;5556         {
;;;5557   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;5558   			}
;;;5559   		} 
;;;5560       else 
;;;5561       {						/* Fast seek */
;;;5562   			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
;;;5563   			fp->fptr = ofs;				/* Set file pointer */
;;;5564   			if (ofs > 0) 
;;;5565         {
;;;5566   				fp->clust = clmt_clust(fp, ofs - 1);
;;;5567   				dsc = clst2sect(fs, fp->clust);
;;;5568   				if (dsc == 0) 
;;;5569             ABORT(fs, FR_INT_ERR);
;;;5570   				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
;;;5571   				if (fp->fptr % SS(fs) && dsc != fp->sect) /* Refill sector cache if needed */
;;;5572           {	
;;;5573   #if !FF_FS_TINY
;;;5574   #if !FF_FS_READONLY
;;;5575   					if (fp->flag & FA_DIRTY) /* Write-back dirty sector cache */
;;;5576             {		
;;;5577   						if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) 
;;;5578                 ABORT(fs, FR_DISK_ERR);
;;;5579   						fp->flag &= (BYTE)~FA_DIRTY;
;;;5580   					}
;;;5581   #endif
;;;5582   					if (disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK)   /* Load current sector */
;;;5583               ABORT(fs, FR_DISK_ERR);	
;;;5584   #endif
;;;5585   					fp->sect = dsc;
;;;5586   				}
;;;5587   			}
;;;5588   		}
;;;5589   	} else
;;;5590   #endif
;;;5591   
;;;5592   	/* Normal Seek */
;;;5593   	{
;;;5594   #if FF_FS_EXFAT
;;;5595   		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) /* Clip at 4 GiB - 1 if at FATxx */
;;;5596         ofs = 0xFFFFFFFF;	
;;;5597   #endif
;;;5598   		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) /* In read-only mode, clip offset with the file size */
;;;5599       {	
;;;5600   			ofs = fp->obj.objsize;
;;;5601   		}
;;;5602   		ifptr = fp->fptr;
;;;5603   		fp->fptr = nsect = 0;
;;;5604   		if (ofs > 0) 
;;;5605       {
;;;5606   			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
;;;5607   			if (ifptr > 0 &&
;;;5608   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) /* When seek to same or following cluster, */
;;;5609         {	
;;;5610   				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
;;;5611   				ofs -= fp->fptr;
;;;5612   				clst = fp->clust;
;;;5613   			} 
;;;5614          else 
;;;5615          {									/* When seek to back cluster, */
;;;5616   				clst = fp->obj.sclust;					/* start from the first cluster */
;;;5617   #if !FF_FS_READONLY
;;;5618   				if (clst == 0) 		/* If no cluster chain, create a new chain */
;;;5619           {				
;;;5620   					clst = create_chain(&fp->obj, 0);
;;;5621   					if (clst == 1) ABORT(fs, FR_INT_ERR);
;;;5622   					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;5623   					fp->obj.sclust = clst;
;;;5624   				}
;;;5625   #endif
;;;5626   				fp->clust = clst;
;;;5627   			}
;;;5628   			if (clst != 0) 
;;;5629         {
;;;5630   				while (ofs > bcs) 		/* Cluster following loop */
;;;5631           {				
;;;5632   					ofs -= bcs; fp->fptr += bcs;
;;;5633   #if !FF_FS_READONLY
;;;5634   					if (fp->flag & FA_WRITE) 		/* Check if in write mode or not */
;;;5635             {	
;;;5636   						if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) /* No FAT chain object needs correct objsize to generate FAT value */
;;;5637               {	
;;;5638   							fp->obj.objsize = fp->fptr;
;;;5639   							fp->flag |= FA_MODIFIED;
;;;5640   						}
;;;5641   						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
;;;5642   						if (clst == 0) 		/* Clip file size in case of disk full */
;;;5643               {		
;;;5644   							ofs = 0; 
;;;5645                 break;
;;;5646   						}
;;;5647   					} 
;;;5648             else
;;;5649   #endif
;;;5650   					{
;;;5651   						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
;;;5652   					}
;;;5653   					if (clst == 0xFFFFFFFF) 
;;;5654               ABORT(fs, FR_DISK_ERR);
;;;5655   					if (clst <= 1 || clst >= fs->n_fatent) 
;;;5656               ABORT(fs, FR_INT_ERR);
;;;5657   					fp->clust = clst;
;;;5658   				}
;;;5659   				fp->fptr += ofs;
;;;5660   				if (ofs % SS(fs)) 
;;;5661           {
;;;5662   					nsect = clst2sect(fs, clst);	/* Current sector */
;;;5663   					if (nsect == 0) ABORT(fs, FR_INT_ERR);
;;;5664   					nsect += (DWORD)(ofs / SS(fs));
;;;5665   				}
;;;5666   			}
;;;5667   		}
;;;5668   		if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) /* Set file change flag if the file size is extended */
;;;5669       {	
;;;5670   			fp->obj.objsize = fp->fptr;
;;;5671   			fp->flag |= FA_MODIFIED;
;;;5672   		}
;;;5673   		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
;;;5674   #if !FF_FS_TINY
;;;5675   #if !FF_FS_READONLY
;;;5676   			if (fp->flag & FA_DIRTY) 		/* Write-back dirty sector cache */
;;;5677         {	
;;;5678   				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;5679   				fp->flag &= (BYTE)~FA_DIRTY;
;;;5680   			}
;;;5681   #endif
;;;5682   			if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
;;;5683           ABORT(fs, FR_DISK_ERR);	
;;;5684   #endif
;;;5685   			fp->sect = nsect;
;;;5686   		}
;;;5687   	}
;;;5688   
;;;5689   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
;;;5690   }
000024  e8bd8ff8          POP      {r3-r11,pc}
                  |L19.40|
000028  68e0              LDR      r0,[r4,#0xc]          ;5598
00002a  42b0              CMP      r0,r6                 ;5598
00002c  d204              BCS      |L19.56|
00002e  7c20              LDRB     r0,[r4,#0x10]         ;5598
000030  f0000002          AND      r0,r0,#2              ;5598
000034  b900              CBNZ     r0,|L19.56|
000036  68e6              LDR      r6,[r4,#0xc]          ;5600
                  |L19.56|
000038  f8d49014          LDR      r9,[r4,#0x14]         ;5602
00003c  f04f0800          MOV      r8,#0                 ;5603
000040  f8c48014          STR      r8,[r4,#0x14]         ;5603
000044  2e00              CMP      r6,#0                 ;5604
000046  d068              BEQ      |L19.282|
000048  9800              LDR      r0,[sp,#0]            ;5606
00004a  8940              LDRH     r0,[r0,#0xa]          ;5606
00004c  0247              LSLS     r7,r0,#9              ;5606
00004e  f1b90f00          CMP      r9,#0                 ;5607
000052  d011              BEQ      |L19.120|
000054  1e70              SUBS     r0,r6,#1              ;5608
000056  fbb0f1f7          UDIV     r1,r0,r7              ;5608
00005a  f1a90001          SUB      r0,r9,#1              ;5608
00005e  fbb0f0f7          UDIV     r0,r0,r7              ;5608
000062  4281              CMP      r1,r0                 ;5608
000064  d308              BCC      |L19.120|
000066  f1a90001          SUB      r0,r9,#1              ;5610
00006a  1e79              SUBS     r1,r7,#1              ;5610
00006c  4388              BICS     r0,r0,r1              ;5610
00006e  6160              STR      r0,[r4,#0x14]         ;5610
000070  6960              LDR      r0,[r4,#0x14]         ;5611
000072  1a36              SUBS     r6,r6,r0              ;5611
000074  69a5              LDR      r5,[r4,#0x18]         ;5612
000076  e012              B        |L19.158|
                  |L19.120|
000078  68a5              LDR      r5,[r4,#8]            ;5616
00007a  b97d              CBNZ     r5,|L19.156|
00007c  2100              MOVS     r1,#0                 ;5620
00007e  4620              MOV      r0,r4                 ;5620
000080  f7fffffe          BL       create_chain
000084  4605              MOV      r5,r0                 ;5620
000086  2d01              CMP      r5,#1                 ;5621
000088  d102              BNE      |L19.144|
00008a  2002              MOVS     r0,#2                 ;5621
00008c  7460              STRB     r0,[r4,#0x11]         ;5621
00008e  e7c9              B        |L19.36|
                  |L19.144|
000090  1c68              ADDS     r0,r5,#1              ;5622
000092  b910              CBNZ     r0,|L19.154|
000094  2001              MOVS     r0,#1                 ;5622
000096  7460              STRB     r0,[r4,#0x11]         ;5622
000098  e7c4              B        |L19.36|
                  |L19.154|
00009a  60a5              STR      r5,[r4,#8]            ;5623
                  |L19.156|
00009c  61a5              STR      r5,[r4,#0x18]         ;5626
                  |L19.158|
00009e  2d00              CMP      r5,#0                 ;5628
0000a0  d03b              BEQ      |L19.282|
0000a2  e024              B        |L19.238|
                  |L19.164|
0000a4  1bf6              SUBS     r6,r6,r7              ;5632
0000a6  6960              LDR      r0,[r4,#0x14]         ;5632
0000a8  4438              ADD      r0,r0,r7              ;5632
0000aa  6160              STR      r0,[r4,#0x14]         ;5632
0000ac  7c20              LDRB     r0,[r4,#0x10]         ;5634
0000ae  f0000002          AND      r0,r0,#2              ;5634
0000b2  b140              CBZ      r0,|L19.198|
0000b4  bf00              NOP                            ;5636
0000b6  4629              MOV      r1,r5                 ;5641
0000b8  4620              MOV      r0,r4                 ;5641
0000ba  f7fffffe          BL       create_chain
0000be  4605              MOV      r5,r0                 ;5641
0000c0  b935              CBNZ     r5,|L19.208|
0000c2  2600              MOVS     r6,#0                 ;5644
0000c4  e015              B        |L19.242|
                  |L19.198|
0000c6  4629              MOV      r1,r5                 ;5651
0000c8  4620              MOV      r0,r4                 ;5651
0000ca  f7fffffe          BL       get_fat
0000ce  4605              MOV      r5,r0                 ;5651
                  |L19.208|
0000d0  1c68              ADDS     r0,r5,#1              ;5653
0000d2  b910              CBNZ     r0,|L19.218|
0000d4  2001              MOVS     r0,#1                 ;5654
0000d6  7460              STRB     r0,[r4,#0x11]         ;5654
0000d8  e7a4              B        |L19.36|
                  |L19.218|
0000da  2d01              CMP      r5,#1                 ;5655
0000dc  d903              BLS      |L19.230|
0000de  9800              LDR      r0,[sp,#0]            ;5655
0000e0  6940              LDR      r0,[r0,#0x14]         ;5655
0000e2  42a8              CMP      r0,r5                 ;5655
0000e4  d802              BHI      |L19.236|
                  |L19.230|
0000e6  2002              MOVS     r0,#2                 ;5656
0000e8  7460              STRB     r0,[r4,#0x11]         ;5656
0000ea  e79b              B        |L19.36|
                  |L19.236|
0000ec  61a5              STR      r5,[r4,#0x18]         ;5657
                  |L19.238|
0000ee  42be              CMP      r6,r7                 ;5630
0000f0  d8d8              BHI      |L19.164|
                  |L19.242|
0000f2  bf00              NOP                            ;5645
0000f4  6960              LDR      r0,[r4,#0x14]         ;5659
0000f6  4430              ADD      r0,r0,r6              ;5659
0000f8  6160              STR      r0,[r4,#0x14]         ;5659
0000fa  f3c60008          UBFX     r0,r6,#0,#9           ;5660
0000fe  b160              CBZ      r0,|L19.282|
000100  4629              MOV      r1,r5                 ;5662
000102  9800              LDR      r0,[sp,#0]            ;5662
000104  f7fffffe          BL       clst2sect
000108  4680              MOV      r8,r0                 ;5662
00010a  f1b80f00          CMP      r8,#0                 ;5663
00010e  d102              BNE      |L19.278|
000110  2002              MOVS     r0,#2                 ;5663
000112  7460              STRB     r0,[r4,#0x11]         ;5663
000114  e786              B        |L19.36|
                  |L19.278|
000116  eb082856          ADD      r8,r8,r6,LSR #9       ;5664
                  |L19.282|
00011a  68e1              LDR      r1,[r4,#0xc]          ;5668
00011c  6960              LDR      r0,[r4,#0x14]         ;5668
00011e  4288              CMP      r0,r1                 ;5668
000120  d905              BLS      |L19.302|
000122  6960              LDR      r0,[r4,#0x14]         ;5670
000124  60e0              STR      r0,[r4,#0xc]          ;5670
000126  7c20              LDRB     r0,[r4,#0x10]         ;5671
000128  f0400040          ORR      r0,r0,#0x40           ;5671
00012c  7420              STRB     r0,[r4,#0x10]         ;5671
                  |L19.302|
00012e  8aa0              LDRH     r0,[r4,#0x14]         ;5673
000130  f3c00008          UBFX     r0,r0,#0,#9           ;5673
000134  b320              CBZ      r0,|L19.384|
000136  69e0              LDR      r0,[r4,#0x1c]         ;5673
000138  4540              CMP      r0,r8                 ;5673
00013a  d021              BEQ      |L19.384|
00013c  7c20              LDRB     r0,[r4,#0x10]         ;5676
00013e  f0000080          AND      r0,r0,#0x80           ;5676
000142  b178              CBZ      r0,|L19.356|
000144  69e2              LDR      r2,[r4,#0x1c]         ;5678
000146  9900              LDR      r1,[sp,#0]            ;5678
000148  7848              LDRB     r0,[r1,#1]            ;5678
00014a  2301              MOVS     r3,#1                 ;5678
00014c  f1040128          ADD      r1,r4,#0x28           ;5678
000150  f7fffffe          BL       disk_write
000154  b110              CBZ      r0,|L19.348|
000156  2001              MOVS     r0,#1                 ;5678
000158  7460              STRB     r0,[r4,#0x11]         ;5678
00015a  e763              B        |L19.36|
                  |L19.348|
00015c  7c20              LDRB     r0,[r4,#0x10]         ;5679
00015e  f000007f          AND      r0,r0,#0x7f           ;5679
000162  7420              STRB     r0,[r4,#0x10]         ;5679
                  |L19.356|
000164  9900              LDR      r1,[sp,#0]            ;5682
000166  7848              LDRB     r0,[r1,#1]            ;5682
000168  2301              MOVS     r3,#1                 ;5682
00016a  4642              MOV      r2,r8                 ;5682
00016c  f1040128          ADD      r1,r4,#0x28           ;5682
000170  f7fffffe          BL       disk_read
000174  b110              CBZ      r0,|L19.380|
000176  2001              MOVS     r0,#1                 ;5683
000178  7460              STRB     r0,[r4,#0x11]         ;5683
00017a  e753              B        |L19.36|
                  |L19.380|
00017c  f8c4801c          STR      r8,[r4,#0x1c]         ;5685
                  |L19.384|
000180  4650              MOV      r0,r10                ;5689
000182  e74f              B        |L19.36|
;;;5691   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=2

                  f_mkdir PROC
;;;6384   *******************************************************************************/
;;;6385   FRESULT f_mkdir (
000000  e92d41f1          PUSH     {r0,r4-r8,lr}
;;;6386   	const TCHAR* path		/* Pointer to the directory path *//* 目录名的指针 */
;;;6387   )
;;;6388   {
000004  b08d              SUB      sp,sp,#0x34
;;;6389   	FRESULT res;    //文件函数执行结果返回码
;;;6390   	DIR     dj;
;;;6391   	FATFS   *fs;    //文件系统对象
;;;6392   	BYTE    *dir;
;;;6393   	DWORD   dcl, pcl, tm;
;;;6394   	DEF_NAMBUF
;;;6395   
;;;6396   
;;;6397   	/* Get logical drive */
;;;6398   	res = find_volume(&path, &fs, FA_WRITE);
000006  2202              MOVS     r2,#2
000008  a901              ADD      r1,sp,#4
00000a  a80d              ADD      r0,sp,#0x34
00000c  f7fffffe          BL       find_volume
000010  4605              MOV      r5,r0
;;;6399   	if (res == FR_OK) 
000012  2d00              CMP      r5,#0
000014  d176              BNE      |L20.260|
;;;6400     {
;;;6401   		dj.obj.fs = fs;
000016  9801              LDR      r0,[sp,#4]
000018  9002              STR      r0,[sp,#8]
;;;6402   		INIT_NAMBUF(fs);
;;;6403   		res = follow_path(&dj, path);			  /* Follow the file path */    //该函数给定一个全路径，得到相应的目录对象。
00001a  a802              ADD      r0,sp,#8
00001c  990d              LDR      r1,[sp,#0x34]
00001e  f7fffffe          BL       follow_path
000022  4605              MOV      r5,r0
;;;6404   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
000024  b905              CBNZ     r5,|L20.40|
000026  2508              MOVS     r5,#8
                  |L20.40|
;;;6405   		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) 
000028  bf00              NOP      
;;;6406       {
;;;6407   			res = FR_INVALID_NAME;
;;;6408   		}
;;;6409   		if (res == FR_NO_FILE) 		/* Can create a new directory */
00002a  2d04              CMP      r5,#4
00002c  d16a              BNE      |L20.260|
;;;6410       {		
;;;6411   			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
00002e  2100              MOVS     r1,#0
000030  a802              ADD      r0,sp,#8
000032  f7fffffe          BL       create_chain
000036  4606              MOV      r6,r0
;;;6412   			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
000038  9801              LDR      r0,[sp,#4]
00003a  8940              LDRH     r0,[r0,#0xa]
00003c  0240              LSLS     r0,r0,#9
00003e  9005              STR      r0,[sp,#0x14]
;;;6413   			res = FR_OK;
000040  2500              MOVS     r5,#0
;;;6414   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000042  b906              CBNZ     r6,|L20.70|
000044  2507              MOVS     r5,#7
                  |L20.70|
;;;6415   			if (dcl == 1) res = FR_INT_ERR;
000046  2e01              CMP      r6,#1
000048  d100              BNE      |L20.76|
00004a  2502              MOVS     r5,#2
                  |L20.76|
;;;6416   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
00004c  1c70              ADDS     r0,r6,#1
00004e  b900              CBNZ     r0,|L20.82|
000050  2501              MOVS     r5,#1
                  |L20.82|
;;;6417   			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
000052  b91d              CBNZ     r5,|L20.92|
000054  9801              LDR      r0,[sp,#4]
000056  f7fffffe          BL       sync_window
00005a  4605              MOV      r5,r0
                  |L20.92|
;;;6418   			tm = GET_FATTIME();
00005c  f8df80ac          LDR      r8,|L20.268|
;;;6419   			if (res == FR_OK) 		/* Initialize the new directory table */
000060  bb7d              CBNZ     r5,|L20.194|
;;;6420         {			
;;;6421   				res = dir_clear(fs, dcl);		/* Clean up the new table */
000062  4631              MOV      r1,r6
000064  9801              LDR      r0,[sp,#4]
000066  f7fffffe          BL       dir_clear
00006a  4605              MOV      r5,r0
;;;6422   				if (res == FR_OK && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT)) /* Create dot entries (FAT only) */
00006c  bb4d              CBNZ     r5,|L20.194|
00006e  bf00              NOP      
;;;6423           {	
;;;6424   					dir = fs->win;
000070  9801              LDR      r0,[sp,#4]
000072  f1000430          ADD      r4,r0,#0x30
;;;6425   					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
000076  220b              MOVS     r2,#0xb
000078  2120              MOVS     r1,#0x20
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       mem_set
;;;6426   					dir[DIR_Name] = '.';
000080  202e              MOVS     r0,#0x2e
000082  7020              STRB     r0,[r4,#0]
;;;6427   					dir[DIR_Attr] = AM_DIR;
000084  2010              MOVS     r0,#0x10
000086  72e0              STRB     r0,[r4,#0xb]
;;;6428   					st_dword(dir + DIR_ModTime, tm);
000088  4641              MOV      r1,r8
00008a  f1040016          ADD      r0,r4,#0x16
00008e  f7fffffe          BL       st_dword
;;;6429   					st_clust(fs, dir, dcl);
000092  4632              MOV      r2,r6
000094  4621              MOV      r1,r4
000096  9801              LDR      r0,[sp,#4]
000098  f7fffffe          BL       st_clust
;;;6430   					mem_cpy(dir + SZDIRE, dir, SZDIRE); /* Create ".." entry */
00009c  2220              MOVS     r2,#0x20
00009e  4621              MOV      r1,r4
0000a0  f1040020          ADD      r0,r4,#0x20
0000a4  f7fffffe          BL       mem_cpy
;;;6431   					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
0000a8  202e              MOVS     r0,#0x2e
0000aa  f8840021          STRB     r0,[r4,#0x21]
0000ae  9f04              LDR      r7,[sp,#0x10]
;;;6432   					st_clust(fs, dir + SZDIRE, pcl);
0000b0  463a              MOV      r2,r7
0000b2  f1040120          ADD      r1,r4,#0x20
0000b6  9801              LDR      r0,[sp,#4]
0000b8  f7fffffe          BL       st_clust
;;;6433   					fs->wflag = 1;
0000bc  2001              MOVS     r0,#1
0000be  9901              LDR      r1,[sp,#4]
0000c0  70c8              STRB     r0,[r1,#3]
                  |L20.194|
;;;6434   				}
;;;6435   			}
;;;6436   			if (res == FR_OK) 
0000c2  b91d              CBNZ     r5,|L20.204|
;;;6437         {
;;;6438   				res = dir_register(&dj);	/* Register the object to the directoy */
0000c4  a802              ADD      r0,sp,#8
0000c6  f7fffffe          BL       dir_register
0000ca  4605              MOV      r5,r0
                  |L20.204|
;;;6439   			}
;;;6440   			if (res == FR_OK) 
0000cc  b9ad              CBNZ     r5,|L20.250|
;;;6441         {
;;;6442   #if FF_FS_EXFAT
;;;6443   				if (fs->fs_type == FS_EXFAT) /* Initialize directory entry block */
;;;6444           {	
;;;6445   					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
;;;6446   					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
;;;6447   					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
;;;6448   					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
;;;6449   					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag */
;;;6450   					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
;;;6451   					res = store_xdir(&dj);
;;;6452   				} 
;;;6453           else
;;;6454   #endif
;;;6455   				{
;;;6456   					dir = dj.dir;
0000ce  9c09              LDR      r4,[sp,#0x24]
;;;6457   					st_dword(dir + DIR_ModTime, tm);	/* Created time */
0000d0  4641              MOV      r1,r8
0000d2  f1040016          ADD      r0,r4,#0x16
0000d6  f7fffffe          BL       st_dword
;;;6458   					st_clust(fs, dir, dcl);				/* Table start cluster */
0000da  4632              MOV      r2,r6
0000dc  4621              MOV      r1,r4
0000de  9801              LDR      r0,[sp,#4]
0000e0  f7fffffe          BL       st_clust
;;;6459   					dir[DIR_Attr] = AM_DIR;				/* Attribute */
0000e4  2010              MOVS     r0,#0x10
0000e6  72e0              STRB     r0,[r4,#0xb]
;;;6460   					fs->wflag = 1;
0000e8  2001              MOVS     r0,#1
0000ea  9901              LDR      r1,[sp,#4]
0000ec  70c8              STRB     r0,[r1,#3]
;;;6461   				}
;;;6462   				if (res == FR_OK) 
0000ee  b91d              CBNZ     r5,|L20.248|
;;;6463           {
;;;6464   					res = sync_fs(fs);
0000f0  9801              LDR      r0,[sp,#4]
0000f2  f7fffffe          BL       sync_fs
0000f6  4605              MOV      r5,r0
                  |L20.248|
0000f8  e004              B        |L20.260|
                  |L20.250|
;;;6465   				}
;;;6466   			} 
;;;6467         else 
;;;6468         {
;;;6469   				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
0000fa  2200              MOVS     r2,#0
0000fc  4631              MOV      r1,r6
0000fe  a802              ADD      r0,sp,#8
000100  f7fffffe          BL       remove_chain
                  |L20.260|
;;;6470   			}
;;;6471   		}
;;;6472   		FREE_NAMBUF();
;;;6473   	}
;;;6474   
;;;6475   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
000104  4628              MOV      r0,r5
;;;6476   }
000106  b00e              ADD      sp,sp,#0x38
000108  e8bd81f0          POP      {r4-r8,pc}
;;;6477   
                          ENDP

                  |L20.268|
                          DCD      0x4c210000

                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;4509   *******************************************************************************/
;;;4510   FRESULT f_mount (
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;4511                   FATFS* fs,			    /* Pointer to the filesystem object (NULL:unmount)*/    //指向文件系统对象的指针（null：卸载）
;;;4512                   const TCHAR* path,	/* Logical drive number to be mounted/unmounted */      //要安装/卸载的逻辑驱动器号 
;;;4513                   BYTE opt			      /* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */ //模式选项0：不要挂载（延迟安装），1：立即安装 
;;;4514   )
;;;4515   {
000002  b082              SUB      sp,sp,#8
000004  4616              MOV      r6,r2
;;;4516   	FATFS       *cfs;       //文件系统对象
;;;4517   	int         vol;
;;;4518   	FRESULT     res;        //文件函数执行结果返回码
;;;4519   	const TCHAR *rp = path;
000006  9803              LDR      r0,[sp,#0xc]
000008  9001              STR      r0,[sp,#4]
;;;4520   
;;;4521   
;;;4522   	//==========================获取逻辑驱动器号
;;;4523   	vol = get_ldnumber(&rp);    /* Get logical drive number */  //从路径名称获取逻辑驱动器号
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       get_ldnumber
000010  4605              MOV      r5,r0
;;;4524   	if (vol < 0) 
000012  2d00              CMP      r5,#0
000014  da02              BGE      |L21.28|
;;;4525       return FR_INVALID_DRIVE;  //无效驱动器号
000016  200b              MOVS     r0,#0xb
                  |L21.24|
;;;4526   	cfs = FatFs[vol];					  /* Pointer to fs object */      //指向文件系统地址
;;;4527     //==========================
;;;4528   	if (cfs)    //已经有旧文件系统---需要清除相关数据
;;;4529     {
;;;4530   #if FF_FS_LOCK != 0   //如果已定义锁功能（暂时忽略）
;;;4531   		clear_lock(cfs);
;;;4532   #endif
;;;4533   #if FF_FS_REENTRANT		//如果定义重构驱动器（暂时忽略）				/* Discard sync object of the current volume */ //丢弃当前卷的同步对象
;;;4534   		if (!ff_del_syncobj(cfs->sobj))
;;;4535         return FR_INT_ERR;
;;;4536   #endif
;;;4537   		cfs->fs_type = 0;				/* Clear old fs object */   //清除旧的fs对象
;;;4538   	}
;;;4539     //========================
;;;4540   	if (fs)   //如果导入的文件系统地址有效（用户已建立）
;;;4541     {
;;;4542   		fs->fs_type = 0;				  /* Clear new fs object */   //清除新的fs对象
;;;4543   #if FF_FS_REENTRANT						/* Create sync object for the new volume *///为新驱动器创建新的对象（暂时忽略）
;;;4544   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj))
;;;4545         return FR_INT_ERR;
;;;4546   #endif
;;;4547   	}
;;;4548     //==========================注册新的fs对象（将新的对象地址存入用户文件系统）
;;;4549   	FatFs[vol] = fs;					/* Register new fs object */
;;;4550     //==========================模式选项0：不要挂载（延迟安装），1：立即安装
;;;4551   	if (opt == 0)     //不立即安装
;;;4552       return FR_OK;			/* Do not mount now, it will be mounted later */
;;;4553     //==========================立即安装
;;;4554   	res = find_volume(&path, &fs, 0);	  /* Force mounted the volume */
;;;4555   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
;;;4556   }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L21.28|
00001c  480c              LDR      r0,|L21.80|
00001e  f8504025          LDR      r4,[r0,r5,LSL #2]     ;4526
000022  b10c              CBZ      r4,|L21.40|
000024  2000              MOVS     r0,#0                 ;4537
000026  7020              STRB     r0,[r4,#0]            ;4537
                  |L21.40|
000028  9802              LDR      r0,[sp,#8]            ;4540
00002a  b110              CBZ      r0,|L21.50|
00002c  2000              MOVS     r0,#0                 ;4542
00002e  9902              LDR      r1,[sp,#8]            ;4542
000030  7008              STRB     r0,[r1,#0]            ;4542
                  |L21.50|
000032  4907              LDR      r1,|L21.80|
000034  9802              LDR      r0,[sp,#8]            ;4549
000036  f8410025          STR      r0,[r1,r5,LSL #2]     ;4549
00003a  b90e              CBNZ     r6,|L21.64|
00003c  2000              MOVS     r0,#0                 ;4552
00003e  e7eb              B        |L21.24|
                  |L21.64|
000040  2200              MOVS     r2,#0                 ;4554
000042  a902              ADD      r1,sp,#8              ;4554
000044  a803              ADD      r0,sp,#0xc            ;4554
000046  f7fffffe          BL       find_volume
00004a  4607              MOV      r7,r0                 ;4554
00004c  4638              MOV      r0,r7                 ;4555
00004e  e7e3              B        |L21.24|
;;;4557   
                          ENDP

                  |L21.80|
                          DCD      FatFs

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=2

                  f_open PROC
;;;4574   *******************************************************************************/
;;;4575   FRESULT f_open (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;4576                   FIL* fp,			      /* Pointer to the blank file object */      // 要创建的目标文件结构体指针
;;;4577                   const TCHAR* path,  /* Pointer to the file name */              // 指定创建或打开以空终止的字符串文件名指针
;;;4578                   BYTE mode			      /* Access mode and file open mode flags */  // 文件打开模式标志(查看File access mode and open method flags） */
;;;4579   )
;;;4580   {
000004  b08e              SUB      sp,sp,#0x38
000006  4604              MOV      r4,r0
000008  4616              MOV      r6,r2
;;;4581   	FRESULT res;      //文件函数执行结果返回码
;;;4582   	DIR     dj;       //目录对象
;;;4583   	FATFS   *fs;      //文件系统对象
;;;4584   #if !FF_FS_READONLY
;;;4585   	DWORD dw, cl, bcs, clst, sc;
;;;4586   	FSIZE_t ofs;
;;;4587   #endif
;;;4588   	DEF_NAMBUF
;;;4589   
;;;4590     
;;;4591   	if (!fp)  //空对象
00000a  b91c              CBNZ     r4,|L22.20|
;;;4592       return FR_INVALID_OBJECT;
00000c  2009              MOVS     r0,#9
                  |L22.14|
;;;4593   	//===============================查找驱动器编号/* Get logical drive number */
;;;4594   	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
;;;4595   	res = find_volume(&path, &fs, mode);
;;;4596     //===============================
;;;4597   	if (res == FR_OK)
;;;4598     {
;;;4599   		dj.obj.fs = fs;
;;;4600   		INIT_NAMBUF(fs);
;;;4601   		res = follow_path(&dj, path);	/* Follow the file path */        //该函数给定一个全路径，得到相应的目录对象。
;;;4602   #if !FF_FS_READONLY	              /* Read/Write configuration */    //未定义只读
;;;4603   		if (res == FR_OK)
;;;4604       {
;;;4605   			if (dj.fn[NSFLAG] & NS_NONAME)
;;;4606         {	/* Origin directory itself? */
;;;4607   				res = FR_INVALID_NAME;
;;;4608   			}
;;;4609   #if FF_FS_LOCK != 0
;;;4610   			else
;;;4611         {
;;;4612   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
;;;4613   			}
;;;4614   #endif
;;;4615   		}
;;;4616   		/* Create or Open a file */
;;;4617   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW))
;;;4618       {
;;;4619   			if (res != FR_OK)
;;;4620         {					/* No file, create new */
;;;4621   				if (res == FR_NO_FILE)
;;;4622           {		/* There is no file to open, create a new entry */
;;;4623   #if FF_FS_LOCK != 0
;;;4624   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;4625   #else
;;;4626   					res = dir_register(&dj);
;;;4627   #endif
;;;4628   				}
;;;4629   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;4630   			}
;;;4631   			else
;;;4632         {								/* Any object with the same name is already existing */
;;;4633   				if (dj.obj.attr & (AM_RDO | AM_DIR))
;;;4634           {	/* Cannot overwrite it (R/O or DIR) */
;;;4635   					res = FR_DENIED;
;;;4636   				}
;;;4637           else
;;;4638           {
;;;4639   					if (mode & FA_CREATE_NEW)
;;;4640               res = FR_EXIST;	/* Cannot create as new file */
;;;4641   				}
;;;4642   			}
;;;4643   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS))
;;;4644         {	/* Truncate the file if overwrite mode */
;;;4645   #if FF_FS_EXFAT
;;;4646   				if (fs->fs_type == FS_EXFAT)
;;;4647           {
;;;4648   					/* Get current allocation info */
;;;4649   					fp->obj.fs = fs;
;;;4650   					init_alloc_info(fs, &fp->obj);
;;;4651   					/* Set directory entry block initial state */
;;;4652   					mem_set(fs->dirbuf + 2, 0, 30);		/* Clear 85 entry except for NumSec */
;;;4653   					mem_set(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
;;;4654   					fs->dirbuf[XDIR_Attr] = AM_ARC;
;;;4655   					st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
;;;4656   					fs->dirbuf[XDIR_GenFlags] = 1;
;;;4657   					res = store_xdir(&dj);
;;;4658   					if (res == FR_OK && fp->obj.sclust != 0)
;;;4659             {	/* Remove the cluster chain if exist */
;;;4660   						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
;;;4661   						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
;;;4662   					}
;;;4663   				}
;;;4664           else
;;;4665   #endif
;;;4666   				{
;;;4667   					/* Set directory entry initial state */
;;;4668   					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
;;;4669   					st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
;;;4670   					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
;;;4671   					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
;;;4672   					st_dword(dj.dir + DIR_FileSize, 0);
;;;4673   					fs->wflag = 1;
;;;4674   					if (cl != 0) 
;;;4675             {						/* Remove the cluster chain if exist */
;;;4676   						dw = fs->winsect;
;;;4677   						res = remove_chain(&dj.obj, cl, 0);
;;;4678   						if (res == FR_OK) 
;;;4679               {
;;;4680   							res = move_window(fs, dw);
;;;4681   							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
;;;4682   						}
;;;4683   					}
;;;4684   				}
;;;4685   			}
;;;4686   		}
;;;4687   		else 
;;;4688       {	/* Open an existing file */
;;;4689   			if (res == FR_OK) 
;;;4690         {					/* Is the object exsiting? */
;;;4691   				if (dj.obj.attr & AM_DIR) 
;;;4692           {		/* File open against a directory */
;;;4693   					res = FR_NO_FILE;
;;;4694   				} 
;;;4695           else 
;;;4696           {
;;;4697   					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) 
;;;4698             { /* Write mode open against R/O file */
;;;4699   						res = FR_DENIED;
;;;4700   					}
;;;4701   				}
;;;4702   			}
;;;4703   		}
;;;4704   		if (res == FR_OK) 
;;;4705       {
;;;4706   			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
;;;4707   			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
;;;4708   			fp->dir_ptr = dj.dir;
;;;4709   #if FF_FS_LOCK != 0
;;;4710   			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
;;;4711   			if (fp->obj.lockid == 0) 
;;;4712           res = FR_INT_ERR;
;;;4713   #endif
;;;4714   		}
;;;4715   #else		/* R/O configuration */
;;;4716   		if (res == FR_OK) 
;;;4717       {
;;;4718   			if (dj.fn[NSFLAG] & NS_NONAME)
;;;4719         {	/* Is it origin directory itself? */
;;;4720   				res = FR_INVALID_NAME;
;;;4721   			} 
;;;4722         else 
;;;4723         {
;;;4724   				if (dj.obj.attr & AM_DIR) 
;;;4725           {		/* Is it a directory? */
;;;4726   					res = FR_NO_FILE;
;;;4727   				}
;;;4728   			}
;;;4729   		}
;;;4730   #endif
;;;4731   
;;;4732   		if (res == FR_OK) 
;;;4733       {
;;;4734   #if FF_FS_EXFAT
;;;4735   			if (fs->fs_type == FS_EXFAT) 
;;;4736         {
;;;4737   				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
;;;4738   				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
;;;4739   				fp->obj.c_ofs = dj.blk_ofs;
;;;4740   				init_alloc_info(fs, &fp->obj);
;;;4741   			} 
;;;4742         else
;;;4743   #endif
;;;4744   			{
;;;4745   				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
;;;4746   				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
;;;4747   			}
;;;4748   #if FF_USE_FASTSEEK
;;;4749   			fp->cltbl = 0;			/* Disable fast seek mode */
;;;4750   #endif
;;;4751   			fp->obj.fs = fs;	 	/* Validate the file object */
;;;4752   			fp->obj.id = fs->id;
;;;4753   			fp->flag = mode;		/* Set file access mode */
;;;4754   			fp->err = 0;			/* Clear error flag */
;;;4755   			fp->sect = 0;			/* Invalidate current data sector */
;;;4756   			fp->fptr = 0;			/* Set file pointer top of the file */
;;;4757   #if !FF_FS_READONLY
;;;4758   #if !FF_FS_TINY
;;;4759   			mem_set(fp->buf, 0, FF_MAX_SS);	/* Clear sector buffer */
;;;4760   #endif
;;;4761   			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) 
;;;4762         {	/* Seek to end of file if FA_OPEN_APPEND is specified */
;;;4763   				fp->fptr = fp->obj.objsize;			/* Offset to seek */
;;;4764   				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
;;;4765   				clst = fp->obj.sclust;				/* Follow the cluster chain */
;;;4766   				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) 
;;;4767           {
;;;4768   					clst = get_fat(&fp->obj, clst);
;;;4769   					if (clst <= 1) res = FR_INT_ERR;
;;;4770   					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;4771   				}
;;;4772   				fp->clust = clst;
;;;4773   				if (res == FR_OK && ofs % SS(fs)) 
;;;4774           {	/* Fill sector buffer if not on the sector boundary */
;;;4775   					if ((sc = clst2sect(fs, clst)) == 0) 
;;;4776             {
;;;4777   						res = FR_INT_ERR;
;;;4778   					} 
;;;4779             else 
;;;4780             {
;;;4781   						fp->sect = sc + (DWORD)(ofs / SS(fs));
;;;4782   #if !FF_FS_TINY
;;;4783   						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) 
;;;4784                 res = FR_DISK_ERR;
;;;4785   #endif
;;;4786   					}
;;;4787   				}
;;;4788   			}
;;;4789   #endif
;;;4790   		}
;;;4791   
;;;4792   		FREE_NAMBUF();
;;;4793   	}
;;;4794   
;;;4795   	if (res != FR_OK) 
;;;4796       fp->obj.fs = 0;	/* Invalidate file object on error */
;;;4797   
;;;4798   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
;;;4799   }
00000e  b011              ADD      sp,sp,#0x44
000010  e8bd8ff0          POP      {r4-r11,pc}
                  |L22.20|
000014  f006063f          AND      r6,r6,#0x3f           ;4594
000018  4632              MOV      r2,r6                 ;4595
00001a  a902              ADD      r1,sp,#8              ;4595
00001c  a80f              ADD      r0,sp,#0x3c           ;4595
00001e  f7fffffe          BL       find_volume
000022  4605              MOV      r5,r0                 ;4595
000024  2d00              CMP      r5,#0                 ;4597
000026  d17d              BNE      |L22.292|
000028  9802              LDR      r0,[sp,#8]            ;4599
00002a  9003              STR      r0,[sp,#0xc]          ;4599
00002c  a803              ADD      r0,sp,#0xc            ;4601
00002e  990f              LDR      r1,[sp,#0x3c]         ;4601
000030  f7fffffe          BL       follow_path
000034  4605              MOV      r5,r0                 ;4601
000036  b92d              CBNZ     r5,|L22.68|
000038  f89d0037          LDRB     r0,[sp,#0x37]         ;4605
00003c  f0000080          AND      r0,r0,#0x80           ;4605
000040  b100              CBZ      r0,|L22.68|
000042  2506              MOVS     r5,#6                 ;4607
                  |L22.68|
000044  f006001c          AND      r0,r6,#0x1c           ;4617
000048  2800              CMP      r0,#0                 ;4617
00004a  d04d              BEQ      |L22.232|
00004c  b145              CBZ      r5,|L22.96|
00004e  2d04              CMP      r5,#4                 ;4621
000050  d103              BNE      |L22.90|
000052  a803              ADD      r0,sp,#0xc            ;4626
000054  f7fffffe          BL       dir_register
000058  4605              MOV      r5,r0                 ;4626
                  |L22.90|
00005a  f0460608          ORR      r6,r6,#8              ;4629
00005e  e00a              B        |L22.118|
                  |L22.96|
000060  f89d0012          LDRB     r0,[sp,#0x12]         ;4633
000064  f0000011          AND      r0,r0,#0x11           ;4633
000068  b108              CBZ      r0,|L22.110|
00006a  2507              MOVS     r5,#7                 ;4635
00006c  e003              B        |L22.118|
                  |L22.110|
00006e  f0060004          AND      r0,r6,#4              ;4639
000072  b100              CBZ      r0,|L22.118|
000074  2508              MOVS     r5,#8                 ;4640
                  |L22.118|
000076  2d00              CMP      r5,#0                 ;4643
000078  d147              BNE      |L22.266|
00007a  f0060008          AND      r0,r6,#8              ;4643
00007e  2800              CMP      r0,#0                 ;4643
000080  d043              BEQ      |L22.266|
000082  990a              LDR      r1,[sp,#0x28]         ;4668
000084  9802              LDR      r0,[sp,#8]            ;4668
000086  f7fffffe          BL       ld_clust
00008a  4681              MOV      r9,r0                 ;4668
00008c  990a              LDR      r1,[sp,#0x28]         ;4669
00008e  f101000e          ADD      r0,r1,#0xe            ;4669
000092  4953              LDR      r1,|L22.480|
000094  f7fffffe          BL       st_dword
000098  2020              MOVS     r0,#0x20              ;4670
00009a  990a              LDR      r1,[sp,#0x28]         ;4670
00009c  72c8              STRB     r0,[r1,#0xb]          ;4670
00009e  2200              MOVS     r2,#0                 ;4671
0000a0  990a              LDR      r1,[sp,#0x28]         ;4671
0000a2  9802              LDR      r0,[sp,#8]            ;4671
0000a4  f7fffffe          BL       st_clust
0000a8  990a              LDR      r1,[sp,#0x28]         ;4672
0000aa  f101001c          ADD      r0,r1,#0x1c           ;4672
0000ae  2100              MOVS     r1,#0                 ;4672
0000b0  f7fffffe          BL       st_dword
0000b4  2001              MOVS     r0,#1                 ;4673
0000b6  9902              LDR      r1,[sp,#8]            ;4673
0000b8  70c8              STRB     r0,[r1,#3]            ;4673
0000ba  f1b90f00          CMP      r9,#0                 ;4674
0000be  d024              BEQ      |L22.266|
0000c0  9802              LDR      r0,[sp,#8]            ;4676
0000c2  6ac0              LDR      r0,[r0,#0x2c]         ;4676
0000c4  9001              STR      r0,[sp,#4]            ;4676
0000c6  2200              MOVS     r2,#0                 ;4677
0000c8  4649              MOV      r1,r9                 ;4677
0000ca  a803              ADD      r0,sp,#0xc            ;4677
0000cc  f7fffffe          BL       remove_chain
0000d0  4605              MOV      r5,r0                 ;4677
0000d2  b9d5              CBNZ     r5,|L22.266|
0000d4  e9dd1001          LDRD     r1,r0,[sp,#4]         ;4680
0000d8  f7fffffe          BL       move_window
0000dc  4605              MOV      r5,r0                 ;4680
0000de  f1a90001          SUB      r0,r9,#1              ;4681
0000e2  9902              LDR      r1,[sp,#8]            ;4681
0000e4  60c8              STR      r0,[r1,#0xc]          ;4681
0000e6  e010              B        |L22.266|
                  |L22.232|
0000e8  b97d              CBNZ     r5,|L22.266|
0000ea  f89d0012          LDRB     r0,[sp,#0x12]         ;4691
0000ee  f0000010          AND      r0,r0,#0x10           ;4691
0000f2  b108              CBZ      r0,|L22.248|
0000f4  2504              MOVS     r5,#4                 ;4693
0000f6  e008              B        |L22.266|
                  |L22.248|
0000f8  f0060002          AND      r0,r6,#2              ;4697
0000fc  b128              CBZ      r0,|L22.266|
0000fe  f89d0012          LDRB     r0,[sp,#0x12]         ;4697
000102  f0000001          AND      r0,r0,#1              ;4697
000106  b100              CBZ      r0,|L22.266|
000108  2507              MOVS     r5,#7                 ;4699
                  |L22.266|
00010a  b94d              CBNZ     r5,|L22.288|
00010c  f0060008          AND      r0,r6,#8              ;4706
000110  b108              CBZ      r0,|L22.278|
000112  f0460640          ORR      r6,r6,#0x40           ;4706
                  |L22.278|
000116  9802              LDR      r0,[sp,#8]            ;4707
000118  6ac0              LDR      r0,[r0,#0x2c]         ;4707
00011a  6220              STR      r0,[r4,#0x20]         ;4707
00011c  980a              LDR      r0,[sp,#0x28]         ;4708
00011e  6260              STR      r0,[r4,#0x24]         ;4708
                  |L22.288|
000120  2d00              CMP      r5,#0                 ;4732
000122  e000              B        |L22.294|
                  |L22.292|
000124  e048              B        |L22.440|
                  |L22.294|
000126  d155              BNE      |L22.468|
000128  990a              LDR      r1,[sp,#0x28]         ;4745
00012a  9802              LDR      r0,[sp,#8]            ;4745
00012c  f7fffffe          BL       ld_clust
000130  60a0              STR      r0,[r4,#8]            ;4745
000132  990a              LDR      r1,[sp,#0x28]         ;4746
000134  f101001c          ADD      r0,r1,#0x1c           ;4746
000138  f7fffffe          BL       ld_dword
00013c  60e0              STR      r0,[r4,#0xc]          ;4746
00013e  9802              LDR      r0,[sp,#8]            ;4751
000140  6020              STR      r0,[r4,#0]            ;4751
000142  9802              LDR      r0,[sp,#8]            ;4752
000144  88c0              LDRH     r0,[r0,#6]            ;4752
000146  80a0              STRH     r0,[r4,#4]            ;4752
000148  7426              STRB     r6,[r4,#0x10]         ;4753
00014a  2000              MOVS     r0,#0                 ;4754
00014c  7460              STRB     r0,[r4,#0x11]         ;4754
00014e  61e0              STR      r0,[r4,#0x1c]         ;4755
000150  6160              STR      r0,[r4,#0x14]         ;4756
000152  f44f7200          MOV      r2,#0x200             ;4759
000156  2100              MOVS     r1,#0                 ;4759
000158  f1040028          ADD      r0,r4,#0x28           ;4759
00015c  f7fffffe          BL       mem_set
000160  f0060020          AND      r0,r6,#0x20           ;4761
000164  b340              CBZ      r0,|L22.440|
000166  68e0              LDR      r0,[r4,#0xc]          ;4761
000168  b330              CBZ      r0,|L22.440|
00016a  68e0              LDR      r0,[r4,#0xc]          ;4763
00016c  6160              STR      r0,[r4,#0x14]         ;4763
00016e  9802              LDR      r0,[sp,#8]            ;4764
000170  8940              LDRH     r0,[r0,#0xa]          ;4764
000172  ea4f2a40          LSL      r10,r0,#9             ;4764
000176  68a7              LDR      r7,[r4,#8]            ;4765
000178  f8d4800c          LDR      r8,[r4,#0xc]          ;4766
00017c  e00c              B        |L22.408|
                  |L22.382|
00017e  4639              MOV      r1,r7                 ;4768
000180  4620              MOV      r0,r4                 ;4768
000182  f7fffffe          BL       get_fat
000186  4607              MOV      r7,r0                 ;4768
000188  2f01              CMP      r7,#1                 ;4769
00018a  d800              BHI      |L22.398|
00018c  2502              MOVS     r5,#2                 ;4769
                  |L22.398|
00018e  1c78              ADDS     r0,r7,#1              ;4770
000190  b900              CBNZ     r0,|L22.404|
000192  2501              MOVS     r5,#1                 ;4770
                  |L22.404|
000194  eba8080a          SUB      r8,r8,r10             ;4766
                  |L22.408|
000198  b90d              CBNZ     r5,|L22.414|
00019a  45d0              CMP      r8,r10                ;4766
00019c  d8ef              BHI      |L22.382|
                  |L22.414|
00019e  61a7              STR      r7,[r4,#0x18]         ;4772
0001a0  b955              CBNZ     r5,|L22.440|
0001a2  f3c80008          UBFX     r0,r8,#0,#9           ;4773
0001a6  b138              CBZ      r0,|L22.440|
0001a8  4639              MOV      r1,r7                 ;4775
0001aa  9802              LDR      r0,[sp,#8]            ;4775
0001ac  f7fffffe          BL       clst2sect
0001b0  f1b00b00          SUBS     r11,r0,#0             ;4775
0001b4  d101              BNE      |L22.442|
0001b6  2502              MOVS     r5,#2                 ;4777
                  |L22.440|
0001b8  e00c              B        |L22.468|
                  |L22.442|
0001ba  eb0b2058          ADD      r0,r11,r8,LSR #9      ;4781
0001be  61e0              STR      r0,[r4,#0x1c]         ;4781
0001c0  69e2              LDR      r2,[r4,#0x1c]         ;4783
0001c2  9902              LDR      r1,[sp,#8]            ;4783
0001c4  7848              LDRB     r0,[r1,#1]            ;4783
0001c6  2301              MOVS     r3,#1                 ;4783
0001c8  f1040128          ADD      r1,r4,#0x28           ;4783
0001cc  f7fffffe          BL       disk_read
0001d0  b100              CBZ      r0,|L22.468|
0001d2  2501              MOVS     r5,#1                 ;4784
                  |L22.468|
0001d4  b10d              CBZ      r5,|L22.474|
0001d6  2000              MOVS     r0,#0                 ;4796
0001d8  6020              STR      r0,[r4,#0]            ;4796
                  |L22.474|
0001da  4628              MOV      r0,r5                 ;4798
0001dc  e717              B        |L22.14|
;;;4800   
                          ENDP

0001de  0000              DCW      0x0000
                  |L22.480|
                          DCD      0x4c210000

                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;5712   *******************************************************************************/
;;;5713   FRESULT f_opendir (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;5714                     DIR*  dp,			    /* Pointer to directory object to create */ //目录对象结构体指针
;;;5715                     const TCHAR* path	/* Pointer to the directory path */         //指向目录路径的指针
;;;5716   )
;;;5717   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
;;;5718   	FRESULT res;    //文件函数执行结果返回码
;;;5719   	FATFS   *fs;    //文件系统对象
;;;5720   	DEF_NAMBUF
;;;5721   
;;;5722   
;;;5723   	if (!dp)
000006  b90c              CBNZ     r4,|L23.12|
;;;5724       return FR_INVALID_OBJECT;
000008  2009              MOVS     r0,#9
                  |L23.10|
;;;5725   	/* Get logical drive */
;;;5726   	res = find_volume(&path, &fs, 0);   //确定逻辑驱动器号并在需要时装入卷及初始化驱动器及获取磁盘相关信息
;;;5727   	if (res == FR_OK)
;;;5728     {
;;;5729   		dp->obj.fs = fs;    //目录中包含的文件系统对象结构体地址
;;;5730   		INIT_NAMBUF(fs);
;;;5731   		res = follow_path(dp, path);			    /* Follow the path to the directory */  //该函数给定一个全路径，得到相应的目录对象。
;;;5732   		if (res == FR_OK)                     /* Follow completed */
;;;5733        {						
;;;5734   			if (!(dp->fn[NSFLAG] & NS_NONAME))  /* It is not the origin directory itself */
;;;5735         {	
;;;5736   				if (dp->obj.attr & AM_DIR)        /* This object is a sub-directory */
;;;5737           {		
;;;5738   #if FF_FS_EXFAT   //如果支持exFAT文件系统
;;;5739   					if (fs->fs_type == FS_EXFAT)
;;;5740             {
;;;5741   						dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
;;;5742   						dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
;;;5743   						dp->obj.c_ofs = dp->blk_ofs;
;;;5744   						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
;;;5745   					}
;;;5746             else
;;;5747   #endif
;;;5748   					{
;;;5749   						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
;;;5750   					}
;;;5751   				}
;;;5752           else    /* This object is a file */
;;;5753           {						
;;;5754   					res = FR_NO_PATH;
;;;5755   				}
;;;5756   			}
;;;5757   			if (res == FR_OK)
;;;5758         {
;;;5759   				dp->obj.id = fs->id;      //获取当前目录文件系统所挂载ID
;;;5760   				res = dir_sdi(dp, 0);			/* Rewind directory */    //目录处理-设置目录索引--从dp->blk_ofs开始查找
;;;5761   #if FF_FS_LOCK != 0
;;;5762   				if (res == FR_OK)
;;;5763           {
;;;5764   					if (dp->obj.sclust != 0)
;;;5765             {
;;;5766   						dp->obj.lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;5767   						if (!dp->obj.lockid)
;;;5768                 res = FR_TOO_MANY_OPEN_FILES;
;;;5769   					}
;;;5770             else    /* Root directory need not to be locked */    //根目录不需要锁定
;;;5771             {
;;;5772   						dp->obj.lockid = 0;	
;;;5773   					}
;;;5774   				}
;;;5775   #endif
;;;5776   			}
;;;5777   		}
;;;5778   		FREE_NAMBUF();
;;;5779   		if (res == FR_NO_FILE)
;;;5780         res = FR_NO_PATH;
;;;5781   	}
;;;5782   	if (res != FR_OK)     /* Invalidate the directory object if function faild */
;;;5783       dp->obj.fs = 0;	    //目录中包含的文件系统对象结构体地址
;;;5784   
;;;5785   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
;;;5786   }
00000a  bd3e              POP      {r1-r5,pc}
                  |L23.12|
00000c  2200              MOVS     r2,#0                 ;5726
00000e  4669              MOV      r1,sp                 ;5726
000010  a802              ADD      r0,sp,#8              ;5726
000012  f7fffffe          BL       find_volume
000016  4605              MOV      r5,r0                 ;5726
000018  bb1d              CBNZ     r5,|L23.98|
00001a  9800              LDR      r0,[sp,#0]            ;5729
00001c  6020              STR      r0,[r4,#0]            ;5729
00001e  4620              MOV      r0,r4                 ;5731
000020  9902              LDR      r1,[sp,#8]            ;5731
000022  f7fffffe          BL       follow_path
000026  4605              MOV      r5,r0                 ;5731
000028  b9c5              CBNZ     r5,|L23.92|
00002a  202b              MOVS     r0,#0x2b              ;5734
00002c  5d00              LDRB     r0,[r0,r4]            ;5734
00002e  f0000080          AND      r0,r0,#0x80           ;5734
000032  b950              CBNZ     r0,|L23.74|
000034  79a0              LDRB     r0,[r4,#6]            ;5736
000036  f0000010          AND      r0,r0,#0x10           ;5736
00003a  b128              CBZ      r0,|L23.72|
00003c  69e1              LDR      r1,[r4,#0x1c]         ;5749
00003e  9800              LDR      r0,[sp,#0]            ;5749
000040  f7fffffe          BL       ld_clust
000044  60a0              STR      r0,[r4,#8]            ;5749
000046  e000              B        |L23.74|
                  |L23.72|
000048  2505              MOVS     r5,#5                 ;5754
                  |L23.74|
00004a  b93d              CBNZ     r5,|L23.92|
00004c  9800              LDR      r0,[sp,#0]            ;5759
00004e  88c0              LDRH     r0,[r0,#6]            ;5759
000050  80a0              STRH     r0,[r4,#4]            ;5759
000052  2100              MOVS     r1,#0                 ;5760
000054  4620              MOV      r0,r4                 ;5760
000056  f7fffffe          BL       dir_sdi
00005a  4605              MOV      r5,r0                 ;5760
                  |L23.92|
00005c  2d04              CMP      r5,#4                 ;5779
00005e  d100              BNE      |L23.98|
000060  2505              MOVS     r5,#5                 ;5780
                  |L23.98|
000062  b10d              CBZ      r5,|L23.104|
000064  2000              MOVS     r0,#0                 ;5783
000066  6020              STR      r0,[r4,#0]            ;5783
                  |L23.104|
000068  4628              MOV      r0,r5                 ;5785
00006a  e7ce              B        |L23.10|
;;;5787   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;4821   *******************************************************************************/
;;;4822   FRESULT f_read (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;4823                 FIL*  fp,   /* Pointer to the file object */        //文件对象结构体指针
;;;4824                 void* buff, /* Pointer to data buffer */            //读取数据缓冲区指针
;;;4825                 UINT  btr,  /* Number of bytes to read */           //需要读取的数据个数
;;;4826                 UINT* br	  /* Pointer to number of bytes read */   //已完成读取的字节数变量指针
;;;4827   )
;;;4828   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
;;;4829   	FRESULT res;        //文件函数执行结果返回码
;;;4830   	FATFS   *fs;        //文件系统对象
;;;4831   	DWORD   clst, sect;
;;;4832   	FSIZE_t remain;
;;;4833   	UINT    rcnt, cc, csect;
;;;4834   	BYTE    *rbuff = (BYTE*)buff;
00000c  f8ddb018          LDR      r11,[sp,#0x18]
;;;4835   
;;;4836   
;;;4837   	*br = 0;	/* Clear read byte counter */
000010  2000              MOVS     r0,#0
000012  f8ca0000          STR      r0,[r10,#0]
;;;4838   	res = validate(&fp->obj, &fs);				                  /* Check validity of the file object */
000016  a903              ADD      r1,sp,#0xc
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       validate
00001e  9004              STR      r0,[sp,#0x10]
;;;4839   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK)  /* Check validity */
000020  9804              LDR      r0,[sp,#0x10]
000022  b910              CBNZ     r0,|L24.42|
000024  7c60              LDRB     r0,[r4,#0x11]
000026  9004              STR      r0,[sp,#0x10]
000028  b118              CBZ      r0,|L24.50|
                  |L24.42|
;;;4840       LEAVE_FF(fs, res);	    //释放文件系统同步对象并将状态返回(return)。
00002a  9804              LDR      r0,[sp,#0x10]
                  |L24.44|
;;;4841   	if (!(fp->flag & FA_READ))  /* Check access mode */
;;;4842       LEAVE_FF(fs, FR_DENIED);  //释放文件系统同步对象并将状态返回(return)。
;;;4843   	remain = fp->obj.objsize - fp->fptr;
;;;4844   	if (btr > remain) 	        /* Truncate btr by remaining bytes */
;;;4845       btr = (UINT)remain;	
;;;4846     //======================================开始读取数据
;;;4847   	for ( ;  btr;								/* Repeat until btr bytes read */
;;;4848   		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) 
;;;4849     {
;;;4850   		if (fp->fptr % SS(fs) == 0) 		/* On the sector boundary? */
;;;4851       {	
;;;4852   			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
;;;4853   			if (csect == 0)               /* On the cluster boundary? */
;;;4854         {					
;;;4855   				if (fp->fptr == 0)          /* On the top of the file? */
;;;4856           {	
;;;4857   					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
;;;4858   				} 
;;;4859           else 		    /* Middle or end of the file */
;;;4860           {				
;;;4861   #if FF_USE_FASTSEEK
;;;4862   					if (fp->cltbl) 
;;;4863             {
;;;4864   						clst = clmt_clust(fp, fp->fptr);	    /* Get cluster# from the CLMT */
;;;4865   					} 
;;;4866             else
;;;4867   #endif
;;;4868   					{
;;;4869   						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
;;;4870   					}
;;;4871   				}
;;;4872   				if (clst < 2)
;;;4873             ABORT(fs, FR_INT_ERR);
;;;4874   				if (clst == 0xFFFFFFFF)
;;;4875             ABORT(fs, FR_DISK_ERR);
;;;4876   				fp->clust = clst;				        /* Update current cluster */    
;;;4877   			}
;;;4878   			sect = clst2sect(fs, fp->clust);	/* Get current sector */      //获取当前扇区
;;;4879   			if (sect == 0) 
;;;4880           ABORT(fs, FR_INT_ERR);
;;;4881   			sect += csect;
;;;4882   			cc = btr / SS(fs);					      /* When remaining bytes >= sector size, */
;;;4883   			if (cc > 0)                       /* Read maximum contiguous sectors directly */
;;;4884         {						        
;;;4885   				if (csect + cc > fs->csize) 	  /* Clip at cluster boundary */
;;;4886           {
;;;4887   					cc = fs->csize - csect;
;;;4888   				}
;;;4889   				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) 
;;;4890             ABORT(fs, FR_DISK_ERR);       //退出
;;;4891           //======================================复制数据
;;;4892   #if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2		/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;4893   #if FF_FS_TINY
;;;4894   				if (fs->wflag && fs->winsect - sect < cc) 
;;;4895           {
;;;4896   					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
;;;4897   				}
;;;4898   #else
;;;4899   				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) 
;;;4900           {
;;;4901   					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
;;;4902   				}
;;;4903   #endif
;;;4904   #endif
;;;4905   				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
;;;4906   				continue;
;;;4907   			}
;;;4908   #if !FF_FS_TINY
;;;4909   			if (fp->sect != sect) 		  /* Load data sector if not in cache */
;;;4910         {	
;;;4911   #if !FF_FS_READONLY
;;;4912   				if (fp->flag & FA_DIRTY)  /* Write-back dirty sector cache */
;;;4913           {
;;;4914   					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) 
;;;4915               ABORT(fs, FR_DISK_ERR);
;;;4916   					fp->flag &= (BYTE)~FA_DIRTY;
;;;4917   				}
;;;4918   #endif
;;;4919   				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
;;;4920   			}
;;;4921   #endif
;;;4922   			fp->sect = sect;
;;;4923   		}
;;;4924   		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	          /* Number of bytes left in the sector */
;;;4925   		if (rcnt > btr) rcnt = btr;					                /* Clip it by btr if needed */
;;;4926   #if FF_FS_TINY
;;;4927   		if (move_window(fs, fp->sect) != FR_OK) 	          /* Move sector window */
;;;4928         ABORT(fs, FR_DISK_ERR);
;;;4929   		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
;;;4930   #else
;;;4931   		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
;;;4932   #endif
;;;4933   	}
;;;4934   
;;;4935   	LEAVE_FF(fs, FR_OK);    //释放文件系统同步对象并将状态返回(return)。
;;;4936   }
00002c  b009              ADD      sp,sp,#0x24
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L24.50|
000032  7c20              LDRB     r0,[r4,#0x10]         ;4841
000034  f0000001          AND      r0,r0,#1              ;4841
000038  b908              CBNZ     r0,|L24.62|
00003a  2007              MOVS     r0,#7                 ;4842
00003c  e7f6              B        |L24.44|
                  |L24.62|
00003e  6961              LDR      r1,[r4,#0x14]         ;4843
000040  68e0              LDR      r0,[r4,#0xc]          ;4843
000042  1a40              SUBS     r0,r0,r1              ;4843
000044  9001              STR      r0,[sp,#4]            ;4843
000046  9801              LDR      r0,[sp,#4]            ;4844
000048  4285              CMP      r5,r0                 ;4844
00004a  d900              BLS      |L24.78|
00004c  9d01              LDR      r5,[sp,#4]            ;4845
                  |L24.78|
00004e  e0a0              B        |L24.402|
                  |L24.80|
000050  8aa0              LDRH     r0,[r4,#0x14]         ;4850
000052  f3c00008          UBFX     r0,r0,#0,#9           ;4850
000056  2800              CMP      r0,#0                 ;4850
000058  d17e              BNE      |L24.344|
00005a  9803              LDR      r0,[sp,#0xc]          ;4852
00005c  8940              LDRH     r0,[r0,#0xa]          ;4852
00005e  1e40              SUBS     r0,r0,#1              ;4852
000060  6961              LDR      r1,[r4,#0x14]         ;4852
000062  ea002951          AND      r9,r0,r1,LSR #9       ;4852
000066  f1b90f00          CMP      r9,#0                 ;4853
00006a  d117              BNE      |L24.156|
00006c  6960              LDR      r0,[r4,#0x14]         ;4855
00006e  b910              CBNZ     r0,|L24.118|
000070  68a0              LDR      r0,[r4,#8]            ;4857
000072  9002              STR      r0,[sp,#8]            ;4857
000074  e004              B        |L24.128|
                  |L24.118|
000076  4620              MOV      r0,r4                 ;4869
000078  69a1              LDR      r1,[r4,#0x18]         ;4869
00007a  f7fffffe          BL       get_fat
00007e  9002              STR      r0,[sp,#8]            ;4869
                  |L24.128|
000080  9802              LDR      r0,[sp,#8]            ;4872
000082  2802              CMP      r0,#2                 ;4872
000084  d202              BCS      |L24.140|
000086  2002              MOVS     r0,#2                 ;4873
000088  7460              STRB     r0,[r4,#0x11]         ;4873
00008a  e7cf              B        |L24.44|
                  |L24.140|
00008c  9802              LDR      r0,[sp,#8]            ;4874
00008e  1c40              ADDS     r0,r0,#1              ;4874
000090  b910              CBNZ     r0,|L24.152|
000092  2001              MOVS     r0,#1                 ;4875
000094  7460              STRB     r0,[r4,#0x11]         ;4875
000096  e7c9              B        |L24.44|
                  |L24.152|
000098  9802              LDR      r0,[sp,#8]            ;4876
00009a  61a0              STR      r0,[r4,#0x18]         ;4876
                  |L24.156|
00009c  69a1              LDR      r1,[r4,#0x18]         ;4878
00009e  9803              LDR      r0,[sp,#0xc]          ;4878
0000a0  f7fffffe          BL       clst2sect
0000a4  4606              MOV      r6,r0                 ;4878
0000a6  b916              CBNZ     r6,|L24.174|
0000a8  2002              MOVS     r0,#2                 ;4880
0000aa  7460              STRB     r0,[r4,#0x11]         ;4880
0000ac  e7be              B        |L24.44|
                  |L24.174|
0000ae  444e              ADD      r6,r6,r9              ;4881
0000b0  ea4f2855          LSR      r8,r5,#9              ;4882
0000b4  f1b80f00          CMP      r8,#0                 ;4883
0000b8  d029              BEQ      |L24.270|
0000ba  eb090008          ADD      r0,r9,r8              ;4885
0000be  9903              LDR      r1,[sp,#0xc]          ;4885
0000c0  8949              LDRH     r1,[r1,#0xa]          ;4885
0000c2  4288              CMP      r0,r1                 ;4885
0000c4  d903              BLS      |L24.206|
0000c6  9803              LDR      r0,[sp,#0xc]          ;4887
0000c8  8940              LDRH     r0,[r0,#0xa]          ;4887
0000ca  eba00809          SUB      r8,r0,r9              ;4887
                  |L24.206|
0000ce  9903              LDR      r1,[sp,#0xc]          ;4889
0000d0  7848              LDRB     r0,[r1,#1]            ;4889
0000d2  4643              MOV      r3,r8                 ;4889
0000d4  4632              MOV      r2,r6                 ;4889
0000d6  4659              MOV      r1,r11                ;4889
0000d8  f7fffffe          BL       disk_read
0000dc  b110              CBZ      r0,|L24.228|
0000de  2001              MOVS     r0,#1                 ;4890
0000e0  7460              STRB     r0,[r4,#0x11]         ;4890
0000e2  e7a3              B        |L24.44|
                  |L24.228|
0000e4  7c20              LDRB     r0,[r4,#0x10]         ;4899
0000e6  f0000080          AND      r0,r0,#0x80           ;4899
0000ea  b168              CBZ      r0,|L24.264|
0000ec  69e0              LDR      r0,[r4,#0x1c]         ;4899
0000ee  1b80              SUBS     r0,r0,r6              ;4899
0000f0  4540              CMP      r0,r8                 ;4899
0000f2  d209              BCS      |L24.264|
0000f4  69e1              LDR      r1,[r4,#0x1c]         ;4901
0000f6  1b89              SUBS     r1,r1,r6              ;4901
0000f8  eb0b2041          ADD      r0,r11,r1,LSL #9      ;4901
0000fc  f44f7200          MOV      r2,#0x200             ;4901
000100  f1040128          ADD      r1,r4,#0x28           ;4901
000104  f7fffffe          BL       mem_cpy
                  |L24.264|
000108  ea4f2748          LSL      r7,r8,#9              ;4905
00010c  e037              B        |L24.382|
                  |L24.270|
00010e  69e0              LDR      r0,[r4,#0x1c]         ;4909
000110  42b0              CMP      r0,r6                 ;4909
000112  d020              BEQ      |L24.342|
000114  7c20              LDRB     r0,[r4,#0x10]         ;4912
000116  f0000080          AND      r0,r0,#0x80           ;4912
00011a  b178              CBZ      r0,|L24.316|
00011c  69e2              LDR      r2,[r4,#0x1c]         ;4914
00011e  9903              LDR      r1,[sp,#0xc]          ;4914
000120  7848              LDRB     r0,[r1,#1]            ;4914
000122  2301              MOVS     r3,#1                 ;4914
000124  f1040128          ADD      r1,r4,#0x28           ;4914
000128  f7fffffe          BL       disk_write
00012c  b110              CBZ      r0,|L24.308|
00012e  2001              MOVS     r0,#1                 ;4915
000130  7460              STRB     r0,[r4,#0x11]         ;4915
000132  e77b              B        |L24.44|
                  |L24.308|
000134  7c20              LDRB     r0,[r4,#0x10]         ;4916
000136  f000007f          AND      r0,r0,#0x7f           ;4916
00013a  7420              STRB     r0,[r4,#0x10]         ;4916
                  |L24.316|
00013c  9903              LDR      r1,[sp,#0xc]          ;4919
00013e  7848              LDRB     r0,[r1,#1]            ;4919
000140  2301              MOVS     r3,#1                 ;4919
000142  4632              MOV      r2,r6                 ;4919
000144  f1040128          ADD      r1,r4,#0x28           ;4919
000148  f7fffffe          BL       disk_read
00014c  b118              CBZ      r0,|L24.342|
00014e  2001              MOVS     r0,#1                 ;4919
000150  7460              STRB     r0,[r4,#0x11]         ;4919
000152  e76b              B        |L24.44|
000154  e000              B        |L24.344|
                  |L24.342|
000156  61e6              STR      r6,[r4,#0x1c]         ;4922
                  |L24.344|
000158  8aa0              LDRH     r0,[r4,#0x14]         ;4924
00015a  f3c00008          UBFX     r0,r0,#0,#9           ;4924
00015e  f5c07700          RSB      r7,r0,#0x200          ;4924
000162  42af              CMP      r7,r5                 ;4925
000164  d900              BLS      |L24.360|
000166  462f              MOV      r7,r5                 ;4925
                  |L24.360|
000168  8aa0              LDRH     r0,[r4,#0x14]         ;4931
00016a  f3c00208          UBFX     r2,r0,#0,#9           ;4931
00016e  f1040028          ADD      r0,r4,#0x28           ;4931
000172  1811              ADDS     r1,r2,r0              ;4931
000174  463a              MOV      r2,r7                 ;4931
000176  4658              MOV      r0,r11                ;4931
000178  f7fffffe          BL       mem_cpy
00017c  bf00              NOP                            ;4906
                  |L24.382|
00017e  1bed              SUBS     r5,r5,r7              ;4848
000180  f8da0000          LDR      r0,[r10,#0]           ;4848
000184  4438              ADD      r0,r0,r7              ;4848
000186  f8ca0000          STR      r0,[r10,#0]           ;4848
00018a  44bb              ADD      r11,r11,r7            ;4848
00018c  6960              LDR      r0,[r4,#0x14]         ;4848
00018e  4438              ADD      r0,r0,r7              ;4848
000190  6160              STR      r0,[r4,#0x14]         ;4848
                  |L24.402|
000192  2d00              CMP      r5,#0                 ;4847
000194  f47faf5c          BNE      |L24.80|
000198  2000              MOVS     r0,#0                 ;4935
00019a  e747              B        |L24.44|
;;;4937   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;5850   *******************************************************************************/
;;;5851   FRESULT f_readdir (
000000  b5f8              PUSH     {r3-r7,lr}
;;;5852                   DIR*      dp,   /* Pointer to the open directory object */    //打开的目录对象结构体指针
;;;5853                   FILINFO*  fno   /* Pointer to file information to return */   //存储读取的文件信息结构指针
;;;5854   )
;;;5855   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;5856   	FRESULT   res;  //文件函数执行结果返回码
;;;5857   	FATFS     *fs;  //文件系统对象
;;;5858   	DEF_NAMBUF
;;;5859   
;;;5860     //==============================检查目录对象的有效性
;;;5861   	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
000006  4669              MOV      r1,sp
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       validate
00000e  4604              MOV      r4,r0
;;;5862   	if (res == FR_OK)
000010  b9dc              CBNZ     r4,|L25.74|
;;;5863     {
;;;5864       //==========================接收文件信息的缓存无效---------
;;;5865   		if (!fno)   
000012  b92d              CBNZ     r5,|L25.32|
;;;5866       {
;;;5867   			res = dir_sdi(dp, 0);			  /* Rewind the directory object */ //目录处理-设置目录索引--从0开始查找
000014  2100              MOVS     r1,#0
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       dir_sdi
00001c  4604              MOV      r4,r0
00001e  e014              B        |L25.74|
                  |L25.32|
;;;5868   		}
;;;5869       //==========================接收文件信息的缓存有效---------
;;;5870       else
;;;5871       {
;;;5872   			INIT_NAMBUF(fs);            //未知
;;;5873         //--------------------读取一个目录
;;;5874   			res = dir_read_file(dp);    /* Read an item */
000020  2100              MOVS     r1,#0
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       dir_read
000028  4604              MOV      r4,r0
;;;5875   			if (res == FR_NO_FILE)      /* Ignore end of directory */   //忽略目录的末尾
00002a  2c04              CMP      r4,#4
00002c  d100              BNE      |L25.48|
;;;5876           res = FR_OK;	
00002e  2400              MOVS     r4,#0
                  |L25.48|
;;;5877   			if (res == FR_OK)           /* A valid entry is found */    //找到有效的条目
000030  b95c              CBNZ     r4,|L25.74|
;;;5878         {	
;;;5879           //--------------------获取对象信息
;;;5880   				get_fileinfo(dp, fno);		/* Get the object information */  //从目录条目获取文件信息
000032  4629              MOV      r1,r5
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       get_fileinfo
;;;5881           //--------------------目录处理-下一步移动目录表索引
;;;5882   				res = dir_next(dp, 0);		/* Increment index for next */    //目录处理-下一步移动目录表索引  
00003a  2100              MOVS     r1,#0
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       dir_next
000042  4604              MOV      r4,r0
;;;5883   				if (res == FR_NO_FILE)    /* Ignore end of directory now */ //已到目录尾端 
000044  2c04              CMP      r4,#4
000046  d100              BNE      |L25.74|
;;;5884             res = FR_OK;	
000048  2400              MOVS     r4,#0
                  |L25.74|
;;;5885   			}
;;;5886   			FREE_NAMBUF();      //释放缓存  
;;;5887   		}
;;;5888   	}
;;;5889   	LEAVE_FF(fs, res);      //释放文件系统同步对象并将状态返回(return)。
00004a  4620              MOV      r0,r4
;;;5890   }
00004c  bdf8              POP      {r3-r7,pc}
;;;5891   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;6507   *******************************************************************************/
;;;6508   FRESULT f_rename (
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;6509   	const TCHAR* path_old,	/* Pointer to the object name to be renamed */    /* 原对象名的指针 */
;;;6510   	const TCHAR* path_new	  /* Pointer to the new name */                     /* 新对象名的指针 */
;;;6511   )
;;;6512   {
000002  b09f              SUB      sp,sp,#0x7c
;;;6513   	FRESULT res;        //文件函数执行结果返回码
;;;6514     FATFS   *fs;        //文件系统对象
;;;6515   	DIR     djo, djn;	
;;;6516   	BYTE    buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
;;;6517   	DWORD   dw;
;;;6518   	DEF_NAMBUF
;;;6519   
;;;6520   
;;;6521   	get_ldnumber(&path_new);						/* Snip the drive number of new name off */   //从路径名称获取逻辑驱动器号
000004  a820              ADD      r0,sp,#0x80
000006  f7fffffe          BL       get_ldnumber
;;;6522   	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
00000a  2202              MOVS     r2,#2
00000c  a91e              ADD      r1,sp,#0x78
00000e  a81f              ADD      r0,sp,#0x7c
000010  f7fffffe          BL       find_volume
000014  4604              MOV      r4,r0
;;;6523   	if (res == FR_OK) 
000016  2c00              CMP      r4,#0
000018  d17c              BNE      |L26.276|
;;;6524     {
;;;6525   		djo.obj.fs = fs;
00001a  981e              LDR      r0,[sp,#0x78]
00001c  9013              STR      r0,[sp,#0x4c]
;;;6526   		INIT_NAMBUF(fs);
;;;6527   		res = follow_path(&djo, path_old);		/* Check old object */    //该函数给定一个全路径，得到相应的目录对象。
00001e  a813              ADD      r0,sp,#0x4c
000020  991f              LDR      r1,[sp,#0x7c]
000022  f7fffffe          BL       follow_path
000026  4604              MOV      r4,r0
;;;6528   		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) /* Check validity of name */
000028  b92c              CBNZ     r4,|L26.54|
00002a  f89d0077          LDRB     r0,[sp,#0x77]
00002e  f00000a0          AND      r0,r0,#0xa0
000032  b100              CBZ      r0,|L26.54|
;;;6529         res = FR_INVALID_NAME;	
000034  2406              MOVS     r4,#6
                  |L26.54|
;;;6530   #if FF_FS_LOCK != 0
;;;6531   		if (res == FR_OK) 
;;;6532       {
;;;6533   			res = chk_lock(&djo, 2);
;;;6534   		}
;;;6535   #endif
;;;6536   		if (res == FR_OK) 		/* Object to be renamed is found */
000036  2c00              CMP      r4,#0
000038  d16c              BNE      |L26.276|
;;;6537       {				
;;;6538   #if FF_FS_EXFAT
;;;6539   			if (fs->fs_type == FS_EXFAT) /* At exFAT volume */
;;;6540         {	
;;;6541   				BYTE nf, nn;
;;;6542   				WORD nh;
;;;6543   
;;;6544   				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
;;;6545   				mem_cpy(&djn, &djo, sizeof djo);
;;;6546   				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */    //该函数给定一个全路径，得到相应的目录对象。
;;;6547   				if (res == FR_OK) 		/* Is new name already in use by any other object? */
;;;6548           {				
;;;6549   					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
;;;6550   				}
;;;6551   				if (res == FR_NO_FILE) 		/* It is a valid path and no name collision */
;;;6552           { 		
;;;6553   					res = dir_register(&djn);			/* Register the new entry */
;;;6554   					if (res == FR_OK) 
;;;6555             {
;;;6556   						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
;;;6557   						nh = ld_word(fs->dirbuf + XDIR_NameHash);
;;;6558   						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);	/* Restore 85+C0 entry */
;;;6559   						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
;;;6560   						st_word(fs->dirbuf + XDIR_NameHash, nh);
;;;6561   						if (!(fs->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
;;;6562   /* Start of critical section where an interruption can cause a cross-link */
;;;6563   						res = store_xdir(&djn);
;;;6564   					}
;;;6565   				}
;;;6566   			} else
;;;6567   #endif
;;;6568   			{	/* At FAT/FAT32 volume */
;;;6569   				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
00003a  2220              MOVS     r2,#0x20
00003c  4668              MOV      r0,sp
00003e  991a              LDR      r1,[sp,#0x68]
000040  f7fffffe          BL       mem_cpy
;;;6570   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
000044  222c              MOVS     r2,#0x2c
000046  a913              ADD      r1,sp,#0x4c
000048  a808              ADD      r0,sp,#0x20
00004a  f7fffffe          BL       mem_cpy
;;;6571   				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */    //该函数给定一个全路径，得到相应的目录对象。
00004e  a808              ADD      r0,sp,#0x20
000050  9920              LDR      r1,[sp,#0x80]
000052  f7fffffe          BL       follow_path
000056  4604              MOV      r4,r0
;;;6572   				if (res == FR_OK) 		/* Is new name already in use by any other object? */
000058  b95c              CBNZ     r4,|L26.114|
;;;6573           {				
;;;6574   					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
00005a  9915              LDR      r1,[sp,#0x54]
00005c  980a              LDR      r0,[sp,#0x28]
00005e  4288              CMP      r0,r1
000060  d105              BNE      |L26.110|
000062  9917              LDR      r1,[sp,#0x5c]
000064  980c              LDR      r0,[sp,#0x30]
000066  4288              CMP      r0,r1
000068  d101              BNE      |L26.110|
00006a  2004              MOVS     r0,#4
00006c  e000              B        |L26.112|
                  |L26.110|
00006e  2008              MOVS     r0,#8
                  |L26.112|
000070  4604              MOV      r4,r0
                  |L26.114|
;;;6575   				}
;;;6576   				if (res == FR_NO_FILE) /* It is a valid path and no name collision */
000072  2c04              CMP      r4,#4
000074  d144              BNE      |L26.256|
;;;6577           { 				
;;;6578   					res = dir_register(&djn);			/* Register the new entry */
000076  a808              ADD      r0,sp,#0x20
000078  f7fffffe          BL       dir_register
00007c  4604              MOV      r4,r0
;;;6579   					if (res == FR_OK) 
00007e  2c00              CMP      r4,#0
000080  d13e              BNE      |L26.256|
;;;6580             {
;;;6581   						dir = djn.dir;					/* Copy directory entry of the object except name */
000082  9d0f              LDR      r5,[sp,#0x3c]
;;;6582   						mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
000084  2213              MOVS     r2,#0x13
000086  f10d010d          ADD      r1,sp,#0xd
00008a  f105000d          ADD      r0,r5,#0xd
00008e  f7fffffe          BL       mem_cpy
;;;6583   						dir[DIR_Attr] = buf[DIR_Attr];
000092  f89d000b          LDRB     r0,[sp,#0xb]
000096  72e8              STRB     r0,[r5,#0xb]
;;;6584   						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
000098  7ae8              LDRB     r0,[r5,#0xb]
00009a  f0000010          AND      r0,r0,#0x10
00009e  b918              CBNZ     r0,|L26.168|
0000a0  7ae8              LDRB     r0,[r5,#0xb]
0000a2  f0400020          ORR      r0,r0,#0x20
0000a6  72e8              STRB     r0,[r5,#0xb]
                  |L26.168|
;;;6585   						fs->wflag = 1;
0000a8  2001              MOVS     r0,#1
0000aa  991e              LDR      r1,[sp,#0x78]
0000ac  70c8              STRB     r0,[r1,#3]
;;;6586   						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) /* Update .. entry in the sub-directory if needed */
0000ae  7ae8              LDRB     r0,[r5,#0xb]
0000b0  f0000010          AND      r0,r0,#0x10
0000b4  b320              CBZ      r0,|L26.256|
0000b6  990a              LDR      r1,[sp,#0x28]
0000b8  9815              LDR      r0,[sp,#0x54]
0000ba  4288              CMP      r0,r1
0000bc  d020              BEQ      |L26.256|
;;;6587               {	
;;;6588   							dw = clst2sect(fs, ld_clust(fs, dir));
0000be  4629              MOV      r1,r5
0000c0  981e              LDR      r0,[sp,#0x78]
0000c2  f7fffffe          BL       ld_clust
0000c6  4607              MOV      r7,r0
0000c8  4639              MOV      r1,r7
0000ca  981e              LDR      r0,[sp,#0x78]
0000cc  f7fffffe          BL       clst2sect
0000d0  4606              MOV      r6,r0
;;;6589   							if (dw == 0) 
0000d2  b90e              CBNZ     r6,|L26.216|
;;;6590                 {
;;;6591   								res = FR_INT_ERR;
0000d4  2402              MOVS     r4,#2
0000d6  e013              B        |L26.256|
                  |L26.216|
;;;6592   							} 
;;;6593                 else 
;;;6594                {
;;;6595   /* Start of critical section where an interruption can cause a cross-link */
;;;6596   								res = move_window(fs, dw);
0000d8  4631              MOV      r1,r6
0000da  981e              LDR      r0,[sp,#0x78]
0000dc  f7fffffe          BL       move_window
0000e0  4604              MOV      r4,r0
;;;6597   								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
0000e2  981e              LDR      r0,[sp,#0x78]
0000e4  f1000550          ADD      r5,r0,#0x50
;;;6598   								if (res == FR_OK && dir[1] == '.') 
0000e8  b954              CBNZ     r4,|L26.256|
0000ea  7868              LDRB     r0,[r5,#1]
0000ec  282e              CMP      r0,#0x2e
0000ee  d107              BNE      |L26.256|
;;;6599                   {
;;;6600   									st_clust(fs, dir, djn.obj.sclust);
0000f0  4629              MOV      r1,r5
0000f2  9a0a              LDR      r2,[sp,#0x28]
0000f4  981e              LDR      r0,[sp,#0x78]
0000f6  f7fffffe          BL       st_clust
;;;6601   									fs->wflag = 1;
0000fa  2001              MOVS     r0,#1
0000fc  991e              LDR      r1,[sp,#0x78]
0000fe  70c8              STRB     r0,[r1,#3]
                  |L26.256|
;;;6602   								}
;;;6603   							}
;;;6604   						}
;;;6605   					}
;;;6606   				}
;;;6607   			}
;;;6608   			if (res == FR_OK) 
000100  b944              CBNZ     r4,|L26.276|
;;;6609         {
;;;6610   				res = dir_remove(&djo);		/* Remove old entry */
000102  a813              ADD      r0,sp,#0x4c
000104  f7fffffe          BL       dir_remove
000108  4604              MOV      r4,r0
;;;6611   				if (res == FR_OK) 
00010a  b91c              CBNZ     r4,|L26.276|
;;;6612           {
;;;6613   					res = sync_fs(fs);
00010c  981e              LDR      r0,[sp,#0x78]
00010e  f7fffffe          BL       sync_fs
000112  4604              MOV      r4,r0
                  |L26.276|
;;;6614   				}
;;;6615   			}
;;;6616   /* End of the critical section */
;;;6617   		}
;;;6618   		FREE_NAMBUF();
;;;6619   	}
;;;6620   
;;;6621   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
000114  4620              MOV      r0,r4
;;;6622   }
000116  b021              ADD      sp,sp,#0x84
000118  bdf0              POP      {r4-r7,pc}
;;;6623   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;5991   *******************************************************************************/
;;;5992   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;5993   	const TCHAR* path,	/* Pointer to the file path */                /* 文件名或目录名的指针 */
;;;5994   	FILINFO* fno		    /* Pointer to file information to return */   /* FILINFO结构的指针 */
;;;5995   )
;;;5996   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;5997   	FRESULT res;  //文件函数执行结果返回码
;;;5998   	DIR     dj;
;;;5999   	DEF_NAMBUF
;;;6000   
;;;6001   
;;;6002   	/* Get logical drive */
;;;6003   	res = find_volume(&path, &dj.obj.fs, 0);
000006  2200              MOVS     r2,#0
000008  4669              MOV      r1,sp
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       find_volume
000010  4604              MOV      r4,r0
;;;6004   	if (res == FR_OK) 
000012  b98c              CBNZ     r4,|L27.56|
;;;6005      {
;;;6006   		INIT_NAMBUF(dj.obj.fs);
;;;6007   		res = follow_path(&dj, path);	/* Follow the file path */    //该函数给定一个全路径，得到相应的目录对象。
000014  4668              MOV      r0,sp
000016  990b              LDR      r1,[sp,#0x2c]
000018  f7fffffe          BL       follow_path
00001c  4604              MOV      r4,r0
;;;6008   		if (res == FR_OK) 		/* Follow completed */
00001e  b95c              CBNZ     r4,|L27.56|
;;;6009       {		
;;;6010   			if (dj.fn[NSFLAG] & NS_NONAME) /* It is origin directory */
000020  f89d002b          LDRB     r0,[sp,#0x2b]
000024  f0000080          AND      r0,r0,#0x80
000028  b108              CBZ      r0,|L27.46|
;;;6011         {	
;;;6012   				res = FR_INVALID_NAME;
00002a  2406              MOVS     r4,#6
00002c  e004              B        |L27.56|
                  |L27.46|
;;;6013   			} 
;;;6014         else 
;;;6015         {							/* Found an object */
;;;6016   				if (fno) 
00002e  b11d              CBZ      r5,|L27.56|
;;;6017             get_fileinfo(&dj, fno);   //从目录条目获取文件信息
000030  4629              MOV      r1,r5
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       get_fileinfo
                  |L27.56|
;;;6018   			}
;;;6019   		}
;;;6020   		FREE_NAMBUF();
;;;6021   	}
;;;6022   
;;;6023   	LEAVE_FF(dj.obj.fs, res);   //释放文件系统同步对象并将状态返回(return)。
000038  4620              MOV      r0,r4
;;;6024   }
00003a  b00d              ADD      sp,sp,#0x34
00003c  bd30              POP      {r4,r5,pc}
;;;6025   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=2

                  f_sync PROC
;;;5113   *******************************************************************************/
;;;5114   FRESULT f_sync (
000000  b5f8              PUSH     {r3-r7,lr}
;;;5115   	FIL* fp		/* Pointer to the file object */
;;;5116   )
;;;5117   {
000002  4604              MOV      r4,r0
;;;5118   	FRESULT res;    //文件函数执行结果返回码
;;;5119   	FATFS   *fs;    //文件系统对象
;;;5120   	DWORD   tm;
;;;5121   	BYTE    *dir;
;;;5122   
;;;5123   
;;;5124   	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4606              MOV      r6,r0
;;;5125   	if (res == FR_OK) 
00000e  2e00              CMP      r6,#0
000010  d142              BNE      |L28.152|
;;;5126     {
;;;5127   		if (fp->flag & FA_MODIFIED) /* Is there any change to the file? */
000012  7c20              LDRB     r0,[r4,#0x10]
000014  f0000040          AND      r0,r0,#0x40
000018  2800              CMP      r0,#0
00001a  d03d              BEQ      |L28.152|
;;;5128       {	
;;;5129   #if !FF_FS_TINY
;;;5130   			if (fp->flag & FA_DIRTY) /* Write-back cached data if needed */
00001c  7c20              LDRB     r0,[r4,#0x10]
00001e  f0000080          AND      r0,r0,#0x80
000022  b170              CBZ      r0,|L28.66|
;;;5131         {	
;;;5132   				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK)
000024  69e2              LDR      r2,[r4,#0x1c]
000026  9900              LDR      r1,[sp,#0]
000028  7848              LDRB     r0,[r1,#1]
00002a  2301              MOVS     r3,#1
00002c  f1040128          ADD      r1,r4,#0x28
000030  f7fffffe          BL       disk_write
000034  b108              CBZ      r0,|L28.58|
;;;5133             LEAVE_FF(fs, FR_DISK_ERR);    //释放文件系统同步对象并将状态返回(return)。
000036  2001              MOVS     r0,#1
                  |L28.56|
;;;5134   				fp->flag &= (BYTE)~FA_DIRTY;
;;;5135   			}
;;;5136   #endif
;;;5137   			/* Update the directory entry */
;;;5138   			tm = GET_FATTIME();				/* Modified time */
;;;5139   #if FF_FS_EXFAT
;;;5140   			if (fs->fs_type == FS_EXFAT) 
;;;5141         {
;;;5142   				res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
;;;5143   				if (res == FR_OK) 
;;;5144           {
;;;5145   					res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
;;;5146   				}
;;;5147   				if (res == FR_OK) 
;;;5148           {
;;;5149   					DIR dj;
;;;5150   					DEF_NAMBUF
;;;5151   
;;;5152   					INIT_NAMBUF(fs);
;;;5153   					res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
;;;5154   					if (res == FR_OK) 
;;;5155             {
;;;5156   						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has been changed */
;;;5157   						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
;;;5158   						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
;;;5159   						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
;;;5160   						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
;;;5161   						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
;;;5162   						fs->dirbuf[XDIR_ModTime10] = 0;
;;;5163   						st_dword(fs->dirbuf + XDIR_AccTime, 0);
;;;5164   						res = store_xdir(&dj);	/* Restore it to the directory */
;;;5165   						if (res == FR_OK) 
;;;5166               {
;;;5167   							res = sync_fs(fs);
;;;5168   							fp->flag &= (BYTE)~FA_MODIFIED;
;;;5169   						}
;;;5170   					}
;;;5171   					FREE_NAMBUF();
;;;5172   				}
;;;5173   			} else
;;;5174   #endif
;;;5175   			{
;;;5176   				res = move_window(fs, fp->dir_sect);
;;;5177   				if (res == FR_OK) 
;;;5178           {
;;;5179   					dir = fp->dir_ptr;
;;;5180   					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
;;;5181   					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
;;;5182   					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
;;;5183   					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
;;;5184   					st_word(dir + DIR_LstAccDate, 0);
;;;5185   					fs->wflag = 1;
;;;5186   					res = sync_fs(fs);					/* Restore it to the directory */
;;;5187   					fp->flag &= (BYTE)~FA_MODIFIED;
;;;5188   				}
;;;5189   			}
;;;5190   		}
;;;5191   	}
;;;5192   
;;;5193   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
;;;5194   }
000038  bdf8              POP      {r3-r7,pc}
                  |L28.58|
00003a  7c20              LDRB     r0,[r4,#0x10]         ;5134
00003c  f000007f          AND      r0,r0,#0x7f           ;5134
000040  7420              STRB     r0,[r4,#0x10]         ;5134
                  |L28.66|
000042  4f16              LDR      r7,|L28.156|
000044  6a21              LDR      r1,[r4,#0x20]         ;5176
000046  9800              LDR      r0,[sp,#0]            ;5176
000048  f7fffffe          BL       move_window
00004c  4606              MOV      r6,r0                 ;5176
00004e  bb1e              CBNZ     r6,|L28.152|
000050  6a65              LDR      r5,[r4,#0x24]         ;5179
000052  7ae8              LDRB     r0,[r5,#0xb]          ;5180
000054  f0400020          ORR      r0,r0,#0x20           ;5180
000058  72e8              STRB     r0,[r5,#0xb]          ;5180
00005a  4629              MOV      r1,r5                 ;5181
00005c  68a2              LDR      r2,[r4,#8]            ;5181
00005e  6820              LDR      r0,[r4,#0]            ;5181
000060  f7fffffe          BL       st_clust
000064  f105001c          ADD      r0,r5,#0x1c           ;5182
000068  68e1              LDR      r1,[r4,#0xc]          ;5182
00006a  f7fffffe          BL       st_dword
00006e  4639              MOV      r1,r7                 ;5183
000070  f1050016          ADD      r0,r5,#0x16           ;5183
000074  f7fffffe          BL       st_dword
000078  2100              MOVS     r1,#0                 ;5184
00007a  f1050012          ADD      r0,r5,#0x12           ;5184
00007e  f7fffffe          BL       st_word
000082  2001              MOVS     r0,#1                 ;5185
000084  9900              LDR      r1,[sp,#0]            ;5185
000086  70c8              STRB     r0,[r1,#3]            ;5185
000088  9800              LDR      r0,[sp,#0]            ;5186
00008a  f7fffffe          BL       sync_fs
00008e  4606              MOV      r6,r0                 ;5186
000090  7c20              LDRB     r0,[r4,#0x10]         ;5187
000092  f00000bf          AND      r0,r0,#0xbf           ;5187
000096  7420              STRB     r0,[r4,#0x10]         ;5187
                  |L28.152|
000098  4630              MOV      r0,r6                 ;5193
00009a  e7cd              B        |L28.56|
;;;5195   
                          ENDP

                  |L28.156|
                          DCD      0x4c210000

                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;6178   *******************************************************************************/
;;;6179   FRESULT f_truncate (
000000  b5f8              PUSH     {r3-r7,lr}
;;;6180           FIL* fp		/* Pointer to the file object */
;;;6181   )
;;;6182   {
000002  4604              MOV      r4,r0
;;;6183   	FRESULT res;  //文件函数执行结果返回码
;;;6184   	FATFS   *fs;  //文件系统对象
;;;6185   	DWORD   ncl; 
;;;6186   
;;;6187   
;;;6188   	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4605              MOV      r5,r0
;;;6189   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK)
00000e  b915              CBNZ     r5,|L29.22|
000010  7c60              LDRB     r0,[r4,#0x11]
000012  1e05              SUBS     r5,r0,#0
000014  d001              BEQ      |L29.26|
                  |L29.22|
;;;6190       LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
000016  4628              MOV      r0,r5
                  |L29.24|
;;;6191   	if (!(fp->flag & FA_WRITE)) 	/* Check access mode */
;;;6192       LEAVE_FF(fs, FR_DENIED);
;;;6193   
;;;6194   	if (fp->fptr < fp->obj.objsize) /* Process when fptr is not on the eof */
;;;6195     {	
;;;6196   		if (fp->fptr == 0) /* When set file size to zero, remove entire cluster chain */
;;;6197       {	
;;;6198   			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
;;;6199   			fp->obj.sclust = 0;
;;;6200   		} 
;;;6201       else 		/* When truncate a part of the file, remove remaining clusters */
;;;6202       {		
;;;6203   			ncl = get_fat(&fp->obj, fp->clust);
;;;6204   			res = FR_OK;
;;;6205   			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;6206   			if (ncl == 1) res = FR_INT_ERR;
;;;6207   			if (res == FR_OK && ncl < fs->n_fatent) 
;;;6208         {
;;;6209   				res = remove_chain(&fp->obj, ncl, fp->clust);
;;;6210   			}
;;;6211   		}
;;;6212   		fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
;;;6213   		fp->flag |= FA_MODIFIED;
;;;6214   #if !FF_FS_TINY
;;;6215   		if (res == FR_OK && (fp->flag & FA_DIRTY)) 
;;;6216       {
;;;6217   			if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) 
;;;6218         {
;;;6219   				res = FR_DISK_ERR;
;;;6220   			} 
;;;6221         else 
;;;6222         {
;;;6223   				fp->flag &= (BYTE)~FA_DIRTY;
;;;6224   			}
;;;6225   		}
;;;6226   #endif
;;;6227   		if (res != FR_OK) ABORT(fs, res);
;;;6228   	}
;;;6229   
;;;6230   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
;;;6231   }
000018  bdf8              POP      {r3-r7,pc}
                  |L29.26|
00001a  7c20              LDRB     r0,[r4,#0x10]         ;6191
00001c  f0000002          AND      r0,r0,#2              ;6191
000020  b908              CBNZ     r0,|L29.38|
000022  2007              MOVS     r0,#7                 ;6192
000024  e7f8              B        |L29.24|
                  |L29.38|
000026  68e1              LDR      r1,[r4,#0xc]          ;6194
000028  6960              LDR      r0,[r4,#0x14]         ;6194
00002a  4288              CMP      r0,r1                 ;6194
00002c  d23f              BCS      |L29.174|
00002e  6960              LDR      r0,[r4,#0x14]         ;6196
000030  b940              CBNZ     r0,|L29.68|
000032  2200              MOVS     r2,#0                 ;6198
000034  4620              MOV      r0,r4                 ;6198
000036  68a1              LDR      r1,[r4,#8]            ;6198
000038  f7fffffe          BL       remove_chain
00003c  4605              MOV      r5,r0                 ;6198
00003e  2000              MOVS     r0,#0                 ;6199
000040  60a0              STR      r0,[r4,#8]            ;6199
000042  e016              B        |L29.114|
                  |L29.68|
000044  4620              MOV      r0,r4                 ;6203
000046  69a1              LDR      r1,[r4,#0x18]         ;6203
000048  f7fffffe          BL       get_fat
00004c  4606              MOV      r6,r0                 ;6203
00004e  2500              MOVS     r5,#0                 ;6204
000050  1c70              ADDS     r0,r6,#1              ;6205
000052  b900              CBNZ     r0,|L29.86|
000054  2501              MOVS     r5,#1                 ;6205
                  |L29.86|
000056  2e01              CMP      r6,#1                 ;6206
000058  d100              BNE      |L29.92|
00005a  2502              MOVS     r5,#2                 ;6206
                  |L29.92|
00005c  b94d              CBNZ     r5,|L29.114|
00005e  9800              LDR      r0,[sp,#0]            ;6207
000060  6940              LDR      r0,[r0,#0x14]         ;6207
000062  42b0              CMP      r0,r6                 ;6207
000064  d905              BLS      |L29.114|
000066  4631              MOV      r1,r6                 ;6209
000068  4620              MOV      r0,r4                 ;6209
00006a  69a2              LDR      r2,[r4,#0x18]         ;6209
00006c  f7fffffe          BL       remove_chain
000070  4605              MOV      r5,r0                 ;6209
                  |L29.114|
000072  6960              LDR      r0,[r4,#0x14]         ;6212
000074  60e0              STR      r0,[r4,#0xc]          ;6212
000076  7c20              LDRB     r0,[r4,#0x10]         ;6213
000078  f0400040          ORR      r0,r0,#0x40           ;6213
00007c  7420              STRB     r0,[r4,#0x10]         ;6213
00007e  b995              CBNZ     r5,|L29.166|
000080  7c20              LDRB     r0,[r4,#0x10]         ;6215
000082  f0000080          AND      r0,r0,#0x80           ;6215
000086  b170              CBZ      r0,|L29.166|
000088  69e2              LDR      r2,[r4,#0x1c]         ;6217
00008a  9900              LDR      r1,[sp,#0]            ;6217
00008c  7848              LDRB     r0,[r1,#1]            ;6217
00008e  2301              MOVS     r3,#1                 ;6217
000090  f1040128          ADD      r1,r4,#0x28           ;6217
000094  f7fffffe          BL       disk_write
000098  b108              CBZ      r0,|L29.158|
00009a  2501              MOVS     r5,#1                 ;6219
00009c  e003              B        |L29.166|
                  |L29.158|
00009e  7c20              LDRB     r0,[r4,#0x10]         ;6223
0000a0  f000007f          AND      r0,r0,#0x7f           ;6223
0000a4  7420              STRB     r0,[r4,#0x10]         ;6223
                  |L29.166|
0000a6  b115              CBZ      r5,|L29.174|
0000a8  7465              STRB     r5,[r4,#0x11]         ;6227
0000aa  4628              MOV      r0,r5                 ;6227
0000ac  e7b4              B        |L29.24|
                  |L29.174|
0000ae  4628              MOV      r0,r5                 ;6230
0000b0  e7b2              B        |L29.24|
;;;6232   /*-----------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;6257   *******************************************************************************/
;;;6258   FRESULT f_unlink (
000000  b531              PUSH     {r0,r4,r5,lr}
;;;6259             const TCHAR* path		/* Pointer to the file or directory path */ /* 对象名的指针 */
;;;6260   )
;;;6261   {
000002  b098              SUB      sp,sp,#0x60
;;;6262   	FRESULT res;        //文件函数执行结果返回码
;;;6263   	DIR     dj, sdj;
;;;6264   	DWORD   dclst = 0;
000004  2500              MOVS     r5,#0
;;;6265   	FATFS   *fs;        //文件系统对象
;;;6266   #if FF_FS_EXFAT
;;;6267   	FFOBJID obj;
;;;6268   #endif
;;;6269   	DEF_NAMBUF
;;;6270   
;;;6271   
;;;6272   	/* Get logical drive */
;;;6273   	res = find_volume(&path, &fs, FA_WRITE);
000006  2202              MOVS     r2,#2
000008  a901              ADD      r1,sp,#4
00000a  a818              ADD      r0,sp,#0x60
00000c  f7fffffe          BL       find_volume
000010  4604              MOV      r4,r0
;;;6274   	if (res == FR_OK) {
000012  2c00              CMP      r4,#0
000014  d146              BNE      |L30.164|
;;;6275   		dj.obj.fs = fs;
000016  9801              LDR      r0,[sp,#4]
000018  900d              STR      r0,[sp,#0x34]
;;;6276   		INIT_NAMBUF(fs);
;;;6277   		res = follow_path(&dj, path);		/* Follow the file path */  //该函数给定一个全路径，得到相应的目录对象。
00001a  a80d              ADD      r0,sp,#0x34
00001c  9918              LDR      r1,[sp,#0x60]
00001e  f7fffffe          BL       follow_path
000022  4604              MOV      r4,r0
;;;6278   		if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
000024  bf00              NOP      
;;;6279       {
;;;6280   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;6281   		}
;;;6282   #if FF_FS_LOCK != 0
;;;6283   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
;;;6284   #endif
;;;6285   		if (res == FR_OK) 		/* The object is accessible */
000026  2c00              CMP      r4,#0
000028  d13c              BNE      |L30.164|
;;;6286       {			
;;;6287   			if (dj.fn[NSFLAG] & NS_NONAME) 
00002a  f89d005f          LDRB     r0,[sp,#0x5f]
00002e  f0000080          AND      r0,r0,#0x80
000032  b108              CBZ      r0,|L30.56|
;;;6288         {
;;;6289   				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
000034  2406              MOVS     r4,#6
000036  e005              B        |L30.68|
                  |L30.56|
;;;6290   			} 
;;;6291         else 
;;;6292         {
;;;6293   				if (dj.obj.attr & AM_RDO) 
000038  f89d003a          LDRB     r0,[sp,#0x3a]
00003c  f0000001          AND      r0,r0,#1
000040  b100              CBZ      r0,|L30.68|
;;;6294           {
;;;6295   					res = FR_DENIED;		/* Cannot remove R/O object */
000042  2407              MOVS     r4,#7
                  |L30.68|
;;;6296   				}
;;;6297   			}
;;;6298   			if (res == FR_OK) 
000044  b9e4              CBNZ     r4,|L30.128|
;;;6299         {
;;;6300   #if FF_FS_EXFAT
;;;6301   				obj.fs = fs;
;;;6302   				if (fs->fs_type == FS_EXFAT) 
;;;6303           {
;;;6304   					init_alloc_info(fs, &obj);
;;;6305   					dclst = obj.sclust;
;;;6306   				} 
;;;6307           else
;;;6308   #endif
;;;6309   				{
;;;6310   					dclst = ld_clust(fs, dj.dir);
000046  9914              LDR      r1,[sp,#0x50]
000048  9801              LDR      r0,[sp,#4]
00004a  f7fffffe          BL       ld_clust
00004e  4605              MOV      r5,r0
;;;6311   				}
;;;6312   				if (dj.obj.attr & AM_DIR) 		/* Is it a sub-directory? */
000050  f89d003a          LDRB     r0,[sp,#0x3a]
000054  f0000010          AND      r0,r0,#0x10
000058  b190              CBZ      r0,|L30.128|
;;;6313           {	
;;;6314   #if FF_FS_RPATH != 0
;;;6315   					if (dclst == fs->cdir) 	 	  /* Is it the current directory? */
;;;6316             {	
;;;6317   						res = FR_DENIED;
;;;6318   					} 
;;;6319             else
;;;6320   #endif
;;;6321   					{
;;;6322   						sdj.obj.fs = fs;				/* Open the sub-directory */
00005a  9801              LDR      r0,[sp,#4]
00005c  9002              STR      r0,[sp,#8]
;;;6323   						sdj.obj.sclust = dclst;
00005e  9504              STR      r5,[sp,#0x10]
;;;6324   #if FF_FS_EXFAT
;;;6325   						if (fs->fs_type == FS_EXFAT) 
;;;6326               {
;;;6327   							sdj.obj.objsize = obj.objsize;
;;;6328   							sdj.obj.stat = obj.stat;
;;;6329   						}
;;;6330   #endif
;;;6331   						res = dir_sdi(&sdj, 0);   //目录处理-设置目录索引--从0开始查找
000060  2100              MOVS     r1,#0
000062  a802              ADD      r0,sp,#8
000064  f7fffffe          BL       dir_sdi
000068  4604              MOV      r4,r0
;;;6332   						if (res == FR_OK) 
00006a  b94c              CBNZ     r4,|L30.128|
;;;6333               {
;;;6334   							res = dir_read_file(&sdj);			/* Test if the directory is empty */
00006c  2100              MOVS     r1,#0
00006e  a802              ADD      r0,sp,#8
000070  f7fffffe          BL       dir_read
000074  4604              MOV      r4,r0
;;;6335   							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
000076  b904              CBNZ     r4,|L30.122|
000078  2407              MOVS     r4,#7
                  |L30.122|
;;;6336   							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
00007a  2c04              CMP      r4,#4
00007c  d100              BNE      |L30.128|
00007e  2400              MOVS     r4,#0
                  |L30.128|
;;;6337   						}
;;;6338   					}
;;;6339   				}
;;;6340   			}
;;;6341   			if (res == FR_OK) 
000080  b984              CBNZ     r4,|L30.164|
;;;6342         {
;;;6343   				res = dir_remove(&dj);			    /* Remove the directory entry */
000082  a80d              ADD      r0,sp,#0x34
000084  f7fffffe          BL       dir_remove
000088  4604              MOV      r4,r0
;;;6344   				if (res == FR_OK && dclst != 0) /* Remove the cluster chain if exist */
00008a  b934              CBNZ     r4,|L30.154|
00008c  b12d              CBZ      r5,|L30.154|
;;;6345           {	
;;;6346   #if FF_FS_EXFAT
;;;6347   					res = remove_chain(&obj, dclst, 0);
;;;6348   #else
;;;6349   					res = remove_chain(&dj.obj, dclst, 0);
00008e  2200              MOVS     r2,#0
000090  4629              MOV      r1,r5
000092  a80d              ADD      r0,sp,#0x34
000094  f7fffffe          BL       remove_chain
000098  4604              MOV      r4,r0
                  |L30.154|
;;;6350   #endif
;;;6351   				}
;;;6352   				if (res == FR_OK) res = sync_fs(fs);
00009a  b91c              CBNZ     r4,|L30.164|
00009c  9801              LDR      r0,[sp,#4]
00009e  f7fffffe          BL       sync_fs
0000a2  4604              MOV      r4,r0
                  |L30.164|
;;;6353   			}
;;;6354   		}
;;;6355   		FREE_NAMBUF();
;;;6356   	}
;;;6357   
;;;6358   	LEAVE_FF(fs, res);    //释放文件系统同步对象并将状态返回(return)。
0000a4  4620              MOV      r0,r4
;;;6359   }
0000a6  b019              ADD      sp,sp,#0x64
0000a8  bd30              POP      {r4,r5,pc}
;;;6360   /*-----------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;4957   *******************************************************************************/
;;;4958   FRESULT f_write (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;4959                 FIL* fp,			    /* Pointer to the file object */          //文件对象结构体指针
;;;4960                 const void* buff,	/* Pointer to the data to be written */   //写入数据缓冲区指针
;;;4961                 UINT btw,			    /* Number of bytes to write */            //需要写入的字节数
;;;4962                 UINT* bw			    /* Pointer to number of bytes written */  //已完成写入的字节数变量指针
;;;4963   )
;;;4964   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  469b              MOV      r11,r3
;;;4965   	FRESULT res;            //文件函数执行结果返回码
;;;4966   	FATFS   *fs;            //文件系统对象
;;;4967   	DWORD   clst, sect;
;;;4968   	UINT    wcnt, cc, csect;
;;;4969   	const BYTE *wbuff = (const BYTE*)buff;
00000c  9804              LDR      r0,[sp,#0x10]
00000e  9000              STR      r0,[sp,#0]
;;;4970   
;;;4971   
;;;4972   	*bw = 0;	/* Clear write byte counter */
000010  2000              MOVS     r0,#0
000012  f8cb0000          STR      r0,[r11,#0]
;;;4973   	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
000016  a901              ADD      r1,sp,#4
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       validate
00001e  9002              STR      r0,[sp,#8]
;;;4974   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK)  /* Check validity */
000020  9802              LDR      r0,[sp,#8]
000022  b910              CBNZ     r0,|L31.42|
000024  7c60              LDRB     r0,[r4,#0x11]
000026  9002              STR      r0,[sp,#8]
000028  b118              CBZ      r0,|L31.50|
                  |L31.42|
;;;4975       LEAVE_FF(fs, res);	//释放文件系统同步对象并将状态返回(return)。
00002a  9802              LDR      r0,[sp,#8]
                  |L31.44|
;;;4976   	if (!(fp->flag & FA_WRITE)) /* Check access mode */
;;;4977       LEAVE_FF(fs, FR_DENIED);	//释放文件系统同步对象并将状态返回(return)。
;;;4978   
;;;4979   	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
;;;4980   	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) 
;;;4981     {
;;;4982   		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
;;;4983   	}
;;;4984   
;;;4985   	for ( ;  btw;							/* Repeat until all data written */
;;;4986   		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) 
;;;4987     {
;;;4988   		if (fp->fptr % SS(fs) == 0) 		/* On the sector boundary? */
;;;4989       {
;;;4990   			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
;;;4991   			if (csect == 0) 		/* On the cluster boundary? */
;;;4992         {		
;;;4993   				if (fp->fptr == 0) 		/* On the top of the file? */
;;;4994           {
;;;4995   					clst = fp->obj.sclust;	/* Follow from the origin */
;;;4996   					if (clst == 0) 		/* If no cluster is allocated, */
;;;4997             {
;;;4998   						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
;;;4999   					}
;;;5000   				} 
;;;5001           else 
;;;5002           {					/* On the middle or end of the file */
;;;5003   #if FF_USE_FASTSEEK
;;;5004   					if (fp->cltbl) 
;;;5005             {
;;;5006   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;5007   					} 
;;;5008             else
;;;5009   #endif
;;;5010   					{
;;;5011   						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;5012   					}
;;;5013   				}
;;;5014   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;5015   				if (clst == 1) 
;;;5016             ABORT(fs, FR_INT_ERR);
;;;5017   				if (clst == 0xFFFFFFFF) 
;;;5018             ABORT(fs, FR_DISK_ERR);
;;;5019   				fp->clust = clst;			/* Update current cluster */
;;;5020   				if (fp->obj.sclust == 0) 
;;;5021             fp->obj.sclust = clst;	/* Set start cluster if the first write */
;;;5022   			}
;;;5023   #if FF_FS_TINY
;;;5024   			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) 
;;;5025           ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
;;;5026   #else
;;;5027   			if (fp->flag & FA_DIRTY) 		/* Write-back sector cache */
;;;5028         {
;;;5029   				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;5030   				fp->flag &= (BYTE)~FA_DIRTY;
;;;5031   			}
;;;5032   #endif
;;;5033   			sect = clst2sect(fs, fp->clust);	/* Get current sector */
;;;5034   			if (sect == 0) 
;;;5035           ABORT(fs, FR_INT_ERR);
;;;5036   			sect += csect;
;;;5037   			cc = btw / SS(fs);	  /* When remaining bytes >= sector size, */
;;;5038   			if (cc > 0) 			    /* Write maximum contiguous sectors directly */
;;;5039         {		
;;;5040   				if (csect + cc > fs->csize) /* Clip at cluster boundary */
;;;5041           {	
;;;5042   					cc = fs->csize - csect;
;;;5043   				}
;;;5044   				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) 
;;;5045             ABORT(fs, FR_DISK_ERR);
;;;5046   #if FF_FS_MINIMIZE <= 2
;;;5047   #if FF_FS_TINY
;;;5048   				if (fs->winsect - sect < cc) /* Refill sector cache if it gets invalidated by the direct write */
;;;5049           {	
;;;5050   					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
;;;5051   					fs->wflag = 0;
;;;5052   				}
;;;5053   #else
;;;5054   				if (fp->sect - sect < cc) /* Refill sector cache if it gets invalidated by the direct write */
;;;5055           { 
;;;5056   					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
;;;5057   					fp->flag &= (BYTE)~FA_DIRTY;
;;;5058   				}
;;;5059   #endif
;;;5060   #endif
;;;5061   				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
;;;5062   				continue;
;;;5063   			}
;;;5064   #if FF_FS_TINY
;;;5065   			if (fp->fptr >= fp->obj.objsize) /* Avoid silly cache filling on the growing edge */
;;;5066         {	
;;;5067   				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
;;;5068   				fs->winsect = sect;
;;;5069   			}
;;;5070   #else
;;;5071   			if (fp->sect != sect && 		/* Fill sector cache with file data */
;;;5072   				fp->fptr < fp->obj.objsize &&
;;;5073   				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) 
;;;5074         {
;;;5075   					ABORT(fs, FR_DISK_ERR);
;;;5076   			}
;;;5077   #endif
;;;5078   			fp->sect = sect;
;;;5079   		}
;;;5080   		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
;;;5081   		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
;;;5082   #if FF_FS_TINY
;;;5083   		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
;;;5084   		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
;;;5085   		fs->wflag = 1;
;;;5086   #else
;;;5087   		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
;;;5088   		fp->flag |= FA_DIRTY;
;;;5089   #endif
;;;5090   	}
;;;5091   
;;;5092   	fp->flag |= FA_MODIFIED;				/* Set file change flag */
;;;5093   
;;;5094   	LEAVE_FF(fs, FR_OK);    //释放文件系统同步对象并将状态返回(return)。
;;;5095   }
00002c  b007              ADD      sp,sp,#0x1c
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L31.50|
000032  7c20              LDRB     r0,[r4,#0x10]         ;4976
000034  f0000002          AND      r0,r0,#2              ;4976
000038  b908              CBNZ     r0,|L31.62|
00003a  2007              MOVS     r0,#7                 ;4977
00003c  e7f6              B        |L31.44|
                  |L31.62|
00003e  bf00              NOP                            ;4980
000040  6960              LDR      r0,[r4,#0x14]         ;4980
000042  4428              ADD      r0,r0,r5              ;4980
000044  6961              LDR      r1,[r4,#0x14]         ;4980
000046  4288              CMP      r0,r1                 ;4980
000048  d202              BCS      |L31.80|
00004a  6960              LDR      r0,[r4,#0x14]         ;4982
00004c  f1c035ff          RSB      r5,r0,#0xffffffff     ;4982
                  |L31.80|
000050  e0bb              B        |L31.458|
                  |L31.82|
000052  8aa0              LDRH     r0,[r4,#0x14]         ;4988
000054  f3c00008          UBFX     r0,r0,#0,#9           ;4988
000058  2800              CMP      r0,#0                 ;4988
00005a  d175              BNE      |L31.328|
00005c  9801              LDR      r0,[sp,#4]            ;4990
00005e  8940              LDRH     r0,[r0,#0xa]          ;4990
000060  1e40              SUBS     r0,r0,#1              ;4990
000062  6961              LDR      r1,[r4,#0x14]         ;4990
000064  ea002a51          AND      r10,r0,r1,LSR #9      ;4990
000068  f1ba0f00          CMP      r10,#0                ;4991
00006c  d11e              BNE      |L31.172|
00006e  6960              LDR      r0,[r4,#0x14]         ;4993
000070  b938              CBNZ     r0,|L31.130|
000072  68a7              LDR      r7,[r4,#8]            ;4995
000074  b957              CBNZ     r7,|L31.140|
000076  2100              MOVS     r1,#0                 ;4998
000078  4620              MOV      r0,r4                 ;4998
00007a  f7fffffe          BL       create_chain
00007e  4607              MOV      r7,r0                 ;4998
000080  e004              B        |L31.140|
                  |L31.130|
000082  4620              MOV      r0,r4                 ;5011
000084  69a1              LDR      r1,[r4,#0x18]         ;5011
000086  f7fffffe          BL       create_chain
00008a  4607              MOV      r7,r0                 ;5011
                  |L31.140|
00008c  b907              CBNZ     r7,|L31.144|
00008e  e09f              B        |L31.464|
                  |L31.144|
000090  2f01              CMP      r7,#1                 ;5015
000092  d102              BNE      |L31.154|
000094  2002              MOVS     r0,#2                 ;5016
000096  7460              STRB     r0,[r4,#0x11]         ;5016
000098  e7c8              B        |L31.44|
                  |L31.154|
00009a  1c78              ADDS     r0,r7,#1              ;5017
00009c  b910              CBNZ     r0,|L31.164|
00009e  2001              MOVS     r0,#1                 ;5018
0000a0  7460              STRB     r0,[r4,#0x11]         ;5018
0000a2  e7c3              B        |L31.44|
                  |L31.164|
0000a4  61a7              STR      r7,[r4,#0x18]         ;5019
0000a6  68a0              LDR      r0,[r4,#8]            ;5020
0000a8  b900              CBNZ     r0,|L31.172|
0000aa  60a7              STR      r7,[r4,#8]            ;5021
                  |L31.172|
0000ac  7c20              LDRB     r0,[r4,#0x10]         ;5027
0000ae  f0000080          AND      r0,r0,#0x80           ;5027
0000b2  b178              CBZ      r0,|L31.212|
0000b4  69e2              LDR      r2,[r4,#0x1c]         ;5029
0000b6  9901              LDR      r1,[sp,#4]            ;5029
0000b8  7848              LDRB     r0,[r1,#1]            ;5029
0000ba  2301              MOVS     r3,#1                 ;5029
0000bc  f1040128          ADD      r1,r4,#0x28           ;5029
0000c0  f7fffffe          BL       disk_write
0000c4  b110              CBZ      r0,|L31.204|
0000c6  2001              MOVS     r0,#1                 ;5029
0000c8  7460              STRB     r0,[r4,#0x11]         ;5029
0000ca  e7af              B        |L31.44|
                  |L31.204|
0000cc  7c20              LDRB     r0,[r4,#0x10]         ;5030
0000ce  f000007f          AND      r0,r0,#0x7f           ;5030
0000d2  7420              STRB     r0,[r4,#0x10]         ;5030
                  |L31.212|
0000d4  69a1              LDR      r1,[r4,#0x18]         ;5033
0000d6  9801              LDR      r0,[sp,#4]            ;5033
0000d8  f7fffffe          BL       clst2sect
0000dc  4606              MOV      r6,r0                 ;5033
0000de  b916              CBNZ     r6,|L31.230|
0000e0  2002              MOVS     r0,#2                 ;5035
0000e2  7460              STRB     r0,[r4,#0x11]         ;5035
0000e4  e7a2              B        |L31.44|
                  |L31.230|
0000e6  4456              ADD      r6,r6,r10             ;5036
0000e8  ea4f2955          LSR      r9,r5,#9              ;5037
0000ec  f1b90f00          CMP      r9,#0                 ;5038
0000f0  d02b              BEQ      |L31.330|
0000f2  eb0a0009          ADD      r0,r10,r9             ;5040
0000f6  9901              LDR      r1,[sp,#4]            ;5040
0000f8  8949              LDRH     r1,[r1,#0xa]          ;5040
0000fa  4288              CMP      r0,r1                 ;5040
0000fc  d903              BLS      |L31.262|
0000fe  9801              LDR      r0,[sp,#4]            ;5042
000100  8940              LDRH     r0,[r0,#0xa]          ;5042
000102  eba0090a          SUB      r9,r0,r10             ;5042
                  |L31.262|
000106  9901              LDR      r1,[sp,#4]            ;5044
000108  7848              LDRB     r0,[r1,#1]            ;5044
00010a  464b              MOV      r3,r9                 ;5044
00010c  4632              MOV      r2,r6                 ;5044
00010e  9900              LDR      r1,[sp,#0]            ;5044
000110  f7fffffe          BL       disk_write
000114  b110              CBZ      r0,|L31.284|
000116  2001              MOVS     r0,#1                 ;5045
000118  7460              STRB     r0,[r4,#0x11]         ;5045
00011a  e787              B        |L31.44|
                  |L31.284|
00011c  69e0              LDR      r0,[r4,#0x1c]         ;5054
00011e  1b80              SUBS     r0,r0,r6              ;5054
000120  4548              CMP      r0,r9                 ;5054
000122  d20e              BCS      |L31.322|
000124  69e0              LDR      r0,[r4,#0x1c]         ;5056
000126  1b80              SUBS     r0,r0,r6              ;5056
000128  9a00              LDR      r2,[sp,#0]            ;5056
00012a  eb022140          ADD      r1,r2,r0,LSL #9       ;5056
00012e  f44f7200          MOV      r2,#0x200             ;5056
000132  f1040028          ADD      r0,r4,#0x28           ;5056
000136  f7fffffe          BL       mem_cpy
00013a  7c20              LDRB     r0,[r4,#0x10]         ;5057
00013c  f000007f          AND      r0,r0,#0x7f           ;5057
000140  7420              STRB     r0,[r4,#0x10]         ;5057
                  |L31.322|
000142  ea4f2849          LSL      r8,r9,#9              ;5061
000146  e02b              B        |L31.416|
                  |L31.328|
000148  e013              B        |L31.370|
                  |L31.330|
00014a  69e0              LDR      r0,[r4,#0x1c]         ;5071
00014c  42b0              CMP      r0,r6                 ;5071
00014e  d00f              BEQ      |L31.368|
000150  68e1              LDR      r1,[r4,#0xc]          ;5072
000152  6960              LDR      r0,[r4,#0x14]         ;5072
000154  4288              CMP      r0,r1                 ;5072
000156  d20b              BCS      |L31.368|
000158  9901              LDR      r1,[sp,#4]            ;5073
00015a  7848              LDRB     r0,[r1,#1]            ;5073
00015c  2301              MOVS     r3,#1                 ;5073
00015e  4632              MOV      r2,r6                 ;5073
000160  f1040128          ADD      r1,r4,#0x28           ;5073
000164  f7fffffe          BL       disk_read
000168  b110              CBZ      r0,|L31.368|
00016a  2001              MOVS     r0,#1                 ;5075
00016c  7460              STRB     r0,[r4,#0x11]         ;5075
00016e  e75d              B        |L31.44|
                  |L31.368|
000170  61e6              STR      r6,[r4,#0x1c]         ;5078
                  |L31.370|
000172  8aa0              LDRH     r0,[r4,#0x14]         ;5080
000174  f3c00008          UBFX     r0,r0,#0,#9           ;5080
000178  f5c07800          RSB      r8,r0,#0x200          ;5080
00017c  45a8              CMP      r8,r5                 ;5081
00017e  d900              BLS      |L31.386|
000180  46a8              MOV      r8,r5                 ;5081
                  |L31.386|
000182  8aa1              LDRH     r1,[r4,#0x14]         ;5087
000184  f3c10208          UBFX     r2,r1,#0,#9           ;5087
000188  f1040128          ADD      r1,r4,#0x28           ;5087
00018c  1850              ADDS     r0,r2,r1              ;5087
00018e  4642              MOV      r2,r8                 ;5087
000190  9900              LDR      r1,[sp,#0]            ;5087
000192  f7fffffe          BL       mem_cpy
000196  7c20              LDRB     r0,[r4,#0x10]         ;5088
000198  f0400080          ORR      r0,r0,#0x80           ;5088
00019c  7420              STRB     r0,[r4,#0x10]         ;5088
00019e  bf00              NOP                            ;5062
                  |L31.416|
0001a0  eba50508          SUB      r5,r5,r8              ;4986
0001a4  f8db0000          LDR      r0,[r11,#0]           ;4986
0001a8  4440              ADD      r0,r0,r8              ;4986
0001aa  f8cb0000          STR      r0,[r11,#0]           ;4986
0001ae  9800              LDR      r0,[sp,#0]            ;4986
0001b0  4440              ADD      r0,r0,r8              ;4986
0001b2  9000              STR      r0,[sp,#0]            ;4986
0001b4  6960              LDR      r0,[r4,#0x14]         ;4986
0001b6  4440              ADD      r0,r0,r8              ;4986
0001b8  6160              STR      r0,[r4,#0x14]         ;4986
0001ba  68e1              LDR      r1,[r4,#0xc]          ;4986
0001bc  6960              LDR      r0,[r4,#0x14]         ;4986
0001be  4288              CMP      r0,r1                 ;4986
0001c0  d901              BLS      |L31.454|
0001c2  6960              LDR      r0,[r4,#0x14]         ;4986
0001c4  e000              B        |L31.456|
                  |L31.454|
0001c6  68e0              LDR      r0,[r4,#0xc]          ;4986
                  |L31.456|
0001c8  60e0              STR      r0,[r4,#0xc]          ;4986
                  |L31.458|
0001ca  2d00              CMP      r5,#0                 ;4985
0001cc  f47faf41          BNE      |L31.82|
                  |L31.464|
0001d0  bf00              NOP                            ;5014
0001d2  7c20              LDRB     r0,[r4,#0x10]         ;5092
0001d4  f0400040          ORR      r0,r0,#0x40           ;5092
0001d8  7420              STRB     r0,[r4,#0x10]         ;5092
0001da  2000              MOVS     r0,#0                 ;5094
0001dc  e726              B        |L31.44|
;;;5096   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;4168   *******************************************************************************/
;;;4169   static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;4170                 const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
;;;4171                 FATFS** rfs,				    /* Pointer to pointer to the found filesystem object */
;;;4172                 BYTE mode					      /* !=0: Check write protection for write access */
;;;4173   )
;;;4174   {
000004  b08a              SUB      sp,sp,#0x28
;;;4175   	BYTE      fmt, *pt;
;;;4176   	int       vol;
;;;4177   	DSTATUS   stat;
;;;4178   	DWORD     bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
;;;4179   	WORD      nrsv;
;;;4180   	FATFS     *fs;    //文件系统对象
;;;4181   	UINT      i;
;;;4182   
;;;4183   
;;;4184   	/* Get logical drive number */
;;;4185   	*rfs  = 0;
000006  2100              MOVS     r1,#0
000008  980b              LDR      r0,[sp,#0x2c]
00000a  6001              STR      r1,[r0,#0]
;;;4186   	vol   = get_ldnumber(path);   //从路径名称获取逻辑驱动器号
00000c  980a              LDR      r0,[sp,#0x28]
00000e  f7fffffe          BL       get_ldnumber
000012  9008              STR      r0,[sp,#0x20]
;;;4187   	if (vol < 0) 
000014  9808              LDR      r0,[sp,#0x20]
000016  2800              CMP      r0,#0
000018  da03              BGE      |L32.34|
;;;4188       return FR_INVALID_DRIVE;    //无效驱动器号
00001a  200b              MOVS     r0,#0xb
                  |L32.28|
;;;4189   
;;;4190   	/* Check if the filesystem object is valid or not */
;;;4191     //=========================检查文件系统是否有效，
;;;4192   	fs = FatFs[vol];				  /* Get pointer to the filesystem object */
;;;4193   	if (!fs)                  //文件系统不可用
;;;4194       return FR_NOT_ENABLED;  /* Is the filesystem object available? */
;;;4195   #if FF_FS_REENTRANT
;;;4196   	if (!lock_fs(fs))         //获取文件系统同步对象，不成功返回超时，成功，继续执行。
;;;4197       return FR_TIMEOUT;	    /* Lock the volume */
;;;4198   #endif
;;;4199   	*rfs = fs;							  /* Return pointer to the filesystem object */
;;;4200   
;;;4201   	mode &= (BYTE)~FA_READ;	  /* Desired access mode, write access or not */  //mode==1,立即安装驱动
;;;4202   	if (fs->fs_type != 0)     /* If the volume has been mounted */    //驱动器号已占用--已安装
;;;4203     {				
;;;4204   		stat = disk_status(fs->pdrv);   //获取驱动器状态
;;;4205   		if (!(stat & STA_NOINIT))       //驱动器未初始化
;;;4206       {		/* and the physical drive is kept initialized */
;;;4207   			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT))
;;;4208         {	/* Check write protection if needed */
;;;4209   				return FR_WRITE_PROTECTED;    //在存储介质被写保护的情况下，以写模式打开或创建文件对象
;;;4210   			}
;;;4211   			return FR_OK;				/* The filesystem object is valid */
;;;4212   		}
;;;4213   	}
;;;4214   
;;;4215   	/* The filesystem object is not valid. */
;;;4216   	/* Following code attempts to mount the volume. (analyze BPB and initialize the filesystem object) */
;;;4217   
;;;4218   	fs->fs_type = 0;					        /* Clear the filesystem object */   //清除文件对象
;;;4219   	fs->pdrv = LD2PD(vol);				    /* Bind the logical drive and a physical drive */ //绑定逻辑驱动器和物理驱动器
;;;4220     //=========================初始化驱动器
;;;4221   	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
;;;4222   	if (stat & STA_NOINIT)    //未初始化成功
;;;4223     { 			/* Check if the initialization succeeded */
;;;4224   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;4225   	}
;;;4226   	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT))    //已写保护
;;;4227     { /* Check disk write protection if needed */
;;;4228   		return FR_WRITE_PROTECTED;
;;;4229   	}
;;;4230   #if FF_MAX_SS != FF_MIN_SS				/* Get sector size (multiple sector size cfg only) */
;;;4231   	if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK)
;;;4232       return FR_DISK_ERR;
;;;4233   	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1)))
;;;4234       return FR_DISK_ERR;
;;;4235   #endif
;;;4236     //在驱动器上找到一个FAT分区。只支持通用分区规则
;;;4237   	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
;;;4238   	bsect = 0;
;;;4239   	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */    //加载一个扇区并检查它是否是一个FAT文件系统--该函数用于读取BOOT扇区，检查是否FAT文件系统。
;;;4240   	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0))   /* Not an FAT-VBR or forced partition number */ //不是FAT-VBR或强制分区号
;;;4241     {	
;;;4242   		for (i = 0; i < 4; i++)   /* Get partition offset */    //获取分区偏移 
;;;4243       {		
;;;4244   			pt = fs->win + (MBR_Table + i * SZ_PTE);
;;;4245   			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
;;;4246   		}
;;;4247   		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
;;;4248   		if (i != 0)
;;;4249         i--;
;;;4250   		do
;;;4251       {							/* Find an FAT volume */   // 查找FAT卷
;;;4252   			bsect = br[i];
;;;4253   			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */   //该函数用于读取BOOT扇区，检查是否FAT文件系统。
;;;4254   		}while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
;;;4255   	}
;;;4256   	if (fmt == 4)
;;;4257       return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;4258   	if (fmt >= 2)
;;;4259       return FR_NO_FILESYSTEM;	/* No FAT volume is found */
;;;4260   
;;;4261   	/* An FAT volume is found (bsect). Following code initializes the filesystem object */
;;;4262   
;;;4263   #if FF_FS_EXFAT
;;;4264   	if (fmt == 1) 
;;;4265     {
;;;4266   		QWORD maxlba;
;;;4267   
;;;4268   		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
;;;4269   		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
;;;4270   
;;;4271   		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (must be version 1.0) */
;;;4272   
;;;4273   		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
;;;4274   			return FR_NO_FILESYSTEM;
;;;4275   		}
;;;4276   
;;;4277   		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
;;;4278   		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
;;;4279   
;;;4280   		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
;;;4281   
;;;4282   		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
;;;4283   		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
;;;4284   
;;;4285   		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
;;;4286   		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
;;;4287   
;;;4288   		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
;;;4289   		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
;;;4290   		fs->n_fatent = nclst + 2;
;;;4291   
;;;4292   		/* Boundaries and Limits */
;;;4293   		fs->volbase = bsect;
;;;4294   		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
;;;4295   		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
;;;4296   		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
;;;4297   		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
;;;4298   
;;;4299   		/* Check if bitmap location is in assumption (at the first cluster) */
;;;4300   		if (move_window(fs, clst2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
;;;4301   		for (i = 0; i < SS(fs); i += SZDIRE) {
;;;4302   			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
;;;4303   		}
;;;4304   		if (i == SS(fs)) return FR_NO_FILESYSTEM;
;;;4305   #if !FF_FS_READONLY
;;;4306   		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
;;;4307   #endif
;;;4308   		fmt = FS_EXFAT;			/* FAT sub-type */
;;;4309   	} 
;;;4310     else
;;;4311   #endif	/* FF_FS_EXFAT */
;;;4312   	{
;;;4313   		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) 
;;;4314         return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;4315   
;;;4316   		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
;;;4317   		if (fasize == 0) 
;;;4318         fasize = ld_dword(fs->win + BPB_FATSz32);
;;;4319   		fs->fsize = fasize;
;;;4320   
;;;4321   		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
;;;4322   		if (fs->n_fats != 1 && fs->n_fats != 2) 
;;;4323         return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
;;;4324   		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
;;;4325   
;;;4326   		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
;;;4327   		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) 
;;;4328         return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
;;;4329   
;;;4330   		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */  //根目录条目数
;;;4331   		if (fs->n_rootdir % (SS(fs) / SZDIRE)) 
;;;4332         return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
;;;4333   
;;;4334   		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */   //卷上扇区数
;;;4335   		if (tsect == 0) 
;;;4336         tsect = ld_dword(fs->win + BPB_TotSec32);
;;;4337   
;;;4338   		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */    //预留扇区数
;;;4339   		if (nrsv == 0) 
;;;4340         return FR_NO_FILESYSTEM;			/* (Must not be 0) */
;;;4341   
;;;4342   		/* Determine the FAT sub type */
;;;4343   		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
;;;4344   		if (tsect < sysect) 
;;;4345         return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
;;;4346   		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
;;;4347   		if (nclst == 0) 
;;;4348         return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;4349   		fmt = 0;
;;;4350   		if (nclst <= MAX_FAT32) 
;;;4351         fmt = FS_FAT32;
;;;4352   		if (nclst <= MAX_FAT16) 
;;;4353         fmt = FS_FAT16;
;;;4354   		if (nclst <= MAX_FAT12) 
;;;4355         fmt = FS_FAT12;
;;;4356   		if (fmt == 0) 
;;;4357         return FR_NO_FILESYSTEM;
;;;4358   
;;;4359   		/* Boundaries and Limits */
;;;4360   		fs->n_fatent  = nclst + 2;					  /* Number of FAT entries */
;;;4361   		fs->volbase   = bsect;							  /* Volume start sector */
;;;4362   		fs->fatbase   = bsect + nrsv; 			  /* FAT start sector */
;;;4363   		fs->database  = bsect + sysect;			  /* Data start sector */
;;;4364   		if (fmt == FS_FAT32) 
;;;4365       {
;;;4366   			if (ld_word(fs->win + BPB_FSVer32) != 0) 
;;;4367           return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
;;;4368   			if (fs->n_rootdir != 0) 
;;;4369           return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
;;;4370   			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
;;;4371   			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
;;;4372   		}
;;;4373       else
;;;4374       {
;;;4375   			if (fs->n_rootdir == 0)	
;;;4376           return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;4377   			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
;;;4378   			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
;;;4379   				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;4380   		}
;;;4381   		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))
;;;4382         return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
;;;4383   
;;;4384   #if !FF_FS_READONLY
;;;4385   		/* Get FSInfo if available */
;;;4386   		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
;;;4387   		fs->fsi_flag = 0x80;
;;;4388   #if (FF_FS_NOFSINFO & 3) != 3
;;;4389   		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
;;;4390   			&& ld_word(fs->win + BPB_FSInfo32) == 1
;;;4391   			&& move_window(fs, bsect + 1) == FR_OK)
;;;4392   		{
;;;4393   			fs->fsi_flag = 0;
;;;4394   			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
;;;4395   				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
;;;4396   				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
;;;4397   			{
;;;4398   #if (FF_FS_NOFSINFO & 1) == 0
;;;4399   				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
;;;4400   #endif
;;;4401   #if (FF_FS_NOFSINFO & 2) == 0
;;;4402   				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
;;;4403   #endif
;;;4404   			}
;;;4405   		}
;;;4406   #endif	/* (FF_FS_NOFSINFO & 3) != 3 */
;;;4407   #endif	/* !FF_FS_READONLY */
;;;4408   	}
;;;4409   
;;;4410   	fs->fs_type = fmt;		/* FAT sub-type */
;;;4411   	fs->id = ++Fsid;		  /* Volume mount ID */
;;;4412   #if FF_USE_LFN == 1
;;;4413   	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
;;;4414   #if FF_FS_EXFAT
;;;4415   	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
;;;4416   #endif
;;;4417   #endif
;;;4418   #if FF_FS_RPATH != 0
;;;4419   	fs->cdir = 0;			/* Initialize current directory */
;;;4420   #endif
;;;4421   #if FF_FS_LOCK != 0			/* Clear file lock semaphores */
;;;4422   	clear_lock(fs);
;;;4423   #endif
;;;4424   	return FR_OK;
;;;4425   }
00001c  b00d              ADD      sp,sp,#0x34
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L32.34|
000022  49b5              LDR      r1,|L32.760|
000024  9808              LDR      r0,[sp,#0x20]         ;4192
000026  f8514020          LDR      r4,[r1,r0,LSL #2]     ;4192
00002a  b90c              CBNZ     r4,|L32.48|
00002c  200c              MOVS     r0,#0xc               ;4194
00002e  e7f5              B        |L32.28|
                  |L32.48|
000030  980b              LDR      r0,[sp,#0x2c]         ;4199
000032  6004              STR      r4,[r0,#0]            ;4199
000034  980c              LDR      r0,[sp,#0x30]         ;4201
000036  f00000fe          AND      r0,r0,#0xfe           ;4201
00003a  900c              STR      r0,[sp,#0x30]         ;4201
00003c  7820              LDRB     r0,[r4,#0]            ;4202
00003e  b178              CBZ      r0,|L32.96|
000040  7860              LDRB     r0,[r4,#1]            ;4204
000042  f7fffffe          BL       disk_status
000046  4681              MOV      r9,r0                 ;4204
000048  f0090001          AND      r0,r9,#1              ;4205
00004c  b940              CBNZ     r0,|L32.96|
00004e  980c              LDR      r0,[sp,#0x30]         ;4207
000050  b120              CBZ      r0,|L32.92|
000052  f0090004          AND      r0,r9,#4              ;4207
000056  b108              CBZ      r0,|L32.92|
000058  200a              MOVS     r0,#0xa               ;4209
00005a  e7df              B        |L32.28|
                  |L32.92|
00005c  2000              MOVS     r0,#0                 ;4211
00005e  e7dd              B        |L32.28|
                  |L32.96|
000060  2000              MOVS     r0,#0                 ;4218
000062  7020              STRB     r0,[r4,#0]            ;4218
000064  9808              LDR      r0,[sp,#0x20]         ;4219
000066  7060              STRB     r0,[r4,#1]            ;4219
000068  7860              LDRB     r0,[r4,#1]            ;4221
00006a  f7fffffe          BL       disk_initialize
00006e  4681              MOV      r9,r0                 ;4221
000070  f0090001          AND      r0,r9,#1              ;4222
000074  b108              CBZ      r0,|L32.122|
000076  2003              MOVS     r0,#3                 ;4224
000078  e7d0              B        |L32.28|
                  |L32.122|
00007a  980c              LDR      r0,[sp,#0x30]         ;4226
00007c  b120              CBZ      r0,|L32.136|
00007e  f0090004          AND      r0,r9,#4              ;4226
000082  b108              CBZ      r0,|L32.136|
000084  200a              MOVS     r0,#0xa               ;4228
000086  e7c9              B        |L32.28|
                  |L32.136|
000088  2700              MOVS     r7,#0                 ;4238
00008a  4639              MOV      r1,r7                 ;4239
00008c  4620              MOV      r0,r4                 ;4239
00008e  f7fffffe          BL       check_fs
000092  4605              MOV      r5,r0                 ;4239
000094  2d02              CMP      r5,#2                 ;4240
000096  d001              BEQ      |L32.156|
000098  da2e              BGE      |L32.248|
00009a  e02d              B        |L32.248|
                  |L32.156|
00009c  2600              MOVS     r6,#0                 ;4242
00009e  e014              B        |L32.202|
                  |L32.160|
0000a0  f44f70df          MOV      r0,#0x1be             ;4244
0000a4  eb001106          ADD      r1,r0,r6,LSL #4       ;4244
0000a8  f1040030          ADD      r0,r4,#0x30           ;4244
0000ac  4408              ADD      r0,r0,r1              ;4244
0000ae  9009              STR      r0,[sp,#0x24]         ;4244
0000b0  9809              LDR      r0,[sp,#0x24]         ;4245
0000b2  7900              LDRB     r0,[r0,#4]            ;4245
0000b4  b120              CBZ      r0,|L32.192|
0000b6  9809              LDR      r0,[sp,#0x24]         ;4245
0000b8  3008              ADDS     r0,r0,#8              ;4245
0000ba  f7fffffe          BL       ld_dword
0000be  e000              B        |L32.194|
                  |L32.192|
0000c0  2000              MOVS     r0,#0                 ;4245
                  |L32.194|
0000c2  a902              ADD      r1,sp,#8              ;4245
0000c4  f8410026          STR      r0,[r1,r6,LSL #2]     ;4245
0000c8  1c76              ADDS     r6,r6,#1              ;4242
                  |L32.202|
0000ca  2e04              CMP      r6,#4                 ;4242
0000cc  d3e8              BCC      |L32.160|
0000ce  2600              MOVS     r6,#0                 ;4247
0000d0  b106              CBZ      r6,|L32.212|
0000d2  1e76              SUBS     r6,r6,#1              ;4249
                  |L32.212|
0000d4  bf00              NOP                            ;4250
                  |L32.214|
0000d6  a802              ADD      r0,sp,#8              ;4252
0000d8  f8507026          LDR      r7,[r0,r6,LSL #2]     ;4252
0000dc  b127              CBZ      r7,|L32.232|
0000de  4639              MOV      r1,r7                 ;4253
0000e0  4620              MOV      r0,r4                 ;4253
0000e2  f7fffffe          BL       check_fs
0000e6  e000              B        |L32.234|
                  |L32.232|
0000e8  2003              MOVS     r0,#3                 ;4253
                  |L32.234|
0000ea  4605              MOV      r5,r0                 ;4253
0000ec  2d02              CMP      r5,#2                 ;4254
0000ee  db03              BLT      |L32.248|
0000f0  1c70              ADDS     r0,r6,#1              ;4254
0000f2  4606              MOV      r6,r0                 ;4254
0000f4  2804              CMP      r0,#4                 ;4254
0000f6  d3ee              BCC      |L32.214|
                  |L32.248|
0000f8  2d04              CMP      r5,#4                 ;4256
0000fa  d101              BNE      |L32.256|
0000fc  2001              MOVS     r0,#1                 ;4257
0000fe  e78d              B        |L32.28|
                  |L32.256|
000100  2d02              CMP      r5,#2                 ;4258
000102  db01              BLT      |L32.264|
000104  200d              MOVS     r0,#0xd               ;4259
000106  e789              B        |L32.28|
                  |L32.264|
000108  f104003b          ADD      r0,r4,#0x3b           ;4313
00010c  f7fffffe          BL       ld_word
000110  f5b07f00          CMP      r0,#0x200             ;4313
000114  d001              BEQ      |L32.282|
000116  200d              MOVS     r0,#0xd               ;4314
000118  e780              B        |L32.28|
                  |L32.282|
00011a  f1040046          ADD      r0,r4,#0x46           ;4316
00011e  f7fffffe          BL       ld_word
000122  4680              MOV      r8,r0                 ;4316
000124  f1b80f00          CMP      r8,#0                 ;4317
000128  d104              BNE      |L32.308|
00012a  f1040054          ADD      r0,r4,#0x54           ;4318
00012e  f7fffffe          BL       ld_dword
000132  4680              MOV      r8,r0                 ;4318
                  |L32.308|
000134  f8c48018          STR      r8,[r4,#0x18]         ;4319
000138  2040              MOVS     r0,#0x40              ;4321
00013a  5d00              LDRB     r0,[r0,r4]            ;4321
00013c  70a0              STRB     r0,[r4,#2]            ;4321
00013e  78a0              LDRB     r0,[r4,#2]            ;4322
000140  2801              CMP      r0,#1                 ;4322
000142  d004              BEQ      |L32.334|
000144  78a0              LDRB     r0,[r4,#2]            ;4322
000146  2802              CMP      r0,#2                 ;4322
000148  d001              BEQ      |L32.334|
00014a  200d              MOVS     r0,#0xd               ;4323
00014c  e766              B        |L32.28|
                  |L32.334|
00014e  78a0              LDRB     r0,[r4,#2]            ;4324
000150  fb08f800          MUL      r8,r8,r0              ;4324
000154  203d              MOVS     r0,#0x3d              ;4326
000156  5d00              LDRB     r0,[r0,r4]            ;4326
000158  8160              STRH     r0,[r4,#0xa]          ;4326
00015a  8960              LDRH     r0,[r4,#0xa]          ;4327
00015c  b118              CBZ      r0,|L32.358|
00015e  8960              LDRH     r0,[r4,#0xa]          ;4327
000160  1e41              SUBS     r1,r0,#1              ;4327
000162  4008              ANDS     r0,r0,r1              ;4327
000164  b108              CBZ      r0,|L32.362|
                  |L32.358|
000166  200d              MOVS     r0,#0xd               ;4328
000168  e758              B        |L32.28|
                  |L32.362|
00016a  f1040041          ADD      r0,r4,#0x41           ;4330
00016e  f7fffffe          BL       ld_word
000172  8120              STRH     r0,[r4,#8]            ;4330
000174  7a20              LDRB     r0,[r4,#8]            ;4331
000176  f000000f          AND      r0,r0,#0xf            ;4331
00017a  b108              CBZ      r0,|L32.384|
00017c  200d              MOVS     r0,#0xd               ;4332
00017e  e74d              B        |L32.28|
                  |L32.384|
000180  f1040043          ADD      r0,r4,#0x43           ;4334
000184  f7fffffe          BL       ld_word
000188  4683              MOV      r11,r0                ;4334
00018a  f1bb0f00          CMP      r11,#0                ;4335
00018e  d104              BNE      |L32.410|
000190  f1040050          ADD      r0,r4,#0x50           ;4336
000194  f7fffffe          BL       ld_dword
000198  4683              MOV      r11,r0                ;4336
                  |L32.410|
00019a  f104003e          ADD      r0,r4,#0x3e           ;4338
00019e  f7fffffe          BL       ld_word
0001a2  9001              STR      r0,[sp,#4]            ;4338
0001a4  9801              LDR      r0,[sp,#4]            ;4339
0001a6  b908              CBNZ     r0,|L32.428|
0001a8  200d              MOVS     r0,#0xd               ;4340
0001aa  e737              B        |L32.28|
                  |L32.428|
0001ac  9801              LDR      r0,[sp,#4]            ;4343
0001ae  4440              ADD      r0,r0,r8              ;4343
0001b0  8921              LDRH     r1,[r4,#8]            ;4343
0001b2  eb001011          ADD      r0,r0,r1,LSR #4       ;4343
0001b6  9007              STR      r0,[sp,#0x1c]         ;4343
0001b8  9807              LDR      r0,[sp,#0x1c]         ;4344
0001ba  4583              CMP      r11,r0                ;4344
0001bc  d201              BCS      |L32.450|
0001be  200d              MOVS     r0,#0xd               ;4345
0001c0  e72c              B        |L32.28|
                  |L32.450|
0001c2  9807              LDR      r0,[sp,#0x1c]         ;4346
0001c4  ebab0000          SUB      r0,r11,r0             ;4346
0001c8  8961              LDRH     r1,[r4,#0xa]          ;4346
0001ca  fbb0faf1          UDIV     r10,r0,r1             ;4346
0001ce  f1ba0f00          CMP      r10,#0                ;4347
0001d2  d101              BNE      |L32.472|
0001d4  200d              MOVS     r0,#0xd               ;4348
0001d6  e721              B        |L32.28|
                  |L32.472|
0001d8  2500              MOVS     r5,#0                 ;4349
0001da  4848              LDR      r0,|L32.764|
0001dc  4582              CMP      r10,r0                ;4350
0001de  d800              BHI      |L32.482|
0001e0  2503              MOVS     r5,#3                 ;4351
                  |L32.482|
0001e2  f64f70f5          MOV      r0,#0xfff5            ;4352
0001e6  4582              CMP      r10,r0                ;4352
0001e8  d800              BHI      |L32.492|
0001ea  2502              MOVS     r5,#2                 ;4353
                  |L32.492|
0001ec  f64070f5          MOV      r0,#0xff5             ;4354
0001f0  4582              CMP      r10,r0                ;4354
0001f2  d800              BHI      |L32.502|
0001f4  2501              MOVS     r5,#1                 ;4355
                  |L32.502|
0001f6  b90d              CBNZ     r5,|L32.508|
0001f8  200d              MOVS     r0,#0xd               ;4357
0001fa  e70f              B        |L32.28|
                  |L32.508|
0001fc  f10a0002          ADD      r0,r10,#2             ;4360
000200  6160              STR      r0,[r4,#0x14]         ;4360
000202  61e7              STR      r7,[r4,#0x1c]         ;4361
000204  9801              LDR      r0,[sp,#4]            ;4362
000206  4438              ADD      r0,r0,r7              ;4362
000208  6220              STR      r0,[r4,#0x20]         ;4362
00020a  9807              LDR      r0,[sp,#0x1c]         ;4363
00020c  4438              ADD      r0,r0,r7              ;4363
00020e  62a0              STR      r0,[r4,#0x28]         ;4363
000210  2d03              CMP      r5,#3                 ;4364
000212  d113              BNE      |L32.572|
000214  f104005a          ADD      r0,r4,#0x5a           ;4366
000218  f7fffffe          BL       ld_word
00021c  b108              CBZ      r0,|L32.546|
00021e  200d              MOVS     r0,#0xd               ;4367
000220  e6fc              B        |L32.28|
                  |L32.546|
000222  8920              LDRH     r0,[r4,#8]            ;4368
000224  b108              CBZ      r0,|L32.554|
000226  200d              MOVS     r0,#0xd               ;4369
000228  e6f8              B        |L32.28|
                  |L32.554|
00022a  f104005c          ADD      r0,r4,#0x5c           ;4370
00022e  f7fffffe          BL       ld_dword
000232  6260              STR      r0,[r4,#0x24]         ;4370
000234  6960              LDR      r0,[r4,#0x14]         ;4371
000236  0080              LSLS     r0,r0,#2              ;4371
000238  9006              STR      r0,[sp,#0x18]         ;4371
00023a  e014              B        |L32.614|
                  |L32.572|
00023c  8920              LDRH     r0,[r4,#8]            ;4375
00023e  b908              CBNZ     r0,|L32.580|
000240  200d              MOVS     r0,#0xd               ;4376
000242  e6eb              B        |L32.28|
                  |L32.580|
000244  6a20              LDR      r0,[r4,#0x20]         ;4377
000246  4440              ADD      r0,r0,r8              ;4377
000248  6260              STR      r0,[r4,#0x24]         ;4377
00024a  2d02              CMP      r5,#2                 ;4378
00024c  d102              BNE      |L32.596|
00024e  6960              LDR      r0,[r4,#0x14]         ;4379
000250  0040              LSLS     r0,r0,#1              ;4379
000252  e007              B        |L32.612|
                  |L32.596|
000254  7d20              LDRB     r0,[r4,#0x14]         ;4379
000256  f0000001          AND      r0,r0,#1              ;4379
00025a  6961              LDR      r1,[r4,#0x14]         ;4379
00025c  eb010141          ADD      r1,r1,r1,LSL #1       ;4379
000260  eb000051          ADD      r0,r0,r1,LSR #1       ;4379
                  |L32.612|
000264  9006              STR      r0,[sp,#0x18]         ;4379
                  |L32.614|
000266  69a1              LDR      r1,[r4,#0x18]         ;4381
000268  9806              LDR      r0,[sp,#0x18]         ;4381
00026a  f20010ff          ADD      r0,r0,#0x1ff          ;4381
00026e  ebb12f50          CMP      r1,r0,LSR #9          ;4381
000272  d201              BCS      |L32.632|
000274  200d              MOVS     r0,#0xd               ;4382
000276  e6d1              B        |L32.28|
                  |L32.632|
000278  f04f30ff          MOV      r0,#0xffffffff        ;4386
00027c  6120              STR      r0,[r4,#0x10]         ;4386
00027e  60e0              STR      r0,[r4,#0xc]          ;4386
000280  2080              MOVS     r0,#0x80              ;4387
000282  7120              STRB     r0,[r4,#4]            ;4387
000284  2d03              CMP      r5,#3                 ;4389
000286  d12c              BNE      |L32.738|
000288  f1040060          ADD      r0,r4,#0x60           ;4390
00028c  f7fffffe          BL       ld_word
000290  2801              CMP      r0,#1                 ;4390
000292  d126              BNE      |L32.738|
000294  1c79              ADDS     r1,r7,#1              ;4391
000296  4620              MOV      r0,r4                 ;4391
000298  f7fffffe          BL       move_window
00029c  bb08              CBNZ     r0,|L32.738|
00029e  2000              MOVS     r0,#0                 ;4393
0002a0  7120              STRB     r0,[r4,#4]            ;4393
0002a2  f204202e          ADD      r0,r4,#0x22e          ;4394
0002a6  f7fffffe          BL       ld_word
0002aa  f64a2155          MOV      r1,#0xaa55            ;4394
0002ae  4288              CMP      r0,r1                 ;4394
0002b0  d117              BNE      |L32.738|
0002b2  f1040030          ADD      r0,r4,#0x30           ;4395
0002b6  f7fffffe          BL       ld_dword
0002ba  4911              LDR      r1,|L32.768|
0002bc  4288              CMP      r0,r1                 ;4395
0002be  d110              BNE      |L32.738|
0002c0  f5047005          ADD      r0,r4,#0x214          ;4396
0002c4  f7fffffe          BL       ld_dword
0002c8  490e              LDR      r1,|L32.772|
0002ca  4288              CMP      r0,r1                 ;4396
0002cc  d109              BNE      |L32.738|
0002ce  f5047006          ADD      r0,r4,#0x218          ;4399
0002d2  f7fffffe          BL       ld_dword
0002d6  6120              STR      r0,[r4,#0x10]         ;4399
0002d8  f5047007          ADD      r0,r4,#0x21c          ;4402
0002dc  f7fffffe          BL       ld_dword
0002e0  60e0              STR      r0,[r4,#0xc]          ;4402
                  |L32.738|
0002e2  7025              STRB     r5,[r4,#0]            ;4410
0002e4  4808              LDR      r0,|L32.776|
0002e6  8800              LDRH     r0,[r0,#0]            ;4411  ; Fsid
0002e8  1c40              ADDS     r0,r0,#1              ;4411
0002ea  b280              UXTH     r0,r0                 ;4411
0002ec  4906              LDR      r1,|L32.776|
0002ee  8008              STRH     r0,[r1,#0]            ;4411
0002f0  80e0              STRH     r0,[r4,#6]            ;4411
0002f2  2000              MOVS     r0,#0                 ;4424
0002f4  e692              B        |L32.28|
;;;4426   
                          ENDP

0002f6  0000              DCW      0x0000
                  |L32.760|
                          DCD      FatFs
                  |L32.764|
                          DCD      0x0ffffff5
                  |L32.768|
                          DCD      0x41615252
                  |L32.772|
                          DCD      0x61417272
                  |L32.776|
                          DCD      Fsid

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;3902   *******************************************************************************/
;;;3903   static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;3904                               DIR* dp,					  /* Directory object to return last directory and found object */
;;;3905                               const TCHAR* path	  /* Full-path string to find a file or directory */
;;;3906   )
;;;3907   {
000004  4604              MOV      r4,r0
;;;3908   	FRESULT res;            //文件函数执行结果返回码
;;;3909   	BYTE    ns;
;;;3910   	FATFS   *fs = dp->obj.fs; //目录中包含的文件系统对象结构体地址
000006  6827              LDR      r7,[r4,#0]
;;;3911   
;;;3912   #if FF_FS_RPATH != 0      //使能相对路径
;;;3913   	if (*path != '/' && *path != '\\')  /* Without heading separator */ //无标题分隔符
;;;3914     {	
;;;3915   		dp->obj.sclust = fs->cdir;				/* Start from current directory */
;;;3916   	} 
;;;3917     else
;;;3918   #endif
;;;3919   	{										/* With heading separator */
;;;3920   		while (*path == '/' || *path == '\\') 
000008  e002              B        |L33.16|
                  |L33.10|
;;;3921         path++;	                  /* Strip heading separator */
00000a  9801              LDR      r0,[sp,#4]
00000c  1c40              ADDS     r0,r0,#1
00000e  9001              STR      r0,[sp,#4]
                  |L33.16|
000010  9801              LDR      r0,[sp,#4]            ;3920
000012  7800              LDRB     r0,[r0,#0]            ;3920
000014  282f              CMP      r0,#0x2f              ;3920
000016  d0f8              BEQ      |L33.10|
000018  9801              LDR      r0,[sp,#4]            ;3920
00001a  7800              LDRB     r0,[r0,#0]            ;3920
00001c  285c              CMP      r0,#0x5c              ;3920
00001e  d0f4              BEQ      |L33.10|
;;;3922   		dp->obj.sclust = 0;					/* Start from root directory */   //从根目录开始 
000020  2000              MOVS     r0,#0
000022  60a0              STR      r0,[r4,#8]
;;;3923   	}
;;;3924   #if FF_FS_EXFAT   //exFAT系统
;;;3925   	dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
;;;3926   #if FF_FS_RPATH != 0
;;;3927   	if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {	/* exFAT: Retrieve the sub-directory's status */
;;;3928   		DIR dj;
;;;3929   
;;;3930   		dp->obj.c_scl = fs->cdc_scl;
;;;3931   		dp->obj.c_size = fs->cdc_size;
;;;3932   		dp->obj.c_ofs = fs->cdc_ofs;
;;;3933   		res = load_obj_xdir(&dj, &dp->obj);
;;;3934   		if (res != FR_OK) 
;;;3935         return res;
;;;3936   		dp->obj.objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
;;;3937   		dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;3938   	}
;;;3939   #endif
;;;3940   #endif
;;;3941     //==============================获取需要查找的路径名字符串
;;;3942   	if ((UINT)*path < ' ')  /* Null path name is the origin directory itself */
000024  9801              LDR      r0,[sp,#4]
000026  7800              LDRB     r0,[r0,#0]
000028  2820              CMP      r0,#0x20
00002a  d208              BCS      |L33.62|
;;;3943     {				
;;;3944   		dp->fn[NSFLAG] = NS_NONAME;   //没有路径名
00002c  2180              MOVS     r1,#0x80
00002e  202b              MOVS     r0,#0x2b
000030  5501              STRB     r1,[r0,r4]
;;;3945   		res = dir_sdi(dp, 0);         //目录处理-设置目录索引--从0开始查找
000032  2100              MOVS     r1,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       dir_sdi
00003a  4605              MOV      r5,r0
00003c  e02c              B        |L33.152|
                  |L33.62|
;;;3946   
;;;3947   	}
;;;3948     else
;;;3949     {								/* Follow path */
;;;3950   		for (;;)
00003e  bf00              NOP      
                  |L33.64|
;;;3951       {
;;;3952   			res = create_name(dp, &path);	/* Get a segment name of the path */
000040  a901              ADD      r1,sp,#4
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       create_name
000048  4605              MOV      r5,r0
;;;3953   			if (res != FR_OK) 
00004a  b105              CBZ      r5,|L33.78|
;;;3954           break;
00004c  e023              B        |L33.150|
                  |L33.78|
;;;3955   			res = dir_find(dp);				/* Find an object with the segment name */
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       dir_find
000054  4605              MOV      r5,r0
;;;3956   			ns = dp->fn[NSFLAG];
000056  202b              MOVS     r0,#0x2b
000058  5d06              LDRB     r6,[r0,r4]
;;;3957   			if (res != FR_OK)
00005a  b13d              CBZ      r5,|L33.108|
;;;3958         {				/* Failed to find the object */
;;;3959   				if (res == FR_NO_FILE)
00005c  2d04              CMP      r5,#4
00005e  d104              BNE      |L33.106|
;;;3960           {	/* Object is not found */
;;;3961   					if (FF_FS_RPATH && (ns & NS_DOT))
000060  bf00              NOP      
;;;3962             {	/* If dot entry is not exist, stay there */
;;;3963   						if (!(ns & NS_LAST)) 	/* Continue to follow if not last segment */
;;;3964                 continue;
;;;3965   						dp->fn[NSFLAG] = NS_NONAME;
;;;3966   						res = FR_OK;
;;;3967   					}
;;;3968             else
;;;3969             {							/* Could not find the object */
;;;3970   						if (!(ns & NS_LAST)) 
000062  f0060004          AND      r0,r6,#4
000066  b900              CBNZ     r0,|L33.106|
;;;3971                 res = FR_NO_PATH;	/* Adjust error code if not last segment */
000068  2505              MOVS     r5,#5
                  |L33.106|
;;;3972   					}
;;;3973   				}
;;;3974   				break;
00006a  e014              B        |L33.150|
                  |L33.108|
;;;3975   			}
;;;3976   			if (ns & NS_LAST) 
00006c  f0060004          AND      r0,r6,#4
000070  b100              CBZ      r0,|L33.116|
;;;3977           break;			/* Last segment matched. Function completed. */
000072  e010              B        |L33.150|
                  |L33.116|
;;;3978   			/* Get into the sub-directory */
;;;3979   			if (!(dp->obj.attr & AM_DIR)) 	/* It is not a sub-directory and cannot follow */
000074  79a0              LDRB     r0,[r4,#6]
000076  f0000010          AND      r0,r0,#0x10
00007a  b908              CBNZ     r0,|L33.128|
;;;3980         {	
;;;3981   				res = FR_NO_PATH; break;
00007c  2505              MOVS     r5,#5
00007e  e00a              B        |L33.150|
                  |L33.128|
;;;3982   			}
;;;3983   #if FF_FS_EXFAT
;;;3984   			if (fs->fs_type == FS_EXFAT) 	/* Save containing directory information for next dir */
;;;3985         {	
;;;3986   				dp->obj.c_scl = dp->obj.sclust;
;;;3987   				dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
;;;3988   				dp->obj.c_ofs = dp->blk_ofs;
;;;3989   				init_alloc_info(fs, &dp->obj);	/* Open next directory */
;;;3990   			} 
;;;3991         else
;;;3992   #endif
;;;3993   			{
;;;3994   				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
000080  8a20              LDRH     r0,[r4,#0x10]
000082  f3c00208          UBFX     r2,r0,#0,#9
000086  f1070030          ADD      r0,r7,#0x30
00008a  1811              ADDS     r1,r2,r0
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       ld_clust
000092  60a0              STR      r0,[r4,#8]
000094  e7d4              B        |L33.64|
                  |L33.150|
000096  bf00              NOP                            ;3954
                  |L33.152|
;;;3995   			}
;;;3996   		}
;;;3997   	}
;;;3998   
;;;3999   	return res;
000098  4628              MOV      r0,r5
;;;4000   }
00009a  e8bd81fc          POP      {r2-r8,pc}
;;;4001   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;1310   *******************************************************************************/
;;;1311   static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1312   	FFOBJID* obj,	/* Corresponding object */
;;;1313   	DWORD clst		/* Cluster number to get the value */
;;;1314   )
;;;1315   {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;1316   	UINT wc, bc;
;;;1317   	DWORD val;
;;;1318   	FATFS *fs = obj->fs;
000008  f8d95000          LDR      r5,[r9,#0]
;;;1319   
;;;1320   
;;;1321   	if (clst < 2 || clst >= fs->n_fatent) /* Check if in valid range */
00000c  2c02              CMP      r4,#2
00000e  d302              BCC      |L34.22|
000010  6968              LDR      r0,[r5,#0x14]
000012  42a0              CMP      r0,r4
000014  d802              BHI      |L34.28|
                  |L34.22|
;;;1322     {
;;;1323   		val = 1;	/* Internal error */
000016  f04f0801          MOV      r8,#1
00001a  e05e              B        |L34.218|
                  |L34.28|
;;;1324   
;;;1325   	}
;;;1326     else
;;;1327     {
;;;1328   		val = 0xFFFFFFFF;	/* Default value falls on disk error */
00001c  f04f38ff          MOV      r8,#0xffffffff
;;;1329   
;;;1330   		switch (fs->fs_type)
000020  7828              LDRB     r0,[r5,#0]
000022  2801              CMP      r0,#1
000024  d004              BEQ      |L34.48|
000026  2802              CMP      r0,#2
000028  d02c              BEQ      |L34.132|
00002a  2803              CMP      r0,#3
00002c  d151              BNE      |L34.210|
00002e  e03c              B        |L34.170|
                  |L34.48|
;;;1331       {
;;;1332         case  FS_FAT12 :
;;;1333               bc = (UINT)clst; bc += bc / 2;
000030  4626              MOV      r6,r4
000032  eb060656          ADD      r6,r6,r6,LSR #1
;;;1334               if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK)
000036  6a28              LDR      r0,[r5,#0x20]
000038  eb002156          ADD      r1,r0,r6,LSR #9
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       move_window
000042  b100              CBZ      r0,|L34.70|
;;;1335           break;
000044  e048              B        |L34.216|
                  |L34.70|
;;;1336               wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
000046  4630              MOV      r0,r6
000048  1c76              ADDS     r6,r6,#1
00004a  f3c00108          UBFX     r1,r0,#0,#9
00004e  f1050030          ADD      r0,r5,#0x30
000052  5c47              LDRB     r7,[r0,r1]
;;;1337               if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK)
000054  6a28              LDR      r0,[r5,#0x20]
000056  eb002156          ADD      r1,r0,r6,LSR #9
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       move_window
000060  b100              CBZ      r0,|L34.100|
;;;1338           break;
000062  e039              B        |L34.216|
                  |L34.100|
;;;1339               wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
000064  f3c60108          UBFX     r1,r6,#0,#9
000068  f1050030          ADD      r0,r5,#0x30
00006c  5c40              LDRB     r0,[r0,r1]
00006e  ea472700          ORR      r7,r7,r0,LSL #8
;;;1340               val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
000072  f0040001          AND      r0,r4,#1
000076  b108              CBZ      r0,|L34.124|
000078  0938              LSRS     r0,r7,#4
00007a  e001              B        |L34.128|
                  |L34.124|
00007c  f3c7000b          UBFX     r0,r7,#0,#12
                  |L34.128|
000080  4680              MOV      r8,r0
;;;1341           break;
000082  e029              B        |L34.216|
                  |L34.132|
;;;1342   
;;;1343   		case  FS_FAT16 :
;;;1344             if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK)
000084  6a28              LDR      r0,[r5,#0x20]
000086  eb002114          ADD      r1,r0,r4,LSR #8
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       move_window
000090  b100              CBZ      r0,|L34.148|
;;;1345           break;
000092  e021              B        |L34.216|
                  |L34.148|
;;;1346             val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
000094  f24011ff          MOV      r1,#0x1ff
000098  ea010244          AND      r2,r1,r4,LSL #1
00009c  f1050130          ADD      r1,r5,#0x30
0000a0  1850              ADDS     r0,r2,r1
0000a2  f7fffffe          BL       ld_word
0000a6  4680              MOV      r8,r0
;;;1347           break;
0000a8  e016              B        |L34.216|
                  |L34.170|
;;;1348   
;;;1349   		case  FS_FAT32 :
;;;1350             if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK)
0000aa  6a28              LDR      r0,[r5,#0x20]
0000ac  eb0011d4          ADD      r1,r0,r4,LSR #7
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       move_window
0000b6  b100              CBZ      r0,|L34.186|
;;;1351           break;
0000b8  e00e              B        |L34.216|
                  |L34.186|
;;;1352             val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
0000ba  f24011ff          MOV      r1,#0x1ff
0000be  ea010284          AND      r2,r1,r4,LSL #2
0000c2  f1050130          ADD      r1,r5,#0x30
0000c6  1850              ADDS     r0,r2,r1
0000c8  f7fffffe          BL       ld_dword
0000cc  f0204870          BIC      r8,r0,#0xf0000000
;;;1353           break;
0000d0  e002              B        |L34.216|
                  |L34.210|
;;;1354   #if FF_FS_EXFAT
;;;1355   		case  FS_EXFAT :
;;;1356             if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0)  /* Object except root dir must have valid data length */
;;;1357             {	
;;;1358               DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
;;;1359               DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
;;;1360   
;;;1361               if (obj->stat == 2 && cofs <= clen) /* Is it a contiguous chain? */
;;;1362               {
;;;1363                 val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
;;;1364           break;
;;;1365               }
;;;1366               if (obj->stat == 3 && cofs < obj->n_cont) /* Is it in the 1st fragment? */
;;;1367               {	
;;;1368                 val = clst + 1; 	/* Generate the value */
;;;1369           break;
;;;1370               }
;;;1371               if (obj->stat != 2)   /* Get value from FAT if FAT chain is valid */
;;;1372               {	
;;;1373                 if (obj->n_frag != 0) /* Is it on the growing edge? */
;;;1374                 {	
;;;1375                   val = 0x7FFFFFFF;	/* Generate EOC */
;;;1376                 }
;;;1377                 else
;;;1378                 {
;;;1379                   if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK)
;;;1380           break;
;;;1381                   val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
;;;1382                 }
;;;1383           break;
;;;1384               }
;;;1385             }
;;;1386   			/* go to default */
;;;1387   #endif
;;;1388   		default:
;;;1389   			val = 1;	/* Internal error */
0000d2  f04f0801          MOV      r8,#1
0000d6  bf00              NOP                            ;1330
                  |L34.216|
0000d8  bf00              NOP                            ;1335
                  |L34.218|
;;;1390   		}
;;;1391   	}
;;;1392   	return val;
0000da  4640              MOV      r0,r8
;;;1393   }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;1394   #if !FF_FS_READONLY
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;3400   *******************************************************************************/
;;;3401   static void get_fileinfo (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3402                     DIR*      dp,	  /* Pointer to the directory object */
;;;3403                     FILINFO*  fno		/* Pointer to the file information to be filled */
;;;3404   )
;;;3405   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;3406   	UINT    si, di;
;;;3407   #if FF_USE_LFN
;;;3408   	WCHAR   wc, hs;
;;;3409   	FATFS   *fs = dp->obj.fs;   //目录中包含的文件系统对象结构体地址
;;;3410   #else
;;;3411   	TCHAR   c;
;;;3412   #endif
;;;3413   
;;;3414   
;;;3415   	fno->fname[0] = 0;			/* Invaidate file info */
000008  2000              MOVS     r0,#0
00000a  7260              STRB     r0,[r4,#9]
;;;3416   	if (dp->sect == 0) 
00000c  69a8              LDR      r0,[r5,#0x18]
00000e  b908              CBNZ     r0,|L35.20|
                  |L35.16|
;;;3417       return;	/* Exit if read pointer has reached end of directory */
;;;3418   
;;;3419   #if FF_USE_LFN		/* LFN configuration */
;;;3420   #if FF_FS_EXFAT
;;;3421   	if (fs->fs_type == FS_EXFAT)
;;;3422     {	/* On the exFAT volume */
;;;3423   		get_xfileinfo(fs->dirbuf, fno);
;;;3424   		return;
;;;3425   	} 
;;;3426     else
;;;3427   #endif
;;;3428   	{	/* On the FAT/FAT32 volume */
;;;3429   		if (dp->blk_ofs != 0xFFFFFFFF) 
;;;3430       {	/* Get LFN if available */
;;;3431   			si = di = hs = 0;
;;;3432   			while (fs->lfnbuf[si] != 0) 
;;;3433         {
;;;3434   				wc = fs->lfnbuf[si++];		/* Get an LFN character (UTF-16) */
;;;3435   				if (hs == 0 && IsSurrogate(wc)) 
;;;3436           {	/* Is it a surrogate? */
;;;3437   					hs = wc; 
;;;3438             continue;		/* Get low surrogate */
;;;3439   				}
;;;3440   				wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in UTF-16 or UTF-8 encoding */
;;;3441   				if (wc == 0) { di = 0; break; }	/* Invalid char or buffer overflow? */
;;;3442   				di += wc;
;;;3443   				hs = 0;
;;;3444   			}
;;;3445   			if (hs != 0) 
;;;3446           di = 0;	/* Broken surrogate pair? */
;;;3447   			fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
;;;3448   		}
;;;3449   	}
;;;3450   
;;;3451   	si = di = 0;
;;;3452   	while (si < 11) 
;;;3453     {		/* Get SFN from SFN entry */
;;;3454   		wc = dp->dir[si++];			/* Get a char */
;;;3455   		if (wc == ' ') 
;;;3456         continue;	/* Skip padding spaces */
;;;3457   		if (wc == RDDEM) 
;;;3458         wc = DDEM;	/* Restore replaced DDEM character */
;;;3459   		if (si == 9 && di < FF_SFN_BUF)
;;;3460         fno->altname[di++] = '.';	/* Insert a . if extension is exist */
;;;3461   #if FF_LFN_UNICODE >= 1	/* Unicode output */
;;;3462   		if (dbc_1st((BYTE)wc) && si != 8 && si != 11 && dbc_2nd(dp->dir[si])) 
;;;3463       {	/* Make a DBC if needed */
;;;3464   			wc = wc << 8 | dp->dir[si++];
;;;3465   		}
;;;3466   		wc = ff_oem2uni(wc, CODEPAGE);		/* ANSI/OEM -> Unicode */
;;;3467   		if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
;;;3468   		wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in Unicode */
;;;3469   		if (wc == 0) { di = 0; break; }		/* Buffer overflow? */
;;;3470   		di += wc;
;;;3471   #else					/* ANSI/OEM output */
;;;3472   		fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
;;;3473   #endif
;;;3474   	}
;;;3475   	fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
;;;3476   
;;;3477   	if (fno->fname[0] == 0) 
;;;3478     {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
;;;3479   		if (di == 0) 
;;;3480       {	/* If LFN and SFN both are invalid, this object is inaccesible */
;;;3481   			fno->fname[di++] = '?';
;;;3482   		}
;;;3483       else
;;;3484       {
;;;3485   			for (si = di = 0; fno->altname[si]; si++, di++) 
;;;3486         {	/* Copy altname[] to fname[] with case information */
;;;3487   				wc = (WCHAR)fno->altname[si];
;;;3488   				if (IsUpper(wc) && (dp->dir[DIR_NTres] & ((si >= 9) ? NS_EXT : NS_BODY))) 
;;;3489             wc += 0x20;
;;;3490   				fno->fname[di] = (TCHAR)wc;
;;;3491   			}
;;;3492   		}
;;;3493   		fno->fname[di] = 0;	/* Terminate the LFN */
;;;3494   		if (!dp->dir[DIR_NTres]) 
;;;3495         fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
;;;3496   	}
;;;3497   
;;;3498   #else	/* Non-LFN configuration */ //短文件名
;;;3499   	si = di = 0;
;;;3500     //=============================复制名称正文和扩展名(格式名)
;;;3501   	while (si < 11) 
;;;3502     {		/* Copy name body and extension */    //复制名称正文和扩展名
;;;3503   		c = (TCHAR)dp->dir[si++];
;;;3504   		if (c == ' ') continue;		          /* Skip padding spaces */
;;;3505   		if (c == RDDEM) c = DDEM;	          /* Restore replaced DDEM character */
;;;3506   		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
;;;3507   		fno->fname[di++] = c;
;;;3508   	}
;;;3509   	fno->fname[di] = 0;
;;;3510   #endif
;;;3511     //=============================复制文件属性数据
;;;3512   	fno->fattrib  = dp->dir[DIR_Attr];					        /* Attribute */
;;;3513   	fno->fsize    = ld_dword(dp->dir + DIR_FileSize);		/* Size */
;;;3514   	fno->ftime    = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
;;;3515   	fno->fdate    = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
;;;3516   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L35.20|
000014  2600              MOVS     r6,#0                 ;3499
000016  4637              MOV      r7,r6                 ;3499
000018  e01c              B        |L35.84|
                  |L35.26|
00001a  4630              MOV      r0,r6                 ;3503
00001c  1c76              ADDS     r6,r6,#1              ;3503
00001e  69ea              LDR      r2,[r5,#0x1c]         ;3503
000020  f8128000          LDRB     r8,[r2,r0]            ;3503
000024  f1b80f20          CMP      r8,#0x20              ;3504
000028  d100              BNE      |L35.44|
00002a  e013              B        |L35.84|
                  |L35.44|
00002c  f1b80f05          CMP      r8,#5                 ;3505
000030  d101              BNE      |L35.54|
000032  f04f08e5          MOV      r8,#0xe5              ;3505
                  |L35.54|
000036  2e09              CMP      r6,#9                 ;3506
000038  d105              BNE      |L35.70|
00003a  222e              MOVS     r2,#0x2e              ;3506
00003c  4638              MOV      r0,r7                 ;3506
00003e  1c7f              ADDS     r7,r7,#1              ;3506
000040  f1040109          ADD      r1,r4,#9              ;3506
000044  540a              STRB     r2,[r1,r0]            ;3506
                  |L35.70|
000046  4638              MOV      r0,r7                 ;3507
000048  1c7f              ADDS     r7,r7,#1              ;3507
00004a  f1040109          ADD      r1,r4,#9              ;3507
00004e  f8018000          STRB     r8,[r1,r0]            ;3507
000052  bf00              NOP                            ;3504
                  |L35.84|
000054  2e0b              CMP      r6,#0xb               ;3501
000056  d3e0              BCC      |L35.26|
000058  2100              MOVS     r1,#0                 ;3509
00005a  f1040009          ADD      r0,r4,#9              ;3509
00005e  55c1              STRB     r1,[r0,r7]            ;3509
000060  69e8              LDR      r0,[r5,#0x1c]         ;3512
000062  7ac0              LDRB     r0,[r0,#0xb]          ;3512
000064  7220              STRB     r0,[r4,#8]            ;3512
000066  69e9              LDR      r1,[r5,#0x1c]         ;3513
000068  f101001c          ADD      r0,r1,#0x1c           ;3513
00006c  f7fffffe          BL       ld_dword
000070  6020              STR      r0,[r4,#0]            ;3513
000072  69e9              LDR      r1,[r5,#0x1c]         ;3514
000074  f1010016          ADD      r0,r1,#0x16           ;3514
000078  f7fffffe          BL       ld_word
00007c  80e0              STRH     r0,[r4,#6]            ;3514
00007e  69e9              LDR      r1,[r5,#0x1c]         ;3515
000080  f1010018          ADD      r0,r1,#0x18           ;3515
000084  f7fffffe          BL       ld_word
000088  80a0              STRH     r0,[r4,#4]            ;3515
00008a  bf00              NOP      
00008c  e7c0              B        |L35.16|
;;;3517   
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;4013   *******************************************************************************/
;;;4014   static int get_ldnumber (	                /* Returns logical drive number (-1:invalid drive number or null pointer) */
000000  b570              PUSH     {r4-r6,lr}
;;;4015                       const TCHAR** path		/* Pointer to pointer to the path name */   //指向驱动器路径名称的指针
;;;4016   )
;;;4017   {
000002  4604              MOV      r4,r0
;;;4018   	const TCHAR *tp, *tt; //指向路径的指针变量，*tp用来找到数字编号位置，*tt用来查找冒号位置
;;;4019   	TCHAR tc;             //查找冒号时使用的变量
;;;4020   	int i, vol = -1;      //驱动器编号（例如"0:","1:"中的0，1）
000004  f04f30ff          MOV      r0,#0xffffffff
;;;4021     
;;;4022   #if FF_STR_VOLUME_ID		/* Find string volume ID */   //如果已定义字符串类型盘符
;;;4023   	const char *sp;
;;;4024   	char c;
;;;4025   #endif
;;;4026   
;;;4027   	tt = tp = *path;
000008  6826              LDR      r6,[r4,#0]
00000a  4631              MOV      r1,r6
00000c  4632              MOV      r2,r6
;;;4028   	if (!tp)      //路径名无效
00000e  b901              CBNZ     r1,|L36.18|
                  |L36.16|
;;;4029       return vol;	/* Invalid path name? */
;;;4030     //==============================在路径中查找冒号(冒号前为驱动器编号)
;;;4031   	do
;;;4032       tc = *tt++; 
;;;4033     while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */ //在路径中找到冒号（路径名称结构为"n:")
;;;4034   
;;;4035   	if (tc == ':')                    //查找到冒号
;;;4036     {	/* DOS/Windows style volume ID? */  //DOS/Windows风格的盘符
;;;4037   		i = FF_VOLUMES;   //#define FF_VOLUMES		1 //驱动器数量
;;;4038       //-----------------------------检查是路径结构是否为数字+冒号并且获取驱动器编号
;;;4039   		if (IsDigit(*tp) && tp + 2 == tt)   //冒号前两位为数字    
;;;4040       {	/* Is there a numeric volume ID + colon? */
;;;4041   			i = (int)*tp - '0';	/* Get the LD number */   //获取驱动器编号
;;;4042   		}
;;;4043       //-----------------------------如果启用了任意字符串用做驱动器号----暂时忽略（不启用）
;;;4044   #if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */   //启用任意字符串
;;;4045   		else 
;;;4046       {
;;;4047   			i = 0;
;;;4048   			do
;;;4049         {
;;;4050   				sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
;;;4051   				do 
;;;4052           {	/* Compare the volume ID with path name */
;;;4053   					c = *sp++; tc = *tp++;
;;;4054   					if (IsLower(c))
;;;4055               c -= 0x20;
;;;4056   					if (IsLower(tc))
;;;4057               tc -= 0x20;
;;;4058   				}while (c && (TCHAR)c == tc);
;;;4059   			}while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
;;;4060   		}
;;;4061   #endif
;;;4062       //==============================如果找到卷ID，获取驱动器号并剪断驱动器前缀
;;;4063   		if (i < FF_VOLUMES)   //#define FF_VOLUMES		1 //驱动器数量 /* If a volume ID is found, get the drive number and strip it */
;;;4064       {	
;;;4065   			vol = i;		  /* Drive number */
;;;4066   			*path = tt;		/* Snip the drive prefix off */   //剪断驱动器前缀（例如"0:")
;;;4067   		}
;;;4068   		return vol;     //返回驱动器号，如果驱动器号末找到或者无效，返回-1
;;;4069   	}
;;;4070   #if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */   //如果已使能字符串方式命名
;;;4071   	if (*tp == '/')   //起始字符为'/'
;;;4072     {
;;;4073   		i = 0;
;;;4074   		do 
;;;4075       {
;;;4076   			sp = VolumeStr[i]; 
;;;4077         tp = *path;	          /* This string volume ID and path name */
;;;4078   			do /* Compare the volume ID with path name */
;;;4079         {	
;;;4080   				c = *sp++; 
;;;4081           tc = *(++tp);
;;;4082   				if (IsLower(c))     //判断字母是否为小写字母，是--返回1
;;;4083             c -= 0x20;
;;;4084   				if (IsLower(tc))    //判断字母是否为小写字母，是--返回1
;;;4085             tc -= 0x20;
;;;4086   			} while (c && (TCHAR)c == tc);
;;;4087   		}while ((c || (tc != '/' && (UINT)tc >= (FF_USE_LFN ? ' ' : '!'))) && ++i < FF_VOLUMES);	/* Repeat for each ID until pattern match */
;;;4088   		//==============================如果找到卷ID，获取驱动器号并剪断驱动器前缀
;;;4089       if (i < FF_VOLUMES) 	/* If a volume ID is found, get the drive number and strip it */
;;;4090       {
;;;4091   			vol = i;		  /* Drive number */
;;;4092   			*path = tp;		/* Snip the drive prefix off */
;;;4093   			return vol;
;;;4094   		}
;;;4095   	}
;;;4096   #endif
;;;4097   	/* No drive prefix is found */
;;;4098   #if FF_FS_RPATH != 0
;;;4099   	vol = CurrVol;	/* Default drive is current drive */
;;;4100   #else
;;;4101   	vol = 0;		/* Default drive is 0 */
;;;4102   #endif
;;;4103   	return vol;		/* Return the default drive */
;;;4104   }
000010  bd70              POP      {r4-r6,pc}
                  |L36.18|
000012  bf00              NOP                            ;4031
                  |L36.20|
000014  f8123b01          LDRB     r3,[r2],#1            ;4032
000018  2b21              CMP      r3,#0x21              ;4033
00001a  d301              BCC      |L36.32|
00001c  2b3a              CMP      r3,#0x3a              ;4033
00001e  d1f9              BNE      |L36.20|
                  |L36.32|
000020  2b3a              CMP      r3,#0x3a              ;4035
000022  d111              BNE      |L36.72|
000024  2501              MOVS     r5,#1                 ;4037
000026  780e              LDRB     r6,[r1,#0]            ;4039
000028  2e30              CMP      r6,#0x30              ;4039
00002a  db08              BLT      |L36.62|
00002c  780e              LDRB     r6,[r1,#0]            ;4039
00002e  2e39              CMP      r6,#0x39              ;4039
000030  dc05              BGT      |L36.62|
000032  1c8e              ADDS     r6,r1,#2              ;4039
000034  4296              CMP      r6,r2                 ;4039
000036  d102              BNE      |L36.62|
000038  780e              LDRB     r6,[r1,#0]            ;4041
00003a  f1a60530          SUB      r5,r6,#0x30           ;4041
                  |L36.62|
00003e  2d01              CMP      r5,#1                 ;4063
000040  da01              BGE      |L36.70|
000042  4628              MOV      r0,r5                 ;4065
000044  6022              STR      r2,[r4,#0]            ;4066
                  |L36.70|
000046  e7e3              B        |L36.16|
                  |L36.72|
000048  2000              MOVS     r0,#0                 ;4101
00004a  bf00              NOP                            ;4103
00004c  e7e0              B        |L36.16|
;;;4105   
                          ENDP


                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;2256   *******************************************************************************/
;;;2257   static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
000000  b570              PUSH     {r4-r6,lr}
;;;2258   	FATFS* fs,			/* Pointer to the fs object */
;;;2259   	const BYTE* dir		/* Pointer to the key entry */
;;;2260   )
;;;2261   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2262   	DWORD cl;
;;;2263   
;;;2264   	cl = ld_word(dir + DIR_FstClusLO);
000006  f104001a          ADD      r0,r4,#0x1a
00000a  f7fffffe          BL       ld_word
00000e  4606              MOV      r6,r0
;;;2265   	if (fs->fs_type == FS_FAT32)
000010  7828              LDRB     r0,[r5,#0]
000012  2803              CMP      r0,#3
000014  d105              BNE      |L37.34|
;;;2266     {
;;;2267   		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
000016  f1040014          ADD      r0,r4,#0x14
00001a  f7fffffe          BL       ld_word
00001e  ea464600          ORR      r6,r6,r0,LSL #16
                  |L37.34|
;;;2268   	}
;;;2269   	return cl;
000022  4630              MOV      r0,r6
;;;2270   }
000024  bd70              POP      {r4-r6,pc}
;;;2271   
                          ENDP


                          AREA ||i.ld_dword||, CODE, READONLY, ALIGN=1

                  ld_dword PROC
;;;578    
;;;579    static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word *//*四个8位合并为32位*/
000000  4601              MOV      r1,r0
;;;580    {
;;;581    	DWORD rv;
;;;582    
;;;583    	rv = ptr[3];
000002  78c8              LDRB     r0,[r1,#3]
;;;584    	rv = rv << 8 | ptr[2];
000004  788a              LDRB     r2,[r1,#2]
000006  ea422000          ORR      r0,r2,r0,LSL #8
;;;585    	rv = rv << 8 | ptr[1];
00000a  784a              LDRB     r2,[r1,#1]
00000c  ea422000          ORR      r0,r2,r0,LSL #8
;;;586    	rv = rv << 8 | ptr[0];
000010  780a              LDRB     r2,[r1,#0]
000012  ea422000          ORR      r0,r2,r0,LSL #8
;;;587    	return rv;
;;;588    }
000016  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.ld_word||, CODE, READONLY, ALIGN=1

                  ld_word PROC
;;;569    
;;;570    static WORD ld_word (const BYTE* ptr)	/*Load a 2-byte little-endian word *//*两个8位合并为16位*/
000000  4601              MOV      r1,r0
;;;571    {
;;;572    	WORD rv;
;;;573    
;;;574    	rv = ptr[1];
000002  7848              LDRB     r0,[r1,#1]
;;;575    	rv = rv << 8 | ptr[0];
000004  780a              LDRB     r2,[r1,#0]
000006  ea422000          ORR      r0,r2,r0,LSL #8
;;;576    	return rv;
;;;577    }
00000a  4770              BX       lr
;;;578    
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;666    /* Compare memory block *//*内存比较memcmp*/
;;;667    static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
000000  b5f0              PUSH     {r4-r7,lr}
;;;668    {
000002  4603              MOV      r3,r0
;;;669    	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
000004  461d              MOV      r5,r3
000006  460c              MOV      r4,r1
;;;670    	int r = 0;
000008  2000              MOVS     r0,#0
;;;671    	do
00000a  bf00              NOP      
                  |L40.12|
;;;672      {
;;;673    		r = *d++ - *s++;
00000c  f8157b01          LDRB     r7,[r5],#1
000010  f814cb01          LDRB     r12,[r4],#1
000014  eba7000c          SUB      r0,r7,r12
;;;674    	}while (--cnt && r == 0);
000018  1e56              SUBS     r6,r2,#1
00001a  1e32              SUBS     r2,r6,#0
00001c  d001              BEQ      |L40.34|
00001e  2800              CMP      r0,#0
000020  d0f4              BEQ      |L40.12|
                  |L40.34|
;;;675    	return r;
;;;676    }
000022  bdf0              POP      {r4-r7,pc}
;;;677    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;643    /* Copy memory to memory *//*内存拷贝memcpy*/
;;;644    static void mem_cpy (void* dst, const void* src, UINT cnt)
000000  b530              PUSH     {r4,r5,lr}
;;;645    {
;;;646    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;647    	const BYTE *s = (const BYTE*)src;
000004  460c              MOV      r4,r1
;;;648    
;;;649    	if (cnt != 0)
000006  b13a              CBZ      r2,|L41.24|
;;;650       {
;;;651    		do
000008  bf00              NOP      
                  |L41.10|
;;;652        {
;;;653    			*d++ = *s++;
00000a  f8145b01          LDRB     r5,[r4],#1
00000e  f8035b01          STRB     r5,[r3],#1
;;;654    		}while (--cnt);
000012  1e55              SUBS     r5,r2,#1
000014  1e2a              SUBS     r2,r5,#0
000016  d1f8              BNE      |L41.10|
                  |L41.24|
;;;655    	}
;;;656    }
000018  bd30              POP      {r4,r5,pc}
;;;657    /* Fill memory block*//*内存填充memset*/
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;657    /* Fill memory block*//*内存填充memset*/
;;;658    static void mem_set (void* dst, int val, UINT cnt)
000000  b510              PUSH     {r4,lr}
;;;659    {
;;;660    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;661    	do
000004  bf00              NOP      
                  |L42.6|
;;;662       {
;;;663    		*d++ = (BYTE)val;
000006  f8031b01          STRB     r1,[r3],#1
;;;664    	} while (--cnt);
00000a  1e54              SUBS     r4,r2,#1
00000c  1e22              SUBS     r2,r4,#0
00000e  d1fa              BNE      |L42.6|
;;;665    }
000010  bd10              POP      {r4,pc}
;;;666    /* Compare memory block *//*内存比较memcmp*/
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;1191   *******************************************************************************/
;;;1192   static FRESULT move_window (	      /* Returns FR_OK or FR_DISK_ERR */
000000  b570              PUSH     {r4-r6,lr}
;;;1193                       FATFS* fs,			/* Filesystem object */
;;;1194                       DWORD sector		/* Sector number to make appearance in the fs->win[] */
;;;1195   )
;;;1196   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1197   	FRESULT res = FR_OK;    //文件函数执行结果返回码
000006  2600              MOVS     r6,#0
;;;1198   
;;;1199   	if (sector != fs->winsect)  /* Window offset changed? */
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  42a8              CMP      r0,r5
00000c  d010              BEQ      |L43.48|
;;;1200     {	
;;;1201   #if !FF_FS_READONLY     //未定义只读
;;;1202   		res = sync_window(fs);		/* Write-back changes */  //在文件系统对象中移动/刷新磁盘访问窗口（检查是否有未完成的写操作及完成写操作）
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sync_window
000014  4606              MOV      r6,r0
;;;1203   #endif
;;;1204   		if (res == FR_OK) /* Fill sector window with new data */
000016  b95e              CBNZ     r6,|L43.48|
;;;1205       {			
;;;1206   			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK)    //检查当前扇区是否可用
000018  7860              LDRB     r0,[r4,#1]
00001a  2301              MOVS     r3,#1
00001c  462a              MOV      r2,r5
00001e  f1040130          ADD      r1,r4,#0x30
000022  f7fffffe          BL       disk_read
000026  b110              CBZ      r0,|L43.46|
;;;1207         {
;;;1208   				sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
000028  f04f35ff          MOV      r5,#0xffffffff
;;;1209   				res = FR_DISK_ERR;
00002c  2601              MOVS     r6,#1
                  |L43.46|
;;;1210   			}
;;;1211   			fs->winsect = sector;   //将系统当前工作扇区更新为输入的扇区地址
00002e  62e5              STR      r5,[r4,#0x2c]
                  |L43.48|
;;;1212   		}
;;;1213   	}
;;;1214   	return res;
000030  4630              MOV      r0,r6
;;;1215   }
000032  bd70              POP      {r4-r6,pc}
;;;1216   
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;1408   *******************************************************************************/
;;;1409   static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1410   	FATFS* fs,		/* Corresponding filesystem object */
;;;1411   	DWORD clst,		/* FAT index number (cluster number) to be changed */
;;;1412   	DWORD val	    /* New value to be set to the entry */
;;;1413   )
;;;1414   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1415   	UINT bc;
;;;1416   	BYTE *p;
;;;1417   	FRESULT res = FR_INT_ERR;   //文件函数执行结果返回码
00000a  f04f0902          MOV      r9,#2
;;;1418   
;;;1419   	if (clst >= 2 && clst < fs->n_fatent)   /* Check if in valid range */
00000e  2d02              CMP      r5,#2
000010  d374              BCC      |L44.252|
000012  6960              LDR      r0,[r4,#0x14]
000014  42a8              CMP      r0,r5
000016  d971              BLS      |L44.252|
;;;1420     {
;;;1421   		switch (fs->fs_type)
000018  7820              LDRB     r0,[r4,#0]
00001a  2801              CMP      r0,#1
00001c  d004              BEQ      |L44.40|
00001e  2802              CMP      r0,#2
000020  d049              BEQ      |L44.182|
000022  2803              CMP      r0,#3
000024  d10d              BNE      |L44.66|
000026  e05e              B        |L44.230|
                  |L44.40|
;;;1422       {
;;;1423         case  FS_FAT12 :
;;;1424               bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
000028  462f              MOV      r7,r5
00002a  eb070757          ADD      r7,r7,r7,LSR #1
;;;1425               res = move_window(fs, fs->fatbase + (bc / SS(fs)));
00002e  6a20              LDR      r0,[r4,#0x20]
000030  eb002157          ADD      r1,r0,r7,LSR #9
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       move_window
00003a  4681              MOV      r9,r0
;;;1426               if (res != FR_OK)
00003c  f1b90f00          CMP      r9,#0
000040  d000              BEQ      |L44.68|
                  |L44.66|
;;;1427             break;
000042  e075              B        |L44.304|
                  |L44.68|
;;;1428               p = fs->win + bc++ % SS(fs);
000044  4638              MOV      r0,r7
000046  1c7f              ADDS     r7,r7,#1
000048  f3c00108          UBFX     r1,r0,#0,#9
00004c  f1040030          ADD      r0,r4,#0x30
000050  eb010800          ADD      r8,r1,r0
;;;1429               *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
000054  f0050001          AND      r0,r5,#1
000058  b128              CBZ      r0,|L44.102|
00005a  b2f1              UXTB     r1,r6
00005c  f8980000          LDRB     r0,[r8,#0]
000060  f361101f          BFI      r0,r1,#4,#28
000064  e000              B        |L44.104|
                  |L44.102|
000066  4630              MOV      r0,r6
                  |L44.104|
000068  f8880000          STRB     r0,[r8,#0]
;;;1430               fs->wflag = 1;
00006c  2001              MOVS     r0,#1
00006e  70e0              STRB     r0,[r4,#3]
;;;1431               res = move_window(fs, fs->fatbase + (bc / SS(fs)));
000070  6a20              LDR      r0,[r4,#0x20]
000072  eb002157          ADD      r1,r0,r7,LSR #9
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       move_window
00007c  4681              MOV      r9,r0
;;;1432               if (res != FR_OK)
00007e  f1b90f00          CMP      r9,#0
000082  d000              BEQ      |L44.134|
;;;1433             break;
000084  e054              B        |L44.304|
                  |L44.134|
;;;1434               p = fs->win + bc % SS(fs);
000086  f3c70108          UBFX     r1,r7,#0,#9
00008a  f1040030          ADD      r0,r4,#0x30
00008e  eb010800          ADD      r8,r1,r0
;;;1435               *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
000092  f0050001          AND      r0,r5,#1
000096  b110              CBZ      r0,|L44.158|
000098  f3c61007          UBFX     r0,r6,#4,#8
00009c  e006              B        |L44.172|
                  |L44.158|
00009e  f8980000          LDRB     r0,[r8,#0]
0000a2  f00000f0          AND      r0,r0,#0xf0
0000a6  f3c62103          UBFX     r1,r6,#8,#4
0000aa  4308              ORRS     r0,r0,r1
                  |L44.172|
0000ac  f8880000          STRB     r0,[r8,#0]
;;;1436               fs->wflag = 1;
0000b0  2001              MOVS     r0,#1
0000b2  70e0              STRB     r0,[r4,#3]
;;;1437             break;
0000b4  e03c              B        |L44.304|
                  |L44.182|
;;;1438   
;;;1439         case  FS_FAT16 :
;;;1440               res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  eb002115          ADD      r1,r0,r5,LSR #8
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       move_window
0000c2  4681              MOV      r9,r0
;;;1441               if (res != FR_OK)
0000c4  f1b90f00          CMP      r9,#0
0000c8  d000              BEQ      |L44.204|
;;;1442             break;
0000ca  e031              B        |L44.304|
                  |L44.204|
;;;1443               st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
0000cc  b2b1              UXTH     r1,r6
0000ce  f24012ff          MOV      r2,#0x1ff
0000d2  ea020345          AND      r3,r2,r5,LSL #1
0000d6  f1040230          ADD      r2,r4,#0x30
0000da  1898              ADDS     r0,r3,r2
0000dc  f7fffffe          BL       st_word
;;;1444               fs->wflag = 1;
0000e0  2001              MOVS     r0,#1
0000e2  70e0              STRB     r0,[r4,#3]
;;;1445             break;
0000e4  e024              B        |L44.304|
                  |L44.230|
;;;1446   
;;;1447         case  FS_FAT32 :
;;;1448   #if FF_FS_EXFAT
;;;1449         case  FS_EXFAT :
;;;1450   #endif
;;;1451               res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
0000e6  6a20              LDR      r0,[r4,#0x20]
0000e8  eb0011d5          ADD      r1,r0,r5,LSR #7
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       move_window
0000f2  4681              MOV      r9,r0
;;;1452               if (res != FR_OK)
0000f4  f1b90f00          CMP      r9,#0
0000f8  d001              BEQ      |L44.254|
;;;1453             break;
0000fa  e019              B        |L44.304|
                  |L44.252|
0000fc  e019              B        |L44.306|
                  |L44.254|
;;;1454               if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT)
;;;1455               {
;;;1456                 val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
0000fe  f24011ff          MOV      r1,#0x1ff
000102  ea010285          AND      r2,r1,r5,LSL #2
000106  f1040130          ADD      r1,r4,#0x30
00010a  1850              ADDS     r0,r2,r1
00010c  f7fffffe          BL       ld_dword
000110  f366001b          BFI      r0,r6,#0,#28
000114  4606              MOV      r6,r0
;;;1457               }
;;;1458               st_dword(fs->win + clst * 4 % SS(fs), val);
000116  f24011ff          MOV      r1,#0x1ff
00011a  ea010285          AND      r2,r1,r5,LSL #2
00011e  f1040130          ADD      r1,r4,#0x30
000122  1850              ADDS     r0,r2,r1
000124  4631              MOV      r1,r6
000126  f7fffffe          BL       st_dword
;;;1459               fs->wflag = 1;
00012a  2001              MOVS     r0,#1
00012c  70e0              STRB     r0,[r4,#3]
;;;1460             break;
00012e  bf00              NOP      
                  |L44.304|
000130  bf00              NOP                            ;1427
                  |L44.306|
;;;1461       }
;;;1462   	}
;;;1463   	return res;
000132  4648              MOV      r0,r9
;;;1464   }
000134  e8bd87f0          POP      {r4-r10,pc}
;;;1465   
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;1673   *******************************************************************************/
;;;1674   static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1675   	FFOBJID* obj,		/* Corresponding object */
;;;1676   	DWORD clst,			/* Cluster to remove a chain from */
;;;1677   	DWORD pclst			/* Previous cluster of clst (0:entire chain) */
;;;1678   )
;;;1679   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1680     FRESULT res = FR_OK;    //文件函数执行结果返回码
00000a  f04f0800          MOV      r8,#0
;;;1681   	DWORD nxt;
;;;1682   	FATFS *fs = obj->fs;
00000e  f8d94000          LDR      r4,[r9,#0]
;;;1683   #if FF_FS_EXFAT || FF_USE_TRIM
;;;1684   	DWORD scl = clst, ecl = clst;
;;;1685   #endif
;;;1686   #if FF_USE_TRIM
;;;1687   	DWORD rt[2];
;;;1688   #endif
;;;1689   
;;;1690   	if (clst < 2 || clst >= fs->n_fatent) /* Check if in valid range */
000012  2e02              CMP      r6,#2
000014  d302              BCC      |L45.28|
000016  6960              LDR      r0,[r4,#0x14]
000018  42b0              CMP      r0,r6
00001a  d802              BHI      |L45.34|
                  |L45.28|
;;;1691       return FR_INT_ERR;	
00001c  2002              MOVS     r0,#2
                  |L45.30|
;;;1692   
;;;1693   	/* Mark the previous cluster 'EOC' on the FAT if it exists */
;;;1694   	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2))
;;;1695     {
;;;1696   		res = put_fat(fs, pclst, 0xFFFFFFFF);
;;;1697   		if (res != FR_OK)
;;;1698         return res;
;;;1699   	}
;;;1700   
;;;1701   	/* Remove the chain */
;;;1702   	do 
;;;1703     {
;;;1704   		nxt = get_fat(obj, clst);			/* Get cluster status */
;;;1705   		if (nxt == 0)   /* Empty cluster? */
;;;1706         break;				
;;;1707   		if (nxt == 1)   /* Internal error? */
;;;1708         return FR_INT_ERR;	
;;;1709   		if (nxt == 0xFFFFFFFF)  /* Disk error? */
;;;1710         return FR_DISK_ERR;	
;;;1711   		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT)
;;;1712       {
;;;1713   			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
;;;1714   			if (res != FR_OK)
;;;1715           return res;
;;;1716   		}
;;;1717   		if (fs->free_clst < fs->n_fatent - 2) /* Update FSINFO */
;;;1718       {	
;;;1719   			fs->free_clst++;
;;;1720   			fs->fsi_flag |= 1;
;;;1721   		}
;;;1722   #if FF_FS_EXFAT || FF_USE_TRIM
;;;1723   		if (ecl + 1 == nxt) /* Is next cluster contiguous? */
;;;1724       {	
;;;1725   			ecl = nxt;
;;;1726   		}
;;;1727       else  /* End of contiguous cluster block */
;;;1728       {				
;;;1729   #if FF_FS_EXFAT
;;;1730   			if (fs->fs_type == FS_EXFAT)
;;;1731         {
;;;1732   				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
;;;1733   				if (res != FR_OK)
;;;1734             return res;
;;;1735   			}
;;;1736   #endif
;;;1737   #if FF_USE_TRIM
;;;1738   			rt[0] = clst2sect(fs, scl);					/* Start of data area freed */
;;;1739   			rt[1] = clst2sect(fs, ecl) + fs->csize - 1;	/* End of data area freed */
;;;1740   			disk_ioctl(fs->pdrv, CTRL_TRIM, rt);		/* Inform device the data in the block is no longer needed */
;;;1741   #endif
;;;1742   			scl = ecl = nxt;
;;;1743   		}
;;;1744   #endif
;;;1745   		clst = nxt;					/* Next cluster */
;;;1746   	}while (clst < fs->n_fatent);	/* Repeat while not the last link */
;;;1747   
;;;1748   #if FF_FS_EXFAT
;;;1749   	/* Some post processes for chain status */
;;;1750   	if (fs->fs_type == FS_EXFAT)
;;;1751     {
;;;1752   		if (pclst == 0)   /* Has the entire chain been removed? */
;;;1753       {	
;;;1754   			obj->stat = 0;  /* Change the chain status 'initial' */
;;;1755   		}
;;;1756       else
;;;1757       {
;;;1758   			if (obj->stat == 0) /* Is it a fragmented chain from the beginning of this session? */
;;;1759         {	
;;;1760   				clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
;;;1761   				while (clst != pclst)
;;;1762           {
;;;1763   					nxt = get_fat(obj, clst);
;;;1764   					if (nxt < 2)
;;;1765               return FR_INT_ERR;
;;;1766   					if (nxt == 0xFFFFFFFF)
;;;1767               return FR_DISK_ERR;
;;;1768   					if (nxt != clst + 1)  /* Not contiguous? */
;;;1769               break;	
;;;1770   					clst++;
;;;1771   				}
;;;1772   				if (clst == pclst)  /* Has the chain got contiguous again? */
;;;1773           {	
;;;1774   					obj->stat = 2;		/* Change the chain status 'contiguous' */
;;;1775   				}
;;;1776   			}
;;;1777         else
;;;1778         {
;;;1779   				if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) /* Was the chain fragmented in this session and got contiguous again? */
;;;1780           {	
;;;1781   					obj->stat = 2;	/* Change the chain status 'contiguous' */
;;;1782   				}
;;;1783   			}
;;;1784   		}
;;;1785   	}
;;;1786   #endif
;;;1787   	return FR_OK;
;;;1788   }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L45.34|
000022  b167              CBZ      r7,|L45.62|
000024  bf00              NOP                            ;1694
000026  f04f32ff          MOV      r2,#0xffffffff        ;1696
00002a  4639              MOV      r1,r7                 ;1696
00002c  4620              MOV      r0,r4                 ;1696
00002e  f7fffffe          BL       put_fat
000032  4680              MOV      r8,r0                 ;1696
000034  f1b80f00          CMP      r8,#0                 ;1697
000038  d001              BEQ      |L45.62|
00003a  4640              MOV      r0,r8                 ;1698
00003c  e7ef              B        |L45.30|
                  |L45.62|
00003e  bf00              NOP                            ;1702
                  |L45.64|
000040  4631              MOV      r1,r6                 ;1704
000042  4648              MOV      r0,r9                 ;1704
000044  f7fffffe          BL       get_fat
000048  4605              MOV      r5,r0                 ;1704
00004a  b905              CBNZ     r5,|L45.78|
00004c  e022              B        |L45.148|
                  |L45.78|
00004e  2d01              CMP      r5,#1                 ;1707
000050  d101              BNE      |L45.86|
000052  2002              MOVS     r0,#2                 ;1708
000054  e7e3              B        |L45.30|
                  |L45.86|
000056  1c68              ADDS     r0,r5,#1              ;1709
000058  b908              CBNZ     r0,|L45.94|
00005a  2001              MOVS     r0,#1                 ;1710
00005c  e7df              B        |L45.30|
                  |L45.94|
00005e  2200              MOVS     r2,#0                 ;1713
000060  4631              MOV      r1,r6                 ;1713
000062  4620              MOV      r0,r4                 ;1713
000064  f7fffffe          BL       put_fat
000068  4680              MOV      r8,r0                 ;1713
00006a  f1b80f00          CMP      r8,#0                 ;1714
00006e  d001              BEQ      |L45.116|
000070  4640              MOV      r0,r8                 ;1715
000072  e7d4              B        |L45.30|
                  |L45.116|
000074  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;1717
000078  1e80              SUBS     r0,r0,#2              ;1717
00007a  4281              CMP      r1,r0                 ;1717
00007c  d206              BCS      |L45.140|
00007e  6920              LDR      r0,[r4,#0x10]         ;1719
000080  1c40              ADDS     r0,r0,#1              ;1719
000082  6120              STR      r0,[r4,#0x10]         ;1719
000084  7920              LDRB     r0,[r4,#4]            ;1720
000086  f0400001          ORR      r0,r0,#1              ;1720
00008a  7120              STRB     r0,[r4,#4]            ;1720
                  |L45.140|
00008c  462e              MOV      r6,r5                 ;1745
00008e  6960              LDR      r0,[r4,#0x14]         ;1746
000090  42b0              CMP      r0,r6                 ;1746
000092  d8d5              BHI      |L45.64|
                  |L45.148|
000094  bf00              NOP                            ;1706
000096  2000              MOVS     r0,#0                 ;1787
000098  e7c1              B        |L45.30|
;;;1789   
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;2273   #if !FF_FS_READONLY
;;;2274   static void st_clust (
000000  b570              PUSH     {r4-r6,lr}
;;;2275   	FATFS* fs,	/* Pointer to the fs object */
;;;2276   	BYTE* dir,	/* Pointer to the key entry */
;;;2277   	DWORD cl	/* Value to be set */
;;;2278   )
;;;2279   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;2280   	st_word(dir + DIR_FstClusLO, (WORD)cl);
000008  b2a9              UXTH     r1,r5
00000a  f104001a          ADD      r0,r4,#0x1a
00000e  f7fffffe          BL       st_word
;;;2281   	if (fs->fs_type == FS_FAT32)
000012  7830              LDRB     r0,[r6,#0]
000014  2803              CMP      r0,#3
000016  d104              BNE      |L46.34|
;;;2282     {
;;;2283   		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
000018  0c29              LSRS     r1,r5,#16
00001a  f1040014          ADD      r0,r4,#0x14
00001e  f7fffffe          BL       st_word
                  |L46.34|
;;;2284   	}
;;;2285   }
000022  bd70              POP      {r4-r6,pc}
;;;2286   #endif
                          ENDP


                          AREA ||i.st_dword||, CODE, READONLY, ALIGN=1

                  st_dword PROC
;;;613    
;;;614    static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian *//*32位拆分为四个8位*/
000000  f8001b01          STRB     r1,[r0],#1
;;;615    {
;;;616    	*ptr++ = (BYTE)val; val >>= 8;
000004  0a09              LSRS     r1,r1,#8
;;;617    	*ptr++ = (BYTE)val; val >>= 8;
000006  f8001b01          STRB     r1,[r0],#1
00000a  0a09              LSRS     r1,r1,#8
;;;618    	*ptr++ = (BYTE)val; val >>= 8;
00000c  f8001b01          STRB     r1,[r0],#1
000010  0a09              LSRS     r1,r1,#8
;;;619    	*ptr++ = (BYTE)val;
000012  f8001b01          STRB     r1,[r0],#1
;;;620    }
000016  4770              BX       lr
;;;621    
                          ENDP


                          AREA ||i.st_word||, CODE, READONLY, ALIGN=1

                  st_word PROC
;;;607    #if !FF_FS_READONLY
;;;608    static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian *//*16位拆分为两个8位*/
000000  f8001b01          STRB     r1,[r0],#1
;;;609    {
;;;610    	*ptr++ = (BYTE)val; val >>= 8;
000004  1209              ASRS     r1,r1,#8
;;;611    	*ptr++ = (BYTE)val;
000006  f8001b01          STRB     r1,[r0],#1
;;;612    }
00000a  4770              BX       lr
;;;613    
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=2

                  sync_fs PROC
;;;1232   *******************************************************************************/
;;;1233   static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
000000  b570              PUSH     {r4-r6,lr}
;;;1234   	FATFS* fs		/* Filesystem object */
;;;1235   )
;;;1236   {
000002  4604              MOV      r4,r0
;;;1237   	FRESULT res;    //文件函数执行结果返回码
;;;1238   
;;;1239   
;;;1240   	res = sync_window(fs);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       sync_window
00000a  4605              MOV      r5,r0
;;;1241   	if (res == FR_OK)
00000c  2d00              CMP      r5,#0
00000e  d138              BNE      |L49.130|
;;;1242     {
;;;1243   		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) /* FAT32: Update FSInfo sector if needed */
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d12e              BNE      |L49.116|
000016  7920              LDRB     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d12b              BNE      |L49.116|
;;;1244       {
;;;1245   			/* Create FSInfo structure */
;;;1246   			mem_set(fs->win, 0, SS(fs));
00001c  0242              LSLS     r2,r0,#9
00001e  2100              MOVS     r1,#0
000020  f1040030          ADD      r0,r4,#0x30
000024  f7fffffe          BL       mem_set
;;;1247   			st_word(fs->win + BS_55AA, 0xAA55);
000028  f64a2155          MOV      r1,#0xaa55
00002c  f204202e          ADD      r0,r4,#0x22e
000030  f7fffffe          BL       st_word
;;;1248   			st_dword(fs->win + FSI_LeadSig, 0x41615252);
000034  4914              LDR      r1,|L49.136|
000036  f1040030          ADD      r0,r4,#0x30
00003a  f7fffffe          BL       st_dword
;;;1249   			st_dword(fs->win + FSI_StrucSig, 0x61417272);
00003e  4913              LDR      r1,|L49.140|
000040  f5047005          ADD      r0,r4,#0x214
000044  f7fffffe          BL       st_dword
;;;1250   			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
000048  f5047006          ADD      r0,r4,#0x218
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f7fffffe          BL       st_dword
;;;1251   			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
000052  f5047007          ADD      r0,r4,#0x21c
000056  68e1              LDR      r1,[r4,#0xc]
000058  f7fffffe          BL       st_dword
;;;1252   			/* Write it into the FSInfo sector */
;;;1253   			fs->winsect = fs->volbase + 1;
00005c  69e0              LDR      r0,[r4,#0x1c]
00005e  1c40              ADDS     r0,r0,#1
000060  62e0              STR      r0,[r4,#0x2c]
;;;1254   			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
000062  7860              LDRB     r0,[r4,#1]
000064  2301              MOVS     r3,#1
000066  f1040130          ADD      r1,r4,#0x30
00006a  6ae2              LDR      r2,[r4,#0x2c]
00006c  f7fffffe          BL       disk_write
;;;1255   			fs->fsi_flag = 0;
000070  2000              MOVS     r0,#0
000072  7120              STRB     r0,[r4,#4]
                  |L49.116|
;;;1256   		}
;;;1257   		/* Make sure that no pending write process in the lower layer */
;;;1258   		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK)
000074  7860              LDRB     r0,[r4,#1]
000076  2200              MOVS     r2,#0
000078  4611              MOV      r1,r2
00007a  f7fffffe          BL       disk_ioctl
00007e  b100              CBZ      r0,|L49.130|
;;;1259         res = FR_DISK_ERR;
000080  2501              MOVS     r5,#1
                  |L49.130|
;;;1260   	}
;;;1261   	return res;
000082  4628              MOV      r0,r5
;;;1262   }
000084  bd70              POP      {r4-r6,pc}
;;;1263   
                          ENDP

000086  0000              DCW      0x0000
                  |L49.136|
                          DCD      0x41615252
                  |L49.140|
                          DCD      0x61417272

                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;1150   #if !FF_FS_READONLY
;;;1151   static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
000000  b570              PUSH     {r4-r6,lr}
;;;1152                               FATFS* fs			/* Filesystem object */
;;;1153   )
;;;1154   {
000002  4604              MOV      r4,r0
;;;1155   	FRESULT res = FR_OK;    //文件函数执行结果返回码
000004  2500              MOVS     r5,#0
;;;1156   
;;;1157   
;;;1158   	if (fs->wflag)  /* Is the disk access window dirty */   //磁盘是否有碎片
000006  78e0              LDRB     r0,[r4,#3]
000008  b1e8              CBZ      r0,|L50.70|
;;;1159     {
;;;1160   		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK)  /* Write back the window */
00000a  7860              LDRB     r0,[r4,#1]
00000c  2301              MOVS     r3,#1
00000e  f1040130          ADD      r1,r4,#0x30
000012  6ae2              LDR      r2,[r4,#0x2c]
000014  f7fffffe          BL       disk_write
000018  b9a0              CBNZ     r0,|L50.68|
;;;1161       {	
;;;1162   			fs->wflag = 0;	/* Clear window dirty flag */
00001a  2000              MOVS     r0,#0
00001c  70e0              STRB     r0,[r4,#3]
;;;1163   			if (fs->winsect - fs->fatbase < fs->fsize)  /* Is it in the 1st FAT? */
00001e  6a21              LDR      r1,[r4,#0x20]
000020  6ae0              LDR      r0,[r4,#0x2c]
000022  1a40              SUBS     r0,r0,r1
000024  69a1              LDR      r1,[r4,#0x18]
000026  4288              CMP      r0,r1
000028  d20d              BCS      |L50.70|
;;;1164         {	
;;;1165   				if (fs->n_fats == 2)
00002a  78a0              LDRB     r0,[r4,#2]
00002c  2802              CMP      r0,#2
00002e  d10a              BNE      |L50.70|
;;;1166             disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
000030  69a3              LDR      r3,[r4,#0x18]
000032  6ae1              LDR      r1,[r4,#0x2c]
000034  18ca              ADDS     r2,r1,r3
000036  7860              LDRB     r0,[r4,#1]
000038  2301              MOVS     r3,#1
00003a  f1040130          ADD      r1,r4,#0x30
00003e  f7fffffe          BL       disk_write
000042  e000              B        |L50.70|
                  |L50.68|
;;;1167   			}
;;;1168   		}
;;;1169       else
;;;1170       {
;;;1171   			res = FR_DISK_ERR;
000044  2501              MOVS     r5,#1
                  |L50.70|
;;;1172   		}
;;;1173   	}
;;;1174   	return res;
000046  4628              MOV      r0,r5
;;;1175   }
000048  bd70              POP      {r4-r6,pc}
;;;1176   #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;4440   *******************************************************************************/
;;;4441   static FRESULT    validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
000000  b570              PUSH     {r4-r6,lr}
;;;4442           FFOBJID*  obj,			  /* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
;;;4443           FATFS**   rfs				  /* Pointer to pointer to the owner filesystem object to return */
;;;4444   )
;;;4445   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4446   	FRESULT res = FR_INVALID_OBJECT;    //文件函数执行结果返回码
000006  2609              MOVS     r6,#9
;;;4447   
;;;4448   	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) /* Test if the object is valid */
000008  b18c              CBZ      r4,|L51.46|
00000a  6820              LDR      r0,[r4,#0]
00000c  b178              CBZ      r0,|L51.46|
00000e  6820              LDR      r0,[r4,#0]
000010  7800              LDRB     r0,[r0,#0]
000012  b160              CBZ      r0,|L51.46|
000014  88a0              LDRH     r0,[r4,#4]
000016  6821              LDR      r1,[r4,#0]
000018  88c9              LDRH     r1,[r1,#6]
00001a  4288              CMP      r0,r1
00001c  d107              BNE      |L51.46|
;;;4449     {	
;;;4450   #if FF_FS_REENTRANT
;;;4451   		if (lock_fs(obj->fs))   //获取文件系统同步对象，不成功返回超时，成功，继续执行。
;;;4452       {	/* Obtain the filesystem object */
;;;4453   			if (!(disk_status(obj->fs->pdrv) & STA_NOINIT))  /* Test if the phsical drive is kept initialized */
;;;4454         {
;;;4455   				res = FR_OK;
;;;4456   			} 
;;;4457         else 
;;;4458         {        
;;;4459   				unlock_fs(obj->fs, FR_OK);
;;;4460   			}
;;;4461   		} 
;;;4462       else 
;;;4463       {
;;;4464   			res = FR_TIMEOUT;
;;;4465   		}
;;;4466   #else
;;;4467   		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
00001e  6821              LDR      r1,[r4,#0]
000020  7848              LDRB     r0,[r1,#1]
000022  f7fffffe          BL       disk_status
000026  f0000001          AND      r0,r0,#1
00002a  b900              CBNZ     r0,|L51.46|
;;;4468   			res = FR_OK;
00002c  2600              MOVS     r6,#0
                  |L51.46|
;;;4469   		}
;;;4470   #endif
;;;4471   	}
;;;4472   	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
00002e  b90e              CBNZ     r6,|L51.52|
000030  6820              LDR      r0,[r4,#0]
000032  e000              B        |L51.54|
                  |L51.52|
000034  2000              MOVS     r0,#0
                  |L51.54|
000036  6028              STR      r0,[r5,#0]
;;;4473   	return res;
000038  4630              MOV      r0,r6
;;;4474   }
00003a  bd70              POP      {r4-r6,pc}
;;;4475   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DbcTbl
000000  819fe0fc          DCB      0x81,0x9f,0xe0,0xfc
000004  407e80fc          DCB      0x40,0x7e,0x80,0xfc
000008  0000              DCB      0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  FatFs
                          DCD      0x00000000
                  Fsid
000004  0000              DCB      0x00,0x00
