; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\stm32f10x_adc.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\stm32f10x_adc.crf ..\..\Library\STM32F10x_StdPeriph_Driver\SCR\stm32f10x_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;1153   *******************************************************************************/
;;;1154   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
000000  460a              MOV      r2,r1
;;;1155   {
;;;1156     u32 tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;1157   
;;;1158     /* Check the parameters */
;;;1159     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1160     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1161   
;;;1162     /* Get the old register value */
;;;1163     tmpreg = ADCx->CR1;
000004  6841              LDR      r1,[r0,#4]
;;;1164     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1165     tmpreg &= CR1_AWDMode_Reset;
000006  4b02              LDR      r3,|L1.16|
000008  4019              ANDS     r1,r1,r3
;;;1166     /* Set the analog watchdog enable mode */
;;;1167     tmpreg |= ADC_AnalogWatchdog;
00000a  4311              ORRS     r1,r1,r2
;;;1168     /* Store the new register value */
;;;1169     ADCx->CR1 = tmpreg;
00000c  6041              STR      r1,[r0,#4]
;;;1170   }
00000e  4770              BX       lr
;;;1171   
                          ENDP

                  |L1.16|
                          DCD      0xff3ffdff

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1224   *******************************************************************************/
;;;1225   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
000000  460a              MOV      r2,r1
;;;1226   {
;;;1227     u32 tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;1228   
;;;1229     /* Check the parameters */
;;;1230     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1231     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1232   
;;;1233     /* Get the old register value */
;;;1234     tmpreg = ADCx->CR1;
000004  6841              LDR      r1,[r0,#4]
;;;1235     /* Clear the Analog watchdog channel select bits */
;;;1236     tmpreg &= CR1_AWDCH_Reset;
000006  f021011f          BIC      r1,r1,#0x1f
;;;1237     /* Set the Analog watchdog channel */
;;;1238     tmpreg |= ADC_Channel;
00000a  4311              ORRS     r1,r1,r2
;;;1239     /* Store the new register value */
;;;1240     ADCx->CR1 = tmpreg;
00000c  6041              STR      r1,[r0,#4]
;;;1241   }
00000e  4770              BX       lr
;;;1242   
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1182   *******************************************************************************/
;;;1183   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
000000  6241              STR      r1,[r0,#0x24]
;;;1184                                           u16 LowThreshold)
;;;1185   {
;;;1186     /* Check the parameters */
;;;1187     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1188     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1189     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1190   
;;;1191     /* Set the ADCx high threshold */
;;;1192     ADCx->HTR = HighThreshold;
;;;1193     /* Set the ADCx low threshold */
;;;1194     ADCx->LTR = LowThreshold;
000002  6282              STR      r2,[r0,#0x28]
;;;1195   }
000004  4770              BX       lr
;;;1196   
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;757    *******************************************************************************/
;;;758    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;759    {
;;;760      /* Check the parameters */
;;;761      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;762      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;763    
;;;764      if (NewState != DISABLE)
;;;765      {
;;;766        /* Enable the selected ADC automatic injected group conversion */
;;;767        ADCx->CR1 |= CR1_JAUTO_Set;
000002  6842              LDR      r2,[r0,#4]
000004  f4426280          ORR      r2,r2,#0x400
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;768      }
;;;769      else
;;;770      {
;;;771        /* Disable the selected ADC automatic injected group conversion */
;;;772        ADCx->CR1 &= CR1_JAUTO_Reset;
00000c  6842              LDR      r2,[r0,#4]
00000e  f4226280          BIC      r2,r2,#0x400
000012  6042              STR      r2,[r0,#4]
                  |L4.20|
;;;773      }
;;;774    }
000014  4770              BX       lr
;;;775    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1319   *******************************************************************************/
;;;1320   void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
000000  43ca              MVNS     r2,r1
;;;1321   {
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1324     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1325   
;;;1326     /* Clear the selected ADC flags */
;;;1327     ADCx->SR = ~(u32)ADC_FLAG;
000002  6002              STR      r2,[r0,#0]
;;;1328   }
000004  4770              BX       lr
;;;1329   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1384   *******************************************************************************/
;;;1385   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
000000  2200              MOVS     r2,#0
;;;1386   {
;;;1387     u8 itmask = 0;
;;;1388   
;;;1389     /* Check the parameters */
;;;1390     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1391     assert_param(IS_ADC_IT(ADC_IT));
;;;1392   
;;;1393     /* Get the ADC IT index */
;;;1394     itmask = (u8)(ADC_IT >> 8);
000002  120a              ASRS     r2,r1,#8
;;;1395   
;;;1396     /* Clear the selected ADC interrupt pending bits */
;;;1397     ADCx->SR = ~(u32)itmask;
000004  43d3              MVNS     r3,r2
000006  6003              STR      r3,[r0,#0]
;;;1398   }
000008  4770              BX       lr
;;;1399   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;265    *******************************************************************************/
;;;266    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L7.12|
;;;267    {
;;;268      /* Check the parameters */
;;;269      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;270      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;271    
;;;272      if (NewState != DISABLE)
;;;273      {
;;;274        /* Set the ADON bit to wake up the ADC from power down mode */
;;;275        ADCx->CR2 |= CR2_ADON_Set;
000002  6882              LDR      r2,[r0,#8]
000004  f0420201          ORR      r2,r2,#1
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L7.20|
                  |L7.12|
;;;276      }
;;;277      else
;;;278      {
;;;279        /* Disable the selected ADC peripheral */
;;;280        ADCx->CR2 &= CR2_ADON_Reset;
00000c  6882              LDR      r2,[r0,#8]
00000e  f0220201          BIC      r2,r2,#1
000012  6082              STR      r2,[r0,#8]
                  |L7.20|
;;;281      }
;;;282    }
000014  4770              BX       lr
;;;283    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;293    *******************************************************************************/
;;;294    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;298      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;299    
;;;300      if (NewState != DISABLE)
;;;301      {
;;;302        /* Enable the selected ADC DMA request */
;;;303        ADCx->CR2 |= CR2_DMA_Set;
000002  6882              LDR      r2,[r0,#8]
000004  f4427280          ORR      r2,r2,#0x100
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L8.20|
                  |L8.12|
;;;304      }
;;;305      else
;;;306      {
;;;307        /* Disable the selected ADC DMA request */
;;;308        ADCx->CR2 &= CR2_DMA_Reset;
00000c  6882              LDR      r2,[r0,#8]
00000e  f4227280          BIC      r2,r2,#0x100
000012  6082              STR      r2,[r0,#8]
                  |L8.20|
;;;309      }
;;;310    }
000014  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;129    *******************************************************************************/
;;;130    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  4604              MOV      r4,r0
;;;132      /* Check the parameters */
;;;133      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;134    
;;;135      switch (*(u32*)&ADCx)
000004  4815              LDR      r0,|L9.92|
000006  4420              ADD      r0,r0,r4
000008  b130              CBZ      r0,|L9.24|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d00d              BEQ      |L9.44|
000010  f5b05fc0          CMP      r0,#0x1800
000014  d11e              BNE      |L9.84|
000016  e013              B        |L9.64|
                  |L9.24|
;;;136      {
;;;137        case ADC1_BASE:
;;;138          /* Enable ADC1 reset state */
;;;139          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  0248              LSLS     r0,r1,#9
00001c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;140          /* Release ADC1 from reset state */
;;;141          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000020  2100              MOVS     r1,#0
000022  f44f7000          MOV      r0,#0x200
000026  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;142          break;
00002a  e014              B        |L9.86|
                  |L9.44|
;;;143        
;;;144        case ADC2_BASE:
;;;145          /* Enable ADC2 reset state */
;;;146          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  0288              LSLS     r0,r1,#10
000030  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;147          /* Release ADC2 from reset state */
;;;148          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
000034  2100              MOVS     r1,#0
000036  f44f6080          MOV      r0,#0x400
00003a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;149          break;
00003e  e00a              B        |L9.86|
                  |L9.64|
;;;150          
;;;151        case ADC3_BASE:
;;;152          /* Enable ADC3 reset state */
;;;153          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000040  2101              MOVS     r1,#1
000042  03c8              LSLS     r0,r1,#15
000044  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;154          /* Release ADC3 from reset state */
;;;155          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
000048  2100              MOVS     r1,#0
00004a  f44f4000          MOV      r0,#0x8000
00004e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;156          break; 
000052  e000              B        |L9.86|
                  |L9.84|
;;;157    
;;;158        default:
;;;159          break;
000054  bf00              NOP      
                  |L9.86|
000056  bf00              NOP                            ;142
;;;160      }
;;;161    }
000058  bd10              POP      {r4,pc}
;;;162    
                          ENDP

00005a  0000              DCW      0x0000
                  |L9.92|
                          DCD      0xbffedc00

                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;510    *******************************************************************************/
;;;511    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
000000  b510              PUSH     {r4,lr}
;;;512    {
000002  460a              MOV      r2,r1
;;;513      u32 tmpreg1 = 0;
000004  2100              MOVS     r1,#0
;;;514      u32 tmpreg2 = 0;
000006  2300              MOVS     r3,#0
;;;515    
;;;516      /* Check the parameters */
;;;517      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;518      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;519    
;;;520      /* Get the old register value */
;;;521      tmpreg1 = ADCx->CR1;
000008  6841              LDR      r1,[r0,#4]
;;;522      /* Clear the old discontinuous mode channel count */
;;;523      tmpreg1 &= CR1_DISCNUM_Reset;
00000a  f4214160          BIC      r1,r1,#0xe000
;;;524      /* Set the discontinuous mode channel count */
;;;525      tmpreg2 = Number - 1;
00000e  1e53              SUBS     r3,r2,#1
;;;526      tmpreg1 |= tmpreg2 << 13;
000010  ea413143          ORR      r1,r1,r3,LSL #13
;;;527      /* Store the new register value */
;;;528      ADCx->CR1 = tmpreg1;
000014  6041              STR      r1,[r0,#4]
;;;529    }
000016  bd10              POP      {r4,pc}
;;;530    
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;540    *******************************************************************************/
;;;541    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;542    {
;;;543      /* Check the parameters */
;;;544      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;545      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;546    
;;;547      if (NewState != DISABLE)
;;;548      {
;;;549        /* Enable the selected ADC regular discontinuous mode */
;;;550        ADCx->CR1 |= CR1_DISCEN_Set;
000002  6842              LDR      r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L11.20|
                  |L11.12|
;;;551      }
;;;552      else
;;;553      {
;;;554        /* Disable the selected ADC regular discontinuous mode */
;;;555        ADCx->CR1 &= CR1_DISCEN_Reset;
00000c  6842              LDR      r2,[r0,#4]
00000e  f4226200          BIC      r2,r2,#0x800
000012  6042              STR      r2,[r0,#4]
                  |L11.20|
;;;556      }
;;;557    }
000014  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.ADC_ExternalTrigConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigConvCmd PROC
;;;700    *******************************************************************************/
;;;701    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L12.12|
;;;702    {
;;;703      /* Check the parameters */
;;;704      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;705      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;706    
;;;707      if (NewState != DISABLE)
;;;708      {
;;;709        /* Enable the selected ADC conversion on external event */
;;;710        ADCx->CR2 |= CR2_EXTTRIG_Set;
000002  6882              LDR      r2,[r0,#8]
000004  f4421280          ORR      r2,r2,#0x100000
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L12.20|
                  |L12.12|
;;;711      }
;;;712      else
;;;713      {
;;;714        /* Disable the selected ADC conversion on external event */
;;;715        ADCx->CR2 &= CR2_EXTTRIG_Reset;
00000c  6882              LDR      r2,[r0,#8]
00000e  f4221280          BIC      r2,r2,#0x100000
000012  6082              STR      r2,[r0,#8]
                  |L12.20|
;;;716      }
;;;717    }
000014  4770              BX       lr
;;;718    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;871    *******************************************************************************/
;;;872    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;873    {
;;;874      /* Check the parameters */
;;;875      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;876      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;877    
;;;878      if (NewState != DISABLE)
;;;879      {
;;;880        /* Enable the selected ADC external event selection for injected group */
;;;881        ADCx->CR2 |= CR2_JEXTTRIG_Set;
000002  6882              LDR      r2,[r0,#8]
000004  f4424200          ORR      r2,r2,#0x8000
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L13.20|
                  |L13.12|
;;;882      }
;;;883      else
;;;884      {
;;;885        /* Disable the selected ADC external event selection for injected group */
;;;886        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
00000c  6882              LDR      r2,[r0,#8]
00000e  f4224200          BIC      r2,r2,#0x8000
000012  6082              STR      r2,[r0,#8]
                  |L13.20|
;;;887      }
;;;888    }
000014  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;842    *******************************************************************************/
;;;843    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
000000  460a              MOV      r2,r1
;;;844    {
;;;845      u32 tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;846    
;;;847      /* Check the parameters */
;;;848      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;849      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;850    
;;;851      /* Get the old register value */
;;;852      tmpreg = ADCx->CR2;
000004  6881              LDR      r1,[r0,#8]
;;;853      /* Clear the old external event selection for injected group */
;;;854      tmpreg &= CR2_JEXTSEL_Reset;
000006  f42141e0          BIC      r1,r1,#0x7000
;;;855      /* Set the external event selection for injected group */
;;;856      tmpreg |= ADC_ExternalTrigInjecConv;
00000a  4311              ORRS     r1,r1,r2
;;;857      /* Store the new register value */
;;;858      ADCx->CR2 = tmpreg;
00000c  6081              STR      r1,[r0,#8]
;;;859    }
00000e  4770              BX       lr
;;;860    
                          ENDP


                          AREA ||i.ADC_GetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationStatus PROC
;;;419    *******************************************************************************/
;;;420    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;421    {
;;;422      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;423    
;;;424      /* Check the parameters */
;;;425      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;426    
;;;427      /* Check the status of CAL bit */
;;;428      if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
000004  688a              LDR      r2,[r1,#8]
000006  f0020204          AND      r2,r2,#4
00000a  b10a              CBZ      r2,|L15.16|
;;;429      {
;;;430        /* CAL bit is set: calibration on going */
;;;431        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L15.18|
                  |L15.16|
;;;432      }
;;;433      else
;;;434      {
;;;435        /* CAL bit is reset: end of calibration */
;;;436        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L15.18|
;;;437      }
;;;438    
;;;439      /* Return the CAL bit status */
;;;440      return  bitstatus;
;;;441    }
000012  4770              BX       lr
;;;442    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;725    *******************************************************************************/
;;;726    u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;727    {
;;;728      /* Check the parameters */
;;;729      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;730    
;;;731      /* Return the selected ADC conversion value */
;;;732      return (u16) ADCx->DR;
000002  6cc8              LDR      r0,[r1,#0x4c]
000004  b280              UXTH     r0,r0
;;;733    }
000006  4770              BX       lr
;;;734    
                          ENDP


                          AREA ||i.ADC_GetDualModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetDualModeConversionValue PROC
;;;740    *******************************************************************************/
;;;741    u32 ADC_GetDualModeConversionValue(void)
000000  4801              LDR      r0,|L17.8|
;;;742    {
;;;743      /* Return the dual mode conversion value */
;;;744      return (*(vu32 *) DR_ADDRESS);
000002  6800              LDR      r0,[r0,#0]
;;;745    }
000004  4770              BX       lr
;;;746    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x4001244c

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1281   *******************************************************************************/
;;;1282   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1283   {
;;;1284     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1285   
;;;1286     /* Check the parameters */
;;;1287     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1288     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1289   
;;;1290     /* Check the status of the specified ADC flag */
;;;1291     if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
000004  6813              LDR      r3,[r2,#0]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L18.14|
;;;1292     {
;;;1293       /* ADC_FLAG is set */
;;;1294       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L18.16|
                  |L18.14|
;;;1295     }
;;;1296     else
;;;1297     {
;;;1298       /* ADC_FLAG is reset */
;;;1299       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L18.16|
;;;1300     }
;;;1301   
;;;1302     /* Return the ADC_FLAG status */
;;;1303     return  bitstatus;
;;;1304   }
000010  4770              BX       lr
;;;1305   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1341   *******************************************************************************/
;;;1342   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1343   {
000002  4602              MOV      r2,r0
;;;1344     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1345     u32 itmask = 0, enablestatus = 0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;1346   
;;;1347     /* Check the parameters */
;;;1348     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1349     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1350   
;;;1351     /* Get the ADC IT index */
;;;1352     itmask = ADC_IT >> 8;
00000a  120b              ASRS     r3,r1,#8
;;;1353   
;;;1354     /* Get the ADC_IT enable bit status */
;;;1355     enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
00000c  6855              LDR      r5,[r2,#4]
00000e  b2ce              UXTB     r6,r1
000010  ea050406          AND      r4,r5,r6
;;;1356   
;;;1357     /* Check the status of the specified ADC interrupt */
;;;1358     if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
000014  6815              LDR      r5,[r2,#0]
000016  401d              ANDS     r5,r5,r3
000018  b115              CBZ      r5,|L19.32|
00001a  b10c              CBZ      r4,|L19.32|
;;;1359     {
;;;1360       /* ADC_IT is set */
;;;1361       bitstatus = SET;
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L19.34|
                  |L19.32|
;;;1362     }
;;;1363     else
;;;1364     {
;;;1365       /* ADC_IT is reset */
;;;1366       bitstatus = RESET;
000020  2000              MOVS     r0,#0
                  |L19.34|
;;;1367     }
;;;1368   
;;;1369     /* Return the ADC_IT status */
;;;1370     return  bitstatus;
;;;1371   }
000022  bd70              POP      {r4-r6,pc}
;;;1372   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1119   *******************************************************************************/
;;;1120   u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
000000  4602              MOV      r2,r0
;;;1121   {
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1124     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1125   
;;;1126     /* Returns the selected injected channel conversion data value */
;;;1127     return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
000002  1850              ADDS     r0,r2,r1
000004  6a80              LDR      r0,[r0,#0x28]
000006  b280              UXTH     r0,r0
;;;1128   }
000008  4770              BX       lr
;;;1129   
                          ENDP


                          AREA ||i.ADC_GetResetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetResetCalibrationStatus PROC
;;;373    *******************************************************************************/
;;;374    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)	
000000  4601              MOV      r1,r0
;;;375    {
;;;376      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;377    
;;;378      /* Check the parameters */
;;;379      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;380    
;;;381      /* Check the status of RSTCAL bit */
;;;382      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
000004  688a              LDR      r2,[r1,#8]
000006  f0020208          AND      r2,r2,#8
00000a  b10a              CBZ      r2,|L21.16|
;;;383      {
;;;384        /* RSTCAL bit is set */
;;;385        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L21.18|
                  |L21.16|
;;;386      }
;;;387      else
;;;388      {
;;;389        /* RSTCAL bit is reset */
;;;390        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L21.18|
;;;391      }
;;;392    
;;;393      /* Return the RSTCAL bit status */
;;;394      return  bitstatus;
;;;395    }
000012  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;478    *******************************************************************************/
;;;479    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;480    {
;;;481      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;482    
;;;483      /* Check the parameters */
;;;484      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;485    
;;;486      /* Check the status of SWSTART bit */
;;;487      if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
000004  688a              LDR      r2,[r1,#8]
000006  f4020280          AND      r2,r2,#0x400000
00000a  b10a              CBZ      r2,|L22.16|
;;;488      {
;;;489        /* SWSTART bit is set */
;;;490        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L22.18|
                  |L22.16|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* SWSTART bit is reset */
;;;495        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L22.18|
;;;496      }
;;;497    
;;;498      /* Return the SWSTART bit status */
;;;499      return  bitstatus;
;;;500    }
000012  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;927    *******************************************************************************/
;;;928    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;929    {
;;;930      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;931    
;;;932      /* Check the parameters */
;;;933      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;934    
;;;935      /* Check the status of JSWSTART bit */
;;;936      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
000004  688a              LDR      r2,[r1,#8]
000006  f4021200          AND      r2,r2,#0x200000
00000a  b10a              CBZ      r2,|L23.16|
;;;937      {
;;;938        /* JSWSTART bit is set */
;;;939        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L23.18|
                  |L23.16|
;;;940      }
;;;941      else
;;;942      {
;;;943        /* JSWSTART bit is reset */
;;;944        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L23.18|
;;;945      }
;;;946    
;;;947      /* Return the JSWSTART bit status */
;;;948      return  bitstatus;
;;;949    }
000012  4770              BX       lr
;;;950    
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;326    *******************************************************************************/
;;;327    void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;328    {
;;;329      u8 itmask = 0;
000002  2300              MOVS     r3,#0
;;;330    
;;;331      /* Check the parameters */
;;;332      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;333      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;334      assert_param(IS_ADC_IT(ADC_IT));
;;;335    
;;;336      /* Get the ADC IT index */
;;;337      itmask = (u8)ADC_IT;
000004  b2cb              UXTB     r3,r1
;;;338    
;;;339      if (NewState != DISABLE)
000006  b11a              CBZ      r2,|L24.16|
;;;340      {
;;;341        /* Enable the selected ADC interrupts */
;;;342        ADCx->CR1 |= itmask;
000008  6844              LDR      r4,[r0,#4]
00000a  431c              ORRS     r4,r4,r3
00000c  6044              STR      r4,[r0,#4]
00000e  e002              B        |L24.22|
                  |L24.16|
;;;343      }
;;;344      else
;;;345      {
;;;346        /* Disable the selected ADC interrupts */
;;;347        ADCx->CR1 &= (~(u32)itmask);
000010  6844              LDR      r4,[r0,#4]
000012  439c              BICS     r4,r4,r3
000014  6044              STR      r4,[r0,#4]
                  |L24.22|
;;;348      }
;;;349    }
000016  bd10              POP      {r4,pc}
;;;350    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;173    ******************************************************************************/
;;;174    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;175    {
000002  4602              MOV      r2,r0
;;;176      u32 tmpreg1 = 0;
000004  2000              MOVS     r0,#0
;;;177      u8 tmpreg2 = 0;
000006  2300              MOVS     r3,#0
;;;178    
;;;179      /* Check the parameters */
;;;180      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;181      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;182      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;183      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
;;;184      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;185      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;186      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;187    
;;;188      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;189      /* Get the ADCx CR1 value */
;;;190      tmpreg1 = ADCx->CR1;
000008  6850              LDR      r0,[r2,#4]
;;;191      /* Clear DUALMOD and SCAN bits */
;;;192      tmpreg1 &= CR1_CLEAR_Mask;
00000a  4c0f              LDR      r4,|L25.72|
00000c  4020              ANDS     r0,r0,r4
;;;193      /* Configure ADCx: Dual mode and scan conversion mode */
;;;194      /* Set DUALMOD bits according to ADC_Mode value */
;;;195      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;196      tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
00000e  790d              LDRB     r5,[r1,#4]
000010  680c              LDR      r4,[r1,#0]
000012  ea442405          ORR      r4,r4,r5,LSL #8
000016  4320              ORRS     r0,r0,r4
;;;197      /* Write to ADCx CR1 */
;;;198      ADCx->CR1 = tmpreg1;
000018  6050              STR      r0,[r2,#4]
;;;199    
;;;200      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;201      /* Get the ADCx CR2 value */
;;;202      tmpreg1 = ADCx->CR2;
00001a  6890              LDR      r0,[r2,#8]
;;;203      /* Clear CONT, ALIGN and EXTSEL bits */
;;;204      tmpreg1 &= CR2_CLEAR_Mask;
00001c  4c0b              LDR      r4,|L25.76|
00001e  4020              ANDS     r0,r0,r4
;;;205      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;206      /* Set ALIGN bit according to ADC_DataAlign value */
;;;207      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;208      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;209      tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
000020  e9d15402          LDRD     r5,r4,[r1,#8]
000024  432c              ORRS     r4,r4,r5
000026  794d              LDRB     r5,[r1,#5]
000028  ea440445          ORR      r4,r4,r5,LSL #1
00002c  4320              ORRS     r0,r0,r4
;;;210                ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;211      /* Write to ADCx CR2 */
;;;212      ADCx->CR2 = tmpreg1;
00002e  6090              STR      r0,[r2,#8]
;;;213    
;;;214      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;215      /* Get the ADCx SQR1 value */
;;;216      tmpreg1 = ADCx->SQR1;
000030  6ad0              LDR      r0,[r2,#0x2c]
;;;217      /* Clear L bits */
;;;218      tmpreg1 &= SQR1_CLEAR_Mask;
000032  f4200070          BIC      r0,r0,#0xf00000
;;;219      /* Configure ADCx: regular channel sequence length */
;;;220      /* Set L bits according to ADC_NbrOfChannel value */
;;;221      tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
000036  7c0c              LDRB     r4,[r1,#0x10]
000038  1e64              SUBS     r4,r4,#1
00003a  431c              ORRS     r4,r4,r3
00003c  b2e3              UXTB     r3,r4
;;;222      tmpreg1 |= ((u32)tmpreg2 << 20);
00003e  ea405003          ORR      r0,r0,r3,LSL #20
;;;223      /* Write to ADCx SQR1 */
;;;224      ADCx->SQR1 = tmpreg1;
000042  62d0              STR      r0,[r2,#0x2c]
;;;225    }
000044  bd30              POP      {r4,r5,pc}
;;;226    
                          ENDP

000046  0000              DCW      0x0000
                  |L25.72|
                          DCD      0xfff0feff
                  |L25.76|
                          DCD      0xfff1f7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;991    *******************************************************************************/
;;;992    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
000000  b5f0              PUSH     {r4-r7,lr}
;;;993    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;994      u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
000006  2000              MOVS     r0,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;995    
;;;996      /* Check the parameters */
;;;997      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;998      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;999      assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1000     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1001   
;;;1002     /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;1003     if (ADC_Channel > ADC_Channel_9)
00000c  2909              CMP      r1,#9
00000e  dd11              BLE      |L26.52|
;;;1004     {
;;;1005       /* Get the old register value */
;;;1006       tmpreg1 = ADCx->SMPR1;
000010  68e0              LDR      r0,[r4,#0xc]
;;;1007       /* Calculate the mask to clear */
;;;1008       tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
000012  f1a1070a          SUB      r7,r1,#0xa
000016  eb070c47          ADD      r12,r7,r7,LSL #1
00001a  2707              MOVS     r7,#7
00001c  fa07f20c          LSL      r2,r7,r12
;;;1009       /* Clear the old discontinuous mode channel count */
;;;1010       tmpreg1 &= ~tmpreg2;
000020  4390              BICS     r0,r0,r2
;;;1011       /* Calculate the mask to set */
;;;1012       tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
000022  f1a1070a          SUB      r7,r1,#0xa
000026  eb070747          ADD      r7,r7,r7,LSL #1
00002a  fa03f207          LSL      r2,r3,r7
;;;1013       /* Set the discontinuous mode channel count */
;;;1014       tmpreg1 |= tmpreg2;
00002e  4310              ORRS     r0,r0,r2
;;;1015       /* Store the new register value */
;;;1016       ADCx->SMPR1 = tmpreg1;
000030  60e0              STR      r0,[r4,#0xc]
000032  e00c              B        |L26.78|
                  |L26.52|
;;;1017     }
;;;1018     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1019     {
;;;1020       /* Get the old register value */
;;;1021       tmpreg1 = ADCx->SMPR2;
000034  6920              LDR      r0,[r4,#0x10]
;;;1022       /* Calculate the mask to clear */
;;;1023       tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000036  eb010c41          ADD      r12,r1,r1,LSL #1
00003a  2707              MOVS     r7,#7
00003c  fa07f20c          LSL      r2,r7,r12
;;;1024       /* Clear the old discontinuous mode channel count */
;;;1025       tmpreg1 &= ~tmpreg2;
000040  4390              BICS     r0,r0,r2
;;;1026       /* Calculate the mask to set */
;;;1027       tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
000042  eb010741          ADD      r7,r1,r1,LSL #1
000046  fa03f207          LSL      r2,r3,r7
;;;1028       /* Set the discontinuous mode channel count */
;;;1029       tmpreg1 |= tmpreg2;
00004a  4310              ORRS     r0,r0,r2
;;;1030       /* Store the new register value */
;;;1031       ADCx->SMPR2 = tmpreg1;
00004c  6120              STR      r0,[r4,#0x10]
                  |L26.78|
;;;1032     }
;;;1033   
;;;1034     /* Rank configuration */
;;;1035     /* Get the old register value */
;;;1036     tmpreg1 = ADCx->JSQR;
00004e  6ba0              LDR      r0,[r4,#0x38]
;;;1037     /* Get JL value: Number = JL+1 */
;;;1038     tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000050  f3c05601          UBFX     r6,r0,#20,#2
;;;1039     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1040     tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
000054  1cef              ADDS     r7,r5,#3
000056  f1060c01          ADD      r12,r6,#1
00005a  eba7070c          SUB      r7,r7,r12
00005e  eb070c87          ADD      r12,r7,r7,LSL #2
000062  271f              MOVS     r7,#0x1f
000064  fa07f20c          LSL      r2,r7,r12
;;;1041     /* Clear the old JSQx bits for the selected rank */
;;;1042     tmpreg1 &= ~tmpreg2;
000068  4390              BICS     r0,r0,r2
;;;1043     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1044     tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
00006a  1cef              ADDS     r7,r5,#3
00006c  f1060c01          ADD      r12,r6,#1
000070  eba7070c          SUB      r7,r7,r12
000074  eb070787          ADD      r7,r7,r7,LSL #2
000078  fa01f207          LSL      r2,r1,r7
;;;1045     /* Set the JSQx bits for the selected rank */
;;;1046     tmpreg1 |= tmpreg2;
00007c  4310              ORRS     r0,r0,r2
;;;1047     /* Store the new register value */
;;;1048     ADCx->JSQR = tmpreg1;
00007e  63a0              STR      r0,[r4,#0x38]
;;;1049   }
000080  bdf0              POP      {r4-r7,pc}
;;;1050   
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;786    *******************************************************************************/
;;;787    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L27.12|
;;;788    {
;;;789      /* Check the parameters */
;;;790      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;791      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;792    
;;;793      if (NewState != DISABLE)
;;;794      {
;;;795        /* Enable the selected ADC injected discontinuous mode */
;;;796        ADCx->CR1 |= CR1_JDISCEN_Set;
000002  6842              LDR      r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L27.20|
                  |L27.12|
;;;797      }
;;;798      else
;;;799      {
;;;800        /* Disable the selected ADC injected discontinuous mode */
;;;801        ADCx->CR1 &= CR1_JDISCEN_Reset;
00000c  6842              LDR      r2,[r0,#4]
00000e  f4225280          BIC      r2,r2,#0x1000
000012  6042              STR      r2,[r0,#4]
                  |L27.20|
;;;802      }
;;;803    }
000014  4770              BX       lr
;;;804    
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;1059   *******************************************************************************/
;;;1060   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
000000  b510              PUSH     {r4,lr}
;;;1061   {
000002  460a              MOV      r2,r1
;;;1062     u32 tmpreg1 = 0;
000004  2100              MOVS     r1,#0
;;;1063     u32 tmpreg2 = 0;
000006  2300              MOVS     r3,#0
;;;1064   
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1067     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1068     
;;;1069     /* Get the old register value */
;;;1070     tmpreg1 = ADCx->JSQR;
000008  6b81              LDR      r1,[r0,#0x38]
;;;1071     /* Clear the old injected sequnence lenght JL bits */
;;;1072     tmpreg1 &= JSQR_JL_Reset;
00000a  f4211140          BIC      r1,r1,#0x300000
;;;1073     /* Set the injected sequnence lenght JL bits */
;;;1074     tmpreg2 = Length - 1; 
00000e  1e53              SUBS     r3,r2,#1
;;;1075     tmpreg1 |= tmpreg2 << 20;
000010  ea415103          ORR      r1,r1,r3,LSL #20
;;;1076     /* Store the new register value */
;;;1077     ADCx->JSQR = tmpreg1;
000014  6381              STR      r1,[r0,#0x38]
;;;1078   }
000016  bd10              POP      {r4,pc}
;;;1079   
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;599    *******************************************************************************/
;;;600    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
000000  b5f0              PUSH     {r4-r7,lr}
;;;601    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;602      u32 tmpreg1 = 0, tmpreg2 = 0;
000006  2000              MOVS     r0,#0
000008  2100              MOVS     r1,#0
;;;603    
;;;604      /* Check the parameters */
;;;605      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;606      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;607      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;608      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;609    
;;;610      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;611      if (ADC_Channel > ADC_Channel_9)
00000a  2d09              CMP      r5,#9
00000c  dd11              BLE      |L29.50|
;;;612      {
;;;613        /* Get the old register value */
;;;614        tmpreg1 = ADCx->SMPR1;
00000e  68e0              LDR      r0,[r4,#0xc]
;;;615        /* Calculate the mask to clear */
;;;616        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
000010  f1a5060a          SUB      r6,r5,#0xa
000014  eb060746          ADD      r7,r6,r6,LSL #1
000018  2607              MOVS     r6,#7
00001a  fa06f107          LSL      r1,r6,r7
;;;617        /* Clear the old discontinuous mode channel count */
;;;618        tmpreg1 &= ~tmpreg2;
00001e  4388              BICS     r0,r0,r1
;;;619        /* Calculate the mask to set */
;;;620        tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
000020  f1a5060a          SUB      r6,r5,#0xa
000024  eb060646          ADD      r6,r6,r6,LSL #1
000028  fa03f106          LSL      r1,r3,r6
;;;621        /* Set the discontinuous mode channel count */
;;;622        tmpreg1 |= tmpreg2;
00002c  4308              ORRS     r0,r0,r1
;;;623        /* Store the new register value */
;;;624        ADCx->SMPR1 = tmpreg1;
00002e  60e0              STR      r0,[r4,#0xc]
000030  e00c              B        |L29.76|
                  |L29.50|
;;;625      }
;;;626      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;627      {
;;;628        /* Get the old register value */
;;;629        tmpreg1 = ADCx->SMPR2;
000032  6920              LDR      r0,[r4,#0x10]
;;;630        /* Calculate the mask to clear */
;;;631        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000034  eb050745          ADD      r7,r5,r5,LSL #1
000038  2607              MOVS     r6,#7
00003a  fa06f107          LSL      r1,r6,r7
;;;632        /* Clear the old discontinuous mode channel count */
;;;633        tmpreg1 &= ~tmpreg2;
00003e  4388              BICS     r0,r0,r1
;;;634        /* Calculate the mask to set */
;;;635        tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
000040  eb050645          ADD      r6,r5,r5,LSL #1
000044  fa03f106          LSL      r1,r3,r6
;;;636        /* Set the discontinuous mode channel count */
;;;637        tmpreg1 |= tmpreg2;
000048  4308              ORRS     r0,r0,r1
;;;638        /* Store the new register value */
;;;639        ADCx->SMPR2 = tmpreg1;
00004a  6120              STR      r0,[r4,#0x10]
                  |L29.76|
;;;640      }
;;;641      /* For Rank 1 to 6 */
;;;642      if (Rank < 7)
00004c  2a07              CMP      r2,#7
00004e  da0f              BGE      |L29.112|
;;;643      {
;;;644        /* Get the old register value */
;;;645        tmpreg1 = ADCx->SQR3;
000050  6b60              LDR      r0,[r4,#0x34]
;;;646        /* Calculate the mask to clear */
;;;647        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
000052  1e56              SUBS     r6,r2,#1
000054  eb060786          ADD      r7,r6,r6,LSL #2
000058  261f              MOVS     r6,#0x1f
00005a  fa06f107          LSL      r1,r6,r7
;;;648        /* Clear the old SQx bits for the selected rank */
;;;649        tmpreg1 &= ~tmpreg2;
00005e  4388              BICS     r0,r0,r1
;;;650        /* Calculate the mask to set */
;;;651        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
000060  1e56              SUBS     r6,r2,#1
000062  eb060686          ADD      r6,r6,r6,LSL #2
000066  fa05f106          LSL      r1,r5,r6
;;;652        /* Set the SQx bits for the selected rank */
;;;653        tmpreg1 |= tmpreg2;
00006a  4308              ORRS     r0,r0,r1
;;;654        /* Store the new register value */
;;;655        ADCx->SQR3 = tmpreg1;
00006c  6360              STR      r0,[r4,#0x34]
00006e  e022              B        |L29.182|
                  |L29.112|
;;;656      }
;;;657      /* For Rank 7 to 12 */
;;;658      else if (Rank < 13)
000070  2a0d              CMP      r2,#0xd
000072  da0f              BGE      |L29.148|
;;;659      {
;;;660        /* Get the old register value */
;;;661        tmpreg1 = ADCx->SQR2;
000074  6b20              LDR      r0,[r4,#0x30]
;;;662        /* Calculate the mask to clear */
;;;663        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
000076  1fd6              SUBS     r6,r2,#7
000078  eb060786          ADD      r7,r6,r6,LSL #2
00007c  261f              MOVS     r6,#0x1f
00007e  fa06f107          LSL      r1,r6,r7
;;;664        /* Clear the old SQx bits for the selected rank */
;;;665        tmpreg1 &= ~tmpreg2;
000082  4388              BICS     r0,r0,r1
;;;666        /* Calculate the mask to set */
;;;667        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
000084  1fd6              SUBS     r6,r2,#7
000086  eb060686          ADD      r6,r6,r6,LSL #2
00008a  fa05f106          LSL      r1,r5,r6
;;;668        /* Set the SQx bits for the selected rank */
;;;669        tmpreg1 |= tmpreg2;
00008e  4308              ORRS     r0,r0,r1
;;;670        /* Store the new register value */
;;;671        ADCx->SQR2 = tmpreg1;
000090  6320              STR      r0,[r4,#0x30]
000092  e010              B        |L29.182|
                  |L29.148|
;;;672      }
;;;673      /* For Rank 13 to 16 */
;;;674      else
;;;675      {
;;;676        /* Get the old register value */
;;;677        tmpreg1 = ADCx->SQR1;
000094  6ae0              LDR      r0,[r4,#0x2c]
;;;678        /* Calculate the mask to clear */
;;;679        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
000096  f1a2060d          SUB      r6,r2,#0xd
00009a  eb060786          ADD      r7,r6,r6,LSL #2
00009e  261f              MOVS     r6,#0x1f
0000a0  fa06f107          LSL      r1,r6,r7
;;;680        /* Clear the old SQx bits for the selected rank */
;;;681        tmpreg1 &= ~tmpreg2;
0000a4  4388              BICS     r0,r0,r1
;;;682        /* Calculate the mask to set */
;;;683        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
0000a6  f1a2060d          SUB      r6,r2,#0xd
0000aa  eb060686          ADD      r6,r6,r6,LSL #2
0000ae  fa05f106          LSL      r1,r5,r6
;;;684        /* Set the SQx bits for the selected rank */
;;;685        tmpreg1 |= tmpreg2;
0000b2  4308              ORRS     r0,r0,r1
;;;686        /* Store the new register value */
;;;687        ADCx->SQR1 = tmpreg1;
0000b4  62e0              STR      r0,[r4,#0x2c]
                  |L29.182|
;;;688      }
;;;689    }
0000b6  bdf0              POP      {r4-r7,pc}
;;;690    
                          ENDP


                          AREA ||i.ADC_ResetCalibration||, CODE, READONLY, ALIGN=1

                  ADC_ResetCalibration PROC
;;;357    *******************************************************************************/
;;;358    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;359    {
;;;360      /* Check the parameters */
;;;361      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;362    
;;;363      /* Resets the selected ADC calibartion registers */  
;;;364      ADCx->CR2 |= CR2_RSTCAL_Set;
000002  f0410108          ORR      r1,r1,#8
000006  6081              STR      r1,[r0,#8]
;;;365    }
000008  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1095   *******************************************************************************/
;;;1096   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
000000  5042              STR      r2,[r0,r1]
;;;1097   {
;;;1098     /* Check the parameters */
;;;1099     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1100     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1101     assert_param(IS_ADC_OFFSET(Offset));  
;;;1102   
;;;1103     /* Set the selected injected channel data offset */
;;;1104     *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
;;;1105   }
000002  4770              BX       lr
;;;1106   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConvCmd PROC
;;;451    *******************************************************************************/
;;;452    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L32.12|
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;456      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;457    
;;;458      if (NewState != DISABLE)
;;;459      {
;;;460        /* Enable the selected ADC conversion on external event and start the selected
;;;461           ADC conversion */
;;;462        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
000002  6882              LDR      r2,[r0,#8]
000004  f44202a0          ORR      r2,r2,#0x500000
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L32.20|
                  |L32.12|
;;;463      }
;;;464      else
;;;465      {
;;;466        /* Disable the selected ADC conversion on external event and stop the selected
;;;467           ADC conversion */
;;;468        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
00000c  6882              LDR      r2,[r0,#8]
00000e  f42202a0          BIC      r2,r2,#0x500000
000012  6082              STR      r2,[r0,#8]
                  |L32.20|
;;;469      }
;;;470    }
000014  4770              BX       lr
;;;471    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;900    *******************************************************************************/
;;;901    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L33.12|
;;;902    {
;;;903      /* Check the parameters */
;;;904      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;905      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;906    
;;;907      if (NewState != DISABLE)
;;;908      {
;;;909        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;910           ADC injected conversion */
;;;911        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
000002  6882              LDR      r2,[r0,#8]
000004  f4421202          ORR      r2,r2,#0x208000
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L33.20|
                  |L33.12|
;;;912      }
;;;913      else
;;;914      {
;;;915        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;916           ADC injected conversion */
;;;917        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
00000c  6882              LDR      r2,[r0,#8]
00000e  f4221202          BIC      r2,r2,#0x208000
000012  6082              STR      r2,[r0,#8]
                  |L33.20|
;;;918      }
;;;919    }
000014  4770              BX       lr
;;;920    
                          ENDP


                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=1

                  ADC_StartCalibration PROC
;;;403    *******************************************************************************/
;;;404    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;405    {
;;;406      /* Check the parameters */
;;;407      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;408    
;;;409      /* Enable the selected ADC calibration process */  
;;;410      ADCx->CR2 |= CR2_CAL_Set;
000002  f0410104          ORR      r1,r1,#4
000006  6081              STR      r1,[r0,#8]
;;;411    }
000008  4770              BX       lr
;;;412    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;234    *******************************************************************************/
;;;235    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;236    {
;;;237      /* Reset ADC init structure parameters values */
;;;238      /* Initialize the ADC_Mode member */
;;;239      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
000002  6001              STR      r1,[r0,#0]
;;;240    
;;;241      /* initialize the ADC_ScanConvMode member */
;;;242      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000004  7101              STRB     r1,[r0,#4]
;;;243    
;;;244      /* Initialize the ADC_ContinuousConvMode member */
;;;245      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;246    
;;;247      /* Initialize the ADC_ExternalTrigConv member */
;;;248      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
000008  6081              STR      r1,[r0,#8]
;;;249    
;;;250      /* Initialize the ADC_DataAlign member */
;;;251      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00000a  60c1              STR      r1,[r0,#0xc]
;;;252    
;;;253      /* Initialize the ADC_NbrOfChannel member */
;;;254      ADC_InitStruct->ADC_NbrOfChannel = 1;
00000c  2101              MOVS     r1,#1
00000e  7401              STRB     r1,[r0,#0x10]
;;;255    }
000010  4770              BX       lr
;;;256    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;1250   *******************************************************************************/
;;;1251   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L36.16|
;;;1252   {
;;;1253     /* Check the parameters */
;;;1254     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1255   
;;;1256     if (NewState != DISABLE)
;;;1257     {
;;;1258       /* Enable the temperature sensor and Vrefint channel*/
;;;1259       ADC1->CR2 |= CR2_TSVREFE_Set;
000002  4907              LDR      r1,|L36.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4410100          ORR      r1,r1,#0x800000
00000a  4a05              LDR      r2,|L36.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L36.28|
                  |L36.16|
;;;1260     }
;;;1261     else
;;;1262     {
;;;1263       /* Disable the temperature sensor and Vrefint channel*/
;;;1264       ADC1->CR2 &= CR2_TSVREFE_Reset;
000010  4903              LDR      r1,|L36.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4210100          BIC      r1,r1,#0x800000
000018  4a01              LDR      r2,|L36.32|
00001a  6011              STR      r1,[r2,#0]
                  |L36.28|
;;;1265     }
;;;1266   }
00001c  4770              BX       lr
;;;1267   
                          ENDP

00001e  0000              DCW      0x0000
                  |L36.32|
                          DCD      0x40012408
