; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\obj\i2c.o --asm_dir=.\OutPut\List\ --list_dir=.\OutPut\List\ --depend=.\output\obj\i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Library\STM32F10x_StdPeriph_Driver\INC -I..\..\Library\Startup\STM32F10x -I..\..\Library\C -I..\..\Library\ARM\Include -I..\..\Driver\WOW\INC -I..\..\Driver\Components\INC -I..\..\Driver\Protocol -I..\..\Examples\DEMO\include -I..\..\Examples\WOW -I.\main -I..\..\Driver\Tool -I..\..\Driver\FatFs\source -IE:\Project\MKD\STM32\STM32F1xWorkSpace\Project\STM32F1xWOW\RTE -I"D:\Program Files (x86)\MDK\Pack\ARM\CMSIS\5.0.1\CMSIS\Include" -I"D:\Program Files (x86)\MDK\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=516 -D_RTE_ -DSTM32F10X_HD -DAMPLCDV11 --omf_browse=.\output\obj\i2c.crf ..\..\Driver\Protocol\I2C.C]
                          THUMB

                          AREA ||i.I2C_Ack||, CODE, READONLY, ALIGN=2

                  I2C_Ack PROC
;;;187    *******************************************************************************/
;;;188    void I2C_Ack(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190    	I2C_SDASetOut(sI2C);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_SDASetOut
;;;191    	
;;;192    	I2C_SDALow(sI2C);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_SDALow
;;;193    	I2C_Delayus(i2cdelaytime);
000010  480c              LDR      r0,|L1.68|
000012  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000014  f7fffffe          BL       I2C_Delayus
;;;194    	
;;;195    	I2C_SCLHigh(sI2C);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       I2C_SCLHigh
;;;196    	I2C_Delayus(i2cdelaytime);
00001e  4809              LDR      r0,|L1.68|
000020  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000022  f7fffffe          BL       I2C_Delayus
;;;197    	
;;;198    	I2C_SCLLow(sI2C);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       I2C_SCLLow
;;;199    	I2C_Delayus(i2cdelaytime);
00002c  4805              LDR      r0,|L1.68|
00002e  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000030  f7fffffe          BL       I2C_Delayus
;;;200    	I2C_SDAHigh(sI2C);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_SDAHigh
;;;201    	I2C_Delayus(i2cdelaytime);
00003a  4802              LDR      r0,|L1.68|
00003c  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
00003e  f7fffffe          BL       I2C_Delayus
;;;202    }
000042  bd10              POP      {r4,pc}
;;;203    /*******************************************************************************
                          ENDP

                  |L1.68|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_Configuration||, CODE, READONLY, ALIGN=1

                  I2C_Configuration PROC
;;;25     *******************************************************************************/
;;;26     void I2C_Configuration(sI2CDef *sI2C)		//启用锁--配置
000000  b510              PUSH     {r4,lr}
;;;27     {
000002  4604              MOV      r4,r0
;;;28     	//=====================================SDA脚
;;;29     	GPIO_Configuration_OPP50	(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
000004  88a1              LDRH     r1,[r4,#4]
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       GPIO_Configuration_OPP50
;;;30     	//=====================================SCL脚
;;;31     	GPIO_Configuration_OPP50	(sI2C->HW.SCL_Port,sI2C->HW.SCL_Pin);			//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
00000c  89a1              LDRH     r1,[r4,#0xc]
00000e  68a0              LDR      r0,[r4,#8]
000010  f7fffffe          BL       GPIO_Configuration_OPP50
;;;32     	//=====================================SDA,SCL拉低
;;;33     	GPIO_SetBits(sI2C->HW.SCL_Port,sI2C->HW.SCL_Pin);
000014  89a1              LDRH     r1,[r4,#0xc]
000016  68a0              LDR      r0,[r4,#8]
000018  f7fffffe          BL       GPIO_SetBits
;;;34     	GPIO_SetBits(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);	
00001c  88a1              LDRH     r1,[r4,#4]
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       GPIO_SetBits
;;;35     	
;;;36     	sI2C->DATA.EEtype=AT24C02;		//EEPROM类型24C01、24C02这两个型号是8个字节一个页，而24C04、24C08、24C16是16个字节一页
000024  2001              MOVS     r0,#1
000026  7420              STRB     r0,[r4,#0x10]
;;;37     	
;;;38     	//-------------------------------------页大小参数设置
;;;39     	if((sI2C->DATA.EEtype==AT24C01)||(sI2C->DATA.EEtype==AT24C02))
000028  7c20              LDRB     r0,[r4,#0x10]
00002a  b110              CBZ      r0,|L2.50|
00002c  7c20              LDRB     r0,[r4,#0x10]
00002e  2801              CMP      r0,#1
000030  d102              BNE      |L2.56|
                  |L2.50|
;;;40     	{	//24C01、24C02这两个型号是8个字节一个页
;;;41     		sI2C->DATA.PageSize=8;
000032  2108              MOVS     r1,#8
000034  7461              STRB     r1,[r4,#0x11]
000036  e001              B        |L2.60|
                  |L2.56|
;;;42     	}
;;;43     	else
;;;44     	{//24C04、24C08、24C16是16个字节一页
;;;45     		sI2C->DATA.PageSize=16;
000038  2110              MOVS     r1,#0x10
00003a  7461              STRB     r1,[r4,#0x11]
                  |L2.60|
;;;46     	}
;;;47     	sI2C->DATA.DeviceAddr	=	0xA0;	//设备地址
00003c  21a0              MOVS     r1,#0xa0
00003e  76a1              STRB     r1,[r4,#0x1a]
;;;48     }
000040  bd10              POP      {r4,pc}
;;;49     /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_Delayms||, CODE, READONLY, ALIGN=1

                  I2C_Delayms PROC
;;;790    *******************************************************************************/
;;;791    void I2C_Delayms(unsigned	short Time)
000000  b510              PUSH     {r4,lr}
;;;792    {
000002  4604              MOV      r4,r0
;;;793    	SysTick_DeleymS(Time);				//SysTick延时nmS
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SysTick_DeleymS
;;;794    }
00000a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.I2C_Delayus||, CODE, READONLY, ALIGN=1

                  I2C_Delayus PROC
;;;777    *******************************************************************************/
;;;778    void I2C_Delayus(unsigned	short Time)
000000  b510              PUSH     {r4,lr}
;;;779    {
000002  4604              MOV      r4,r0
;;;780    	SysTick_DeleyuS(Time);				//SysTick延时nmS
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SysTick_DeleyuS
;;;781    }
00000a  bd10              POP      {r4,pc}
;;;782    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_NAck||, CODE, READONLY, ALIGN=2

                  I2C_NAck PROC
;;;211    *******************************************************************************/
;;;212    void I2C_NAck(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;213    {
000002  4604              MOV      r4,r0
;;;214    	I2C_SDASetOut(sI2C);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_SDASetOut
;;;215    	
;;;216    	I2C_SDAHigh(sI2C);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_SDAHigh
;;;217    	I2C_Delayus(i2cdelaytime);
000010  480a              LDR      r0,|L5.60|
000012  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000014  f7fffffe          BL       I2C_Delayus
;;;218    	
;;;219    	I2C_SCLHigh(sI2C);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       I2C_SCLHigh
;;;220    	I2C_Delayus(i2cdelaytime);
00001e  4807              LDR      r0,|L5.60|
000020  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000022  f7fffffe          BL       I2C_Delayus
;;;221    	
;;;222    	I2C_SCLLow(sI2C);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       I2C_SCLLow
;;;223    	I2C_Delayus(i2cdelaytime);
00002c  4803              LDR      r0,|L5.60|
00002e  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000030  f7fffffe          BL       I2C_Delayus
;;;224    	
;;;225    	I2C_SDALow(sI2C);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_SDALow
;;;226    }
00003a  bd10              POP      {r4,pc}
;;;227    /*******************************************************************************
                          ENDP

                  |L5.60|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_ReadBit||, CODE, READONLY, ALIGN=1

                  I2C_ReadBit PROC
;;;235    *******************************************************************************/
;;;236    unsigned char I2C_ReadBit(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;237    {
000002  4604              MOV      r4,r0
;;;238    	if(GPIO_ReadInputDataBit(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin))
000004  88a1              LDRH     r1,[r4,#4]
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  b108              CBZ      r0,|L6.18|
;;;239    		return 1;
00000e  2001              MOVS     r0,#1
                  |L6.16|
;;;240    	else
;;;241    		return 0;
;;;242    }
000010  bd10              POP      {r4,pc}
                  |L6.18|
000012  2000              MOVS     r0,#0                 ;241
000014  e7fc              B        |L6.16|
;;;243    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_ReadBuffer||, CODE, READONLY, ALIGN=1

                  I2C_ReadBuffer PROC
;;;717    *******************************************************************************/
;;;718    unsigned short I2C_ReadBuffer(sI2CDef *sI2C,unsigned short address,unsigned char* pBuffer,unsigned short length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;719    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;720    	unsigned char ucByte;
;;;721    	unsigned short i	=	0;
00000c  2400              MOVS     r4,#0
;;;722    	unsigned char temp	=	0xA0;		//bit0=0:write;bit0=1:read
00000e  f04f09a0          MOV      r9,#0xa0
;;;723    	//---------------------------启动I2C
;;;724    	I2C_Start(sI2C);
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       I2C_Start
;;;725    	//---------------------------写器件地址
;;;726    	I2C_SendByte(sI2C,temp);
000018  4649              MOV      r1,r9
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       I2C_SendByte
;;;727    	if(!I2C_WaitAck(sI2C))
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       I2C_WaitAck
000026  b928              CBNZ     r0,|L7.52|
;;;728    	{		
;;;729    		I2C_Stop(sI2C);
000028  4640              MOV      r0,r8
00002a  f7fffffe          BL       I2C_Stop
;;;730    		return 0;
00002e  2000              MOVS     r0,#0
                  |L7.48|
;;;731    	}
;;;732    	//---------------------------写内存地址
;;;733    	temp	=	address;
;;;734    	
;;;735    	I2C_SDASetOut(sI2C);
;;;736    	I2C_SendByte(sI2C,temp);
;;;737    	if(!I2C_WaitAck(sI2C))
;;;738    	{
;;;739    		I2C_Stop(sI2C);
;;;740    		return 0;
;;;741    	}
;;;742    	//---------------------------启动读
;;;743    	temp	=	0xA1;				//bit0=0:write;bit0=1:read
;;;744    	I2C_Start(sI2C);
;;;745    	I2C_SendByte(sI2C,temp);
;;;746    	if(!I2C_WaitAck(sI2C))
;;;747    	{		
;;;748    		I2C_Stop(sI2C);
;;;749    		return 0;
;;;750    	}
;;;751    	//---------------------------读数据
;;;752    	for(i=0;i<length;i++)
;;;753    	{
;;;754    		I2C_SDASetIn(sI2C);	//设置为上拉输入模式
;;;755    		pBuffer[i]=I2C_ReadByte(sI2C);
;;;756    		if(i>=length-1)
;;;757    		{
;;;758    			I2C_NAck(sI2C);								//CPU产生一个NACK信号(NACK即无应答信号)
;;;759    		}
;;;760    		else
;;;761    		{
;;;762    			I2C_Ack(sI2C);								//CPU产生一个ACK信号
;;;763    		}
;;;764    	}	
;;;765    	I2C_Stop(sI2C);
;;;766    
;;;767    	return ucByte;
;;;768    }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L7.52|
000034  f00609ff          AND      r9,r6,#0xff           ;733
000038  4640              MOV      r0,r8                 ;735
00003a  f7fffffe          BL       I2C_SDASetOut
00003e  4649              MOV      r1,r9                 ;736
000040  4640              MOV      r0,r8                 ;736
000042  f7fffffe          BL       I2C_SendByte
000046  4640              MOV      r0,r8                 ;737
000048  f7fffffe          BL       I2C_WaitAck
00004c  b920              CBNZ     r0,|L7.88|
00004e  4640              MOV      r0,r8                 ;739
000050  f7fffffe          BL       I2C_Stop
000054  2000              MOVS     r0,#0                 ;740
000056  e7eb              B        |L7.48|
                  |L7.88|
000058  f04f09a1          MOV      r9,#0xa1              ;743
00005c  4640              MOV      r0,r8                 ;744
00005e  f7fffffe          BL       I2C_Start
000062  4649              MOV      r1,r9                 ;745
000064  4640              MOV      r0,r8                 ;745
000066  f7fffffe          BL       I2C_SendByte
00006a  4640              MOV      r0,r8                 ;746
00006c  f7fffffe          BL       I2C_WaitAck
000070  b920              CBNZ     r0,|L7.124|
000072  4640              MOV      r0,r8                 ;748
000074  f7fffffe          BL       I2C_Stop
000078  2000              MOVS     r0,#0                 ;749
00007a  e7d9              B        |L7.48|
                  |L7.124|
00007c  2400              MOVS     r4,#0                 ;752
00007e  e012              B        |L7.166|
                  |L7.128|
000080  4640              MOV      r0,r8                 ;754
000082  f7fffffe          BL       I2C_SDASetIn
000086  4640              MOV      r0,r8                 ;755
000088  f7fffffe          BL       I2C_ReadByte
00008c  5538              STRB     r0,[r7,r4]            ;755
00008e  1e68              SUBS     r0,r5,#1              ;756
000090  42a0              CMP      r0,r4                 ;756
000092  dc03              BGT      |L7.156|
000094  4640              MOV      r0,r8                 ;758
000096  f7fffffe          BL       I2C_NAck
00009a  e002              B        |L7.162|
                  |L7.156|
00009c  4640              MOV      r0,r8                 ;762
00009e  f7fffffe          BL       I2C_Ack
                  |L7.162|
0000a2  1c60              ADDS     r0,r4,#1              ;752
0000a4  b284              UXTH     r4,r0                 ;752
                  |L7.166|
0000a6  42ac              CMP      r4,r5                 ;752
0000a8  dbea              BLT      |L7.128|
0000aa  4640              MOV      r0,r8                 ;765
0000ac  f7fffffe          BL       I2C_Stop
0000b0  4650              MOV      r0,r10                ;767
0000b2  e7bd              B        |L7.48|
;;;769    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=2

                  I2C_ReadByte PROC
;;;561    *******************************************************************************/
;;;562    unsigned char I2C_ReadByte(sI2CDef *sI2C)
000000  b570              PUSH     {r4-r6,lr}
;;;563    {
000002  4606              MOV      r6,r0
;;;564    	unsigned char ucByte;
;;;565    	unsigned char i	=	0;
000004  2500              MOVS     r5,#0
;;;566    	for(i=0;i<8;i++)
000006  bf00              NOP      
000008  e017              B        |L8.58|
                  |L8.10|
;;;567    	{
;;;568    		ucByte<<=1;	
00000a  0660              LSLS     r0,r4,#25
00000c  0e04              LSRS     r4,r0,#24
;;;569    		I2C_SCLLow(sI2C);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       I2C_SCLLow
;;;570    		I2C_Delayus(i2cdelaytime);
000014  480e              LDR      r0,|L8.80|
000016  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000018  f7fffffe          BL       I2C_Delayus
;;;571    		
;;;572    		I2C_SCLHigh(sI2C);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       I2C_SCLHigh
;;;573    		I2C_Delayus(i2cdelaytime);
000022  480b              LDR      r0,|L8.80|
000024  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000026  f7fffffe          BL       I2C_Delayus
;;;574    		
;;;575    		if(I2C_ReadBit(sI2C))
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       I2C_ReadBit
000030  b108              CBZ      r0,|L8.54|
;;;576    		{
;;;577    			ucByte+=1;
000032  1c60              ADDS     r0,r4,#1
000034  b2c4              UXTB     r4,r0
                  |L8.54|
000036  1c68              ADDS     r0,r5,#1              ;566
000038  b2c5              UXTB     r5,r0                 ;566
                  |L8.58|
00003a  2d08              CMP      r5,#8                 ;566
00003c  dbe5              BLT      |L8.10|
;;;578    		}		
;;;579    	}
;;;580    	I2C_SCLLow(sI2C);
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       I2C_SCLLow
;;;581    	I2C_Delayus(i2cdelaytime);
000044  4802              LDR      r0,|L8.80|
000046  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000048  f7fffffe          BL       I2C_Delayus
;;;582    	
;;;583    	return ucByte;
00004c  4620              MOV      r0,r4
;;;584    }
00004e  bd70              POP      {r4-r6,pc}
;;;585    /*******************************************************************************
                          ENDP

                  |L8.80|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_ReadOneByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadOneByte PROC
;;;593    *******************************************************************************/
;;;594    unsigned char I2C_ReadOneByte(sI2CDef *sI2C,unsigned short address)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;595    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;596    	unsigned char ucByte;
;;;597    	unsigned char i	=	0;
000008  2700              MOVS     r7,#0
;;;598    	unsigned char temp	=	0xA1;		//bit0=0:write;bit0=1:read
00000a  26a1              MOVS     r6,#0xa1
;;;599    	//---------------------------启动I2C
;;;600    	I2C_Start(sI2C);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       I2C_Start
;;;601    	//---------------------------写器件地址
;;;602    	I2C_SendByte(sI2C,temp);
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       I2C_SendByte
;;;603    	if(!I2C_WaitAck(sI2C))
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       I2C_WaitAck
000020  b928              CBNZ     r0,|L9.46|
;;;604    	{		
;;;605    		I2C_Stop(sI2C);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       I2C_Stop
;;;606    		return 0;
000028  2000              MOVS     r0,#0
                  |L9.42|
;;;607    	}
;;;608    	//---------------------------写内存地址
;;;609    	temp	=	address;
;;;610    	
;;;611    	I2C_SDASetOut(sI2C);
;;;612    	I2C_SendByte(sI2C,temp);
;;;613    	if(!I2C_WaitAck(sI2C))
;;;614    	{
;;;615    		I2C_Stop(sI2C);
;;;616    		return 0;
;;;617    	}
;;;618    	//---------------------------启动读
;;;619    	temp	=	0xA1;
;;;620    	I2C_Start(sI2C);
;;;621    	I2C_SendByte(sI2C,temp);
;;;622    	if(!I2C_WaitAck(sI2C))
;;;623    	{		
;;;624    		I2C_Stop(sI2C);
;;;625    		return 0;
;;;626    	}
;;;627    	//---------------------------读数据
;;;628    	I2C_SDASetIn(sI2C);	//设置为上拉输入模式
;;;629    	ucByte	=	 I2C_ReadByte(sI2C);
;;;630    	
;;;631    	I2C_NAck(sI2C);								//CPU产生一个NACK信号(NACK即无应答信号)
;;;632    	I2C_Stop(sI2C);
;;;633    	
;;;634    	return ucByte;
;;;635    }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.46|
00002e  b2e6              UXTB     r6,r4                 ;609
000030  4628              MOV      r0,r5                 ;611
000032  f7fffffe          BL       I2C_SDASetOut
000036  4631              MOV      r1,r6                 ;612
000038  4628              MOV      r0,r5                 ;612
00003a  f7fffffe          BL       I2C_SendByte
00003e  4628              MOV      r0,r5                 ;613
000040  f7fffffe          BL       I2C_WaitAck
000044  b920              CBNZ     r0,|L9.80|
000046  4628              MOV      r0,r5                 ;615
000048  f7fffffe          BL       I2C_Stop
00004c  2000              MOVS     r0,#0                 ;616
00004e  e7ec              B        |L9.42|
                  |L9.80|
000050  26a1              MOVS     r6,#0xa1              ;619
000052  4628              MOV      r0,r5                 ;620
000054  f7fffffe          BL       I2C_Start
000058  4631              MOV      r1,r6                 ;621
00005a  4628              MOV      r0,r5                 ;621
00005c  f7fffffe          BL       I2C_SendByte
000060  4628              MOV      r0,r5                 ;622
000062  f7fffffe          BL       I2C_WaitAck
000066  b920              CBNZ     r0,|L9.114|
000068  4628              MOV      r0,r5                 ;624
00006a  f7fffffe          BL       I2C_Stop
00006e  2000              MOVS     r0,#0                 ;625
000070  e7db              B        |L9.42|
                  |L9.114|
000072  4628              MOV      r0,r5                 ;628
000074  f7fffffe          BL       I2C_SDASetIn
000078  4628              MOV      r0,r5                 ;629
00007a  f7fffffe          BL       I2C_ReadByte
00007e  4680              MOV      r8,r0                 ;629
000080  4628              MOV      r0,r5                 ;631
000082  f7fffffe          BL       I2C_NAck
000086  4628              MOV      r0,r5                 ;632
000088  f7fffffe          BL       I2C_Stop
00008c  4640              MOV      r0,r8                 ;634
00008e  e7cc              B        |L9.42|
;;;636    
                          ENDP


                          AREA ||i.I2C_ReadPage||, CODE, READONLY, ALIGN=1

                  I2C_ReadPage PROC
;;;645    *******************************************************************************/
;;;646    unsigned short I2C_ReadPage(sI2CDef *sI2C,unsigned short PageAddress,unsigned char* pBuffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;647    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;648    	unsigned char ucByte;	
;;;649    	unsigned char temp	=	0xA0;		//bit0=0:write;bit0=1:read
00000a  f04f08a0          MOV      r8,#0xa0
;;;650    	unsigned short i	=	0;
00000e  2500              MOVS     r5,#0
;;;651    	//---------------------------检查页地址
;;;652    	if(0==sI2C->DATA.PageSize)
000010  7c60              LDRB     r0,[r4,#0x11]
000012  b910              CBNZ     r0,|L10.26|
;;;653    	{
;;;654    		return 0;
000014  2000              MOVS     r0,#0
                  |L10.22|
;;;655    	}
;;;656    	if(0==(PageAddress%sI2C->DATA.PageSize))
;;;657    	{
;;;658    		sI2C->DATA.WPageAddr+=sI2C->DATA.PageSize;
;;;659    	}
;;;660    	else
;;;661    	{
;;;662    		return 0;
;;;663    	}
;;;664    	//---------------------------启动I2C
;;;665    	I2C_Start(sI2C);
;;;666    	//---------------------------写器件地址
;;;667    	I2C_SendByte(sI2C,temp);
;;;668    	if(!I2C_WaitAck(sI2C))
;;;669    	{		
;;;670    		I2C_Stop(sI2C);
;;;671    		return 0;
;;;672    	}
;;;673    	//---------------------------写内存地址
;;;674    	
;;;675    	I2C_SDASetOut(sI2C);
;;;676    	I2C_SendByte(sI2C,PageAddress);
;;;677    	if(!I2C_WaitAck(sI2C))
;;;678    	{
;;;679    		I2C_Stop(sI2C);
;;;680    		return 0;
;;;681    	}
;;;682    	//---------------------------启动读
;;;683    	temp	=	0xA1;				//bit0=0:write;bit0=1:read
;;;684    	I2C_Start(sI2C);
;;;685    	I2C_SendByte(sI2C,temp);
;;;686    	if(!I2C_WaitAck(sI2C))
;;;687    	{		
;;;688    		I2C_Stop(sI2C);
;;;689    		return 0;
;;;690    	}
;;;691    	//---------------------------读数据
;;;692    	for(i=0;i<sI2C->DATA.PageSize;i++)
;;;693    	{
;;;694    		I2C_SDASetIn(sI2C);	//设置为上拉输入模式
;;;695    		pBuffer[i]=I2C_ReadByte(sI2C);
;;;696    		if(i>=sI2C->DATA.PageSize-1)
;;;697    		{
;;;698    			I2C_NAck(sI2C);								//CPU产生一个NACK信号(NACK即无应答信号)
;;;699    		}
;;;700    		else
;;;701    		{
;;;702    			I2C_Ack(sI2C);								//CPU产生一个ACK信号
;;;703    		}
;;;704    	}	
;;;705    	I2C_Stop(sI2C);
;;;706    
;;;707    	return ucByte;
;;;708    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L10.26|
00001a  7c60              LDRB     r0,[r4,#0x11]         ;656
00001c  fb96f1f0          SDIV     r1,r6,r0              ;656
000020  fb006011          MLS      r0,r0,r1,r6           ;656
000024  b920              CBNZ     r0,|L10.48|
000026  8aa1              LDRH     r1,[r4,#0x14]         ;658
000028  7c60              LDRB     r0,[r4,#0x11]         ;658
00002a  4408              ADD      r0,r0,r1              ;658
00002c  82a0              STRH     r0,[r4,#0x14]         ;658
00002e  e001              B        |L10.52|
                  |L10.48|
000030  2000              MOVS     r0,#0                 ;662
000032  e7f0              B        |L10.22|
                  |L10.52|
000034  4620              MOV      r0,r4                 ;665
000036  f7fffffe          BL       I2C_Start
00003a  4641              MOV      r1,r8                 ;667
00003c  4620              MOV      r0,r4                 ;667
00003e  f7fffffe          BL       I2C_SendByte
000042  4620              MOV      r0,r4                 ;668
000044  f7fffffe          BL       I2C_WaitAck
000048  b920              CBNZ     r0,|L10.84|
00004a  4620              MOV      r0,r4                 ;670
00004c  f7fffffe          BL       I2C_Stop
000050  2000              MOVS     r0,#0                 ;671
000052  e7e0              B        |L10.22|
                  |L10.84|
000054  4620              MOV      r0,r4                 ;675
000056  f7fffffe          BL       I2C_SDASetOut
00005a  b2f1              UXTB     r1,r6                 ;676
00005c  4620              MOV      r0,r4                 ;676
00005e  f7fffffe          BL       I2C_SendByte
000062  4620              MOV      r0,r4                 ;677
000064  f7fffffe          BL       I2C_WaitAck
000068  b920              CBNZ     r0,|L10.116|
00006a  4620              MOV      r0,r4                 ;679
00006c  f7fffffe          BL       I2C_Stop
000070  2000              MOVS     r0,#0                 ;680
000072  e7d0              B        |L10.22|
                  |L10.116|
000074  f04f08a1          MOV      r8,#0xa1              ;683
000078  4620              MOV      r0,r4                 ;684
00007a  f7fffffe          BL       I2C_Start
00007e  4641              MOV      r1,r8                 ;685
000080  4620              MOV      r0,r4                 ;685
000082  f7fffffe          BL       I2C_SendByte
000086  4620              MOV      r0,r4                 ;686
000088  f7fffffe          BL       I2C_WaitAck
00008c  b920              CBNZ     r0,|L10.152|
00008e  4620              MOV      r0,r4                 ;688
000090  f7fffffe          BL       I2C_Stop
000094  2000              MOVS     r0,#0                 ;689
000096  e7be              B        |L10.22|
                  |L10.152|
000098  2500              MOVS     r5,#0                 ;692
00009a  e013              B        |L10.196|
                  |L10.156|
00009c  4620              MOV      r0,r4                 ;694
00009e  f7fffffe          BL       I2C_SDASetIn
0000a2  4620              MOV      r0,r4                 ;695
0000a4  f7fffffe          BL       I2C_ReadByte
0000a8  5578              STRB     r0,[r7,r5]            ;695
0000aa  7c60              LDRB     r0,[r4,#0x11]         ;696
0000ac  1e40              SUBS     r0,r0,#1              ;696
0000ae  42a8              CMP      r0,r5                 ;696
0000b0  dc03              BGT      |L10.186|
0000b2  4620              MOV      r0,r4                 ;698
0000b4  f7fffffe          BL       I2C_NAck
0000b8  e002              B        |L10.192|
                  |L10.186|
0000ba  4620              MOV      r0,r4                 ;702
0000bc  f7fffffe          BL       I2C_Ack
                  |L10.192|
0000c0  1c68              ADDS     r0,r5,#1              ;692
0000c2  b285              UXTH     r5,r0                 ;692
                  |L10.196|
0000c4  7c60              LDRB     r0,[r4,#0x11]         ;692
0000c6  42a8              CMP      r0,r5                 ;692
0000c8  dce8              BGT      |L10.156|
0000ca  4620              MOV      r0,r4                 ;705
0000cc  f7fffffe          BL       I2C_Stop
0000d0  4648              MOV      r0,r9                 ;707
0000d2  e7a0              B        |L10.22|
;;;709    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SCLHigh||, CODE, READONLY, ALIGN=1

                  I2C_SCLHigh PROC
;;;72     *******************************************************************************/
;;;73     void I2C_SCLHigh(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  4604              MOV      r4,r0
;;;75     	GPIO_SetBits(sI2C->HW.SCL_Port,sI2C->HW.SCL_Pin);
000004  89a1              LDRH     r1,[r4,#0xc]
000006  68a0              LDR      r0,[r4,#8]
000008  f7fffffe          BL       GPIO_SetBits
;;;76     }
00000c  bd10              POP      {r4,pc}
;;;77     /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SCLLow||, CODE, READONLY, ALIGN=1

                  I2C_SCLLow PROC
;;;85     *******************************************************************************/
;;;86     void I2C_SCLLow(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;87     {
000002  4604              MOV      r4,r0
;;;88     	GPIO_ResetBits(sI2C->HW.SCL_Port,sI2C->HW.SCL_Pin);
000004  89a1              LDRH     r1,[r4,#0xc]
000006  68a0              LDR      r0,[r4,#8]
000008  f7fffffe          BL       GPIO_ResetBits
;;;89     }
00000c  bd10              POP      {r4,pc}
;;;90     /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SDAHigh||, CODE, READONLY, ALIGN=1

                  I2C_SDAHigh PROC
;;;98     *******************************************************************************/
;;;99     void I2C_SDAHigh(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;100    {
000002  4604              MOV      r4,r0
;;;101    	GPIO_SetBits(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);
000004  88a1              LDRH     r1,[r4,#4]
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       GPIO_SetBits
;;;102    }
00000c  bd10              POP      {r4,pc}
;;;103    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SDALow||, CODE, READONLY, ALIGN=1

                  I2C_SDALow PROC
;;;111    *******************************************************************************/
;;;112    void I2C_SDALow(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;113    {
000002  4604              MOV      r4,r0
;;;114    	GPIO_ResetBits(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);
000004  88a1              LDRH     r1,[r4,#4]
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       GPIO_ResetBits
;;;115    }
00000c  bd10              POP      {r4,pc}
;;;116    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SDASetIn||, CODE, READONLY, ALIGN=1

                  I2C_SDASetIn PROC
;;;140    *******************************************************************************/
;;;141    void I2C_SDASetIn(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;142    {
000002  4604              MOV      r4,r0
;;;143    	I2C_SCLLow(sI2C);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_SCLLow
;;;144    	I2C_SDALow(sI2C);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_SDALow
;;;145    	GPIO_Configuration_INF	(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);			//将GPIO相应管脚配置为上拉输入模式----V20170605
000010  88a1              LDRH     r1,[r4,#4]
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       GPIO_Configuration_INF
;;;146    }
000018  bd10              POP      {r4,pc}
;;;147    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SDASetOut||, CODE, READONLY, ALIGN=1

                  I2C_SDASetOut PROC
;;;124    *******************************************************************************/
;;;125    void I2C_SDASetOut(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127    	I2C_SCLLow(sI2C);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_SCLLow
;;;128    	I2C_SDALow(sI2C);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_SDALow
;;;129    	GPIO_RegConfiguration_OPP50	(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);	//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20190104--寄存器版本
000010  88a1              LDRH     r1,[r4,#4]
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       GPIO_RegConfiguration_OPP50
;;;130    	//GPIO_Configuration_OOD50	(sI2C->HW.SDA_Port,sI2C->HW.SDA_Pin);	//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20190104--寄存器版本
;;;131    }
000018  bd10              POP      {r4,pc}
;;;132    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=2

                  I2C_SendByte PROC
;;;296    *******************************************************************************/
;;;297    void I2C_SendByte(sI2CDef *sI2C,unsigned char ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;299    	unsigned char i	=	0;
000006  2500              MOVS     r5,#0
;;;300    	I2C_SCLLow(sI2C);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       I2C_SCLLow
;;;301    	I2C_Delayus(i2cdelaytime);
00000e  4812              LDR      r0,|L17.88|
000010  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000012  f7fffffe          BL       I2C_Delayus
;;;302    	for(i=0;i<8;i++)
000016  bf00              NOP      
000018  e01b              B        |L17.82|
                  |L17.26|
;;;303    	{
;;;304    		if(ucByte & 0x80)
00001a  f0040080          AND      r0,r4,#0x80
00001e  b118              CBZ      r0,|L17.40|
;;;305    		{
;;;306    			I2C_SDAHigh(sI2C);
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       I2C_SDAHigh
000026  e002              B        |L17.46|
                  |L17.40|
;;;307    		}
;;;308    		else
;;;309    		{
;;;310    			I2C_SDALow(sI2C);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       I2C_SDALow
                  |L17.46|
;;;311    		}
;;;312    		I2C_Delayus(i2cdelaytime);
00002e  480a              LDR      r0,|L17.88|
000030  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000032  f7fffffe          BL       I2C_Delayus
;;;313    		I2C_SCLHigh(sI2C);
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       I2C_SCLHigh
;;;314    		I2C_Delayus(i2cdelaytime);
00003c  4806              LDR      r0,|L17.88|
00003e  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000040  f7fffffe          BL       I2C_Delayus
;;;315    		I2C_SCLLow(sI2C);
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       I2C_SCLLow
;;;316    		
;;;317    		ucByte<<=1;		//左移1个bit
00004a  0660              LSLS     r0,r4,#25
00004c  0e04              LSRS     r4,r0,#24
00004e  1c68              ADDS     r0,r5,#1              ;302
000050  b2c5              UXTB     r5,r0                 ;302
                  |L17.82|
000052  2d08              CMP      r5,#8                 ;302
000054  dbe1              BLT      |L17.26|
;;;318    		//I2C_Delayus(i2cdelaytime);
;;;319    	}
;;;320    }
000056  bd70              POP      {r4-r6,pc}
;;;321    /*******************************************************************************
                          ENDP

                  |L17.88|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_Server||, CODE, READONLY, ALIGN=1

                  I2C_Server PROC
;;;57     *******************************************************************************/
;;;58     void I2C_Server(sI2CDef *sI2C)
000000  4770              BX       lr
;;;59     {
;;;60     	
;;;61     }
;;;62     
                          ENDP


                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=2

                  I2C_Start PROC
;;;251    *******************************************************************************/
;;;252    void I2C_Start(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;253    {
000002  4604              MOV      r4,r0
;;;254    	I2C_SCLLow(sI2C);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_SCLLow
;;;255    	I2C_SDASetOut(sI2C);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_SDASetOut
;;;256    	//=====================================SDA,SCL设置为高
;;;257    	I2C_SDAHigh(sI2C);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_SDAHigh
;;;258    	I2C_SCLHigh(sI2C);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       I2C_SCLHigh
;;;259    	I2C_Delayus(i2cdelaytime);
00001c  4809              LDR      r0,|L19.68|
00001e  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000020  f7fffffe          BL       I2C_Delayus
;;;260    	//=====================================SDA向低电平跳变
;;;261    	I2C_SDALow(sI2C);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_SDALow
;;;262    	I2C_Delayus(i2cdelaytime);
00002a  4806              LDR      r0,|L19.68|
00002c  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
00002e  f7fffffe          BL       I2C_Delayus
;;;263    	I2C_SCLLow(sI2C);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       I2C_SCLLow
;;;264    	I2C_Delayus(i2cdelaytime);
000038  4802              LDR      r0,|L19.68|
00003a  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
00003c  f7fffffe          BL       I2C_Delayus
;;;265    }
000040  bd10              POP      {r4,pc}
;;;266    /*******************************************************************************
                          ENDP

000042  0000              DCW      0x0000
                  |L19.68|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=2

                  I2C_Stop PROC
;;;274    *******************************************************************************/
;;;275    void I2C_Stop(sI2CDef *sI2C)
000000  b510              PUSH     {r4,lr}
;;;276    {
000002  4604              MOV      r4,r0
;;;277    	I2C_SDASetOut(sI2C);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_SDASetOut
;;;278    	//=====================================SDA设置为低,SCL设置为高
;;;279    	I2C_SDALow(sI2C);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_SDALow
;;;280    	I2C_SCLHigh(sI2C);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2C_SCLHigh
;;;281    	I2C_Delayus(i2cdelaytime);
000016  4806              LDR      r0,|L20.48|
000018  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
00001a  f7fffffe          BL       I2C_Delayus
;;;282    	//=====================================SDA由低电平向高电平跳变
;;;283    	I2C_SDAHigh(sI2C);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_SDAHigh
;;;284    	I2C_Delayus(i2cdelaytime);
000024  4802              LDR      r0,|L20.48|
000026  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
000028  f7fffffe          BL       I2C_Delayus
;;;285    //	I2C_SCLLow(sI2C);
;;;286    //	I2C_Delay();
;;;287    }
00002c  bd10              POP      {r4,pc}
;;;288    /*******************************************************************************
                          ENDP

00002e  0000              DCW      0x0000
                  |L20.48|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_WaitAck||, CODE, READONLY, ALIGN=2

                  I2C_WaitAck PROC
;;;155    *******************************************************************************/
;;;156    unsigned char I2C_WaitAck(sI2CDef *sI2C)
000000  b570              PUSH     {r4-r6,lr}
;;;157    {
000002  4605              MOV      r5,r0
;;;158    	I2CACKDef ack=I2C_ACK;
000004  2601              MOVS     r6,#1
;;;159    	unsigned long i	=	0;
000006  2400              MOVS     r4,#0
;;;160    	I2C_SCLLow(sI2C);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       I2C_SCLLow
;;;161    	I2C_SDASetIn(sI2C);	//设置为上拉输入模式
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       I2C_SDASetIn
;;;162    	I2C_SCLHigh(sI2C);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       I2C_SCLHigh
;;;163    	I2C_Delayus(i2cdelaytime);
00001a  480f              LDR      r0,|L21.88|
00001c  7800              LDRB     r0,[r0,#0]  ; i2cdelaytime
00001e  f7fffffe          BL       I2C_Delayus
;;;164    	while((I2C_ReadBit(sI2C))&&(i++<=40000))		//应答:SDA=0;无应答:SDA=1;
000022  e006              B        |L21.50|
                  |L21.36|
;;;165    	if(i>=40000-1)		//应答超时
000024  f649403f          MOV      r0,#0x9c3f
000028  4284              CMP      r4,r0
00002a  d301              BCC      |L21.48|
;;;166    	{
;;;167    		ack	= I2C_NACK;
00002c  2600              MOVS     r6,#0
00002e  e000              B        |L21.50|
                  |L21.48|
;;;168    	}
;;;169    	else
;;;170    	{
;;;171    		ack	= I2C_ACK;
000030  2601              MOVS     r6,#1
                  |L21.50|
000032  4628              MOV      r0,r5                 ;164
000034  f7fffffe          BL       I2C_ReadBit
000038  b128              CBZ      r0,|L21.70|
00003a  4620              MOV      r0,r4                 ;164
00003c  1c64              ADDS     r4,r4,#1              ;164
00003e  f6494140          MOV      r1,#0x9c40            ;164
000042  4288              CMP      r0,r1                 ;164
000044  d9ee              BLS      |L21.36|
                  |L21.70|
;;;172    	}
;;;173    	I2C_SCLLow(sI2C);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       I2C_SCLLow
;;;174    	
;;;175    	I2C_SDASetOut(sI2C);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       I2C_SDASetOut
;;;176    	
;;;177    	return (unsigned char)ack;
000052  4630              MOV      r0,r6
;;;178    }
000054  bd70              POP      {r4-r6,pc}
;;;179    /*******************************************************************************
                          ENDP

000056  0000              DCW      0x0000
                  |L21.88|
                          DCD      i2cdelaytime

                          AREA ||i.I2C_WriteBuffer||, CODE, READONLY, ALIGN=1

                  I2C_WriteBuffer PROC
;;;486    *******************************************************************************/
;;;487    void I2C_WriteBuffer(sI2CDef *sI2C,unsigned short address,const unsigned char* pBuffer,unsigned short length)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;488    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4692              MOV      r10,r2
00000a  469b              MOV      r11,r3
;;;489    	unsigned short i						=	0;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;490    //	unsigned char	PageSize			=	8;	//24C01、24C02这两个型号是8个字节一个页，而24C04、24C08、24C16是16个字节一页
;;;491    	unsigned char	WriteLen			=	0;
000010  2500              MOVS     r5,#0
;;;492    	unsigned short WWritelen		=	0;	//剩余待写入长度
000012  2600              MOVS     r6,#0
;;;493    	unsigned char	StartAddress	=	0;
000014  2700              MOVS     r7,#0
;;;494    	unsigned char* DataAddr;
;;;495    	//---------------------------启动I2C
;;;496    	I2C_Start(sI2C);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       I2C_Start
;;;497    	//---------------------------写器件地址
;;;498    	I2C_SendByte(sI2C,sI2C->DATA.DeviceAddr);	//bit0=0:write;bit0=1:read
00001c  7ea1              LDRB     r1,[r4,#0x1a]
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_SendByte
;;;499    	if(!I2C_WaitAck(sI2C))
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_WaitAck
00002a  b900              CBNZ     r0,|L22.46|
;;;500    	{		
;;;501    		goto stopI2C;
00002c  e043              B        |L22.182|
                  |L22.46|
;;;502    	}
;;;503    	StartAddress=address;			//
00002e  f00807ff          AND      r7,r8,#0xff
;;;504    	WWritelen=length;
000032  465e              MOV      r6,r11
;;;505    	DataAddr=(unsigned char*)&pBuffer[0];
000034  46d1              MOV      r9,r10
;;;506    	
;;;507    	StartWrite:
000036  bf00              NOP      
                  |L22.56|
;;;508    	//---------------------------判断数据地址是否为整页起始地址
;;;509    
;;;510    	if(0!=StartAddress%sI2C->DATA.PageSize)	//起始地址非页起始地址：先将不完整页写完
000038  7c60              LDRB     r0,[r4,#0x11]
00003a  fb97f1f0          SDIV     r1,r7,r0
00003e  fb007011          MLS      r0,r0,r1,r7
000042  b170              CBZ      r0,|L22.98|
;;;511    	{
;;;512    		WriteLen=(address/sI2C->DATA.PageSize+1)*sI2C->DATA.PageSize-StartAddress;	//不完整页的起始待写入数据个数
000044  7c60              LDRB     r0,[r4,#0x11]
000046  fb98f0f0          SDIV     r0,r8,r0
00004a  1c40              ADDS     r0,r0,#1
00004c  7c61              LDRB     r1,[r4,#0x11]
00004e  4348              MULS     r0,r1,r0
000050  1bc0              SUBS     r0,r0,r7
000052  b2c5              UXTB     r5,r0
;;;513    		
;;;514    		I2C_WriteNbyte(sI2C,StartAddress,DataAddr,WriteLen);		
000054  462b              MOV      r3,r5
000056  464a              MOV      r2,r9
000058  4639              MOV      r1,r7
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       I2C_WriteNbyte
000060  e010              B        |L22.132|
                  |L22.98|
;;;515    	}
;;;516    	else	//起始地址为页地址
;;;517    	{
;;;518    		//-----------------------是否为整页大小
;;;519    		if(WWritelen>=sI2C->DATA.PageSize)
000062  7c60              LDRB     r0,[r4,#0x11]
000064  42b0              CMP      r0,r6
000066  dc06              BGT      |L22.118|
;;;520    		{			
;;;521    			WriteLen=sI2C->DATA.PageSize;
000068  7c65              LDRB     r5,[r4,#0x11]
;;;522    			
;;;523    			I2C_WritePage(sI2C,StartAddress,DataAddr);
00006a  464a              MOV      r2,r9
00006c  4639              MOV      r1,r7
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       I2C_WritePage
000074  e006              B        |L22.132|
                  |L22.118|
;;;524    		}
;;;525    		else
;;;526    		{
;;;527    			WriteLen=WWritelen;	//不完整页的起始待写入数据个数
000076  b2f5              UXTB     r5,r6
;;;528    			
;;;529    			I2C_WriteNbyte(sI2C,StartAddress,DataAddr,WriteLen);
000078  462b              MOV      r3,r5
00007a  464a              MOV      r2,r9
00007c  4639              MOV      r1,r7
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       I2C_WriteNbyte
                  |L22.132|
;;;530    		}
;;;531    	}
;;;532    	//-------------------------------剩余待写入长度
;;;533    	WWritelen=WWritelen-WriteLen;		//剩余待写入长度
000084  1b70              SUBS     r0,r6,r5
000086  b286              UXTH     r6,r0
;;;534    	if(WWritelen>0)
000088  2e00              CMP      r6,#0
00008a  dd13              BLE      |L22.180|
;;;535    	{
;;;536    		StartAddress=StartAddress+WriteLen;		//下一个待写入数据的起始地址
00008c  1978              ADDS     r0,r7,r5
00008e  b2c7              UXTB     r7,r0
;;;537    		DataAddr=&DataAddr[WriteLen];	//新地址
000090  44a9              ADD      r9,r9,r5
;;;538    		I2C_Delayms(5);		//等待5ms完成写入EEPROM内部存储
000092  2005              MOVS     r0,#5
000094  f7fffffe          BL       I2C_Delayms
;;;539    		do		//检查器件是否完成写入
000098  bf00              NOP      
                  |L22.154|
;;;540    		{
;;;541    			I2C_Start(sI2C);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       I2C_Start
;;;542    			//---------------------------写器件地址
;;;543    			I2C_SendByte(sI2C,sI2C->DATA.DeviceAddr);	//bit0=0:write;bit0=1:read
0000a0  7ea1              LDRB     r1,[r4,#0x1a]
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       I2C_SendByte
;;;544    		}
;;;545    		while(I2C_NACK==I2C_WaitAck(sI2C));
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       I2C_WaitAck
0000ae  2800              CMP      r0,#0
0000b0  d0f3              BEQ      |L22.154|
;;;546    		goto StartWrite;
0000b2  e7c1              B        |L22.56|
                  |L22.180|
;;;547    	}
;;;548    	//---------------------------停止I2C
;;;549    	stopI2C:
0000b4  bf00              NOP      
                  |L22.182|
;;;550    	I2C_Stop(sI2C);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       I2C_Stop
;;;551    	I2C_Delayms(5);		//等待5ms完成写入EEPROM内部存储
0000bc  2005              MOVS     r0,#5
0000be  f7fffffe          BL       I2C_Delayms
;;;552    }
0000c2  e8bd8ff8          POP      {r3-r11,pc}
;;;553    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_WriteNbyte||, CODE, READONLY, ALIGN=1

                  I2C_WriteNbyte PROC
;;;439    *******************************************************************************/
;;;440    void I2C_WriteNbyte(sI2CDef *sI2C,unsigned short address,const unsigned char* pBuffer,unsigned short length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;441    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;442    	unsigned short i						=	0;
00000c  2400              MOVS     r4,#0
;;;443    //	unsigned char	PageSize			=	8;	//24C01、24C02这两个型号是8个字节一个页，而24C04、24C08、24C16是16个字节一页
;;;444    	//unsigned char	WriteLen			=	0;
;;;445    	//unsigned short WWritelen		=	0;	//剩余待写入长度
;;;446    	//unsigned char	StartAddress	=	0;
;;;447    	//---------------------------启动I2C
;;;448    	I2C_Start(sI2C);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       I2C_Start
;;;449    	//---------------------------写器件地址
;;;450    	I2C_SendByte(sI2C,sI2C->DATA.DeviceAddr);	//bit0=0:write;bit0=1:read
000014  7ea9              LDRB     r1,[r5,#0x1a]
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       I2C_SendByte
;;;451    	if(!I2C_WaitAck(sI2C))
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       I2C_WaitAck
000022  b900              CBNZ     r0,|L23.38|
;;;452    	{		
;;;453    		goto stopI2C;
000024  e01e              B        |L23.100|
                  |L23.38|
;;;454    	}
;;;455    	//---------------------------写内存地址
;;;456    	I2C_SDASetOut(sI2C);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       I2C_SDASetOut
;;;457    	I2C_SendByte(sI2C,address);
00002c  b2f1              UXTB     r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       I2C_SendByte
;;;458    	
;;;459    	if(!I2C_WaitAck(sI2C))
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       I2C_WaitAck
00003a  b900              CBNZ     r0,|L23.62|
;;;460    	{
;;;461    		goto stopI2C;
00003c  e012              B        |L23.100|
                  |L23.62|
;;;462    	}
;;;463    	//---------------------------写数据
;;;464    	I2C_SDASetOut(sI2C);
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       I2C_SDASetOut
;;;465    	for(i=0;i<length;i++)
000044  2400              MOVS     r4,#0
000046  e00a              B        |L23.94|
                  |L23.72|
;;;466    	{
;;;467    		I2C_SendByte(sI2C,pBuffer[i]);
000048  5d39              LDRB     r1,[r7,r4]
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       I2C_SendByte
;;;468    		if(!I2C_WaitAck(sI2C))
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       I2C_WaitAck
000056  b900              CBNZ     r0,|L23.90|
;;;469    		{
;;;470    			goto stopI2C;
000058  e004              B        |L23.100|
                  |L23.90|
00005a  1c60              ADDS     r0,r4,#1              ;465
00005c  b284              UXTH     r4,r0                 ;465
                  |L23.94|
00005e  4544              CMP      r4,r8                 ;465
000060  dbf2              BLT      |L23.72|
;;;471    		}
;;;472    	}
;;;473    	//---------------------------
;;;474    	//---------------------------停止I2C
;;;475    	stopI2C:
000062  bf00              NOP      
                  |L23.100|
;;;476    	I2C_Stop(sI2C);
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       I2C_Stop
;;;477    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;478    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_WriteOneByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteOneByte PROC
;;;329    *******************************************************************************/
;;;330    void I2C_WriteOneByte(sI2CDef *sI2C,const unsigned short address,unsigned char ucByte)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;331    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;332    	unsigned char i	=	0;
00000a  f04f0800          MOV      r8,#0
;;;333    	unsigned char temp	=	0xA0;		//bit0=0:write;bit0=1:read
00000e  27a0              MOVS     r7,#0xa0
;;;334    	I2C_Start(sI2C);
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       I2C_Start
;;;335    	//---------------------------写器件地址
;;;336    	I2C_SendByte(sI2C,temp);
000016  4639              MOV      r1,r7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       I2C_SendByte
;;;337    
;;;338    	if(!I2C_WaitAck(sI2C))
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       I2C_WaitAck
000024  b900              CBNZ     r0,|L24.40|
;;;339    	{		
;;;340    		goto stopI2C;
000026  e01a              B        |L24.94|
                  |L24.40|
;;;341    	}
;;;342    	//---------------------------写内存地址
;;;343    	temp	=	address;
000028  b2e7              UXTB     r7,r4
;;;344    	
;;;345    	I2C_SDASetOut(sI2C);
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       I2C_SDASetOut
;;;346    	I2C_SendByte(sI2C,temp);
000030  4639              MOV      r1,r7
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       I2C_SendByte
;;;347    	
;;;348    	if(!I2C_WaitAck(sI2C))
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       I2C_WaitAck
00003e  b900              CBNZ     r0,|L24.66|
;;;349    	{
;;;350    		goto stopI2C;
000040  e00d              B        |L24.94|
                  |L24.66|
;;;351    	}
;;;352    	//---------------------------写数据
;;;353    	temp	=	ucByte;
000042  462f              MOV      r7,r5
;;;354    	
;;;355    	I2C_SDASetOut(sI2C);
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       I2C_SDASetOut
;;;356    	I2C_SendByte(sI2C,temp);
00004a  4639              MOV      r1,r7
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       I2C_SendByte
;;;357    	
;;;358    	if(!I2C_WaitAck(sI2C))
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       I2C_WaitAck
000058  b900              CBNZ     r0,|L24.92|
;;;359    	{
;;;360    		goto stopI2C;
00005a  e000              B        |L24.94|
                  |L24.92|
;;;361    	}
;;;362    	//---------------------------停止I2C
;;;363    	stopI2C:
00005c  bf00              NOP      
                  |L24.94|
;;;364    	I2C_Stop(sI2C);
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       I2C_Stop
;;;365    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;366    /*******************************************************************************
                          ENDP


                          AREA ||i.I2C_WritePage||, CODE, READONLY, ALIGN=1

                  I2C_WritePage PROC
;;;375    *******************************************************************************/
;;;376    void I2C_WritePage(sI2CDef *sI2C,unsigned short PageAddress,const unsigned char* pBuffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;377    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;378    	
;;;379    	unsigned char		temp			=	0xA0;	//bit0=0:write;bit0=1:read
00000a  f04f08a0          MOV      r8,#0xa0
;;;380    	//unsigned char	 	PageSize	=	0;
;;;381    	unsigned short 	i					=	0;
00000e  2600              MOVS     r6,#0
;;;382    	//---------------------------检查数据
;;;383    
;;;384    	//---------------------------检查页地址
;;;385    	if(0==sI2C->DATA.PageSize)
000010  7c60              LDRB     r0,[r4,#0x11]
000012  b908              CBNZ     r0,|L25.24|
                  |L25.20|
;;;386    	{
;;;387    		return;
;;;388    	}
;;;389    	if(0==PageAddress%sI2C->DATA.PageSize)
;;;390    	{
;;;391    		sI2C->DATA.WPageAddr+=sI2C->DATA.PageSize;
;;;392    	}
;;;393    	else
;;;394    	{
;;;395    		return;
;;;396    	}
;;;397    	
;;;398    	//---------------------------启动I2C
;;;399    	I2C_Start(sI2C);
;;;400    	//---------------------------写器件地址
;;;401    	I2C_SendByte(sI2C,temp);
;;;402    	if(!I2C_WaitAck(sI2C))
;;;403    	{		
;;;404    		goto stopI2C;
;;;405    	}
;;;406    	//---------------------------写内存地址
;;;407    	temp	=	PageAddress;
;;;408    	
;;;409    	I2C_SDASetOut(sI2C);
;;;410    	I2C_SendByte(sI2C,temp);
;;;411    	
;;;412    	if(!I2C_WaitAck(sI2C))
;;;413    	{
;;;414    		goto stopI2C;
;;;415    	}
;;;416    	//---------------------------写数据
;;;417    	I2C_SDASetOut(sI2C);
;;;418    	for(i=0;i<sI2C->DATA.PageSize;i++)
;;;419    	{
;;;420    		temp=pBuffer[i];
;;;421    		I2C_SendByte(sI2C,temp);
;;;422    		if(!I2C_WaitAck(sI2C))
;;;423    		{
;;;424    			goto stopI2C;
;;;425    		}
;;;426    	}
;;;427    	//---------------------------停止I2C
;;;428    	stopI2C:
;;;429    	I2C_Stop(sI2C);
;;;430    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L25.24|
000018  7c60              LDRB     r0,[r4,#0x11]         ;389
00001a  fb95f1f0          SDIV     r1,r5,r0              ;389
00001e  fb005011          MLS      r0,r0,r1,r5           ;389
000022  b920              CBNZ     r0,|L25.46|
000024  8aa1              LDRH     r1,[r4,#0x14]         ;391
000026  7c60              LDRB     r0,[r4,#0x11]         ;391
000028  4408              ADD      r0,r0,r1              ;391
00002a  82a0              STRH     r0,[r4,#0x14]         ;391
00002c  e000              B        |L25.48|
                  |L25.46|
00002e  e7f1              B        |L25.20|
                  |L25.48|
000030  4620              MOV      r0,r4                 ;399
000032  f7fffffe          BL       I2C_Start
000036  4641              MOV      r1,r8                 ;401
000038  4620              MOV      r0,r4                 ;401
00003a  f7fffffe          BL       I2C_SendByte
00003e  4620              MOV      r0,r4                 ;402
000040  f7fffffe          BL       I2C_WaitAck
000044  b900              CBNZ     r0,|L25.72|
000046  e023              B        |L25.144|
                  |L25.72|
000048  f00508ff          AND      r8,r5,#0xff           ;407
00004c  4620              MOV      r0,r4                 ;409
00004e  f7fffffe          BL       I2C_SDASetOut
000052  4641              MOV      r1,r8                 ;410
000054  4620              MOV      r0,r4                 ;410
000056  f7fffffe          BL       I2C_SendByte
00005a  4620              MOV      r0,r4                 ;412
00005c  f7fffffe          BL       I2C_WaitAck
000060  b900              CBNZ     r0,|L25.100|
000062  e015              B        |L25.144|
                  |L25.100|
000064  4620              MOV      r0,r4                 ;417
000066  f7fffffe          BL       I2C_SDASetOut
00006a  2600              MOVS     r6,#0                 ;418
00006c  e00c              B        |L25.136|
                  |L25.110|
00006e  f8178006          LDRB     r8,[r7,r6]            ;420
000072  4641              MOV      r1,r8                 ;421
000074  4620              MOV      r0,r4                 ;421
000076  f7fffffe          BL       I2C_SendByte
00007a  4620              MOV      r0,r4                 ;422
00007c  f7fffffe          BL       I2C_WaitAck
000080  b900              CBNZ     r0,|L25.132|
000082  e005              B        |L25.144|
                  |L25.132|
000084  1c70              ADDS     r0,r6,#1              ;418
000086  b286              UXTH     r6,r0                 ;418
                  |L25.136|
000088  7c60              LDRB     r0,[r4,#0x11]         ;418
00008a  42b0              CMP      r0,r6                 ;418
00008c  dcef              BGT      |L25.110|
00008e  bf00              NOP                            ;428
                  |L25.144|
000090  4620              MOV      r0,r4                 ;429
000092  f7fffffe          BL       I2C_Stop
000096  bf00              NOP      
000098  e7bc              B        |L25.20|
;;;431    /*******************************************************************************
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  i2cdelaytime
000000  01                DCB      0x01
