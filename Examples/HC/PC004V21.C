#ifdef PC004V21				//单元控制板

#include "PC004V21.H"


#include "STM32F10x_BitBand.H"
#include "STM32_GPIO.H"
#include "STM32_SYS.H"
#include "STM32_SYSTICK.H"
#include "STM32_WDG.H"
#include "STM32_PWM.H"


#include "STM32_CAN.H"
#include "STM32_USART.H"
#include "STM32_TOOLS.H"		//数据校验工具


#include "string.h"				//串和内存操作函数头文件

/*##############################################################################
################################################################################
# 项目名		:	MS0800_PC004V10	
# 功能描述	:	智能药架单元板
-------------------------------------------------------------------------------	
********************************功能说明***************************************
-------------------------------------------------------------------------------
● 与网关板通讯，传达指令到数码管显示板，
● 显示地址：柜机号
● 拔码方式：
● CAN通讯说明：
	波特率：	100K
	公有地址：0X000
	
● 485通讯说明：485与网关板通讯
	波特率：	9600
	串口号：	USART2
	控制脚：	PA1
	头码：		0XFA,0XFB
	私有地址：拔码开关地址
-------------------------------------------------------------------------------
********************************软件流程***************************************
-------------------------------------------------------------------------------
1）配置项目
2）上电后主动获取单元地址
3）	
4）	
5）	
-------------------------------------------------------------------------------
*****************************指令/协议说明*************************************
-------------------------------------------------------------------------------

--------------------------------CAN协议----------------------------------------
1.1）	CAN协议：				与数码管板通讯
			CAN―ID：					0X3FF(StdId=0X3FF;)
			长度：						3	(DLC=1;)
			层时间同步：			0XAA;(Data[0]=0XAA;)
			获取/显示ID指令：	0X01;(Data[0]=0X01;)
			自检指令：				0X02;(Data[0]=0X02;)
			熄屏指令：				0X03;(Data[0]=0X02;)
-------------------------------------------------------------------------------		
1.2）	数码管板上报地址：设定完数码管板ID后往单元板上他地址
			CAN―ID：			SW_ID（拔码开关地址）
			长度：				1	(DLC=1;)
			层时间同步：	0XAA;(Data[0]=0XAA;)
		
1.3）	数码管板接收数据：接收上级单元板数据，显示或者关闭
			CAN―ID：			SW_ID（拔码开关地址）
			长度：					3	(DLC=3;)
			数据显示标识：	0X08;(Data[0]=0X08;)
			显示数据内容：	最大显示999
										高位8位：Data[1]
										低位8位：Data[2]
									
1.4）	数码管板应答：数据完板接收到正确的数据后的回执
			CAN―ID：			SW_ID（拔码开关地址）
			长度：					1	(DLC=1;)
			层时间同步：		0XA0;(Data[0]=0XA0;)
--------------------------------485协议----------------------------------------
2.1）	485协议：			与网关板通讯
			数据长度：	13Byte
			RS232通讯说明：			FA F5 01 01 BCC8 00 06 01 01 01 00 01 25------->FA F5 01 01 27 00 06 01 01 01 00 01 25
//			格式：			HEAD(2)，命令，柜号，单元号，数值高位，数值低位，异或校验
			说明：
			HEAD:				0XFA,0XFB
			命令：			0X00--关闭显示，0X01--显示数值，0x02--获取连接设备地址（柜号和单元号）,0x03--显示单元ID，
			柜号：			单元柜号，1~0XFF
			单元号：		数码管ID号，10~77
			数值高位：	与低位连接
			数值低位：	与高位连接，连接后取值范围：0~999，数码管只有三位
			异或校验：	Byte0~Byte6校验
			接收数据单元无误，回执位为0X80|命令类型
			接收数据单元地址错误：回执位0XE0|命令类型
-------------------------------------------------------------------------------


********************************************************************************

################################################################################
###############################################################################*/

#define RS485TX	0
#define RS485RX	1
#define PC004V10_RS4851_CTL(n)	if(n==RS485RX){GPIO_ResetBits(GPIOA,GPIO_Pin_1);}else{GPIO_SetBits(GPIOA,GPIO_Pin_1);}

//************CAN通讯数据
#define	CAN_ID				PC004V10_Num[8]*10+PC004V10_Num[9]		//单元地址	由两位数合并，十位为层，个位为序号
#define	CAN_Command		PC004V10_Num[5]												//命令类型----上位机用户码
#define	Data_H				PC004V10_Num[11]											//数据高位
#define	Data_L				PC004V10_Num[12]											//数据低位

//#define	PC002Test			//智能药盒主控板测试
#define	USART_TO_485	//USART与RS485互转
//#define	PD002TEST				//称重控制板测试
//#define	PD003V11TEST		//智能药盒测试
//#define	PD014V15TEST		//盒剂控制板测试
//#define	PD011V20TEST		//八路电机控制板测试
//************485通讯数据
//#define	

#define	PC004V10_BufferSize 1024															//DMA1缓冲大小

//u8 RxBuffer[PC004V10_BufferSize]={0};								//RS485缓存
//u8 ReBuffer[PC004V10_BufferSize]={0};								//RS485缓存

u8 RS485RxB[PC004V10_BufferSize]={0};								//RS485缓存
u8 RS485RvB[PC004V10_BufferSize]={0};								//RS485缓存
u8 RS485Txd[PC004V10_BufferSize]={0};								//RS485缓存

u8 USART1Rxd[PC004V10_BufferSize]={0};								//RS485缓存
u8 USART1Txd[PC004V10_BufferSize]={0};								//RS485缓存

u8 PC004V10_Buffer[PC004V10_BufferSize]={0};								//RS485缓存
u8 PC004V10_TBuffer[PC004V10_BufferSize]={0};								//RS485缓存
u8 PC004V10_Num[13]={0};																		//接收到的数据
u8 PC004V10_CANBuffer[8]={0};																//接收到的数据

u8 ID_ARR[8][8]={0,0};			//存储已连接数码管ID列表
u8 ON_line[8][8]={0,0};			//对应ID列表标志位，0--无此ID，1--有对应ID

u8 SwitchID=0;				//拔码开关地址 //单元板ID----从右到左依次为增高，最右边为最低位
u8 SwitchIDBAC=0xFF;			//ID备份---ID变化时更新
u8 NumW=0;				//槽号--MS拨码为槽号
u8 NumF=0;				//发药数量--LS拨码为发药数量

u16	SYSTime=0;							//循环计时变量
u8 Buzzer_time=0;						//开机蜂鸣器响应次数

u8 Self_Dsp=0;							//拔码开关为0时，自检测试显示标识变量

u16 num=0;
u8 PB1Flg=0;
u8 PW1Flg=0;
u16 KeyTime=0;

RS485_TypeDef  RS485B;			//连接到下级接口485
RS485_TypeDef  RS485A;			//连接到上级接口485
CanRxMsg RxMessage;
CanTxMsg TxMessage;

u8 RxData	=	0;
/*******************************************************************************
* 函数名		:	
* 功能描述	:	 
* 输入		:	
* 输出		:
* 返回 		:
*******************************************************************************/
void PC004V21_Configuration(void)
{
	
	SYS_Configuration();					//系统配置---打开系统时钟 STM32_SYS.H
	
	GPIO_DeInitAll();							//将所有的GPIO关闭----V20170605
	
	PC004V21_PinSet();
	
	SysTick_Configuration(500);	//系统嘀嗒时钟配置72MHz,单位为uS
	
//	IWDG_Configuration(1000);			//独立看门狗配置---参数单位ms	
	
	PWM_OUT(TIM2,PWM_OUTChannel1,1,900);						//PWM设定-20161127版本
//	PWM_OUT(TIM3,PWM_OUTChannel3,0.5,5);						//PWM设定-20161127版本
	
	PD002V30_USART_Cofiguration();
	
	CAN_Configuration_NR(100000);										//CAN配置---标志位查询方式，不开中断
	
	CAN_FilterInitConfiguration_StdData(0X01,0X001,0X001);			//CAN滤波器配置---标准数据帧模式

	
	PC004V10_Num[8]=1;
	PC004V10_Num[9]=0;
	PC004V10_Num[11]=0;
	PC004V10_Num[12]=0;
	
	PC004V10_TBuffer[0]=0x00;
	PC004V10_TBuffer[1]=0x05;
	PC004V10_TBuffer[2]=0x03;
	PC004V10_TBuffer[3]=0x03;
	PC004V10_TBuffer[4]=0x00;
	PC004V10_TBuffer[5]=0x00;
	PC004V10_TBuffer[6]=0x00;
	PC004V10_TBuffer[7]=0x00;
	PC004V10_TBuffer[8]=0x00;
	PC004V10_TBuffer[9]=0x00;
	
	PC004V10_TBuffer[10]=BCC8(PC004V10_TBuffer,10);		//异或校验
}
/*******************************************************************************
* 函数名		:	
* 功能描述	:	 
* 输入		:	
* 输出		:
* 返回 		:
*******************************************************************************/
void PC004V21_Server(void)
{
	//循环周期1mS
	IWDG_Feed();								//独立看门狗喂狗
	
#ifdef PD002TEST			//称重控制板测试
	PD002VXXFUN();			//称重控制板测试
	return;
#endif
#ifdef PD003V11TEST		//智能药盒测试
	PD003V11FUN();
	return;
#endif
#ifdef PD011V20TEST		//智能药盒测试
	PD011V20FUN();			//八路电机控制板测试
	return;
#endif
#ifdef USART_TO_485
	USART2RS485();			//USART与RS485互转
	return;
#endif	
	
#ifdef PC002Test
	PC002VxxFUN();			//智能药盒主控板测试
	return;
#endif
#ifdef PD014V15TEST
	PD014V15FUN();			//盒剂控制板测试
	return;
#endif

}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: void
* 返回值			: void
* 修改时间		: 无
* 修改内容		: 无
* 其它			: wegam@sina.com
*******************************************************************************/
void PC002VxxFUN(void)				//智能药盒主控板测试
{
	u8 status=0;
	if(SYSTime++>500)
	{
		SYSTime	=	0;
		RS485_DMASend(&RS485B,&RxData,1);	//RS485-DMA发送程序
	}
	status	=	RS485_ReadBufferIDLE(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(status	==	9)
	{
		u32 AD1=0,AD2=0;
		u32 temp	=	0;
		AD1	=	(u32)(RS485RvB[4]<<24)	+	(u32)(RS485RvB[3]<<16)	+	(u32)(RS485RvB[2]<<8)	+	(u32)(RS485RvB[1]<<0);
		AD2	=	(u32)(RS485RvB[8]<<24)	+	(u32)(RS485RvB[7]<<16)	+	(u32)(RS485RvB[6]<<8)	+	(u32)(RS485RvB[5]<<0);		
		USART_DMAPrintf	(USART1,"CH1:%0.8X\r\nCH2:%0.8X\r\n",AD1,AD2);					//自定义printf串口DMA发送程序,后边的省略号就是可变参数
	}
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: void
* 返回值			: void
* 修改时间		: 无
* 修改内容		: 无
* 其它			: wegam@sina.com
*******************************************************************************/
void USART2RS485(void)		//USART与RS485互转
{
	u16 status=0;	
	status	=	USART_ReadBufferIDLE(USART1,USART1Rxd);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(status)
	{
		SysTick_DeleymS(1);				//SysTick延时nmS
		memcpy(RS485Txd,USART1Rxd,status);
		RS485_DMASend(&RS485B,RS485Txd,status);					//RS485-DMA发送程序
		SysTick_DeleymS(1);				//SysTick延时nmS
	}
	status	=	RS485_ReadBufferIDLE(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(status)
	{
		memcpy(USART1Txd,RS485RvB,status);
		USART_DMASend(USART1,USART1Txd,status);
	}
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	板
* 输入			: 命令：0x11发药，0x12盘点，0x13加药,0x14
* 返回值			: void
*******************************************************************************/
void PD002VXXFUN(void)		//称重控制板测试
{
	u8 status=0;	
	status	=	USART_ReadBufferIDLE(USART1,USART1Rxd);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(status)
	{
		SysTick_DeleymS(1);				//SysTick延时nmS
		memcpy(RS485Txd,USART1Rxd,status);
		RS485_DMASend(&RS485B,RS485Txd,status);					//RS485-DMA发送程序
//		SysTick_DeleymS(1);				//SysTick延时nmS
	}
	status	=	RS485_ReadBufferIDLE(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(status)
	{
		if(RS485RvB[3]	==	0x0A)
		{
			memset(RS485RvB,0x00,status);
			return;
		}
		else
		{
			memcpy(RS485Txd,RS485RvB,status);
			memcpy(USART1Txd,RS485RvB,status);
			RS485Txd[3]		=	0x0B;			//异或校验
			RS485Txd[11]	=	BCC8(&RS485Txd[2],9);				//异或校验
			RS485_DMASend(&RS485B,RS485Txd,12);					//RS485-DMA发送程序
		}
		USART_DMASend(USART1,USART1Txd,status);
	}
	return;
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: 命令：0x11发药，0x12盘点，0x13加药,0x14
* 返回值			: void
*******************************************************************************/
void PD003V11FUN(void)		//智能药盒测试
{
	u16 len	=	0;
	static u8 BOXID[6]={0};	//电子标签
	static u8 serail=1;			//流水号
	if(serail>=0xFE)
		serail	=	1;
	len	=	USART_ReadBufferIDLE(USART1,USART1Rxd);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(len)
	{
		//===测试药盒ID号
		if(BOXID[0]	==	0x00)
		{
			BOXID[0]	=	0x9E;
			BOXID[1]	=	0xB1;
			BOXID[2]	=	0x18;
			BOXID[3]	=	0x19;
			BOXID[4]	=	0x00;
			BOXID[5]	=	0x00;
		}
		if((USART1Rxd[0]==0x11)||(USART1Rxd[0]==0x12)||(USART1Rxd[0]==0x13)||(USART1Rxd[0]==0x14))
		{
			RS485Txd[0]	=	0xFA;
			RS485Txd[1]	=	0xF5;
			RS485Txd[2]	=	serail++;	//流水号
			memcpy(&RS485Txd[3],BOXID,6);	//电子标签
			RS485Txd[9]	=	0x00;	//软件自定义
			RS485Txd[10]	=	0x00;	//软件自定义
			RS485Txd[11]	=	USART1Rxd[0];	//命令类型
			RS485Txd[12]	=	0x01;	//物理盘点此位必须是0x01
			RS485Txd[13]	=	0x01;	//1-6，该位对应某个位置药盒执行指令
			RS485Txd[14]	=	0x00;	//运行状态位
			RS485Txd[15]	=	0x00;	//错误状态
			RS485Txd[16]	=	BCC8(&RS485Txd[3],13);	//校验
		}
		RS485_DMASend(&RS485B,RS485Txd,17);					//RS485-DMA发送程序
	}
	len	=	RS485_ReadBufferIDLE(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(len)
	{
		//接收到药盒应答消息
		if(RS485RvB[14]	==	0x0A)
		{
			USART_DMAPrintf(USART1,"智能药盒应答\r\n");
//			USART_DMASend(USART1,RS485RvB,len);		//串口DMA发送程序
			memset(RS485RvB,0x00,17);
			return;
		}
//		USART_DMASend(USART1,RS485RvB,len);		//串口DMA发送程序
		//应答药盒
		SysTick_DeleymS(10);				//SysTick延时nmS
		memcpy(RS485Txd,RS485RvB,len);
		RS485Txd[14]	=	0X0B;			//应答位
		RS485Txd[16]	=	BCC8(&RS485Txd[3],13);			//校验位
		RS485_DMASend(&RS485B,RS485Txd,len);				//RS485-DMA发送程序
		if(RS485RvB[11]	==	0x14)
		{
			memcpy(BOXID,&RS485RvB[3],6);
			USART_DMAPrintf(USART1,"接收到电子标签：%0.2X %0.2X %0.2X %0.2X %0.2X %0.2X\r\n",BOXID[0],BOXID[1],BOXID[2],BOXID[3],BOXID[4],BOXID[5],BOXID[6]);					//自定义printf串口DMA发送程序,后边的省略号就是可变参数
			return;
		}
		switch(RS485RvB[15])
		{
			case	0xE0:USART_DMAPrintf(USART1,"智能药盒超时未取\r\n");
						break;
			case	0xE1:USART_DMAPrintf(USART1,"ID不能读取\r\n");
						break;
			case	0xE2:USART_DMAPrintf(USART1,"智能药盒盒内药量不足，不满足发药数\r\n");
						break;
			case	0xE3:USART_DMAPrintf(USART1,"智能药盒发药数是0或者超过72，属于发药数量越界\r\n");
						break;
			case	0xE4:USART_DMAPrintf(USART1,"智能药盒动作盘点计算数据不是0-72，明显错误\r\n");
						break;
			case	0xE5:USART_DMAPrintf(USART1,"药盒电子标签信息和存取记录不匹配\r\n");
						break;
			case	0xE6:USART_DMAPrintf(USART1,"智能药盒位置位不是1-6\r\n");
						break;
			case	0xE7:USART_DMAPrintf(USART1,"智能药盒异常拔出收回\r\n");
						break;
			case	0xE8:USART_DMAPrintf(USART1,"智能药盒异常拔出\r\n");
						break;			
			default:break;			
		}
		memset(RS485RvB,0x00,17);
		return;
	}
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: 
* 返回值			: void
*******************************************************************************/
void PD011V20FUN(void)		//八路电机控制板测试
{
	u16 len	=	0;
	static u8 BOXID[6]={0};	//电子标签
	static u8 serail=1;			//流水号
	if(serail>=0xFE)
		serail	=	1;
	len	=	USART_ReadBufferIDLE(USART1,USART1Rxd);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(len)
	{
		//===测试药盒ID号
		if(BOXID[0]	==	0x00)
		{
			BOXID[0]	=	0x9E;
			BOXID[1]	=	0xB1;
			BOXID[2]	=	0x18;
			BOXID[3]	=	0x19;
			BOXID[4]	=	0x00;
			BOXID[5]	=	0x00;
		}
		if((USART1Rxd[0]==0x11)||(USART1Rxd[0]==0x12)||(USART1Rxd[0]==0x13)||(USART1Rxd[0]==0x14))
		{
			RS485Txd[0]	=	0xFA;
			RS485Txd[1]	=	0xF5;
			RS485Txd[2]	=	serail++;	//流水号
			memcpy(&RS485Txd[3],BOXID,6);	//电子标签
			RS485Txd[9]	=	0x00;	//软件自定义
			RS485Txd[10]	=	0x00;	//软件自定义
			RS485Txd[11]	=	USART1Rxd[0];	//命令类型
			RS485Txd[12]	=	0x01;	//物理盘点此位必须是0x01
			RS485Txd[13]	=	0x01;	//1-6，该位对应某个位置药盒执行指令
			RS485Txd[14]	=	0x00;	//运行状态位
			RS485Txd[15]	=	0x00;	//错误状态
			RS485Txd[16]	=	BCC8(&RS485Txd[3],13);	//校验
		}
		RS485_DMASend(&RS485B,RS485Txd,17);					//RS485-DMA发送程序
	}
	len	=	RS485_ReadBufferIDLE(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	if(len)
	{
		//接收到药盒应答消息
		if(RS485RvB[14]	==	0x0A)
		{
			USART_DMAPrintf(USART1,"智能药盒应答\r\n");
//			USART_DMASend(USART1,RS485RvB,len);		//串口DMA发送程序
			memset(RS485RvB,0x00,17);
			return;
		}
//		USART_DMASend(USART1,RS485RvB,len);		//串口DMA发送程序
		//应答药盒
		SysTick_DeleymS(10);				//SysTick延时nmS
		memcpy(RS485Txd,RS485RvB,len);
		RS485Txd[14]	=	0X0B;			//应答位
		RS485Txd[16]	=	BCC8(&RS485Txd[3],13);			//校验位
		RS485_DMASend(&RS485B,RS485Txd,len);				//RS485-DMA发送程序
		if(RS485RvB[11]	==	0x14)
		{
			memcpy(BOXID,&RS485RvB[3],6);
			USART_DMAPrintf(USART1,"接收到电子标签：%0.2X %0.2X %0.2X %0.2X %0.2X %0.2X\r\n",BOXID[0],BOXID[1],BOXID[2],BOXID[3],BOXID[4],BOXID[5],BOXID[6]);					//自定义printf串口DMA发送程序,后边的省略号就是可变参数
			return;
		}
		switch(RS485RvB[15])
		{
			case	0xE0:USART_DMAPrintf(USART1,"智能药盒超时未取\r\n");
						break;
			case	0xE1:USART_DMAPrintf(USART1,"ID不能读取\r\n");
						break;
			case	0xE2:USART_DMAPrintf(USART1,"智能药盒盒内药量不足，不满足发药数\r\n");
						break;
			case	0xE3:USART_DMAPrintf(USART1,"智能药盒发药数是0或者超过72，属于发药数量越界\r\n");
						break;
			case	0xE4:USART_DMAPrintf(USART1,"智能药盒动作盘点计算数据不是0-72，明显错误\r\n");
						break;
			case	0xE5:USART_DMAPrintf(USART1,"药盒电子标签信息和存取记录不匹配\r\n");
						break;
			case	0xE6:USART_DMAPrintf(USART1,"智能药盒位置位不是1-6\r\n");
						break;
			case	0xE7:USART_DMAPrintf(USART1,"智能药盒异常拔出收回\r\n");
						break;
			case	0xE8:USART_DMAPrintf(USART1,"智能药盒异常拔出\r\n");
						break;			
			default:break;			
		}
		memset(RS485RvB,0x00,17);
		return;
	}
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: void
* 返回值			: void
* 修改时间		: 无
* 修改内容		: 无
* 其它			: wegam@sina.com
*******************************************************************************/
void PD014V15FUN(void)		//盒剂控制板测试
{
	
	SYSTime++;
	//锁接口LED指示灯
	{
		if(SYSTime%1000<50)
		{
			PB0	=	1;
		}
		else
		{
			PB0	=	0;
		}
	}
	
//	if(RxData>=250)
//	{
//		RxData=0;
//	}
//	status	=	RS485_ReadBufferIDLE(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
//	if(status)
//	{
//		RxData+=1;
//	}
//	if(SYSTime	==500)
//	{
//		SYSTime	=	0;
//		RxData+=1;
//		RS485_DMASend(&RS485B,&RxData,1);	//RS485-DMA发送程序
//		SysTick_DeleymS(5);				//SysTick延时nmS
//		return;
//	}
	
	SwitchID=PC004V21_GetSwitchID();	//获取当前设备ID//机柜号
	NumW=((SwitchID>>4)&0x0F)|(SwitchID<<1&0x10);			//MS拨码为槽号（HSH,右边最低位）
	NumF=SwitchID&0x07;														//发药数量--LS拨码为发药数量（HSL拨码)
//	SwitchIDBAC=0xFF;								//ID备份---ID变化时更新
	if(SwitchIDBAC!=SwitchID)
	{		
		SwitchIDBAC=SwitchID;		//更新备份
		PC004V10_TBuffer[0]=0x00;		//0xFF,NumW,NumF
		PC004V10_TBuffer[1]=0xFF;		//0xFF,NumW,NumF
		PC004V10_TBuffer[2]=NumW;		//0xFF,NumW,NumF
		PC004V10_TBuffer[3]=NumF;		//0xFF,NumW,NumF
		RS485_DMASend	(&RS485B,PC004V10_TBuffer,4);	//RS485-DMA发送程序
//		RS485_DMAPrintf(&RS485_Conf,"请求更新，发药槽号:%d,发药数量：%d",NumW,NumF);					//自定义printf串口DMA发送程序,后边的省略号就是可变参数
	}
	if(SYSTime	==500)
	{
		RS485_DMASend(&RS485B,PC004V10_TBuffer,11);	//RS485-DMA发送程序		
	}
	else
	{
		RS485_ReadBufferIDLE			(&RS485B,RS485RvB);	//串口空闲模式读串口接收缓冲区，如果有数据，将数据拷贝到RevBuffer,并返回接收到的数据个数，然后重新将接收缓冲区地址指向RxdBuffer
	}
//	return;
	if(SYSTime>=1000)
	{
		SYSTime=0;
		num++;
		if(num>5)
		{
			num=0;
//			RS485_DMASend(&RS485_Conf,(u32*)PC004V10_TBuffer,11);	//RS485-DMA发送程序
		}
//		GPIO_Toggle	(GPIOB,GPIO_Pin_0);		//将GPIO相应管脚输出翻转----V20170605//锁接口
//		TxMessage.Data[3]=num;
//		PC004V10_CAN_COMMAD();					//CAN发送命令函数，地址，命令类型，数据--时间同步--发送获取D命令
//		PC004V10_Num[0]=num;
//		CAN_StdTX_DATA(0X15,1,PC004V10_Num);			//CAN使用标准帧发送数据
//		CAN_ExtTX_DATA(0X15,1,PC004V10_Num);			//CAN使用扩展帧发送数据
	}
	if(PB1in)		//无按键
	{	
		if(KeyTime>=10&&KeyTime<3000)	//短按键
		{			
			if(PB1Flg==0)
					PB1Flg=1;
		}
		else if(KeyTime>=3000)	//长按
		{
			if(PB1Flg==0)
					PB1Flg=2;
		}
		KeyTime=0;
	}
	else
	{		
		if(KeyTime<=5000)
		{
			KeyTime++;
		}
	}
	if(PB1Flg==2)	//长按
	{
		PC004V10_CANBuffer[0]=0x01;		//命令:0x01查询槽位信息，0x02发药命令
		
		PC004V10_TBuffer[0]=0x01;
		
		RS485_DMASend(&RS485B,PC004V10_TBuffer,1);	//RS485-DMA发送程序
		CAN_StdTX_DATA(0x01,0x08,PC004V10_CANBuffer);			//CAN使用标准帧发送数据
		
		PB1Flg=0;
	}
	if(PB1Flg==1)
	{		
//		PC004V21_KEYData();		//按键发药处理函数
		PC004V10_CANBuffer[0]=0x02;		//命令:0x01查询槽位信息，0x02发药命令
		PC004V10_CANBuffer[1]=NumW;		//槽号
		PC004V10_CANBuffer[2]=NumF;		//数量
		
		PC004V10_TBuffer[0]=0x02;
		PC004V10_TBuffer[1]=NumW;
		PC004V10_TBuffer[2]=NumF;
		RS485_DMASend(&RS485B,PC004V10_TBuffer,3);	//RS485-DMA发送程序
//		RS485_DMAPrintf(&RS485B,"%d,%d",NumW,NumF);					//自定义printf串口DMA发送程序,后边的省略号就是可变参数
		CAN_StdTX_DATA(0x01,0x08,PC004V10_CANBuffer);			//CAN使用标准帧发送数据
		if(PW1Flg==0)
		{
			PW1Flg=1;
			PB1Flg=0;				
//			PWM_OUT(TIM3,PWM_OUTChannel3,0.5,10);						//PWM设定-20161127版本
		}
		else
		{
			PW1Flg=0;
			PB1Flg=0;
//			PWM_OUT(TIM3,PWM_OUTChannel3,5,500);						//PWM设定-20161127版本
		}
	}
	if(CAN_RX_DATA(&RxMessage))
	{
		if(RxMessage.Data[0]==0x81)
		{
			PC004V10_TBuffer[0]=RxMessage.Data[0];	//返回代码类型
			PC004V10_TBuffer[1]=RxMessage.Data[1];
			PC004V10_TBuffer[2]=RxMessage.Data[2];
			PC004V10_TBuffer[3]=RxMessage.Data[3];	
			PC004V10_TBuffer[4]=RxMessage.Data[4];	
			PC004V10_TBuffer[5]=RxMessage.Data[5];	//错误类型
			RS485_DMASend(&RS485B,PC004V10_TBuffer,6);	//RS485-DMA发送程序
			
		}
		if(RxMessage.StdId==0x01)
		{
			PC004V10_TBuffer[0]=RxMessage.Data[0];	//返回代码类型
			PC004V10_TBuffer[1]=RxMessage.Data[1];
			PC004V10_TBuffer[2]=RxMessage.Data[2];
			PC004V10_TBuffer[3]=RxMessage.Data[3];	//错误类型
			RS485_DMASend(&RS485B,PC004V10_TBuffer,4);	//RS485-DMA发送程序
		}
	}
	//**************检查通讯标志位，查看是否为通讯中断，如果是，则此次时间增量无效
//	status=PC004V10_485_TR();				//485收发程序//通讯接口
//	if(status&&(SYSTime>0))
//		SYSTime--;	
	
	
//	
//	//**************检测设备ID有无变化，有就更新
//	if(SYSTime%500==0)
//	{
//		if(SwitchID!=PC004V21_GetSwitchID())
//		{
//			SwitchID=PC004V21_GetSwitchID();
//			PC004V10_Buffer[5]=0x01;							//获取ID指令0x01
//			PC004V10_CAN_COMMAD();					//CAN发送命令函数，地址，命令类型，数据--时间同步--发送获取D命令
//		}
//	}
//	if(SwitchID==0)
//	{
//		Self_Test(SYSTime);
//	}
//	PC004V10_CAN_RX();									//主要接收数码管板地址，
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: void
* 返回值			: void
*******************************************************************************/
void PC004V21_PinSet(void)
{
	//********************RS485_CTL配置
	GPIO_Configuration_OPP50(GPIOA,GPIO_Pin_1);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605
	
	GPIO_Configuration_OPP50(GPIOB,GPIO_Pin_0);					//将GPIO相应管脚配置为PP(推挽)输出模式，最大速度50MHz----V20170605//锁接口
	
	GPIO_Configuration_INF(GPIOB,GPIO_Pin_1);						//将GPIO相应管脚配置为浮空输入模式----V20170605
	
	//********************拔码开关配置
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_0);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_1);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_2);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_3);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_4);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_5);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_6);						//将GPIO相应管脚配置为上拉输入模式----V20170605
	GPIO_Configuration_IPU(GPIOC,GPIO_Pin_7);						//将GPIO相应管脚配置为上拉输入模式----V20170605
}
/*******************************************************************************
* 函数名			:	function
* 功能描述		:	函数功能说明 
* 输入			: void
* 返回值			: void
*******************************************************************************/
void PD002V30_USART_Cofiguration(void)
{
	RS485B.USARTx=UART4;
	RS485B.RS485_CTL_PORT=GPIOC;
	RS485B.RS485_CTL_Pin=GPIO_Pin_12;
	
	RS485A.USARTx	=	USART2;
	RS485A.RS485_CTL_PORT	=	GPIOA;
	RS485A.RS485_CTL_Pin	=	GPIO_Pin_1;
	
	RS485_DMA_ConfigurationNR	(&RS485B,19200,PC004V10_BufferSize);	//USART_DMA配置--查询方式，不开中断,配置完默认为接收状态
	
	USART_DMA_ConfigurationNR	(USART1,115200,PC004V10_BufferSize);	//USART_DMA配置--查询方式，不开中断
}
/*******************************************************************************
* 函数名			:	PC004V21_KEYData
* 功能描述		:	按键发药处理函数 
* 输入			: void
* 返回值			: void
*******************************************************************************/
void PC004V21_KEYData(void)		//按键发药处理函数
{
	unsigned char SW=PC004V21_GetSwitchID();				//获取当前设备ID//机柜号(高位当发药头号，低位当发药数量）

	
	PC004V10_TBuffer[0]=0x00;			//B0-SWITCHID
	PC004V10_TBuffer[1]=0x03;			//B1-CMD命令
//	PC004V10_TBuffer[2]=0x03;
//	PC004V10_TBuffer[3]=0x03;
//	PC004V10_TBuffer[4]=0x00;
//	PC004V10_TBuffer[5]=0x00;
//	PC004V10_TBuffer[6]=0x00;
//	PC004V10_TBuffer[7]=0x00;
//	PC004V10_TBuffer[8]=0x00;
//	PC004V10_TBuffer[9]=0x00;
	
	memset(&PC004V10_TBuffer[2],0x00,8);		//所有发药头发药数量设置为0
	
	PC004V10_TBuffer[2+(SW>>4)]=SW&0x0F;		//传入数据
	
	PC004V10_TBuffer[10]=BCC8(PC004V10_TBuffer,10);		//异或校验
	
	RS485_DMASend(&RS485B,PC004V10_TBuffer,11);	//RS485-DMA发送程序
}
/*******************************************************************************
* 函数名		:
* 功能描述	: 
* 输入			: 无
* 输出			: 无
* 返回			: 无
*******************************************************************************/
u8 PC004V10_485_TR(void)				//485收发程序//通讯接口
{
	//***********串口状态检测控制485脚为接收方式
	u16 num=0;
//	u8 temp=0;
//	num=USART_RX_FlagClear(USART2);						//清除串口DMA发送全局中断标志
	//1)**********对接收到的数据进行规格检测
	if(num)
	{	
		//1.1)**********RS485转发发送模式，防止有数据进来干扰数据
		PC004V10_RS4851_CTL(RS485TX);						//485在发送模式，不接收数据
		PC004V10_delay(2000);										//延时，使得485收发控制引脚电平正确转换
		//1.3)**********命令类信息
		if((PC004V10_Buffer[0]==0xFA)&&(PC004V10_Buffer[1]==0xF5)&&(PC004V10_Buffer[2]==0x05)&&(PC004V10_Buffer[3]==0x0A))
		{
			if(PC004V10_Buffer[5]==0x04)					//更新ID指令
			{
				memset(ID_ARR,0,sizeof(ID_ARR));		//清空地址存储空间
				memset(ON_line,0,sizeof(ON_line));	//清空地址在线标志
			}
			PC004V10_CAN_COMMAD();								//CAN发送命令函数，地址，命令类型，数据--时间同步
			PC004V10_RS4851_CTL(RS485RX);					//485转为接收模式
		}
		//1.2)**********检查数据正确性
		else if((PC004V10_Buffer[0]==0xFA)&&(PC004V10_Buffer[1]==0xF5)&&(PC004V10_Buffer[7]==SwitchID)&&((PC004V10_Buffer[4]==BCC8(&PC004V10_Buffer[7],6))))			//检测头标识、机柜号和异或校验位
		{
//			/********************************************/
//			//***************判断单元地址正确与否
			u8 temp=0;
			temp=PC004V10_Buffer[8]*10+PC004V10_Buffer[9];						//将单元地址的层号和序号合成
			//1.2.1）***************判断单元地址正确与否
			if(memchr(ID_ARR,temp,sizeof(ID_ARR)))										//单元地址正确	//判断单元地址有没存在，在数组x的前n个字节中搜索字符ch。返回值为指向s中首次出现ch的指针位置。如果ch没有在s数组中出现。返回NULL			
			{
				memcpy(PC004V10_Num,PC004V10_Buffer,13);								//复制数据						

				PC004V10_Buffer[3]|=0x80;						//修改回执位
				USART_DMASend(USART2,PC004V10_Buffer,(u32)num);		//返回回执给网关板
				
				PC004V10_CAN_TX();					//CAN发送数据，地址，命令类型，数据
			}
			else		//单元地址错误
			{
				PC004V10_Buffer[3]|=0xE0;																//修改回执位
				USART_DMASend(USART2,PC004V10_Buffer,(u32)num);		//返回回执给网关板
			}
			/**********************************************/
		}
		
		else			//接收数据无效，恢复485为接收数据状态
		{
			memset(PC004V10_Buffer,0,PC004V10_BufferSize);	//初始化缓冲
			PC004V10_RS4851_CTL(RS485RX);										//485转为接收模式			
		}
		return 1;		
	}
	//2)**********根据串口2DMA发送完成中断
//	else if(USART_TX_DMAFlagClear(USART2))
//	{
//		memset(PC004V10_Buffer,0,PC004V10_BufferSize);			//初始化缓冲		
//		return 1;
//	}
	//3)**********数据发送完成后将485控制脚拉低转为接收模式
	else	if(USART_GetFlagStatus(USART2,USART_FLAG_TC)==SET)
	{
		PC004V10_RS4851_CTL(RS485RX);
		USART_ClearFlag(USART2,USART_FLAG_TC);
		return 0;
	}
	else
	{
		return 0;
	}
}
/*******************************************************************************
* 函数名		:
* 功能描述	: 
* 输入			: 无
* 输出			: 无
* 返回			: 无
*******************************************************************************/
void PC004V10_CAN_RX(void)									//主要接收数码管板地址，
{
	u8 ID_Temp=0;
	if(SET == CAN_GetITStatus(CAN_IT_FF0))
	{
		CAN_ClearITPendingBit(CAN_IT_FF0);
	}
	else if(SET == CAN_GetITStatus(CAN_IT_FOV0))
	{
		CAN_ClearITPendingBit(CAN_IT_FOV0);
	}
	else if(SET == CAN_GetITStatus(CAN_IT_FMP0))
	{
		CAN_ClearITPendingBit(CAN_IT_FMP0);
	}
	else
	{
		CAN_Receive(CAN_FIFO0,&RxMessage);
		if(RxMessage.DLC==1&&RxMessage.Data[0]==0XAA)
		{
			ID_Temp=RxMessage.StdId;
			ID_ARR[ID_Temp/10][ID_Temp%10]=ID_Temp;
			ON_line[ID_Temp/10][ID_Temp%10]=1;
		}
	}
}
/*******************************************************************************
* 函数名		:
* 功能描述	: 
* 输入			: 无
* 输出			: 无
* 返回			: 无
*******************************************************************************/
void PC004V10_CAN_TX(void)					//CAN发送数据，地址，命令类型，数据
{
	CanTxMsg TxMessage;
	
	u8	TransmitMailbox = 0;
	u32	i;

	TxMessage.StdId=CAN_ID;					//标准帧ID
//	TxMessage.ExtId=0XFF;					//扩展帧ID
	TxMessage.RTR=CAN_RTR_DATA;			//数据帧
	TxMessage.IDE=CAN_ID_STD;				//使用标准标识符
	TxMessage.DLC=8;
	TxMessage.Data[0]=CAN_Command;	//命令类型
	TxMessage.Data[1]=Data_H;				//数据高位
	TxMessage.Data[2]=Data_L;				//数据低位
	TxMessage.Data[3]=0x03;
	TxMessage.Data[4]=0x04;
	TxMessage.Data[5]=0x05;
	TxMessage.Data[6]=0x06;
	TxMessage.Data[7]=0x07;
	TransmitMailbox = CAN_Transmit(&TxMessage);
	i = 0;
	// 用于检查消息传输是否正常
	while((CAN_TransmitStatus(TransmitMailbox) != CANTXOK) && (i != 0xFF))
	{
		i++;
	}
	i = 0;
	// 检查返回的挂号的信息数目
	while((CAN_MessagePending(CAN_FIFO0) < 1) && (i != 0xFF))
	{
		i++;
	}
}
/*******************************************************************************
* 函数名		:
* 功能描述	: 
* 输入			: 无
* 输出			: 无
* 返回			: 无
*******************************************************************************/
void PC004V10_CAN_COMMAD(void)					//CAN发送命令函数，地址，命令类型，数据--时间同步
{
//	CanTxMsg TxMessage;
	
	u8	TransmitMailbox = 0;
	u32	i;

	TxMessage.StdId=0X3FF;							//标准帧ID
	TxMessage.ExtId=0X3F5;						//扩展帧ID
	TxMessage.RTR=CAN_RTR_DATA;					//数据帧
	TxMessage.IDE=CAN_ID_EXT;						//使用扩展帧标识符
	TxMessage.DLC=4;
	TxMessage.Data[0]=PC004V10_Buffer[5];	//命令类型
	TxMessage.Data[1]=0x00;						//数据高位
	TxMessage.Data[2]=0x00;						//数据低位
//	TxMessage.Data[3]=0x00;
//	TxMessage.Data[4]=0x00;
//	TxMessage.Data[5]=0x00;
//	TxMessage.Data[6]=0x00;
//	TxMessage.Data[7]=0x00;
	TransmitMailbox = CAN_Transmit(&TxMessage);
	i = 0;
	// 用于检查消息传输是否正常
	while((CAN_TransmitStatus(TransmitMailbox) != CANTXOK) && (i != 0xFF))
	{
		i++;
	}
	i = 0;
	// 检查返回的挂号的信息数目
	while((CAN_MessagePending(CAN_FIFO0) < 1) && (i != 0xFF))
	{
		i++;
	}
	memset(PC004V10_Buffer,0,PC004V10_BufferSize);	//初始化缓冲
}

/*******************************************************************************
*函数名		:	function
*功能描述	:	函数功能说明
*输入			: 
*输出			:	无
*返回值		:	无
*例程			:
*******************************************************************************/
u8 PC004V21_GetSwitchID(void)
{
	u8	SW_ID=0;
	//1)***************获取H拔码开关地址，从右到左为从低到高
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_4))		//SWH-1
	{
		SW_ID|=1;
	}
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_5))		//SWH-2
	{
		SW_ID|=1;
	}
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_6))		//SWH-3
	{
		SW_ID|=1;
	}
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_7))		//SWH-4
	{
		SW_ID|=1;
	}
	
	//2)***************获取L拔码开关地址，从右到左为从低到高
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_0))		//SWL-1
	{
		SW_ID|=1;
	}
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1))		//SWL-2
	{
		SW_ID|=1;
	}
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2))		//SWL-3
	{
		SW_ID|=1;
	}
	SW_ID<<=1;
	if(!GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_3))		//SWL-4
	{
		SW_ID|=1;
	}
//	SW_ID=~SW_ID;
	//3)***************返回获取的ID值
	return (SW_ID);

}
void Self_Test(u16 time)			//拔码开关为0时，计数显示测试
{
//	//************CAN通讯数据
//#define	CAN_ID				PC004V10_Num[8]*10+PC004V10_Num[9]		//单元地址	由两位数合并，十位为层，个位为序号
//#define	CAN_Command		PC004V10_Num[5]												//命令类型----上位机用户码
//#define	Data_H				PC004V10_Num[11]											//数据高位
//#define	Data_L				PC004V10_Num[12]											//数据低位
//	Self_Dsp=0;							//拔码开关为0时，自检测试显示标识变量
	if((time%10==0)&&(Self_Dsp==0))
	{
		PC004V10_Num[5]=0x05;				//命令类型----上位机用户码
		
//		PC004V10_Num[12]++;
		if(PC004V10_Num[12]++>=99)
		{
			PC004V10_Num[12]=0;
			if(PC004V10_Num[11]++>=9)
			{
				PC004V10_Num[11]=0;
				if(PC004V10_Num[9]++>=3)
				{
					PC004V10_Num[9]=0;
					if(PC004V10_Num[8]++>=5)
					{
						PC004V10_Num[8]=1;
						PC004V10_Num[9]=0;
						PC004V10_Num[11]=0;
						PC004V10_Num[12]=0;
						Self_Dsp=1;							//拔码开关为0时，自检测试显示标识变量，1--显示ID
						SYSTime=0;
					}
				}
			}
		}		
		PC004V10_CAN_TX();					//CAN发送数据，地址，命令类型，数据
	}
	else if(Self_Dsp==1)
	{
		if(time<5)
		{
			PC004V10_Num[5]=0x04;				//命令类型----显示ID
//			PC004V10_CAN_TX();				//CAN发送数据，地址，命令类型，数据
			PC004V10_CAN_COMMAD();			//CAN发送命令函数，地址，命令类型，数据--时间同步
		}
		else if(time>=9999)
		{
			PC004V10_Num[5]=0x05;				//命令类型----上位机用户码
			PC004V10_Num[8]=1;
			PC004V10_Num[9]=0;
			PC004V10_Num[11]=0;
			PC004V10_Num[12]=0;
			PC004V10_CAN_COMMAD();			//CAN发送命令函数，地址，命令类型，数据--时间同步
			Self_Dsp=0;									//拔码开关为0时，自检测试显示标识变量，0--计数
		}
	}
}

/*******************************************************************************
* 函数名		:
* 功能描述	: 
* 输入			: 无
* 输出			: 无
* 返回			: 无
*******************************************************************************/
void PC004V10_delay(u16 time)
{
	while(time--);
}



#endif
